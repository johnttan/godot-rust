use std::os::raw::c_char;
use std::ptr;
use std::mem;

/// `core singleton class GlobalConstants` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_globalconstants.html) in the Godot engine's official documentation.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GlobalConstants {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl GlobalConstants {
    pub const ERR_PARAMETER_RANGE_ERROR: i64 = 5;
    pub const KEY_LAUNCH3: i64 = 16777307;
    pub const KEY_SYSREQ: i64 = 16777227;
    pub const KEY_C: i64 = 67;
    pub const BUTTON_WHEEL_RIGHT: i64 = 7;
    pub const KEY_DOWN: i64 = 16777234;
    pub const KEY_SCROLLLOCK: i64 = 16777243;
    pub const TYPE_NIL: i64 = 0;
    pub const PROPERTY_USAGE_DEFAULT: i64 = 7;
    pub const KEY_KP_8: i64 = 16777358;
    pub const PROPERTY_HINT_RESOURCE_TYPE: i64 = 17;
    pub const KEY_REGISTERED: i64 = 174;
    pub const OP_XOR: i64 = 22;
    pub const PROPERTY_USAGE_EDITOR: i64 = 2;
    pub const KEY_ESCAPE: i64 = 16777217;
    pub const KEY_OCIRCUMFLEX: i64 = 212;
    pub const VALIGN_TOP: i64 = 0;
    pub const PROPERTY_HINT_KEY_ACCEL: i64 = 7;
    pub const KEY_X: i64 = 88;
    pub const OP_POSITIVE: i64 = 11;
    pub const KEY_HYPHEN: i64 = 173;
    pub const PROPERTY_HINT_RANGE: i64 = 1;
    pub const KEY_ONESUPERIOR: i64 = 185;
    pub const PROPERTY_USAGE_STORAGE: i64 = 1;
    pub const JOY_SONY_TRIANGLE: i64 = 3;
    pub const KEY_PARAGRAPH: i64 = 182;
    pub const KEY_BAR: i64 = 124;
    pub const KEY_D: i64 = 68;
    pub const PROPERTY_HINT_LAYERS_2D_RENDER: i64 = 9;
    pub const KEY_LAUNCHMAIL: i64 = 16777302;
    pub const KEY_MASK_CMD: i64 = 268435456;
    pub const KEY_MASK_GROUP_SWITCH: i64 = 1073741824;
    pub const HALIGN_LEFT: i64 = 0;
    pub const KEY_NUMLOCK: i64 = 16777242;
    pub const KEY_BACKTAB: i64 = 16777219;
    pub const KEY_STANDBY: i64 = 16777300;
    pub const TYPE_COLOR_ARRAY: i64 = 26;
    pub const HALIGN_RIGHT: i64 = 2;
    pub const OP_SHIFT_LEFT: i64 = 14;
    pub const PROPERTY_HINT_FILE: i64 = 13;
    pub const PROPERTY_USAGE_NETWORK: i64 = 4;
    pub const VERTICAL: i64 = 1;
    pub const KEY_SUPER_R: i64 = 16777261;
    pub const KEY_YDIAERESIS: i64 = 255;
    pub const ERR_FILE_MISSING_DEPENDENCIES: i64 = 17;
    pub const KEY_MASK_META: i64 = 134217728;
    pub const KEY_REFRESH: i64 = 16777283;
    pub const KEY_KP_PERIOD: i64 = 16777348;
    pub const KEY_V: i64 = 86;
    pub const KEY_GUILLEMOTLEFT: i64 = 171;
    pub const METHOD_FLAGS_DEFAULT: i64 = 1;
    pub const MARGIN_TOP: i64 = 1;
    pub const KEY_QUESTIONDOWN: i64 = 191;
    pub const ERR_FILE_NO_PERMISSION: i64 = 10;
    pub const PROPERTY_HINT_FLAGS: i64 = 8;
    pub const KEY_KP_5: i64 = 16777355;
    pub const JOY_XBOX_X: i64 = 2;
    pub const KEY_FORWARD: i64 = 16777281;
    pub const KEY_LAUNCH2: i64 = 16777306;
    pub const KEY_LAUNCHA: i64 = 16777314;
    pub const KEY_EDIAERESIS: i64 = 203;
    pub const JOY_AXIS_0: i64 = 0;
    pub const BUTTON_WHEEL_UP: i64 = 4;
    pub const BUTTON_MASK_XBUTTON2: i64 = 256;
    pub const KEY_NOBREAKSPACE: i64 = 160;
    pub const KEY_ONEQUARTER: i64 = 188;
    pub const KEY_KP_SUBTRACT: i64 = 16777347;
    pub const KEY_W: i64 = 87;
    pub const KEY_QUESTION: i64 = 63;
    pub const ERR_CANT_RESOLVE: i64 = 26;
    pub const METHOD_FLAG_REVERSE: i64 = 16;
    pub const KEY_B: i64 = 66;
    pub const PROPERTY_HINT_DIR: i64 = 14;
    pub const KEY_CAPSLOCK: i64 = 16777241;
    pub const TYPE_TRANSFORM2D: i64 = 8;
    pub const ERR_LINK_FAILED: i64 = 38;
    pub const PROPERTY_USAGE_DEFAULT_INTL: i64 = 71;
    pub const KEY_Z: i64 = 90;
    pub const TYPE_REAL_ARRAY: i64 = 22;
    pub const KEY_CONTROL: i64 = 16777238;
    pub const PROPERTY_USAGE_EDITOR_HELPER: i64 = 8;
    pub const TYPE_QUAT: i64 = 10;
    pub const OP_MODULE: i64 = 12;
    pub const KEY_STOP: i64 = 16777282;
    pub const KEY_MINUS: i64 = 45;
    pub const JOY_DPAD_UP: i64 = 12;
    pub const KEY_LAUNCH8: i64 = 16777312;
    pub const KEY_SUPER_L: i64 = 16777260;
    pub const TYPE_BASIS: i64 = 12;
    pub const JOY_AXIS_MAX: i64 = 10;
    pub const KEY_LAUNCH5: i64 = 16777309;
    pub const KEY_2: i64 = 50;
    pub const BUTTON_WHEEL_LEFT: i64 = 6;
    pub const JOY_AXIS_6: i64 = 6;
    pub const JOY_SONY_CIRCLE: i64 = 1;
    pub const KEY_EXCLAM: i64 = 33;
    pub const KEY_F16: i64 = 16777259;
    pub const JOY_VR_ANALOG_TRIGGER: i64 = 2;
    pub const CORNER_TOP_LEFT: i64 = 0;
    pub const KEY_MENU: i64 = 16777262;
    pub const KEY_SPACE: i64 = 32;
    pub const JOY_BUTTON_14: i64 = 14;
    pub const KEY_ASTERISK: i64 = 42;
    pub const PROPERTY_HINT_GLOBAL_FILE: i64 = 15;
    pub const KEY_HELP: i64 = 16777265;
    pub const OP_LESS: i64 = 2;
    pub const KEY_SECTION: i64 = 167;
    pub const KEY_PAGEUP: i64 = 16777235;
    pub const JOY_ANALOG_RX: i64 = 2;
    pub const JOY_DS_Y: i64 = 2;
    pub const KEY_MEDIASTOP: i64 = 16777293;
    pub const KEY_KP_0: i64 = 16777350;
    pub const PROPERTY_USAGE_NO_INSTANCE_STATE: i64 = 2048;
    pub const ERR_INVALID_DATA: i64 = 30;
    pub const JOY_AXIS_9: i64 = 9;
    pub const CORNER_BOTTOM_LEFT: i64 = 3;
    pub const JOY_SELECT: i64 = 10;
    pub const JOY_XBOX_Y: i64 = 3;
    pub const ERR_UNAVAILABLE: i64 = 2;
    pub const KEY_QUOTEDBL: i64 = 34;
    pub const MIDI_MESSAGE_NOTE_ON: i64 = 9;
    pub const TYPE_VECTOR3: i64 = 7;
    pub const HALIGN_CENTER: i64 = 1;
    pub const ERR_SKIP: i64 = 45;
    pub const KEY_ETH: i64 = 208;
    pub const KEY_F5: i64 = 16777248;
    pub const KEY_OGRAVE: i64 = 210;
    pub const KEY_BASSUP: i64 = 16777288;
    pub const KEY_UP: i64 = 16777232;
    pub const BUTTON_XBUTTON1: i64 = 8;
    pub const KEY_IDIAERESIS: i64 = 207;
    pub const METHOD_FLAG_FROM_SCRIPT: i64 = 64;
    pub const OP_GREATER: i64 = 4;
    pub const PROPERTY_USAGE_SCRIPT_VARIABLE: i64 = 8192;
    pub const KEY_MASCULINE: i64 = 186;
    pub const ERR_METHOD_NOT_FOUND: i64 = 37;
    pub const METHOD_FLAG_NOSCRIPT: i64 = 4;
    pub const JOY_BUTTON_12: i64 = 12;
    pub const KEY_S: i64 = 83;
    pub const PROPERTY_HINT_EXP_EASING: i64 = 4;
    pub const PROPERTY_HINT_IMAGE_COMPRESS_LOSSLESS: i64 = 22;
    pub const PROPERTY_HINT_LAYERS_3D_RENDER: i64 = 11;
    pub const KEY_THREESUPERIOR: i64 = 179;
    pub const OP_NEGATE: i64 = 10;
    pub const KEY_GUILLEMOTRIGHT: i64 = 187;
    pub const ERR_FILE_UNRECOGNIZED: i64 = 15;
    pub const KEY_ACUTE: i64 = 180;
    pub const KEY_MASK_SHIFT: i64 = 33554432;
    pub const ERR_CANT_OPEN: i64 = 19;
    pub const OP_NOT: i64 = 23;
    pub const JOY_OPENVR_MENU: i64 = 1;
    pub const METHOD_FLAG_NORMAL: i64 = 1;
    pub const KEY_PERCENT: i64 = 37;
    pub const PROPERTY_HINT_GLOBAL_DIR: i64 = 16;
    pub const KEY_F12: i64 = 16777255;
    pub const JOY_BUTTON_0: i64 = 0;
    pub const BUTTON_XBUTTON2: i64 = 9;
    pub const MARGIN_BOTTOM: i64 = 3;
    pub const KEY_CODE_MASK: i64 = 33554431;
    pub const BUTTON_RIGHT: i64 = 2;
    pub const KEY_9: i64 = 57;
    pub const KEY_PLUSMINUS: i64 = 177;
    pub const KEY_OTILDE: i64 = 213;
    pub const ERR_CYCLIC_LINK: i64 = 40;
    pub const KEY_ASCIICIRCUM: i64 = 94;
    pub const ERR_PARSE_ERROR: i64 = 43;
    pub const OK: i64 = 0;
    pub const JOY_BUTTON_9: i64 = 9;
    pub const KEY_E: i64 = 69;
    pub const JOY_DPAD_RIGHT: i64 = 15;
    pub const KEY_KP_4: i64 = 16777354;
    pub const JOY_DS_X: i64 = 3;
    pub const KEY_F13: i64 = 16777256;
    pub const TYPE_INT: i64 = 2;
    pub const KEY_SLASH: i64 = 47;
    pub const CORNER_TOP_RIGHT: i64 = 1;
    pub const JOY_BUTTON_4: i64 = 4;
    pub const KEY_PARENRIGHT: i64 = 41;
    pub const TYPE_NODE_PATH: i64 = 15;
    pub const PROPERTY_USAGE_GROUP: i64 = 128;
    pub const KEY_COMMA: i64 = 44;
    pub const KEY_VOLUMEDOWN: i64 = 16777284;
    pub const KEY_KP_ENTER: i64 = 16777222;
    pub const ERR_LOCKED: i64 = 23;
    pub const ERR_CANT_CONNECT: i64 = 25;
    pub const KEY_BACK: i64 = 16777280;
    pub const ERR_FILE_EOF: i64 = 18;
    pub const KEY_LAUNCH1: i64 = 16777305;
    pub const JOY_AXIS_5: i64 = 5;
    pub const KEY_O: i64 = 79;
    pub const METHOD_FLAG_CONST: i64 = 8;
    pub const OP_STRING_CONCAT: i64 = 13;
    pub const PROPERTY_HINT_IMAGE_COMPRESS_LOSSY: i64 = 21;
    pub const KEY_CURRENCY: i64 = 164;
    pub const KEY_ONEHALF: i64 = 189;
    pub const KEY_PERIOD: i64 = 46;
    pub const KEY_F1: i64 = 16777244;
    pub const TYPE_RECT2: i64 = 6;
    pub const ERR_CANT_FORK: i64 = 29;
    pub const KEY_KP_3: i64 = 16777353;
    pub const PROPERTY_USAGE_CHECKABLE: i64 = 16;
    pub const JOY_BUTTON_10: i64 = 10;
    pub const JOY_VR_TRIGGER: i64 = 15;
    pub const KEY_HOME: i64 = 16777229;
    pub const OP_OR: i64 = 21;
    pub const TYPE_ARRAY: i64 = 19;
    pub const KEY_SEARCH: i64 = 16777299;
    pub const KEY_ACIRCUMFLEX: i64 = 194;
    pub const KEY_LAUNCHC: i64 = 16777316;
    pub const JOY_XBOX_A: i64 = 0;
    pub const KEY_BACKSLASH: i64 = 92;
    pub const BUTTON_MASK_LEFT: i64 = 1;
    pub const JOY_BUTTON_5: i64 = 5;
    pub const KEY_STERLING: i64 = 163;
    pub const KEY_F8: i64 = 16777251;
    pub const KEY_LEFT: i64 = 16777231;
    pub const KEY_OPENURL: i64 = 16777301;
    pub const KEY_ASCIITILDE: i64 = 126;
    pub const KEY_M: i64 = 77;
    pub const OP_BIT_OR: i64 = 17;
    pub const TYPE_VECTOR2_ARRAY: i64 = 24;
    pub const JOY_AXIS_3: i64 = 3;
    pub const KEY_AT: i64 = 64;
    pub const JOY_AXIS_4: i64 = 4;
    pub const ERR_ALREADY_IN_USE: i64 = 22;
    pub const ERR_CANT_CREATE: i64 = 20;
    pub const METHOD_FLAG_VIRTUAL: i64 = 32;
    pub const KEY_LAUNCH4: i64 = 16777308;
    pub const KEY_MASK_CTRL: i64 = 268435456;
    pub const KEY_TREBLEUP: i64 = 16777290;
    pub const ERR_BUG: i64 = 47;
    pub const KEY_END: i64 = 16777230;
    pub const KEY_LAUNCHB: i64 = 16777315;
    pub const JOY_L2: i64 = 6;
    pub const KEY_K: i64 = 75;
    pub const KEY_ODIAERESIS: i64 = 214;
    pub const OP_IN: i64 = 24;
    pub const PROPERTY_USAGE_INTERNATIONALIZED: i64 = 64;
    pub const JOY_BUTTON_13: i64 = 13;
    pub const ERR_QUERY_FAILED: i64 = 21;
    pub const PROPERTY_USAGE_CATEGORY: i64 = 256;
    pub const KEY_THORN: i64 = 222;
    pub const KEY_EXCLAMDOWN: i64 = 161;
    pub const MIDI_MESSAGE_PROGRAM_CHANGE: i64 = 12;
    pub const JOY_ANALOG_RY: i64 = 3;
    pub const KEY_GREATER: i64 = 62;
    pub const KEY_LAUNCHE: i64 = 16777318;
    pub const KEY_PLUS: i64 = 43;
    pub const KEY_UNKNOWN: i64 = 33554431;
    pub const KEY_MASK_ALT: i64 = 67108864;
    pub const PROPERTY_HINT_NONE: i64 = 0;
    pub const TYPE_MAX: i64 = 27;
    pub const ERR_COMPILATION_FAILED: i64 = 36;
    pub const ERR_CONNECTION_ERROR: i64 = 27;
    pub const KEY_5: i64 = 53;
    pub const KEY_DIRECTION_L: i64 = 16777266;
    pub const KEY_F11: i64 = 16777254;
    pub const KEY_NTILDE: i64 = 209;
    pub const KEY_CLEAR: i64 = 16777228;
    pub const KEY_KP_ADD: i64 = 16777349;
    pub const KEY_MULTIPLY: i64 = 215;
    pub const PROPERTY_HINT_EXP_RANGE: i64 = 2;
    pub const KEY_F: i64 = 70;
    pub const BUTTON_MASK_XBUTTON1: i64 = 128;
    pub const KEY_BASSDOWN: i64 = 16777289;
    pub const ERR_HELP: i64 = 46;
    pub const KEY_MODIFIER_MASK: i64 = -16777216;
    pub const KEY_MASK_KPAD: i64 = 536870912;
    pub const KEY_DIVISION: i64 = 247;
    pub const KEY_IGRAVE: i64 = 204;
    pub const ERR_BUSY: i64 = 44;
    pub const KEY_KP_DIVIDE: i64 = 16777346;
    pub const TYPE_PLANE: i64 = 9;
    pub const KEY_BACKSPACE: i64 = 16777220;
    pub const KEY_P: i64 = 80;
    pub const KEY_A: i64 = 65;
    pub const KEY_ECIRCUMFLEX: i64 = 202;
    pub const KEY_I: i64 = 73;
    pub const MIDI_MESSAGE_PITCH_BEND: i64 = 14;
    pub const JOY_SONY_SQUARE: i64 = 2;
    pub const KEY_MEDIAPREVIOUS: i64 = 16777294;
    pub const KEY_RIGHT: i64 = 16777233;
    pub const OP_ADD: i64 = 6;
    pub const ERR_UNCONFIGURED: i64 = 3;
    pub const JOY_BUTTON_1: i64 = 1;
    pub const KEY_SEMICOLON: i64 = 59;
    pub const JOY_OCULUS_AX: i64 = 7;
    pub const JOY_ANALOG_R2: i64 = 7;
    pub const OP_LESS_EQUAL: i64 = 3;
    pub const TYPE_RAW_ARRAY: i64 = 20;
    pub const JOY_OPENVR_TOUCHPADX: i64 = 0;
    pub const ERR_FILE_BAD_PATH: i64 = 9;
    pub const ERR_FILE_ALREADY_IN_USE: i64 = 11;
    pub const JOY_L: i64 = 4;
    pub const KEY_EQUAL: i64 = 61;
    pub const KEY_UCIRCUMFLEX: i64 = 219;
    pub const KEY_AE: i64 = 198;
    pub const KEY_1: i64 = 49;
    pub const KEY_KP_6: i64 = 16777356;
    pub const JOY_R3: i64 = 9;
    pub const KEY_ATILDE: i64 = 195;
    pub const KEY_IACUTE: i64 = 205;
    pub const MARGIN_LEFT: i64 = 0;
    pub const OP_SHIFT_RIGHT: i64 = 15;
    pub const KEY_KP_1: i64 = 16777351;
    pub const TYPE_STRING: i64 = 4;
    pub const KEY_LAUNCH9: i64 = 16777313;
    pub const TYPE_VECTOR3_ARRAY: i64 = 25;
    pub const KEY_QUOTELEFT: i64 = 96;
    pub const ERR_PRINTER_ON_FIRE: i64 = 48;
    pub const JOY_VR_PAD: i64 = 14;
    pub const KEY_MU: i64 = 181;
    pub const KEY_ENTER: i64 = 16777221;
    pub const KEY_LAUNCHF: i64 = 16777319;
    pub const KEY_NOTSIGN: i64 = 172;
    pub const KEY_7: i64 = 55;
    pub const KEY_CCEDILLA: i64 = 199;
    pub const KEY_DIRECTION_R: i64 = 16777267;
    pub const MIDI_MESSAGE_NOTE_OFF: i64 = 8;
    pub const KEY_PAGEDOWN: i64 = 16777236;
    pub const KEY_8: i64 = 56;
    pub const KEY_T: i64 = 84;
    pub const KEY_R: i64 = 82;
    pub const KEY_KP_9: i64 = 16777359;
    pub const KEY_OOBLIQUE: i64 = 216;
    pub const KEY_Y: i64 = 89;
    pub const KEY_MACRON: i64 = 175;
    pub const KEY_BROKENBAR: i64 = 166;
    pub const JOY_ANALOG_LY: i64 = 1;
    pub const KEY_THREEQUARTERS: i64 = 190;
    pub const KEY_Q: i64 = 81;
    pub const JOY_DS_B: i64 = 0;
    pub const JOY_DPAD_DOWN: i64 = 13;
    pub const ERR_OUT_OF_MEMORY: i64 = 6;
    pub const KEY_BASSBOOST: i64 = 16777287;
    pub const JOY_OCULUS_BY: i64 = 1;
    pub const MARGIN_RIGHT: i64 = 2;
    pub const ERR_DATABASE_CANT_WRITE: i64 = 35;
    pub const BUTTON_WHEEL_DOWN: i64 = 5;
    pub const KEY_BRACKETLEFT: i64 = 91;
    pub const KEY_F14: i64 = 16777257;
    pub const FAILED: i64 = 1;
    pub const KEY_F15: i64 = 16777258;
    pub const OP_GREATER_EQUAL: i64 = 5;
    pub const JOY_XBOX_B: i64 = 1;
    pub const KEY_DIAERESIS: i64 = 168;
    pub const JOY_R2: i64 = 7;
    pub const KEY_PERIODCENTERED: i64 = 183;
    pub const ERR_FILE_CORRUPT: i64 = 16;
    pub const BUTTON_MASK_RIGHT: i64 = 2;
    pub const KEY_LAUNCH6: i64 = 16777310;
    pub const KEY_ICIRCUMFLEX: i64 = 206;
    pub const KEY_ORDFEMININE: i64 = 170;
    pub const KEY_N: i64 = 78;
    pub const OP_EQUAL: i64 = 0;
    pub const KEY_VOLUMEUP: i64 = 16777286;
    pub const JOY_OCULUS_MENU: i64 = 3;
    pub const TYPE_BOOL: i64 = 1;
    pub const TYPE_OBJECT: i64 = 17;
    pub const KEY_DELETE: i64 = 16777224;
    pub const KEY_MEDIANEXT: i64 = 16777295;
    pub const KEY_META: i64 = 16777239;
    pub const ERR_FILE_CANT_OPEN: i64 = 12;
    pub const KEY_4: i64 = 52;
    pub const KEY_LAUNCHMEDIA: i64 = 16777303;
    pub const KEY_PRINT: i64 = 16777226;
    pub const OP_NOT_EQUAL: i64 = 1;
    pub const OP_BIT_AND: i64 = 16;
    pub const KEY_INSERT: i64 = 16777223;
    pub const KEY_LAUNCH7: i64 = 16777311;
    pub const BUTTON_MASK_MIDDLE: i64 = 4;
    pub const KEY_LAUNCHD: i64 = 16777317;
    pub const JOY_BUTTON_15: i64 = 15;
    pub const PROPERTY_HINT_LAYERS_3D_PHYSICS: i64 = 12;
    pub const OP_BIT_XOR: i64 = 18;
    pub const TYPE_REAL: i64 = 3;
    pub const JOY_VR_ANALOG_GRIP: i64 = 4;
    pub const KEY_MEDIARECORD: i64 = 16777296;
    pub const KEY_F7: i64 = 16777250;
    pub const ERR_FILE_CANT_WRITE: i64 = 13;
    pub const KEY_FAVORITES: i64 = 16777298;
    pub const KEY_J: i64 = 74;
    pub const PROPERTY_HINT_PLACEHOLDER_TEXT: i64 = 19;
    pub const ERR_DUPLICATE_SYMBOL: i64 = 42;
    pub const KEY_KP_MULTIPLY: i64 = 16777345;
    pub const KEY_KP_2: i64 = 16777352;
    pub const JOY_AXIS_8: i64 = 8;
    pub const ERR_TIMEOUT: i64 = 24;
    pub const KEY_UACUTE: i64 = 218;
    pub const KEY_CEDILLA: i64 = 184;
    pub const MIDI_MESSAGE_CONTROL_CHANGE: i64 = 11;
    pub const CORNER_BOTTOM_RIGHT: i64 = 2;
    pub const TYPE_VECTOR2: i64 = 5;
    pub const KEY_ARING: i64 = 197;
    pub const KEY_BRACELEFT: i64 = 123;
    pub const BUTTON_LEFT: i64 = 1;
    pub const JOY_START: i64 = 11;
    pub const PROPERTY_HINT_LAYERS_2D_PHYSICS: i64 = 10;
    pub const OP_BIT_NEGATE: i64 = 19;
    pub const ERR_INVALID_DECLARATION: i64 = 41;
    pub const JOY_OPENVR_TOUCHPADY: i64 = 1;
    pub const JOY_BUTTON_3: i64 = 3;
    pub const KEY_HYPER_R: i64 = 16777264;
    pub const JOY_DPAD_LEFT: i64 = 14;
    pub const KEY_APOSTROPHE: i64 = 39;
    pub const KEY_F4: i64 = 16777247;
    pub const KEY_F9: i64 = 16777252;
    pub const JOY_AXIS_1: i64 = 1;
    pub const KEY_F10: i64 = 16777253;
    pub const OP_MULTIPLY: i64 = 8;
    pub const KEY_COPYRIGHT: i64 = 169;
    pub const JOY_R: i64 = 5;
    pub const KEY_PAUSE: i64 = 16777225;
    pub const KEY_ALT: i64 = 16777240;
    pub const ERR_DATABASE_CANT_READ: i64 = 34;
    pub const JOY_BUTTON_8: i64 = 8;
    pub const KEY_UNDERSCORE: i64 = 95;
    pub const KEY_OACUTE: i64 = 211;
    pub const SPKEY: i64 = 16777216;
    pub const KEY_AMPERSAND: i64 = 38;
    pub const KEY_TREBLEDOWN: i64 = 16777291;
    pub const KEY_VOLUMEMUTE: i64 = 16777285;
    pub const ERR_FILE_NOT_FOUND: i64 = 7;
    pub const PROPERTY_HINT_ENUM: i64 = 3;
    pub const KEY_AACUTE: i64 = 193;
    pub const KEY_BRACERIGHT: i64 = 125;
    pub const JOY_L3: i64 = 8;
    pub const KEY_PARENLEFT: i64 = 40;
    pub const PROPERTY_USAGE_RESTART_IF_CHANGED: i64 = 4096;
    pub const KEY_F6: i64 = 16777249;
    pub const ERR_FILE_BAD_DRIVE: i64 = 8;
    pub const JOY_ANALOG_L2: i64 = 6;
    pub const KEY_HOMEPAGE: i64 = 16777297;
    pub const PROPERTY_HINT_COLOR_NO_ALPHA: i64 = 20;
    pub const TYPE_TRANSFORM: i64 = 13;
    pub const VALIGN_BOTTOM: i64 = 2;
    pub const JOY_AXIS_7: i64 = 7;
    pub const BUTTON_MIDDLE: i64 = 3;
    pub const KEY_UGRAVE: i64 = 217;
    pub const HORIZONTAL: i64 = 0;
    pub const VALIGN_CENTER: i64 = 1;
    pub const PROPERTY_HINT_MULTILINE_TEXT: i64 = 18;
    pub const KEY_AGRAVE: i64 = 192;
    pub const KEY_EGRAVE: i64 = 200;
    pub const KEY_U: i64 = 85;
    pub const KEY_G: i64 = 71;
    pub const KEY_YEN: i64 = 165;
    pub const KEY_0: i64 = 48;
    pub const KEY_H: i64 = 72;
    pub const KEY_L: i64 = 76;
    pub const KEY_COLON: i64 = 58;
    pub const JOY_BUTTON_2: i64 = 2;
    pub const KEY_SSHARP: i64 = 223;
    pub const KEY_ADIAERESIS: i64 = 196;
    pub const ERR_CANT_ACQUIRE_RESOURCE: i64 = 28;
    pub const KEY_3: i64 = 51;
    pub const JOY_BUTTON_6: i64 = 6;
    pub const JOY_AXIS_2: i64 = 2;
    pub const KEY_F3: i64 = 16777246;
    pub const KEY_SHIFT: i64 = 16777237;
    pub const KEY_UDIAERESIS: i64 = 220;
    pub const KEY_YACUTE: i64 = 221;
    pub const TYPE_RID: i64 = 16;
    pub const KEY_NUMBERSIGN: i64 = 35;
    pub const PROPERTY_USAGE_CHECKED: i64 = 32;
    pub const OP_SUBTRACT: i64 = 7;
    pub const KEY_6: i64 = 54;
    pub const KEY_LAUNCH0: i64 = 16777304;
    pub const METHOD_FLAG_EDITOR: i64 = 2;
    pub const JOY_DS_A: i64 = 1;
    pub const JOY_VR_GRIP: i64 = 2;
    pub const ERR_FILE_CANT_READ: i64 = 14;
    pub const OP_DIVIDE: i64 = 9;
    pub const TYPE_COLOR: i64 = 14;
    pub const JOY_ANALOG_LX: i64 = 0;
    pub const KEY_MEDIAPLAY: i64 = 16777292;
    pub const KEY_TAB: i64 = 16777218;
    pub const KEY_HYPER_L: i64 = 16777263;
    pub const JOY_BUTTON_MAX: i64 = 16;
    pub const KEY_DEGREE: i64 = 176;
    pub const KEY_KP_7: i64 = 16777357;
    pub const ERR_ALREADY_EXISTS: i64 = 32;
    pub const JOY_BUTTON_7: i64 = 7;
    pub const JOY_SONY_X: i64 = 0;
    pub const MIDI_MESSAGE_CHANNEL_PRESSURE: i64 = 13;
    pub const ERR_INVALID_PARAMETER: i64 = 31;
    pub const KEY_EACUTE: i64 = 201;
    pub const KEY_F2: i64 = 16777245;
    pub const KEY_DOLLAR: i64 = 36;
    pub const ERR_UNAUTHORIZED: i64 = 4;
    pub const JOY_BUTTON_11: i64 = 11;
    pub const TYPE_DICTIONARY: i64 = 18;
    pub const OP_AND: i64 = 20;
    pub const TYPE_AABB: i64 = 11;
    pub const ERR_DOES_NOT_EXIST: i64 = 33;
    pub const TYPE_INT_ARRAY: i64 = 21;
    pub const KEY_BRACKETRIGHT: i64 = 93;
    pub const MIDI_MESSAGE_AFTERTOUCH: i64 = 10;
    pub const PROPERTY_HINT_LENGTH: i64 = 5;
    pub const PROPERTY_USAGE_NOEDITOR: i64 = 5;
    pub const TYPE_STRING_ARRAY: i64 = 23;
    pub const KEY_LESS: i64 = 60;
    pub const ERR_SCRIPT_FAILED: i64 = 39;
    pub const KEY_CENT: i64 = 162;
    pub const OP_MAX: i64 = 25;
    pub const KEY_TWOSUPERIOR: i64 = 178;
}
impl GlobalConstants {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"GlobalConstants\0".as_ptr() as *mut _);

            GlobalConstants {
                this
            }
        }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRAnchor` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvranchor.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ARVRAnchor` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ARVRAnchor::free`.
///
/// ## Class hierarchy
///
/// ARVRAnchor inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRAnchor {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ARVRAnchor {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ARVRAnchor::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVRAnchorMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ARVRAnchor {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_anchor_id(&self) -> i64 {
        ARVRAnchor_get_anchor_id(self.this)
    }

    #[inline]
    pub unsafe fn get_anchor_name(&self) -> GodotString {
        ARVRAnchor_get_anchor_name(self.this)
    }

    #[inline]
    pub unsafe fn get_is_active(&self) -> bool {
        ARVRAnchor_get_is_active(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        ARVRAnchor_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_plane(&self) -> Plane {
        ARVRAnchor_get_plane(self.this)
    }

    #[inline]
    pub unsafe fn get_size(&self) -> Vector3 {
        ARVRAnchor_get_size(self.this)
    }

    #[inline]
    pub unsafe fn set_anchor_id(&mut self, anchor_id: i64) -> () {
        ARVRAnchor_set_anchor_id(self.this, anchor_id)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRCamera` inherits `Camera` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrcamera.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ARVRCamera` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ARVRCamera::free`.
///
/// ## Class hierarchy
///
/// ARVRCamera inherits methods from:
/// - [Camera](struct.Camera.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRCamera {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ARVRCamera {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ARVRCamera::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVRCameraMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ARVRCamera {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_camera(&self) -> Camera {
        // Not reference-counted.
        Camera { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRController` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrcontroller.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ARVRController` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ARVRController::free`.
///
/// ## Class hierarchy
///
/// ARVRController inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRController {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ARVRController {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ARVRController::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVRControllerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ARVRController {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_controller_id(&self) -> i64 {
        ARVRController_get_controller_id(self.this)
    }

    #[inline]
    pub unsafe fn get_controller_name(&self) -> GodotString {
        ARVRController_get_controller_name(self.this)
    }

    #[inline]
    pub unsafe fn get_hand(&self) -> ARVRPositionalTrackerTrackerHand {
        ARVRController_get_hand(self.this)
    }

    #[inline]
    pub unsafe fn get_is_active(&self) -> bool {
        ARVRController_get_is_active(self.this)
    }

    #[inline]
    pub unsafe fn get_joystick_axis(&self, axis: i64) -> f64 {
        ARVRController_get_joystick_axis(self.this, axis)
    }

    #[inline]
    pub unsafe fn get_joystick_id(&self) -> i64 {
        ARVRController_get_joystick_id(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        ARVRController_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_rumble(&self) -> f64 {
        ARVRController_get_rumble(self.this)
    }

    #[inline]
    pub unsafe fn is_button_pressed(&self, button: i64) -> i64 {
        ARVRController_is_button_pressed(self.this, button)
    }

    #[inline]
    pub unsafe fn set_controller_id(&mut self, controller_id: i64) -> () {
        ARVRController_set_controller_id(self.this, controller_id)
    }

    #[inline]
    pub unsafe fn set_rumble(&mut self, rumble: f64) -> () {
        ARVRController_set_rumble(self.this, rumble)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRInterface` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrinterface.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ARVRInterface inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRInterface {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRInterfaceTracking_status {
    ArvrNormalTracking = 0,
    ArvrExcessiveMotion = 1,
    ArvrInsufficientFeatures = 2,
    ArvrUnknownTracking = 3,
    ArvrNotTracking = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRInterfaceEyes {
    EyeMono = 0,
    EyeLeft = 1,
    EyeRight = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRInterfaceCapabilities {
    ArvrNone = 0,
    ArvrMono = 1,
    ArvrStereo = 2,
    ArvrAr = 4,
    ArvrExternal = 8,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ARVRInterface {
    pub const ARVR_NOT_TRACKING: i64 = 4;
    pub const ARVR_STEREO: i64 = 2;
    pub const ARVR_AR: i64 = 4;
    pub const ARVR_NONE: i64 = 0;
    pub const EYE_LEFT: i64 = 1;
    pub const ARVR_EXTERNAL: i64 = 8;
    pub const ARVR_UNKNOWN_TRACKING: i64 = 3;
    pub const EYE_MONO: i64 = 0;
    pub const EYE_RIGHT: i64 = 2;
    pub const ARVR_NORMAL_TRACKING: i64 = 0;
    pub const ARVR_INSUFFICIENT_FEATURES: i64 = 2;
    pub const ARVR_EXCESSIVE_MOTION: i64 = 1;
    pub const ARVR_MONO: i64 = 1;
}
impl ARVRInterface {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_anchor_detection_is_enabled(&self) -> bool {
        unsafe { ARVRInterface_get_anchor_detection_is_enabled(self.this) }
    }

    #[inline]
    pub fn get_camera_feed_id(&mut self) -> i64 {
        unsafe { ARVRInterface_get_camera_feed_id(self.this) }
    }

    #[inline]
    pub fn get_capabilities(&self) -> i64 {
        unsafe { ARVRInterface_get_capabilities(self.this) }
    }

    #[inline]
    pub fn get_name(&self) -> GodotString {
        unsafe { ARVRInterface_get_name(self.this) }
    }

    #[inline]
    pub fn get_render_targetsize(&mut self) -> Vector2 {
        unsafe { ARVRInterface_get_render_targetsize(self.this) }
    }

    #[inline]
    pub fn get_tracking_status(&self) -> ARVRInterfaceTracking_status {
        unsafe { ARVRInterface_get_tracking_status(self.this) }
    }

    #[inline]
    pub fn initialize(&mut self) -> bool {
        unsafe { ARVRInterface_initialize(self.this) }
    }

    #[inline]
    pub fn is_initialized(&self) -> bool {
        unsafe { ARVRInterface_is_initialized(self.this) }
    }

    #[inline]
    pub fn is_primary(&mut self) -> bool {
        unsafe { ARVRInterface_is_primary(self.this) }
    }

    #[inline]
    pub fn is_stereo(&mut self) -> bool {
        unsafe { ARVRInterface_is_stereo(self.this) }
    }

    #[inline]
    pub fn set_anchor_detection_is_enabled(&mut self, enable: bool) -> () {
        unsafe { ARVRInterface_set_anchor_detection_is_enabled(self.this, enable) }
    }

    #[inline]
    pub fn set_is_initialized(&mut self, initialized: bool) -> () {
        unsafe { ARVRInterface_set_is_initialized(self.this, initialized) }
    }

    #[inline]
    pub fn set_is_primary(&mut self, enable: bool) -> () {
        unsafe { ARVRInterface_set_is_primary(self.this, enable) }
    }

    #[inline]
    pub fn uninitialize(&mut self) -> () {
        unsafe { ARVRInterface_uninitialize(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRInterfaceGDNative` inherits `ARVRInterface` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrinterfacegdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ARVRInterfaceGDNative inherits methods from:
/// - [ARVRInterface](struct.ARVRInterface.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRInterfaceGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ARVRInterfaceGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVRInterfaceGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ARVRInterfaceGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_arvr_interface(&self) -> ARVRInterface {
        unsafe {{ object::add_ref(self.this); }}
        ARVRInterface { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVROrigin` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrorigin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ARVROrigin` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ARVROrigin::free`.
///
/// ## Class hierarchy
///
/// ARVROrigin inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVROrigin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ARVROrigin {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ARVROrigin::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVROriginMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ARVROrigin {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_world_scale(&self) -> f64 {
        ARVROrigin_get_world_scale(self.this)
    }

    #[inline]
    pub unsafe fn set_world_scale(&mut self, world_scale: f64) -> () {
        ARVROrigin_set_world_scale(self.this, world_scale)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ARVRPositionalTracker` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrpositionaltracker.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ARVRPositionalTracker` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ARVRPositionalTracker::free`.
///
/// ## Class hierarchy
///
/// ARVRPositionalTracker inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRPositionalTracker {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRPositionalTrackerTrackerHand {
    Unknown = 0,
    TrackerLeftHand = 1,
    TrackerRightHand = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ARVRPositionalTracker {
    pub const TRACKER_LEFT_HAND: i64 = 1;
    pub const TRACKER_HAND_UNKNOWN: i64 = 0;
    pub const TRACKER_RIGHT_HAND: i64 = 2;
}
impl ARVRPositionalTracker {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ARVRPositionalTracker::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ARVRPositionalTrackerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ARVRPositionalTracker {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _set_joy_id(&mut self, joy_id: i64) -> () {
        ARVRPositionalTracker__set_joy_id(self.this, joy_id)
    }

    #[inline]
    pub unsafe fn _set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        ARVRPositionalTracker__set_mesh(self.this, mesh)
    }

    #[inline]
    pub unsafe fn _set_name(&mut self, name: GodotString) -> () {
        ARVRPositionalTracker__set_name(self.this, name)
    }

    #[inline]
    pub unsafe fn _set_orientation(&mut self, orientation: Basis) -> () {
        ARVRPositionalTracker__set_orientation(self.this, orientation)
    }

    #[inline]
    pub unsafe fn _set_rw_position(&mut self, rw_position: Vector3) -> () {
        ARVRPositionalTracker__set_rw_position(self.this, rw_position)
    }

    #[inline]
    pub unsafe fn _set_type(&mut self, _type: i64) -> () {
        ARVRPositionalTracker__set_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn get_hand(&self) -> ARVRPositionalTrackerTrackerHand {
        ARVRPositionalTracker_get_hand(self.this)
    }

    #[inline]
    pub unsafe fn get_joy_id(&self) -> i64 {
        ARVRPositionalTracker_get_joy_id(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        ARVRPositionalTracker_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_name(&self) -> GodotString {
        ARVRPositionalTracker_get_name(self.this)
    }

    #[inline]
    pub unsafe fn get_orientation(&self) -> Basis {
        ARVRPositionalTracker_get_orientation(self.this)
    }

    #[inline]
    pub unsafe fn get_position(&self) -> Vector3 {
        ARVRPositionalTracker_get_position(self.this)
    }

    #[inline]
    pub unsafe fn get_rumble(&self) -> f64 {
        ARVRPositionalTracker_get_rumble(self.this)
    }

    #[inline]
    pub unsafe fn get_tracks_orientation(&self) -> bool {
        ARVRPositionalTracker_get_tracks_orientation(self.this)
    }

    #[inline]
    pub unsafe fn get_tracks_position(&self) -> bool {
        ARVRPositionalTracker_get_tracks_position(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self, adjust_by_reference_frame: bool) -> Transform {
        ARVRPositionalTracker_get_transform(self.this, adjust_by_reference_frame)
    }

    #[inline]
    pub unsafe fn get_type(&self) -> ARVRServerTrackerType {
        ARVRPositionalTracker_get_type(self.this)
    }

    #[inline]
    pub unsafe fn set_rumble(&mut self, rumble: f64) -> () {
        ARVRPositionalTracker_set_rumble(self.this, rumble)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class ARVRServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arvrserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ARVRServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ARVRServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRServerRotationMode {
    ResetFullRotation = 0,
    ResetButKeepTilt = 1,
    DontResetRotation = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ARVRServerTrackerType {
    TrackerController = 1,
    TrackerBasestation = 2,
    TrackerAnchor = 4,
    TrackerAnyKnown = 127,
    TrackerUnknown = 128,
    TrackerAny = 255,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ARVRServer {
    pub const TRACKER_UNKNOWN: i64 = 128;
    pub const RESET_BUT_KEEP_TILT: i64 = 1;
    pub const RESET_FULL_ROTATION: i64 = 0;
    pub const TRACKER_ANCHOR: i64 = 4;
    pub const TRACKER_CONTROLLER: i64 = 1;
    pub const TRACKER_ANY_KNOWN: i64 = 127;
    pub const TRACKER_BASESTATION: i64 = 2;
    pub const DONT_RESET_ROTATION: i64 = 2;
    pub const TRACKER_ANY: i64 = 255;
}
impl ARVRServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"ARVRServer\0".as_ptr() as *mut _);

            ARVRServer {
                this
            }
        }
    }
    #[inline]
    pub fn center_on_hmd(&mut self, rotation_mode: i64, keep_height: bool) -> () {
        unsafe { ARVRServer_center_on_hmd(self.this, rotation_mode, keep_height) }
    }

    #[inline]
    pub fn find_interface(&self, name: GodotString) -> Option<ARVRInterface> {
        unsafe { ARVRServer_find_interface(self.this, name) }
    }

    #[inline]
    pub fn get_hmd_transform(&mut self) -> Transform {
        unsafe { ARVRServer_get_hmd_transform(self.this) }
    }

    #[inline]
    pub fn get_interface(&self, idx: i64) -> Option<ARVRInterface> {
        unsafe { ARVRServer_get_interface(self.this, idx) }
    }

    #[inline]
    pub fn get_interface_count(&self) -> i64 {
        unsafe { ARVRServer_get_interface_count(self.this) }
    }

    #[inline]
    pub fn get_interfaces(&self) -> VariantArray {
        unsafe { ARVRServer_get_interfaces(self.this) }
    }

    #[inline]
    pub fn get_last_commit_usec(&mut self) -> i64 {
        unsafe { ARVRServer_get_last_commit_usec(self.this) }
    }

    #[inline]
    pub fn get_last_frame_usec(&mut self) -> i64 {
        unsafe { ARVRServer_get_last_frame_usec(self.this) }
    }

    #[inline]
    pub fn get_last_process_usec(&mut self) -> i64 {
        unsafe { ARVRServer_get_last_process_usec(self.this) }
    }

    #[inline]
    pub fn get_primary_interface(&self) -> Option<ARVRInterface> {
        unsafe { ARVRServer_get_primary_interface(self.this) }
    }

    #[inline]
    pub fn get_reference_frame(&self) -> Transform {
        unsafe { ARVRServer_get_reference_frame(self.this) }
    }

    #[inline]
    pub fn get_tracker(&self, idx: i64) -> Option<ARVRPositionalTracker> {
        unsafe { ARVRServer_get_tracker(self.this, idx) }
    }

    #[inline]
    pub fn get_tracker_count(&self) -> i64 {
        unsafe { ARVRServer_get_tracker_count(self.this) }
    }

    #[inline]
    pub fn get_world_scale(&self) -> f64 {
        unsafe { ARVRServer_get_world_scale(self.this) }
    }

    #[inline]
    pub fn set_primary_interface(&mut self, interface: Option<ARVRInterface>) -> () {
        unsafe { ARVRServer_set_primary_interface(self.this, interface) }
    }

    #[inline]
    pub fn set_world_scale(&mut self, arg0: f64) -> () {
        unsafe { ARVRServer_set_world_scale(self.this, arg0) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AStar` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_astar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AStar inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AStar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AStar {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AStarMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AStar {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _compute_cost(&mut self, from_id: i64, to_id: i64) -> f64 {
        unsafe { AStar__compute_cost(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn _estimate_cost(&mut self, from_id: i64, to_id: i64) -> f64 {
        unsafe { AStar__estimate_cost(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn add_point(&mut self, id: i64, position: Vector3, weight_scale: f64) -> () {
        unsafe { AStar_add_point(self.this, id, position, weight_scale) }
    }

    #[inline]
    pub fn are_points_connected(&self, id: i64, to_id: i64, bidirectional: bool) -> bool {
        unsafe { AStar_are_points_connected(self.this, id, to_id, bidirectional) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { AStar_clear(self.this) }
    }

    #[inline]
    pub fn connect_points(&mut self, id: i64, to_id: i64, bidirectional: bool) -> () {
        unsafe { AStar_connect_points(self.this, id, to_id, bidirectional) }
    }

    #[inline]
    pub fn disconnect_points(&mut self, id: i64, to_id: i64, bidirectional: bool) -> () {
        unsafe { AStar_disconnect_points(self.this, id, to_id, bidirectional) }
    }

    #[inline]
    pub fn get_available_point_id(&self) -> i64 {
        unsafe { AStar_get_available_point_id(self.this) }
    }

    #[inline]
    pub fn get_closest_point(&self, to_position: Vector3, include_disabled: bool) -> i64 {
        unsafe { AStar_get_closest_point(self.this, to_position, include_disabled) }
    }

    #[inline]
    pub fn get_closest_position_in_segment(&self, to_position: Vector3) -> Vector3 {
        unsafe { AStar_get_closest_position_in_segment(self.this, to_position) }
    }

    #[inline]
    pub fn get_id_path(&mut self, from_id: i64, to_id: i64) -> Int32Array {
        unsafe { AStar_get_id_path(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn get_point_capacity(&self) -> i64 {
        unsafe { AStar_get_point_capacity(self.this) }
    }

    #[inline]
    pub fn get_point_connections(&mut self, id: i64) -> Int32Array {
        unsafe { AStar_get_point_connections(self.this, id) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { AStar_get_point_count(self.this) }
    }

    #[inline]
    pub fn get_point_path(&mut self, from_id: i64, to_id: i64) -> Vector3Array {
        unsafe { AStar_get_point_path(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn get_point_position(&self, id: i64) -> Vector3 {
        unsafe { AStar_get_point_position(self.this, id) }
    }

    #[inline]
    pub fn get_point_weight_scale(&self, id: i64) -> f64 {
        unsafe { AStar_get_point_weight_scale(self.this, id) }
    }

    #[inline]
    pub fn get_points(&mut self) -> VariantArray {
        unsafe { AStar_get_points(self.this) }
    }

    #[inline]
    pub fn has_point(&self, id: i64) -> bool {
        unsafe { AStar_has_point(self.this, id) }
    }

    #[inline]
    pub fn is_point_disabled(&self, id: i64) -> bool {
        unsafe { AStar_is_point_disabled(self.this, id) }
    }

    #[inline]
    pub fn remove_point(&mut self, id: i64) -> () {
        unsafe { AStar_remove_point(self.this, id) }
    }

    #[inline]
    pub fn reserve_space(&mut self, num_nodes: i64) -> () {
        unsafe { AStar_reserve_space(self.this, num_nodes) }
    }

    #[inline]
    pub fn set_point_disabled(&mut self, id: i64, disabled: bool) -> () {
        unsafe { AStar_set_point_disabled(self.this, id, disabled) }
    }

    #[inline]
    pub fn set_point_position(&mut self, id: i64, position: Vector3) -> () {
        unsafe { AStar_set_point_position(self.this, id, position) }
    }

    #[inline]
    pub fn set_point_weight_scale(&mut self, id: i64, weight_scale: f64) -> () {
        unsafe { AStar_set_point_weight_scale(self.this, id, weight_scale) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AStar2D` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_astar2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AStar2D inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AStar2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AStar2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AStar2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AStar2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_point(&mut self, id: i64, position: Vector2, weight_scale: f64) -> () {
        unsafe { AStar2D_add_point(self.this, id, position, weight_scale) }
    }

    #[inline]
    pub fn are_points_connected(&self, id: i64, to_id: i64) -> bool {
        unsafe { AStar2D_are_points_connected(self.this, id, to_id) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { AStar2D_clear(self.this) }
    }

    #[inline]
    pub fn connect_points(&mut self, id: i64, to_id: i64, bidirectional: bool) -> () {
        unsafe { AStar2D_connect_points(self.this, id, to_id, bidirectional) }
    }

    #[inline]
    pub fn disconnect_points(&mut self, id: i64, to_id: i64) -> () {
        unsafe { AStar2D_disconnect_points(self.this, id, to_id) }
    }

    #[inline]
    pub fn get_available_point_id(&self) -> i64 {
        unsafe { AStar2D_get_available_point_id(self.this) }
    }

    #[inline]
    pub fn get_closest_point(&self, to_position: Vector2, include_disabled: bool) -> i64 {
        unsafe { AStar2D_get_closest_point(self.this, to_position, include_disabled) }
    }

    #[inline]
    pub fn get_closest_position_in_segment(&self, to_position: Vector2) -> Vector2 {
        unsafe { AStar2D_get_closest_position_in_segment(self.this, to_position) }
    }

    #[inline]
    pub fn get_id_path(&mut self, from_id: i64, to_id: i64) -> Int32Array {
        unsafe { AStar2D_get_id_path(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn get_point_capacity(&self) -> i64 {
        unsafe { AStar2D_get_point_capacity(self.this) }
    }

    #[inline]
    pub fn get_point_connections(&mut self, id: i64) -> Int32Array {
        unsafe { AStar2D_get_point_connections(self.this, id) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { AStar2D_get_point_count(self.this) }
    }

    #[inline]
    pub fn get_point_path(&mut self, from_id: i64, to_id: i64) -> Vector2Array {
        unsafe { AStar2D_get_point_path(self.this, from_id, to_id) }
    }

    #[inline]
    pub fn get_point_position(&self, id: i64) -> Vector2 {
        unsafe { AStar2D_get_point_position(self.this, id) }
    }

    #[inline]
    pub fn get_point_weight_scale(&self, id: i64) -> f64 {
        unsafe { AStar2D_get_point_weight_scale(self.this, id) }
    }

    #[inline]
    pub fn get_points(&mut self) -> VariantArray {
        unsafe { AStar2D_get_points(self.this) }
    }

    #[inline]
    pub fn has_point(&self, id: i64) -> bool {
        unsafe { AStar2D_has_point(self.this, id) }
    }

    #[inline]
    pub fn is_point_disabled(&self, id: i64) -> bool {
        unsafe { AStar2D_is_point_disabled(self.this, id) }
    }

    #[inline]
    pub fn remove_point(&mut self, id: i64) -> () {
        unsafe { AStar2D_remove_point(self.this, id) }
    }

    #[inline]
    pub fn reserve_space(&mut self, num_nodes: i64) -> () {
        unsafe { AStar2D_reserve_space(self.this, num_nodes) }
    }

    #[inline]
    pub fn set_point_disabled(&mut self, id: i64, disabled: bool) -> () {
        unsafe { AStar2D_set_point_disabled(self.this, id, disabled) }
    }

    #[inline]
    pub fn set_point_position(&mut self, id: i64, position: Vector2) -> () {
        unsafe { AStar2D_set_point_position(self.this, id, position) }
    }

    #[inline]
    pub fn set_point_weight_scale(&mut self, id: i64, weight_scale: f64) -> () {
        unsafe { AStar2D_set_point_weight_scale(self.this, id, weight_scale) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AcceptDialog` inherits `WindowDialog` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_acceptdialog.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AcceptDialog` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AcceptDialog::free`.
///
/// ## Class hierarchy
///
/// AcceptDialog inherits methods from:
/// - [WindowDialog](struct.WindowDialog.html)
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AcceptDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AcceptDialog {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AcceptDialog::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AcceptDialogMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AcceptDialog {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _builtin_text_entered(&mut self, arg0: GodotString) -> () {
        AcceptDialog__builtin_text_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _custom_action(&mut self, arg0: GodotString) -> () {
        AcceptDialog__custom_action(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _ok(&mut self) -> () {
        AcceptDialog__ok(self.this)
    }

    #[inline]
    pub unsafe fn add_button(&mut self, text: GodotString, right: bool, action: GodotString) -> Option<Button> {
        AcceptDialog_add_button(self.this, text, right, action)
    }

    #[inline]
    pub unsafe fn add_cancel(&mut self, name: GodotString) -> Option<Button> {
        AcceptDialog_add_cancel(self.this, name)
    }

    #[inline]
    pub unsafe fn get_hide_on_ok(&self) -> bool {
        AcceptDialog_get_hide_on_ok(self.this)
    }

    #[inline]
    pub unsafe fn get_label(&mut self) -> Option<Label> {
        AcceptDialog_get_label(self.this)
    }

    #[inline]
    pub unsafe fn get_ok(&mut self) -> Option<Button> {
        AcceptDialog_get_ok(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&self) -> GodotString {
        AcceptDialog_get_text(self.this)
    }

    #[inline]
    pub unsafe fn has_autowrap(&mut self) -> bool {
        AcceptDialog_has_autowrap(self.this)
    }

    #[inline]
    pub unsafe fn register_text_enter(&mut self, line_edit: Option<Node>) -> () {
        AcceptDialog_register_text_enter(self.this, line_edit)
    }

    #[inline]
    pub unsafe fn set_autowrap(&mut self, autowrap: bool) -> () {
        AcceptDialog_set_autowrap(self.this, autowrap)
    }

    #[inline]
    pub unsafe fn set_hide_on_ok(&mut self, enabled: bool) -> () {
        AcceptDialog_set_hide_on_ok(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        AcceptDialog_set_text(self.this, text)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_window_dialog(&self) -> WindowDialog {
        // Not reference-counted.
        WindowDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimatedSprite` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animatedsprite.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AnimatedSprite` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AnimatedSprite::free`.
///
/// ## Class hierarchy
///
/// AnimatedSprite inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimatedSprite {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimatedSprite {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AnimatedSprite::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimatedSpriteMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AnimatedSprite {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _is_playing(&self) -> bool {
        AnimatedSprite__is_playing(self.this)
    }

    #[inline]
    pub unsafe fn _res_changed(&mut self) -> () {
        AnimatedSprite__res_changed(self.this)
    }

    #[inline]
    pub unsafe fn _set_playing(&mut self, playing: bool) -> () {
        AnimatedSprite__set_playing(self.this, playing)
    }

    #[inline]
    pub unsafe fn get_animation(&self) -> GodotString {
        AnimatedSprite_get_animation(self.this)
    }

    #[inline]
    pub unsafe fn get_frame(&self) -> i64 {
        AnimatedSprite_get_frame(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        AnimatedSprite_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        AnimatedSprite_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_sprite_frames(&self) -> Option<SpriteFrames> {
        AnimatedSprite_get_sprite_frames(self.this)
    }

    #[inline]
    pub unsafe fn is_centered(&self) -> bool {
        AnimatedSprite_is_centered(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_h(&self) -> bool {
        AnimatedSprite_is_flipped_h(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_v(&self) -> bool {
        AnimatedSprite_is_flipped_v(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AnimatedSprite_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, anim: GodotString, backwards: bool) -> () {
        AnimatedSprite_play(self.this, anim, backwards)
    }

    #[inline]
    pub unsafe fn set_animation(&mut self, animation: GodotString) -> () {
        AnimatedSprite_set_animation(self.this, animation)
    }

    #[inline]
    pub unsafe fn set_centered(&mut self, centered: bool) -> () {
        AnimatedSprite_set_centered(self.this, centered)
    }

    #[inline]
    pub unsafe fn set_flip_h(&mut self, flip_h: bool) -> () {
        AnimatedSprite_set_flip_h(self.this, flip_h)
    }

    #[inline]
    pub unsafe fn set_flip_v(&mut self, flip_v: bool) -> () {
        AnimatedSprite_set_flip_v(self.this, flip_v)
    }

    #[inline]
    pub unsafe fn set_frame(&mut self, frame: i64) -> () {
        AnimatedSprite_set_frame(self.this, frame)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        AnimatedSprite_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, speed_scale: f64) -> () {
        AnimatedSprite_set_speed_scale(self.this, speed_scale)
    }

    #[inline]
    pub unsafe fn set_sprite_frames(&mut self, sprite_frames: Option<SpriteFrames>) -> () {
        AnimatedSprite_set_sprite_frames(self.this, sprite_frames)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        AnimatedSprite_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimatedSprite3D` inherits `SpriteBase3D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animatedsprite3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AnimatedSprite3D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AnimatedSprite3D::free`.
///
/// ## Class hierarchy
///
/// AnimatedSprite3D inherits methods from:
/// - [SpriteBase3D](struct.SpriteBase3D.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimatedSprite3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimatedSprite3D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AnimatedSprite3D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimatedSprite3DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AnimatedSprite3D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _is_playing(&self) -> bool {
        AnimatedSprite3D__is_playing(self.this)
    }

    #[inline]
    pub unsafe fn _res_changed(&mut self) -> () {
        AnimatedSprite3D__res_changed(self.this)
    }

    #[inline]
    pub unsafe fn _set_playing(&mut self, playing: bool) -> () {
        AnimatedSprite3D__set_playing(self.this, playing)
    }

    #[inline]
    pub unsafe fn get_animation(&self) -> GodotString {
        AnimatedSprite3D_get_animation(self.this)
    }

    #[inline]
    pub unsafe fn get_frame(&self) -> i64 {
        AnimatedSprite3D_get_frame(self.this)
    }

    #[inline]
    pub unsafe fn get_sprite_frames(&self) -> Option<SpriteFrames> {
        AnimatedSprite3D_get_sprite_frames(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AnimatedSprite3D_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, anim: GodotString) -> () {
        AnimatedSprite3D_play(self.this, anim)
    }

    #[inline]
    pub unsafe fn set_animation(&mut self, animation: GodotString) -> () {
        AnimatedSprite3D_set_animation(self.this, animation)
    }

    #[inline]
    pub unsafe fn set_frame(&mut self, frame: i64) -> () {
        AnimatedSprite3D_set_frame(self.this, frame)
    }

    #[inline]
    pub unsafe fn set_sprite_frames(&mut self, sprite_frames: Option<SpriteFrames>) -> () {
        AnimatedSprite3D_set_sprite_frames(self.this, sprite_frames)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        AnimatedSprite3D_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_sprite_base_3d(&self) -> SpriteBase3D {
        // Not reference-counted.
        SpriteBase3D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimatedTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animatedtexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimatedTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimatedTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl AnimatedTexture {
    pub const MAX_FRAMES: i64 = 256;
}
impl AnimatedTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimatedTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimatedTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _update_proxy(&mut self) -> () {
        unsafe { AnimatedTexture__update_proxy(self.this) }
    }

    #[inline]
    pub fn get_fps(&self) -> f64 {
        unsafe { AnimatedTexture_get_fps(self.this) }
    }

    #[inline]
    pub fn get_frame_delay(&self, frame: i64) -> f64 {
        unsafe { AnimatedTexture_get_frame_delay(self.this, frame) }
    }

    #[inline]
    pub fn get_frame_texture(&self, frame: i64) -> Option<Texture> {
        unsafe { AnimatedTexture_get_frame_texture(self.this, frame) }
    }

    #[inline]
    pub fn get_frames(&self) -> i64 {
        unsafe { AnimatedTexture_get_frames(self.this) }
    }

    #[inline]
    pub fn set_fps(&mut self, fps: f64) -> () {
        unsafe { AnimatedTexture_set_fps(self.this, fps) }
    }

    #[inline]
    pub fn set_frame_delay(&mut self, frame: i64, delay: f64) -> () {
        unsafe { AnimatedTexture_set_frame_delay(self.this, frame, delay) }
    }

    #[inline]
    pub fn set_frame_texture(&mut self, frame: i64, texture: Option<Texture>) -> () {
        unsafe { AnimatedTexture_set_frame_texture(self.this, frame, texture) }
    }

    #[inline]
    pub fn set_frames(&mut self, frames: i64) -> () {
        unsafe { AnimatedTexture_set_frames(self.this, frames) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Animation` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animation.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Animation inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Animation {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationTrackType {
    TypeValue = 0,
    TypeTransform = 1,
    TypeMethod = 2,
    TypeBezier = 3,
    TypeAudio = 4,
    TypeAnimation = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationUpdateMode {
    Continuous = 0,
    Discrete = 1,
    Trigger = 2,
    Capture = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationInterpolationType {
    InterpolationNearest = 0,
    InterpolationLinear = 1,
    InterpolationCubic = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Animation {
    pub const INTERPOLATION_LINEAR: i64 = 1;
    pub const UPDATE_DISCRETE: i64 = 1;
    pub const UPDATE_CAPTURE: i64 = 3;
    pub const UPDATE_CONTINUOUS: i64 = 0;
    pub const TYPE_METHOD: i64 = 2;
    pub const TYPE_AUDIO: i64 = 4;
    pub const TYPE_VALUE: i64 = 0;
    pub const TYPE_ANIMATION: i64 = 5;
    pub const TYPE_BEZIER: i64 = 3;
    pub const INTERPOLATION_CUBIC: i64 = 2;
    pub const TYPE_TRANSFORM: i64 = 1;
    pub const INTERPOLATION_NEAREST: i64 = 0;
    pub const UPDATE_TRIGGER: i64 = 2;
}
impl Animation {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Animation {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_track(&mut self, _type: i64, at_position: i64) -> i64 {
        unsafe { Animation_add_track(self.this, _type, at_position) }
    }

    #[inline]
    pub fn animation_track_get_key_animation(&self, track_idx: i64, key_idx: i64) -> GodotString {
        unsafe { Animation_animation_track_get_key_animation(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn animation_track_insert_key(&mut self, track_idx: i64, time: f64, animation: GodotString) -> i64 {
        unsafe { Animation_animation_track_insert_key(self.this, track_idx, time, animation) }
    }

    #[inline]
    pub fn animation_track_set_key_animation(&mut self, track_idx: i64, key_idx: i64, animation: GodotString) -> () {
        unsafe { Animation_animation_track_set_key_animation(self.this, track_idx, key_idx, animation) }
    }

    #[inline]
    pub fn audio_track_get_key_end_offset(&self, track_idx: i64, key_idx: i64) -> f64 {
        unsafe { Animation_audio_track_get_key_end_offset(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn audio_track_get_key_start_offset(&self, track_idx: i64, key_idx: i64) -> f64 {
        unsafe { Animation_audio_track_get_key_start_offset(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn audio_track_get_key_stream(&self, track_idx: i64, key_idx: i64) -> Option<Resource> {
        unsafe { Animation_audio_track_get_key_stream(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn audio_track_insert_key(&mut self, track_idx: i64, time: f64, stream: Option<Resource>, start_offset: f64, end_offset: f64) -> i64 {
        unsafe { Animation_audio_track_insert_key(self.this, track_idx, time, stream, start_offset, end_offset) }
    }

    #[inline]
    pub fn audio_track_set_key_end_offset(&mut self, track_idx: i64, key_idx: i64, offset: f64) -> () {
        unsafe { Animation_audio_track_set_key_end_offset(self.this, track_idx, key_idx, offset) }
    }

    #[inline]
    pub fn audio_track_set_key_start_offset(&mut self, track_idx: i64, key_idx: i64, offset: f64) -> () {
        unsafe { Animation_audio_track_set_key_start_offset(self.this, track_idx, key_idx, offset) }
    }

    #[inline]
    pub fn audio_track_set_key_stream(&mut self, track_idx: i64, key_idx: i64, stream: Option<Resource>) -> () {
        unsafe { Animation_audio_track_set_key_stream(self.this, track_idx, key_idx, stream) }
    }

    #[inline]
    pub fn bezier_track_get_key_in_handle(&self, track_idx: i64, key_idx: i64) -> Vector2 {
        unsafe { Animation_bezier_track_get_key_in_handle(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn bezier_track_get_key_out_handle(&self, track_idx: i64, key_idx: i64) -> Vector2 {
        unsafe { Animation_bezier_track_get_key_out_handle(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn bezier_track_get_key_value(&self, track_idx: i64, key_idx: i64) -> f64 {
        unsafe { Animation_bezier_track_get_key_value(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn bezier_track_insert_key(&mut self, track_idx: i64, time: f64, value: f64, in_handle: Vector2, out_handle: Vector2) -> i64 {
        unsafe { Animation_bezier_track_insert_key(self.this, track_idx, time, value, in_handle, out_handle) }
    }

    #[inline]
    pub fn bezier_track_interpolate(&self, track_idx: i64, time: f64) -> f64 {
        unsafe { Animation_bezier_track_interpolate(self.this, track_idx, time) }
    }

    #[inline]
    pub fn bezier_track_set_key_in_handle(&mut self, track_idx: i64, key_idx: i64, in_handle: Vector2) -> () {
        unsafe { Animation_bezier_track_set_key_in_handle(self.this, track_idx, key_idx, in_handle) }
    }

    #[inline]
    pub fn bezier_track_set_key_out_handle(&mut self, track_idx: i64, key_idx: i64, out_handle: Vector2) -> () {
        unsafe { Animation_bezier_track_set_key_out_handle(self.this, track_idx, key_idx, out_handle) }
    }

    #[inline]
    pub fn bezier_track_set_key_value(&mut self, track_idx: i64, key_idx: i64, value: f64) -> () {
        unsafe { Animation_bezier_track_set_key_value(self.this, track_idx, key_idx, value) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { Animation_clear(self.this) }
    }

    #[inline]
    pub fn copy_track(&mut self, track_idx: i64, to_animation: Option<Animation>) -> () {
        unsafe { Animation_copy_track(self.this, track_idx, to_animation) }
    }

    #[inline]
    pub fn find_track(&self, path: NodePath) -> i64 {
        unsafe { Animation_find_track(self.this, path) }
    }

    #[inline]
    pub fn get_length(&self) -> f64 {
        unsafe { Animation_get_length(self.this) }
    }

    #[inline]
    pub fn get_step(&self) -> f64 {
        unsafe { Animation_get_step(self.this) }
    }

    #[inline]
    pub fn get_track_count(&self) -> i64 {
        unsafe { Animation_get_track_count(self.this) }
    }

    #[inline]
    pub fn has_loop(&self) -> bool {
        unsafe { Animation_has_loop(self.this) }
    }

    #[inline]
    pub fn method_track_get_key_indices(&self, track_idx: i64, time_sec: f64, delta: f64) -> Int32Array {
        unsafe { Animation_method_track_get_key_indices(self.this, track_idx, time_sec, delta) }
    }

    #[inline]
    pub fn method_track_get_name(&self, track_idx: i64, key_idx: i64) -> GodotString {
        unsafe { Animation_method_track_get_name(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn method_track_get_params(&self, track_idx: i64, key_idx: i64) -> VariantArray {
        unsafe { Animation_method_track_get_params(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn remove_track(&mut self, track_idx: i64) -> () {
        unsafe { Animation_remove_track(self.this, track_idx) }
    }

    #[inline]
    pub fn set_length(&mut self, time_sec: f64) -> () {
        unsafe { Animation_set_length(self.this, time_sec) }
    }

    #[inline]
    pub fn set_loop(&mut self, enabled: bool) -> () {
        unsafe { Animation_set_loop(self.this, enabled) }
    }

    #[inline]
    pub fn set_step(&mut self, size_sec: f64) -> () {
        unsafe { Animation_set_step(self.this, size_sec) }
    }

    #[inline]
    pub fn track_find_key(&self, track_idx: i64, time: f64, exact: bool) -> i64 {
        unsafe { Animation_track_find_key(self.this, track_idx, time, exact) }
    }

    #[inline]
    pub fn track_get_interpolation_loop_wrap(&self, track_idx: i64) -> bool {
        unsafe { Animation_track_get_interpolation_loop_wrap(self.this, track_idx) }
    }

    #[inline]
    pub fn track_get_interpolation_type(&self, track_idx: i64) -> AnimationInterpolationType {
        unsafe { Animation_track_get_interpolation_type(self.this, track_idx) }
    }

    #[inline]
    pub fn track_get_key_count(&self, track_idx: i64) -> i64 {
        unsafe { Animation_track_get_key_count(self.this, track_idx) }
    }

    #[inline]
    pub fn track_get_key_time(&self, track_idx: i64, key_idx: i64) -> f64 {
        unsafe { Animation_track_get_key_time(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn track_get_key_transition(&self, track_idx: i64, key_idx: i64) -> f64 {
        unsafe { Animation_track_get_key_transition(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn track_get_key_value(&self, track_idx: i64, key_idx: i64) -> Variant {
        unsafe { Animation_track_get_key_value(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn track_get_path(&self, track_idx: i64) -> NodePath {
        unsafe { Animation_track_get_path(self.this, track_idx) }
    }

    #[inline]
    pub fn track_get_type(&self, track_idx: i64) -> AnimationTrackType {
        unsafe { Animation_track_get_type(self.this, track_idx) }
    }

    #[inline]
    pub fn track_insert_key(&mut self, track_idx: i64, time: f64, key: Variant, transition: f64) -> () {
        unsafe { Animation_track_insert_key(self.this, track_idx, time, key, transition) }
    }

    #[inline]
    pub fn track_is_enabled(&self, track_idx: i64) -> bool {
        unsafe { Animation_track_is_enabled(self.this, track_idx) }
    }

    #[inline]
    pub fn track_is_imported(&self, track_idx: i64) -> bool {
        unsafe { Animation_track_is_imported(self.this, track_idx) }
    }

    #[inline]
    pub fn track_move_down(&mut self, track_idx: i64) -> () {
        unsafe { Animation_track_move_down(self.this, track_idx) }
    }

    #[inline]
    pub fn track_move_to(&mut self, track_idx: i64, to_idx: i64) -> () {
        unsafe { Animation_track_move_to(self.this, track_idx, to_idx) }
    }

    #[inline]
    pub fn track_move_up(&mut self, track_idx: i64) -> () {
        unsafe { Animation_track_move_up(self.this, track_idx) }
    }

    #[inline]
    pub fn track_remove_key(&mut self, track_idx: i64, key_idx: i64) -> () {
        unsafe { Animation_track_remove_key(self.this, track_idx, key_idx) }
    }

    #[inline]
    pub fn track_remove_key_at_position(&mut self, track_idx: i64, position: f64) -> () {
        unsafe { Animation_track_remove_key_at_position(self.this, track_idx, position) }
    }

    #[inline]
    pub fn track_set_enabled(&mut self, track_idx: i64, enabled: bool) -> () {
        unsafe { Animation_track_set_enabled(self.this, track_idx, enabled) }
    }

    #[inline]
    pub fn track_set_imported(&mut self, track_idx: i64, imported: bool) -> () {
        unsafe { Animation_track_set_imported(self.this, track_idx, imported) }
    }

    #[inline]
    pub fn track_set_interpolation_loop_wrap(&mut self, track_idx: i64, interpolation: bool) -> () {
        unsafe { Animation_track_set_interpolation_loop_wrap(self.this, track_idx, interpolation) }
    }

    #[inline]
    pub fn track_set_interpolation_type(&mut self, track_idx: i64, interpolation: i64) -> () {
        unsafe { Animation_track_set_interpolation_type(self.this, track_idx, interpolation) }
    }

    #[inline]
    pub fn track_set_key_time(&mut self, track_idx: i64, key_idx: i64, time: f64) -> () {
        unsafe { Animation_track_set_key_time(self.this, track_idx, key_idx, time) }
    }

    #[inline]
    pub fn track_set_key_transition(&mut self, track_idx: i64, key_idx: i64, transition: f64) -> () {
        unsafe { Animation_track_set_key_transition(self.this, track_idx, key_idx, transition) }
    }

    #[inline]
    pub fn track_set_key_value(&mut self, track_idx: i64, key: i64, value: Variant) -> () {
        unsafe { Animation_track_set_key_value(self.this, track_idx, key, value) }
    }

    #[inline]
    pub fn track_set_path(&mut self, track_idx: i64, path: NodePath) -> () {
        unsafe { Animation_track_set_path(self.this, track_idx, path) }
    }

    #[inline]
    pub fn track_swap(&mut self, track_idx: i64, with_idx: i64) -> () {
        unsafe { Animation_track_swap(self.this, track_idx, with_idx) }
    }

    #[inline]
    pub fn transform_track_insert_key(&mut self, track_idx: i64, time: f64, location: Vector3, rotation: Quat, scale: Vector3) -> i64 {
        unsafe { Animation_transform_track_insert_key(self.this, track_idx, time, location, rotation, scale) }
    }

    #[inline]
    pub fn transform_track_interpolate(&self, track_idx: i64, time_sec: f64) -> VariantArray {
        unsafe { Animation_transform_track_interpolate(self.this, track_idx, time_sec) }
    }

    #[inline]
    pub fn value_track_get_key_indices(&self, track_idx: i64, time_sec: f64, delta: f64) -> Int32Array {
        unsafe { Animation_value_track_get_key_indices(self.this, track_idx, time_sec, delta) }
    }

    #[inline]
    pub fn value_track_get_update_mode(&self, track_idx: i64) -> AnimationUpdateMode {
        unsafe { Animation_value_track_get_update_mode(self.this, track_idx) }
    }

    #[inline]
    pub fn value_track_set_update_mode(&mut self, track_idx: i64, mode: i64) -> () {
        unsafe { Animation_value_track_set_update_mode(self.this, track_idx, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNode` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNode inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationNodeFilterAction {
    FilterIgnore = 0,
    FilterPass = 1,
    FilterStop = 2,
    FilterBlend = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationNode {
    pub const FILTER_STOP: i64 = 2;
    pub const FILTER_IGNORE: i64 = 0;
    pub const FILTER_PASS: i64 = 1;
    pub const FILTER_BLEND: i64 = 3;
}
impl AnimationNode {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNode {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_filters(&self) -> VariantArray {
        unsafe { AnimationNode__get_filters(self.this) }
    }

    #[inline]
    pub fn _set_filters(&mut self, filters: VariantArray) -> () {
        unsafe { AnimationNode__set_filters(self.this, filters) }
    }

    #[inline]
    pub fn add_input(&mut self, name: GodotString) -> () {
        unsafe { AnimationNode_add_input(self.this, name) }
    }

    #[inline]
    pub fn blend_animation(&mut self, animation: GodotString, time: f64, delta: f64, seeked: bool, blend: f64) -> () {
        unsafe { AnimationNode_blend_animation(self.this, animation, time, delta, seeked, blend) }
    }

    #[inline]
    pub fn blend_input(&mut self, input_index: i64, time: f64, seek: bool, blend: f64, filter: i64, optimize: bool) -> f64 {
        unsafe { AnimationNode_blend_input(self.this, input_index, time, seek, blend, filter, optimize) }
    }

    #[inline]
    pub fn blend_node(&mut self, name: GodotString, node: Option<AnimationNode>, time: f64, seek: bool, blend: f64, filter: i64, optimize: bool) -> f64 {
        unsafe { AnimationNode_blend_node(self.this, name, node, time, seek, blend, filter, optimize) }
    }

    #[inline]
    pub fn get_caption(&mut self) -> GodotString {
        unsafe { AnimationNode_get_caption(self.this) }
    }

    #[inline]
    pub fn get_child_by_name(&mut self, name: GodotString) -> Option<Object> {
        unsafe { AnimationNode_get_child_by_name(self.this, name) }
    }

    #[inline]
    pub fn get_child_nodes(&mut self) -> Dictionary {
        unsafe { AnimationNode_get_child_nodes(self.this) }
    }

    #[inline]
    pub fn get_input_count(&self) -> i64 {
        unsafe { AnimationNode_get_input_count(self.this) }
    }

    #[inline]
    pub fn get_input_name(&mut self, input: i64) -> GodotString {
        unsafe { AnimationNode_get_input_name(self.this, input) }
    }

    #[inline]
    pub fn get_parameter(&self, name: GodotString) -> Variant {
        unsafe { AnimationNode_get_parameter(self.this, name) }
    }

    #[inline]
    pub fn get_parameter_default_value(&mut self, name: GodotString) -> Variant {
        unsafe { AnimationNode_get_parameter_default_value(self.this, name) }
    }

    #[inline]
    pub fn get_parameter_list(&mut self) -> VariantArray {
        unsafe { AnimationNode_get_parameter_list(self.this) }
    }

    #[inline]
    pub fn has_filter(&mut self) -> GodotString {
        unsafe { AnimationNode_has_filter(self.this) }
    }

    #[inline]
    pub fn is_filter_enabled(&self) -> bool {
        unsafe { AnimationNode_is_filter_enabled(self.this) }
    }

    #[inline]
    pub fn is_path_filtered(&self, path: NodePath) -> bool {
        unsafe { AnimationNode_is_path_filtered(self.this, path) }
    }

    #[inline]
    pub fn process(&mut self, time: f64, seek: bool) -> () {
        unsafe { AnimationNode_process(self.this, time, seek) }
    }

    #[inline]
    pub fn remove_input(&mut self, index: i64) -> () {
        unsafe { AnimationNode_remove_input(self.this, index) }
    }

    #[inline]
    pub fn set_filter_enabled(&mut self, enable: bool) -> () {
        unsafe { AnimationNode_set_filter_enabled(self.this, enable) }
    }

    #[inline]
    pub fn set_filter_path(&mut self, path: NodePath, enable: bool) -> () {
        unsafe { AnimationNode_set_filter_path(self.this, path, enable) }
    }

    #[inline]
    pub fn set_parameter(&mut self, name: GodotString, value: Variant) -> () {
        unsafe { AnimationNode_set_parameter(self.this, name, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeAdd2` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeadd2.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeAdd2 inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeAdd2 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeAdd2 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeAdd2MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeAdd2 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn is_using_sync(&self) -> bool {
        unsafe { AnimationNodeAdd2_is_using_sync(self.this) }
    }

    #[inline]
    pub fn set_use_sync(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeAdd2_set_use_sync(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeAdd3` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeadd3.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeAdd3 inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeAdd3 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeAdd3 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeAdd3MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeAdd3 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn is_using_sync(&self) -> bool {
        unsafe { AnimationNodeAdd3_is_using_sync(self.this) }
    }

    #[inline]
    pub fn set_use_sync(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeAdd3_set_use_sync(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeAnimation` inherits `AnimationRootNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeanimation.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeAnimation inherits methods from:
/// - [AnimationRootNode](struct.AnimationRootNode.html)
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeAnimation {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeAnimation {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeAnimationMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeAnimation {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_animation(&self) -> GodotString {
        unsafe { AnimationNodeAnimation_get_animation(self.this) }
    }

    #[inline]
    pub fn set_animation(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeAnimation_set_animation(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_root_node(&self) -> AnimationRootNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationRootNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeBlend2` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeblend2.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeBlend2 inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeBlend2 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeBlend2 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeBlend2MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeBlend2 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn is_using_sync(&self) -> bool {
        unsafe { AnimationNodeBlend2_is_using_sync(self.this) }
    }

    #[inline]
    pub fn set_use_sync(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeBlend2_set_use_sync(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeBlend3` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeblend3.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeBlend3 inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeBlend3 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeBlend3 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeBlend3MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeBlend3 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn is_using_sync(&self) -> bool {
        unsafe { AnimationNodeBlend3_is_using_sync(self.this) }
    }

    #[inline]
    pub fn set_use_sync(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeBlend3_set_use_sync(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeBlendSpace1D` inherits `AnimationRootNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeblendspace1d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeBlendSpace1D inherits methods from:
/// - [AnimationRootNode](struct.AnimationRootNode.html)
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeBlendSpace1D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeBlendSpace1D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeBlendSpace1DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeBlendSpace1D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _add_blend_point(&mut self, index: i64, node: Option<AnimationRootNode>) -> () {
        unsafe { AnimationNodeBlendSpace1D__add_blend_point(self.this, index, node) }
    }

    #[inline]
    pub fn _tree_changed(&mut self) -> () {
        unsafe { AnimationNodeBlendSpace1D__tree_changed(self.this) }
    }

    #[inline]
    pub fn add_blend_point(&mut self, node: Option<AnimationRootNode>, pos: f64, at_index: i64) -> () {
        unsafe { AnimationNodeBlendSpace1D_add_blend_point(self.this, node, pos, at_index) }
    }

    #[inline]
    pub fn get_blend_point_count(&self) -> i64 {
        unsafe { AnimationNodeBlendSpace1D_get_blend_point_count(self.this) }
    }

    #[inline]
    pub fn get_blend_point_node(&self, point: i64) -> Option<AnimationRootNode> {
        unsafe { AnimationNodeBlendSpace1D_get_blend_point_node(self.this, point) }
    }

    #[inline]
    pub fn get_blend_point_position(&self, point: i64) -> f64 {
        unsafe { AnimationNodeBlendSpace1D_get_blend_point_position(self.this, point) }
    }

    #[inline]
    pub fn get_max_space(&self) -> f64 {
        unsafe { AnimationNodeBlendSpace1D_get_max_space(self.this) }
    }

    #[inline]
    pub fn get_min_space(&self) -> f64 {
        unsafe { AnimationNodeBlendSpace1D_get_min_space(self.this) }
    }

    #[inline]
    pub fn get_snap(&self) -> f64 {
        unsafe { AnimationNodeBlendSpace1D_get_snap(self.this) }
    }

    #[inline]
    pub fn get_value_label(&self) -> GodotString {
        unsafe { AnimationNodeBlendSpace1D_get_value_label(self.this) }
    }

    #[inline]
    pub fn remove_blend_point(&mut self, point: i64) -> () {
        unsafe { AnimationNodeBlendSpace1D_remove_blend_point(self.this, point) }
    }

    #[inline]
    pub fn set_blend_point_node(&mut self, point: i64, node: Option<AnimationRootNode>) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_blend_point_node(self.this, point, node) }
    }

    #[inline]
    pub fn set_blend_point_position(&mut self, point: i64, pos: f64) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_blend_point_position(self.this, point, pos) }
    }

    #[inline]
    pub fn set_max_space(&mut self, max_space: f64) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_max_space(self.this, max_space) }
    }

    #[inline]
    pub fn set_min_space(&mut self, min_space: f64) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_min_space(self.this, min_space) }
    }

    #[inline]
    pub fn set_snap(&mut self, snap: f64) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_snap(self.this, snap) }
    }

    #[inline]
    pub fn set_value_label(&mut self, text: GodotString) -> () {
        unsafe { AnimationNodeBlendSpace1D_set_value_label(self.this, text) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_root_node(&self) -> AnimationRootNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationRootNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeBlendSpace2D` inherits `AnimationRootNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeblendspace2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeBlendSpace2D inherits methods from:
/// - [AnimationRootNode](struct.AnimationRootNode.html)
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeBlendSpace2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationNodeBlendSpace2DBlendMode {
    ModeInterpolated = 0,
    ModeDiscrete = 1,
    ModeDiscreteCarry = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationNodeBlendSpace2D {
    pub const BLEND_MODE_DISCRETE_CARRY: i64 = 2;
    pub const BLEND_MODE_DISCRETE: i64 = 1;
    pub const BLEND_MODE_INTERPOLATED: i64 = 0;
}
impl AnimationNodeBlendSpace2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeBlendSpace2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeBlendSpace2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _add_blend_point(&mut self, index: i64, node: Option<AnimationRootNode>) -> () {
        unsafe { AnimationNodeBlendSpace2D__add_blend_point(self.this, index, node) }
    }

    #[inline]
    pub fn _get_triangles(&self) -> Int32Array {
        unsafe { AnimationNodeBlendSpace2D__get_triangles(self.this) }
    }

    #[inline]
    pub fn _set_triangles(&mut self, triangles: Int32Array) -> () {
        unsafe { AnimationNodeBlendSpace2D__set_triangles(self.this, triangles) }
    }

    #[inline]
    pub fn _tree_changed(&mut self) -> () {
        unsafe { AnimationNodeBlendSpace2D__tree_changed(self.this) }
    }

    #[inline]
    pub fn _update_triangles(&mut self) -> () {
        unsafe { AnimationNodeBlendSpace2D__update_triangles(self.this) }
    }

    #[inline]
    pub fn add_blend_point(&mut self, node: Option<AnimationRootNode>, pos: Vector2, at_index: i64) -> () {
        unsafe { AnimationNodeBlendSpace2D_add_blend_point(self.this, node, pos, at_index) }
    }

    #[inline]
    pub fn add_triangle(&mut self, x: i64, y: i64, z: i64, at_index: i64) -> () {
        unsafe { AnimationNodeBlendSpace2D_add_triangle(self.this, x, y, z, at_index) }
    }

    #[inline]
    pub fn get_auto_triangles(&self) -> bool {
        unsafe { AnimationNodeBlendSpace2D_get_auto_triangles(self.this) }
    }

    #[inline]
    pub fn get_blend_mode(&self) -> AnimationNodeBlendSpace2DBlendMode {
        unsafe { AnimationNodeBlendSpace2D_get_blend_mode(self.this) }
    }

    #[inline]
    pub fn get_blend_point_count(&self) -> i64 {
        unsafe { AnimationNodeBlendSpace2D_get_blend_point_count(self.this) }
    }

    #[inline]
    pub fn get_blend_point_node(&self, point: i64) -> Option<AnimationRootNode> {
        unsafe { AnimationNodeBlendSpace2D_get_blend_point_node(self.this, point) }
    }

    #[inline]
    pub fn get_blend_point_position(&self, point: i64) -> Vector2 {
        unsafe { AnimationNodeBlendSpace2D_get_blend_point_position(self.this, point) }
    }

    #[inline]
    pub fn get_max_space(&self) -> Vector2 {
        unsafe { AnimationNodeBlendSpace2D_get_max_space(self.this) }
    }

    #[inline]
    pub fn get_min_space(&self) -> Vector2 {
        unsafe { AnimationNodeBlendSpace2D_get_min_space(self.this) }
    }

    #[inline]
    pub fn get_snap(&self) -> Vector2 {
        unsafe { AnimationNodeBlendSpace2D_get_snap(self.this) }
    }

    #[inline]
    pub fn get_triangle_count(&self) -> i64 {
        unsafe { AnimationNodeBlendSpace2D_get_triangle_count(self.this) }
    }

    #[inline]
    pub fn get_triangle_point(&mut self, triangle: i64, point: i64) -> i64 {
        unsafe { AnimationNodeBlendSpace2D_get_triangle_point(self.this, triangle, point) }
    }

    #[inline]
    pub fn get_x_label(&self) -> GodotString {
        unsafe { AnimationNodeBlendSpace2D_get_x_label(self.this) }
    }

    #[inline]
    pub fn get_y_label(&self) -> GodotString {
        unsafe { AnimationNodeBlendSpace2D_get_y_label(self.this) }
    }

    #[inline]
    pub fn remove_blend_point(&mut self, point: i64) -> () {
        unsafe { AnimationNodeBlendSpace2D_remove_blend_point(self.this, point) }
    }

    #[inline]
    pub fn remove_triangle(&mut self, triangle: i64) -> () {
        unsafe { AnimationNodeBlendSpace2D_remove_triangle(self.this, triangle) }
    }

    #[inline]
    pub fn set_auto_triangles(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_auto_triangles(self.this, enable) }
    }

    #[inline]
    pub fn set_blend_mode(&mut self, mode: i64) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_blend_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_blend_point_node(&mut self, point: i64, node: Option<AnimationRootNode>) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_blend_point_node(self.this, point, node) }
    }

    #[inline]
    pub fn set_blend_point_position(&mut self, point: i64, pos: Vector2) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_blend_point_position(self.this, point, pos) }
    }

    #[inline]
    pub fn set_max_space(&mut self, max_space: Vector2) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_max_space(self.this, max_space) }
    }

    #[inline]
    pub fn set_min_space(&mut self, min_space: Vector2) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_min_space(self.this, min_space) }
    }

    #[inline]
    pub fn set_snap(&mut self, snap: Vector2) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_snap(self.this, snap) }
    }

    #[inline]
    pub fn set_x_label(&mut self, text: GodotString) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_x_label(self.this, text) }
    }

    #[inline]
    pub fn set_y_label(&mut self, text: GodotString) -> () {
        unsafe { AnimationNodeBlendSpace2D_set_y_label(self.this, text) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_root_node(&self) -> AnimationRootNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationRootNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeBlendTree` inherits `AnimationRootNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeblendtree.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeBlendTree inherits methods from:
/// - [AnimationRootNode](struct.AnimationRootNode.html)
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeBlendTree {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl AnimationNodeBlendTree {
    pub const CONNECTION_ERROR_NO_INPUT: i64 = 1;
    pub const CONNECTION_ERROR_SAME_NODE: i64 = 4;
    pub const CONNECTION_ERROR_CONNECTION_EXISTS: i64 = 5;
    pub const CONNECTION_OK: i64 = 0;
    pub const CONNECTION_ERROR_NO_OUTPUT: i64 = 3;
    pub const CONNECTION_ERROR_NO_INPUT_INDEX: i64 = 2;
}
impl AnimationNodeBlendTree {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeBlendTreeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeBlendTree {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _node_changed(&mut self, node: GodotString) -> () {
        unsafe { AnimationNodeBlendTree__node_changed(self.this, node) }
    }

    #[inline]
    pub fn _tree_changed(&mut self) -> () {
        unsafe { AnimationNodeBlendTree__tree_changed(self.this) }
    }

    #[inline]
    pub fn add_node(&mut self, name: GodotString, node: Option<AnimationNode>, position: Vector2) -> () {
        unsafe { AnimationNodeBlendTree_add_node(self.this, name, node, position) }
    }

    #[inline]
    pub fn connect_node(&mut self, input_node: GodotString, input_index: i64, output_node: GodotString) -> () {
        unsafe { AnimationNodeBlendTree_connect_node(self.this, input_node, input_index, output_node) }
    }

    #[inline]
    pub fn disconnect_node(&mut self, input_node: GodotString, input_index: i64) -> () {
        unsafe { AnimationNodeBlendTree_disconnect_node(self.this, input_node, input_index) }
    }

    #[inline]
    pub fn get_graph_offset(&self) -> Vector2 {
        unsafe { AnimationNodeBlendTree_get_graph_offset(self.this) }
    }

    #[inline]
    pub fn get_node(&self, name: GodotString) -> Option<AnimationNode> {
        unsafe { AnimationNodeBlendTree_get_node(self.this, name) }
    }

    #[inline]
    pub fn get_node_position(&self, name: GodotString) -> Vector2 {
        unsafe { AnimationNodeBlendTree_get_node_position(self.this, name) }
    }

    #[inline]
    pub fn has_node(&self, name: GodotString) -> bool {
        unsafe { AnimationNodeBlendTree_has_node(self.this, name) }
    }

    #[inline]
    pub fn remove_node(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeBlendTree_remove_node(self.this, name) }
    }

    #[inline]
    pub fn rename_node(&mut self, name: GodotString, new_name: GodotString) -> () {
        unsafe { AnimationNodeBlendTree_rename_node(self.this, name, new_name) }
    }

    #[inline]
    pub fn set_graph_offset(&mut self, offset: Vector2) -> () {
        unsafe { AnimationNodeBlendTree_set_graph_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_node_position(&mut self, name: GodotString, position: Vector2) -> () {
        unsafe { AnimationNodeBlendTree_set_node_position(self.this, name, position) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_root_node(&self) -> AnimationRootNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationRootNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeOneShot` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeoneshot.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeOneShot inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeOneShot {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationNodeOneShotMixMode {
    ModeBlend = 0,
    ModeAdd = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationNodeOneShot {
    pub const MIX_MODE_ADD: i64 = 1;
    pub const MIX_MODE_BLEND: i64 = 0;
}
impl AnimationNodeOneShot {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeOneShotMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeOneShot {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_autorestart_delay(&self) -> f64 {
        unsafe { AnimationNodeOneShot_get_autorestart_delay(self.this) }
    }

    #[inline]
    pub fn get_autorestart_random_delay(&self) -> f64 {
        unsafe { AnimationNodeOneShot_get_autorestart_random_delay(self.this) }
    }

    #[inline]
    pub fn get_fadein_time(&self) -> f64 {
        unsafe { AnimationNodeOneShot_get_fadein_time(self.this) }
    }

    #[inline]
    pub fn get_fadeout_time(&self) -> f64 {
        unsafe { AnimationNodeOneShot_get_fadeout_time(self.this) }
    }

    #[inline]
    pub fn get_mix_mode(&self) -> AnimationNodeOneShotMixMode {
        unsafe { AnimationNodeOneShot_get_mix_mode(self.this) }
    }

    #[inline]
    pub fn has_autorestart(&self) -> bool {
        unsafe { AnimationNodeOneShot_has_autorestart(self.this) }
    }

    #[inline]
    pub fn is_using_sync(&self) -> bool {
        unsafe { AnimationNodeOneShot_is_using_sync(self.this) }
    }

    #[inline]
    pub fn set_autorestart(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeOneShot_set_autorestart(self.this, enable) }
    }

    #[inline]
    pub fn set_autorestart_delay(&mut self, enable: f64) -> () {
        unsafe { AnimationNodeOneShot_set_autorestart_delay(self.this, enable) }
    }

    #[inline]
    pub fn set_autorestart_random_delay(&mut self, enable: f64) -> () {
        unsafe { AnimationNodeOneShot_set_autorestart_random_delay(self.this, enable) }
    }

    #[inline]
    pub fn set_fadein_time(&mut self, time: f64) -> () {
        unsafe { AnimationNodeOneShot_set_fadein_time(self.this, time) }
    }

    #[inline]
    pub fn set_fadeout_time(&mut self, time: f64) -> () {
        unsafe { AnimationNodeOneShot_set_fadeout_time(self.this, time) }
    }

    #[inline]
    pub fn set_mix_mode(&mut self, mode: i64) -> () {
        unsafe { AnimationNodeOneShot_set_mix_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_use_sync(&mut self, enable: bool) -> () {
        unsafe { AnimationNodeOneShot_set_use_sync(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeOutput` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodeoutput.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeOutput inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeOutput {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeOutput {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeOutputMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeOutput {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeStateMachine` inherits `AnimationRootNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodestatemachine.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeStateMachine inherits methods from:
/// - [AnimationRootNode](struct.AnimationRootNode.html)
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeStateMachine {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeStateMachine {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeStateMachineMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeStateMachine {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _tree_changed(&mut self) -> () {
        unsafe { AnimationNodeStateMachine__tree_changed(self.this) }
    }

    #[inline]
    pub fn add_node(&mut self, name: GodotString, node: Option<AnimationNode>, position: Vector2) -> () {
        unsafe { AnimationNodeStateMachine_add_node(self.this, name, node, position) }
    }

    #[inline]
    pub fn add_transition(&mut self, from: GodotString, to: GodotString, transition: Option<AnimationNodeStateMachineTransition>) -> () {
        unsafe { AnimationNodeStateMachine_add_transition(self.this, from, to, transition) }
    }

    #[inline]
    pub fn get_end_node(&self) -> GodotString {
        unsafe { AnimationNodeStateMachine_get_end_node(self.this) }
    }

    #[inline]
    pub fn get_graph_offset(&self) -> Vector2 {
        unsafe { AnimationNodeStateMachine_get_graph_offset(self.this) }
    }

    #[inline]
    pub fn get_node(&self, name: GodotString) -> Option<AnimationNode> {
        unsafe { AnimationNodeStateMachine_get_node(self.this, name) }
    }

    #[inline]
    pub fn get_node_name(&self, node: Option<AnimationNode>) -> GodotString {
        unsafe { AnimationNodeStateMachine_get_node_name(self.this, node) }
    }

    #[inline]
    pub fn get_node_position(&self, name: GodotString) -> Vector2 {
        unsafe { AnimationNodeStateMachine_get_node_position(self.this, name) }
    }

    #[inline]
    pub fn get_start_node(&self) -> GodotString {
        unsafe { AnimationNodeStateMachine_get_start_node(self.this) }
    }

    #[inline]
    pub fn get_transition(&self, idx: i64) -> Option<AnimationNodeStateMachineTransition> {
        unsafe { AnimationNodeStateMachine_get_transition(self.this, idx) }
    }

    #[inline]
    pub fn get_transition_count(&self) -> i64 {
        unsafe { AnimationNodeStateMachine_get_transition_count(self.this) }
    }

    #[inline]
    pub fn get_transition_from(&self, idx: i64) -> GodotString {
        unsafe { AnimationNodeStateMachine_get_transition_from(self.this, idx) }
    }

    #[inline]
    pub fn get_transition_to(&self, idx: i64) -> GodotString {
        unsafe { AnimationNodeStateMachine_get_transition_to(self.this, idx) }
    }

    #[inline]
    pub fn has_node(&self, name: GodotString) -> bool {
        unsafe { AnimationNodeStateMachine_has_node(self.this, name) }
    }

    #[inline]
    pub fn has_transition(&self, from: GodotString, to: GodotString) -> bool {
        unsafe { AnimationNodeStateMachine_has_transition(self.this, from, to) }
    }

    #[inline]
    pub fn remove_node(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeStateMachine_remove_node(self.this, name) }
    }

    #[inline]
    pub fn remove_transition(&mut self, from: GodotString, to: GodotString) -> () {
        unsafe { AnimationNodeStateMachine_remove_transition(self.this, from, to) }
    }

    #[inline]
    pub fn remove_transition_by_index(&mut self, idx: i64) -> () {
        unsafe { AnimationNodeStateMachine_remove_transition_by_index(self.this, idx) }
    }

    #[inline]
    pub fn rename_node(&mut self, name: GodotString, new_name: GodotString) -> () {
        unsafe { AnimationNodeStateMachine_rename_node(self.this, name, new_name) }
    }

    #[inline]
    pub fn set_end_node(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeStateMachine_set_end_node(self.this, name) }
    }

    #[inline]
    pub fn set_graph_offset(&mut self, offset: Vector2) -> () {
        unsafe { AnimationNodeStateMachine_set_graph_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_node_position(&mut self, name: GodotString, position: Vector2) -> () {
        unsafe { AnimationNodeStateMachine_set_node_position(self.this, name, position) }
    }

    #[inline]
    pub fn set_start_node(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeStateMachine_set_start_node(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_root_node(&self) -> AnimationRootNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationRootNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeStateMachinePlayback` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodestatemachineplayback.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeStateMachinePlayback inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeStateMachinePlayback {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeStateMachinePlayback {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeStateMachinePlaybackMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeStateMachinePlayback {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_current_node(&self) -> GodotString {
        unsafe { AnimationNodeStateMachinePlayback_get_current_node(self.this) }
    }

    #[inline]
    pub fn get_travel_path(&self) -> StringArray {
        unsafe { AnimationNodeStateMachinePlayback_get_travel_path(self.this) }
    }

    #[inline]
    pub fn is_playing(&self) -> bool {
        unsafe { AnimationNodeStateMachinePlayback_is_playing(self.this) }
    }

    #[inline]
    pub fn start(&mut self, node: GodotString) -> () {
        unsafe { AnimationNodeStateMachinePlayback_start(self.this, node) }
    }

    #[inline]
    pub fn stop(&mut self) -> () {
        unsafe { AnimationNodeStateMachinePlayback_stop(self.this) }
    }

    #[inline]
    pub fn travel(&mut self, to_node: GodotString) -> () {
        unsafe { AnimationNodeStateMachinePlayback_travel(self.this, to_node) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeStateMachineTransition` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodestatemachinetransition.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeStateMachineTransition inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeStateMachineTransition {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationNodeStateMachineTransitionSwitchMode {
    ModeImmediate = 0,
    ModeSync = 1,
    ModeAtEnd = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationNodeStateMachineTransition {
    pub const SWITCH_MODE_IMMEDIATE: i64 = 0;
    pub const SWITCH_MODE_SYNC: i64 = 1;
    pub const SWITCH_MODE_AT_END: i64 = 2;
}
impl AnimationNodeStateMachineTransition {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeStateMachineTransitionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeStateMachineTransition {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_advance_condition(&self) -> GodotString {
        unsafe { AnimationNodeStateMachineTransition_get_advance_condition(self.this) }
    }

    #[inline]
    pub fn get_priority(&self) -> i64 {
        unsafe { AnimationNodeStateMachineTransition_get_priority(self.this) }
    }

    #[inline]
    pub fn get_switch_mode(&self) -> AnimationNodeStateMachineTransitionSwitchMode {
        unsafe { AnimationNodeStateMachineTransition_get_switch_mode(self.this) }
    }

    #[inline]
    pub fn get_xfade_time(&self) -> f64 {
        unsafe { AnimationNodeStateMachineTransition_get_xfade_time(self.this) }
    }

    #[inline]
    pub fn has_auto_advance(&self) -> bool {
        unsafe { AnimationNodeStateMachineTransition_has_auto_advance(self.this) }
    }

    #[inline]
    pub fn is_disabled(&self) -> bool {
        unsafe { AnimationNodeStateMachineTransition_is_disabled(self.this) }
    }

    #[inline]
    pub fn set_advance_condition(&mut self, name: GodotString) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_advance_condition(self.this, name) }
    }

    #[inline]
    pub fn set_auto_advance(&mut self, auto_advance: bool) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_auto_advance(self.this, auto_advance) }
    }

    #[inline]
    pub fn set_disabled(&mut self, disabled: bool) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_disabled(self.this, disabled) }
    }

    #[inline]
    pub fn set_priority(&mut self, priority: i64) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_priority(self.this, priority) }
    }

    #[inline]
    pub fn set_switch_mode(&mut self, mode: i64) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_switch_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_xfade_time(&mut self, secs: f64) -> () {
        unsafe { AnimationNodeStateMachineTransition_set_xfade_time(self.this, secs) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeTimeScale` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodetimescale.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeTimeScale inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeTimeScale {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeTimeScale {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeTimeScaleMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeTimeScale {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeTimeSeek` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodetimeseek.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeTimeSeek inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeTimeSeek {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeTimeSeek {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeTimeSeekMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeTimeSeek {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationNodeTransition` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationnodetransition.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationNodeTransition inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationNodeTransition {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationNodeTransition {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationNodeTransitionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationNodeTransition {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_cross_fade_time(&self) -> f64 {
        unsafe { AnimationNodeTransition_get_cross_fade_time(self.this) }
    }

    #[inline]
    pub fn get_enabled_inputs(&mut self) -> i64 {
        unsafe { AnimationNodeTransition_get_enabled_inputs(self.this) }
    }

    #[inline]
    pub fn get_input_caption(&self, input: i64) -> GodotString {
        unsafe { AnimationNodeTransition_get_input_caption(self.this, input) }
    }

    #[inline]
    pub fn is_input_set_as_auto_advance(&self, input: i64) -> bool {
        unsafe { AnimationNodeTransition_is_input_set_as_auto_advance(self.this, input) }
    }

    #[inline]
    pub fn set_cross_fade_time(&mut self, time: f64) -> () {
        unsafe { AnimationNodeTransition_set_cross_fade_time(self.this, time) }
    }

    #[inline]
    pub fn set_enabled_inputs(&mut self, amount: i64) -> () {
        unsafe { AnimationNodeTransition_set_enabled_inputs(self.this, amount) }
    }

    #[inline]
    pub fn set_input_as_auto_advance(&mut self, input: i64, enable: bool) -> () {
        unsafe { AnimationNodeTransition_set_input_as_auto_advance(self.this, input, enable) }
    }

    #[inline]
    pub fn set_input_caption(&mut self, input: i64, caption: GodotString) -> () {
        unsafe { AnimationNodeTransition_set_input_caption(self.this, input, caption) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationPlayer` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationplayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AnimationPlayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AnimationPlayer::free`.
///
/// ## Class hierarchy
///
/// AnimationPlayer inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationPlayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationPlayerAnimationProcessMode {
    Physics = 0,
    Idle = 1,
    Manual = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationPlayerAnimationMethodCallMode {
    Deferred = 0,
    Immediate = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationPlayer {
    pub const ANIMATION_PROCESS_IDLE: i64 = 1;
    pub const ANIMATION_PROCESS_PHYSICS: i64 = 0;
    pub const ANIMATION_METHOD_CALL_DEFERRED: i64 = 0;
    pub const ANIMATION_PROCESS_MANUAL: i64 = 2;
    pub const ANIMATION_METHOD_CALL_IMMEDIATE: i64 = 1;
}
impl AnimationPlayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AnimationPlayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationPlayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AnimationPlayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _animation_changed(&mut self) -> () {
        AnimationPlayer__animation_changed(self.this)
    }

    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        AnimationPlayer__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_animation(&mut self, name: GodotString, animation: Option<Animation>) -> GodotResult {
        AnimationPlayer_add_animation(self.this, name, animation)
    }

    #[inline]
    pub unsafe fn advance(&mut self, delta: f64) -> () {
        AnimationPlayer_advance(self.this, delta)
    }

    #[inline]
    pub unsafe fn animation_get_next(&self, anim_from: GodotString) -> GodotString {
        AnimationPlayer_animation_get_next(self.this, anim_from)
    }

    #[inline]
    pub unsafe fn animation_set_next(&mut self, anim_from: GodotString, anim_to: GodotString) -> () {
        AnimationPlayer_animation_set_next(self.this, anim_from, anim_to)
    }

    #[inline]
    pub unsafe fn clear_caches(&mut self) -> () {
        AnimationPlayer_clear_caches(self.this)
    }

    #[inline]
    pub unsafe fn clear_queue(&mut self) -> () {
        AnimationPlayer_clear_queue(self.this)
    }

    #[inline]
    pub unsafe fn find_animation(&self, animation: Option<Animation>) -> GodotString {
        AnimationPlayer_find_animation(self.this, animation)
    }

    #[inline]
    pub unsafe fn get_animation(&self, name: GodotString) -> Option<Animation> {
        AnimationPlayer_get_animation(self.this, name)
    }

    #[inline]
    pub unsafe fn get_animation_list(&self) -> StringArray {
        AnimationPlayer_get_animation_list(self.this)
    }

    #[inline]
    pub unsafe fn get_animation_process_mode(&self) -> AnimationPlayerAnimationProcessMode {
        AnimationPlayer_get_animation_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_assigned_animation(&self) -> GodotString {
        AnimationPlayer_get_assigned_animation(self.this)
    }

    #[inline]
    pub unsafe fn get_autoplay(&self) -> GodotString {
        AnimationPlayer_get_autoplay(self.this)
    }

    #[inline]
    pub unsafe fn get_blend_time(&self, anim_from: GodotString, anim_to: GodotString) -> f64 {
        AnimationPlayer_get_blend_time(self.this, anim_from, anim_to)
    }

    #[inline]
    pub unsafe fn get_current_animation(&self) -> GodotString {
        AnimationPlayer_get_current_animation(self.this)
    }

    #[inline]
    pub unsafe fn get_current_animation_length(&self) -> f64 {
        AnimationPlayer_get_current_animation_length(self.this)
    }

    #[inline]
    pub unsafe fn get_current_animation_position(&self) -> f64 {
        AnimationPlayer_get_current_animation_position(self.this)
    }

    #[inline]
    pub unsafe fn get_default_blend_time(&self) -> f64 {
        AnimationPlayer_get_default_blend_time(self.this)
    }

    #[inline]
    pub unsafe fn get_method_call_mode(&self) -> AnimationPlayerAnimationMethodCallMode {
        AnimationPlayer_get_method_call_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_playing_speed(&self) -> f64 {
        AnimationPlayer_get_playing_speed(self.this)
    }

    #[inline]
    pub unsafe fn get_queue(&mut self) -> StringArray {
        AnimationPlayer_get_queue(self.this)
    }

    #[inline]
    pub unsafe fn get_root(&self) -> NodePath {
        AnimationPlayer_get_root(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        AnimationPlayer_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn has_animation(&self, name: GodotString) -> bool {
        AnimationPlayer_has_animation(self.this, name)
    }

    #[inline]
    pub unsafe fn is_active(&self) -> bool {
        AnimationPlayer_is_active(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AnimationPlayer_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, name: GodotString, custom_blend: f64, custom_speed: f64, from_end: bool) -> () {
        AnimationPlayer_play(self.this, name, custom_blend, custom_speed, from_end)
    }

    #[inline]
    pub unsafe fn play_backwards(&mut self, name: GodotString, custom_blend: f64) -> () {
        AnimationPlayer_play_backwards(self.this, name, custom_blend)
    }

    #[inline]
    pub unsafe fn queue(&mut self, name: GodotString) -> () {
        AnimationPlayer_queue(self.this, name)
    }

    #[inline]
    pub unsafe fn remove_animation(&mut self, name: GodotString) -> () {
        AnimationPlayer_remove_animation(self.this, name)
    }

    #[inline]
    pub unsafe fn rename_animation(&mut self, name: GodotString, newname: GodotString) -> () {
        AnimationPlayer_rename_animation(self.this, name, newname)
    }

    #[inline]
    pub unsafe fn seek(&mut self, seconds: f64, update: bool) -> () {
        AnimationPlayer_seek(self.this, seconds, update)
    }

    #[inline]
    pub unsafe fn set_active(&mut self, active: bool) -> () {
        AnimationPlayer_set_active(self.this, active)
    }

    #[inline]
    pub unsafe fn set_animation_process_mode(&mut self, mode: i64) -> () {
        AnimationPlayer_set_animation_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_assigned_animation(&mut self, anim: GodotString) -> () {
        AnimationPlayer_set_assigned_animation(self.this, anim)
    }

    #[inline]
    pub unsafe fn set_autoplay(&mut self, name: GodotString) -> () {
        AnimationPlayer_set_autoplay(self.this, name)
    }

    #[inline]
    pub unsafe fn set_blend_time(&mut self, anim_from: GodotString, anim_to: GodotString, sec: f64) -> () {
        AnimationPlayer_set_blend_time(self.this, anim_from, anim_to, sec)
    }

    #[inline]
    pub unsafe fn set_current_animation(&mut self, anim: GodotString) -> () {
        AnimationPlayer_set_current_animation(self.this, anim)
    }

    #[inline]
    pub unsafe fn set_default_blend_time(&mut self, sec: f64) -> () {
        AnimationPlayer_set_default_blend_time(self.this, sec)
    }

    #[inline]
    pub unsafe fn set_method_call_mode(&mut self, mode: i64) -> () {
        AnimationPlayer_set_method_call_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_root(&mut self, path: NodePath) -> () {
        AnimationPlayer_set_root(self.this, path)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, speed: f64) -> () {
        AnimationPlayer_set_speed_scale(self.this, speed)
    }

    #[inline]
    pub unsafe fn stop(&mut self, reset: bool) -> () {
        AnimationPlayer_stop(self.this, reset)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationRootNode` inherits `AnimationNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationrootnode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationRootNode inherits methods from:
/// - [AnimationNode](struct.AnimationNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationRootNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationRootNode {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationRootNodeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AnimationRootNode {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_animation_node(&self) -> AnimationNode {
        unsafe {{ object::add_ref(self.this); }}
        AnimationNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class AnimationTrackEditPlugin` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationtrackeditplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AnimationTrackEditPlugin inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationTrackEditPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AnimationTrackEditPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationTree` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationtree.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AnimationTree` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AnimationTree::free`.
///
/// ## Class hierarchy
///
/// AnimationTree inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationTree {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationTreeAnimationProcessMode {
    Physics = 0,
    Idle = 1,
    Manual = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationTree {
    pub const ANIMATION_PROCESS_MANUAL: i64 = 2;
    pub const ANIMATION_PROCESS_IDLE: i64 = 1;
    pub const ANIMATION_PROCESS_PHYSICS: i64 = 0;
}
impl AnimationTree {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AnimationTree::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationTreeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AnimationTree {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _clear_caches(&mut self) -> () {
        AnimationTree__clear_caches(self.this)
    }

    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        AnimationTree__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _tree_changed(&mut self) -> () {
        AnimationTree__tree_changed(self.this)
    }

    #[inline]
    pub unsafe fn _update_properties(&mut self) -> () {
        AnimationTree__update_properties(self.this)
    }

    #[inline]
    pub unsafe fn advance(&mut self, delta: f64) -> () {
        AnimationTree_advance(self.this, delta)
    }

    #[inline]
    pub unsafe fn get_animation_player(&self) -> NodePath {
        AnimationTree_get_animation_player(self.this)
    }

    #[inline]
    pub unsafe fn get_process_mode(&self) -> AnimationTreeAnimationProcessMode {
        AnimationTree_get_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_root_motion_track(&self) -> NodePath {
        AnimationTree_get_root_motion_track(self.this)
    }

    #[inline]
    pub unsafe fn get_root_motion_transform(&self) -> Transform {
        AnimationTree_get_root_motion_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_tree_root(&self) -> Option<AnimationNode> {
        AnimationTree_get_tree_root(self.this)
    }

    #[inline]
    pub unsafe fn is_active(&self) -> bool {
        AnimationTree_is_active(self.this)
    }

    #[inline]
    pub unsafe fn rename_parameter(&mut self, old_name: GodotString, new_name: GodotString) -> () {
        AnimationTree_rename_parameter(self.this, old_name, new_name)
    }

    #[inline]
    pub unsafe fn set_active(&mut self, active: bool) -> () {
        AnimationTree_set_active(self.this, active)
    }

    #[inline]
    pub unsafe fn set_animation_player(&mut self, root: NodePath) -> () {
        AnimationTree_set_animation_player(self.this, root)
    }

    #[inline]
    pub unsafe fn set_process_mode(&mut self, mode: i64) -> () {
        AnimationTree_set_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_root_motion_track(&mut self, path: NodePath) -> () {
        AnimationTree_set_root_motion_track(self.this, path)
    }

    #[inline]
    pub unsafe fn set_tree_root(&mut self, root: Option<AnimationNode>) -> () {
        AnimationTree_set_tree_root(self.this, root)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AnimationTreePlayer` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_animationtreeplayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AnimationTreePlayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AnimationTreePlayer::free`.
///
/// ## Class hierarchy
///
/// AnimationTreePlayer inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AnimationTreePlayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationTreePlayerAnimationProcessMode {
    Physics = 0,
    Idle = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AnimationTreePlayerNodeType {
    NodeOutput = 0,
    NodeAnimation = 1,
    NodeOneshot = 2,
    NodeMix = 3,
    NodeBlend2 = 4,
    NodeBlend3 = 5,
    NodeBlend4 = 6,
    NodeTimescale = 7,
    NodeTimeseek = 8,
    NodeTransition = 9,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AnimationTreePlayer {
    pub const NODE_ANIMATION: i64 = 1;
    pub const NODE_BLEND2: i64 = 4;
    pub const NODE_BLEND4: i64 = 6;
    pub const NODE_TIMESCALE: i64 = 7;
    pub const ANIMATION_PROCESS_IDLE: i64 = 1;
    pub const NODE_MIX: i64 = 3;
    pub const NODE_TIMESEEK: i64 = 8;
    pub const NODE_ONESHOT: i64 = 2;
    pub const NODE_TRANSITION: i64 = 9;
    pub const ANIMATION_PROCESS_PHYSICS: i64 = 0;
    pub const NODE_BLEND3: i64 = 5;
    pub const NODE_OUTPUT: i64 = 0;
}
impl AnimationTreePlayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AnimationTreePlayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AnimationTreePlayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AnimationTreePlayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_node(&mut self, _type: i64, id: GodotString) -> () {
        AnimationTreePlayer_add_node(self.this, _type, id)
    }

    #[inline]
    pub unsafe fn advance(&mut self, delta: f64) -> () {
        AnimationTreePlayer_advance(self.this, delta)
    }

    #[inline]
    pub unsafe fn animation_node_get_animation(&self, id: GodotString) -> Option<Animation> {
        AnimationTreePlayer_animation_node_get_animation(self.this, id)
    }

    #[inline]
    pub unsafe fn animation_node_get_master_animation(&self, id: GodotString) -> GodotString {
        AnimationTreePlayer_animation_node_get_master_animation(self.this, id)
    }

    #[inline]
    pub unsafe fn animation_node_get_position(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_animation_node_get_position(self.this, id)
    }

    #[inline]
    pub unsafe fn animation_node_set_animation(&mut self, id: GodotString, animation: Option<Animation>) -> () {
        AnimationTreePlayer_animation_node_set_animation(self.this, id, animation)
    }

    #[inline]
    pub unsafe fn animation_node_set_filter_path(&mut self, id: GodotString, path: NodePath, enable: bool) -> () {
        AnimationTreePlayer_animation_node_set_filter_path(self.this, id, path, enable)
    }

    #[inline]
    pub unsafe fn animation_node_set_master_animation(&mut self, id: GodotString, source: GodotString) -> () {
        AnimationTreePlayer_animation_node_set_master_animation(self.this, id, source)
    }

    #[inline]
    pub unsafe fn are_nodes_connected(&self, id: GodotString, dst_id: GodotString, dst_input_idx: i64) -> bool {
        AnimationTreePlayer_are_nodes_connected(self.this, id, dst_id, dst_input_idx)
    }

    #[inline]
    pub unsafe fn blend2_node_get_amount(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_blend2_node_get_amount(self.this, id)
    }

    #[inline]
    pub unsafe fn blend2_node_set_amount(&mut self, id: GodotString, blend: f64) -> () {
        AnimationTreePlayer_blend2_node_set_amount(self.this, id, blend)
    }

    #[inline]
    pub unsafe fn blend2_node_set_filter_path(&mut self, id: GodotString, path: NodePath, enable: bool) -> () {
        AnimationTreePlayer_blend2_node_set_filter_path(self.this, id, path, enable)
    }

    #[inline]
    pub unsafe fn blend3_node_get_amount(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_blend3_node_get_amount(self.this, id)
    }

    #[inline]
    pub unsafe fn blend3_node_set_amount(&mut self, id: GodotString, blend: f64) -> () {
        AnimationTreePlayer_blend3_node_set_amount(self.this, id, blend)
    }

    #[inline]
    pub unsafe fn blend4_node_get_amount(&self, id: GodotString) -> Vector2 {
        AnimationTreePlayer_blend4_node_get_amount(self.this, id)
    }

    #[inline]
    pub unsafe fn blend4_node_set_amount(&mut self, id: GodotString, blend: Vector2) -> () {
        AnimationTreePlayer_blend4_node_set_amount(self.this, id, blend)
    }

    #[inline]
    pub unsafe fn connect_nodes(&mut self, id: GodotString, dst_id: GodotString, dst_input_idx: i64) -> GodotResult {
        AnimationTreePlayer_connect_nodes(self.this, id, dst_id, dst_input_idx)
    }

    #[inline]
    pub unsafe fn disconnect_nodes(&mut self, id: GodotString, dst_input_idx: i64) -> () {
        AnimationTreePlayer_disconnect_nodes(self.this, id, dst_input_idx)
    }

    #[inline]
    pub unsafe fn get_animation_process_mode(&self) -> AnimationTreePlayerAnimationProcessMode {
        AnimationTreePlayer_get_animation_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_base_path(&self) -> NodePath {
        AnimationTreePlayer_get_base_path(self.this)
    }

    #[inline]
    pub unsafe fn get_master_player(&self) -> NodePath {
        AnimationTreePlayer_get_master_player(self.this)
    }

    #[inline]
    pub unsafe fn get_node_list(&mut self) -> StringArray {
        AnimationTreePlayer_get_node_list(self.this)
    }

    #[inline]
    pub unsafe fn is_active(&self) -> bool {
        AnimationTreePlayer_is_active(self.this)
    }

    #[inline]
    pub unsafe fn mix_node_get_amount(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_mix_node_get_amount(self.this, id)
    }

    #[inline]
    pub unsafe fn mix_node_set_amount(&mut self, id: GodotString, ratio: f64) -> () {
        AnimationTreePlayer_mix_node_set_amount(self.this, id, ratio)
    }

    #[inline]
    pub unsafe fn node_exists(&self, node: GodotString) -> bool {
        AnimationTreePlayer_node_exists(self.this, node)
    }

    #[inline]
    pub unsafe fn node_get_input_count(&self, id: GodotString) -> i64 {
        AnimationTreePlayer_node_get_input_count(self.this, id)
    }

    #[inline]
    pub unsafe fn node_get_input_source(&self, id: GodotString, idx: i64) -> GodotString {
        AnimationTreePlayer_node_get_input_source(self.this, id, idx)
    }

    #[inline]
    pub unsafe fn node_get_position(&self, id: GodotString) -> Vector2 {
        AnimationTreePlayer_node_get_position(self.this, id)
    }

    #[inline]
    pub unsafe fn node_get_type(&self, id: GodotString) -> AnimationTreePlayerNodeType {
        AnimationTreePlayer_node_get_type(self.this, id)
    }

    #[inline]
    pub unsafe fn node_rename(&mut self, node: GodotString, new_name: GodotString) -> GodotResult {
        AnimationTreePlayer_node_rename(self.this, node, new_name)
    }

    #[inline]
    pub unsafe fn node_set_position(&mut self, id: GodotString, screen_position: Vector2) -> () {
        AnimationTreePlayer_node_set_position(self.this, id, screen_position)
    }

    #[inline]
    pub unsafe fn oneshot_node_get_autorestart_delay(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_oneshot_node_get_autorestart_delay(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_get_autorestart_random_delay(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_oneshot_node_get_autorestart_random_delay(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_get_fadein_time(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_oneshot_node_get_fadein_time(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_get_fadeout_time(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_oneshot_node_get_fadeout_time(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_has_autorestart(&self, id: GodotString) -> bool {
        AnimationTreePlayer_oneshot_node_has_autorestart(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_is_active(&self, id: GodotString) -> bool {
        AnimationTreePlayer_oneshot_node_is_active(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_autorestart(&mut self, id: GodotString, enable: bool) -> () {
        AnimationTreePlayer_oneshot_node_set_autorestart(self.this, id, enable)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_autorestart_delay(&mut self, id: GodotString, delay_sec: f64) -> () {
        AnimationTreePlayer_oneshot_node_set_autorestart_delay(self.this, id, delay_sec)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_autorestart_random_delay(&mut self, id: GodotString, rand_sec: f64) -> () {
        AnimationTreePlayer_oneshot_node_set_autorestart_random_delay(self.this, id, rand_sec)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_fadein_time(&mut self, id: GodotString, time_sec: f64) -> () {
        AnimationTreePlayer_oneshot_node_set_fadein_time(self.this, id, time_sec)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_fadeout_time(&mut self, id: GodotString, time_sec: f64) -> () {
        AnimationTreePlayer_oneshot_node_set_fadeout_time(self.this, id, time_sec)
    }

    #[inline]
    pub unsafe fn oneshot_node_set_filter_path(&mut self, id: GodotString, path: NodePath, enable: bool) -> () {
        AnimationTreePlayer_oneshot_node_set_filter_path(self.this, id, path, enable)
    }

    #[inline]
    pub unsafe fn oneshot_node_start(&mut self, id: GodotString) -> () {
        AnimationTreePlayer_oneshot_node_start(self.this, id)
    }

    #[inline]
    pub unsafe fn oneshot_node_stop(&mut self, id: GodotString) -> () {
        AnimationTreePlayer_oneshot_node_stop(self.this, id)
    }

    #[inline]
    pub unsafe fn recompute_caches(&mut self) -> () {
        AnimationTreePlayer_recompute_caches(self.this)
    }

    #[inline]
    pub unsafe fn remove_node(&mut self, id: GodotString) -> () {
        AnimationTreePlayer_remove_node(self.this, id)
    }

    #[inline]
    pub unsafe fn reset(&mut self) -> () {
        AnimationTreePlayer_reset(self.this)
    }

    #[inline]
    pub unsafe fn set_active(&mut self, enabled: bool) -> () {
        AnimationTreePlayer_set_active(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_animation_process_mode(&mut self, mode: i64) -> () {
        AnimationTreePlayer_set_animation_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_base_path(&mut self, path: NodePath) -> () {
        AnimationTreePlayer_set_base_path(self.this, path)
    }

    #[inline]
    pub unsafe fn set_master_player(&mut self, nodepath: NodePath) -> () {
        AnimationTreePlayer_set_master_player(self.this, nodepath)
    }

    #[inline]
    pub unsafe fn timescale_node_get_scale(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_timescale_node_get_scale(self.this, id)
    }

    #[inline]
    pub unsafe fn timescale_node_set_scale(&mut self, id: GodotString, scale: f64) -> () {
        AnimationTreePlayer_timescale_node_set_scale(self.this, id, scale)
    }

    #[inline]
    pub unsafe fn timeseek_node_seek(&mut self, id: GodotString, seconds: f64) -> () {
        AnimationTreePlayer_timeseek_node_seek(self.this, id, seconds)
    }

    #[inline]
    pub unsafe fn transition_node_delete_input(&mut self, id: GodotString, input_idx: i64) -> () {
        AnimationTreePlayer_transition_node_delete_input(self.this, id, input_idx)
    }

    #[inline]
    pub unsafe fn transition_node_get_current(&self, id: GodotString) -> i64 {
        AnimationTreePlayer_transition_node_get_current(self.this, id)
    }

    #[inline]
    pub unsafe fn transition_node_get_input_count(&self, id: GodotString) -> i64 {
        AnimationTreePlayer_transition_node_get_input_count(self.this, id)
    }

    #[inline]
    pub unsafe fn transition_node_get_xfade_time(&self, id: GodotString) -> f64 {
        AnimationTreePlayer_transition_node_get_xfade_time(self.this, id)
    }

    #[inline]
    pub unsafe fn transition_node_has_input_auto_advance(&self, id: GodotString, input_idx: i64) -> bool {
        AnimationTreePlayer_transition_node_has_input_auto_advance(self.this, id, input_idx)
    }

    #[inline]
    pub unsafe fn transition_node_set_current(&mut self, id: GodotString, input_idx: i64) -> () {
        AnimationTreePlayer_transition_node_set_current(self.this, id, input_idx)
    }

    #[inline]
    pub unsafe fn transition_node_set_input_auto_advance(&mut self, id: GodotString, input_idx: i64, enable: bool) -> () {
        AnimationTreePlayer_transition_node_set_input_auto_advance(self.this, id, input_idx, enable)
    }

    #[inline]
    pub unsafe fn transition_node_set_input_count(&mut self, id: GodotString, count: i64) -> () {
        AnimationTreePlayer_transition_node_set_input_count(self.this, id, count)
    }

    #[inline]
    pub unsafe fn transition_node_set_xfade_time(&mut self, id: GodotString, time_sec: f64) -> () {
        AnimationTreePlayer_transition_node_set_xfade_time(self.this, id, time_sec)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Area` inherits `CollisionObject` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_area.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Area` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Area::free`.
///
/// ## Class hierarchy
///
/// Area inherits methods from:
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Area {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AreaSpaceOverride {
    Disabled = 0,
    Combine = 1,
    CombineReplace = 2,
    Replace = 3,
    ReplaceCombine = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Area {
    pub const SPACE_OVERRIDE_DISABLED: i64 = 0;
    pub const SPACE_OVERRIDE_REPLACE: i64 = 3;
    pub const SPACE_OVERRIDE_COMBINE_REPLACE: i64 = 2;
    pub const SPACE_OVERRIDE_COMBINE: i64 = 1;
    pub const SPACE_OVERRIDE_REPLACE_COMBINE: i64 = 4;
}
impl Area {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Area::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AreaMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Area {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _area_enter_tree(&mut self, id: i64) -> () {
        Area__area_enter_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _area_exit_tree(&mut self, id: i64) -> () {
        Area__area_exit_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _area_inout(&mut self, arg0: i64, arg1: Rid, arg2: i64, arg3: i64, arg4: i64) -> () {
        Area__area_inout(self.this, arg0, arg1, arg2, arg3, arg4)
    }

    #[inline]
    pub unsafe fn _body_enter_tree(&mut self, id: i64) -> () {
        Area__body_enter_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _body_exit_tree(&mut self, id: i64) -> () {
        Area__body_exit_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _body_inout(&mut self, arg0: i64, arg1: Rid, arg2: i64, arg3: i64, arg4: i64) -> () {
        Area__body_inout(self.this, arg0, arg1, arg2, arg3, arg4)
    }

    #[inline]
    pub unsafe fn get_angular_damp(&self) -> f64 {
        Area_get_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_audio_bus(&self) -> GodotString {
        Area_get_audio_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        Area_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        Area_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        Area_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        Area_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_gravity(&self) -> f64 {
        Area_get_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_distance_scale(&self) -> f64 {
        Area_get_gravity_distance_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_vector(&self) -> Vector3 {
        Area_get_gravity_vector(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_damp(&self) -> f64 {
        Area_get_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_overlapping_areas(&self) -> VariantArray {
        Area_get_overlapping_areas(self.this)
    }

    #[inline]
    pub unsafe fn get_overlapping_bodies(&self) -> VariantArray {
        Area_get_overlapping_bodies(self.this)
    }

    #[inline]
    pub unsafe fn get_priority(&self) -> f64 {
        Area_get_priority(self.this)
    }

    #[inline]
    pub unsafe fn get_reverb_amount(&self) -> f64 {
        Area_get_reverb_amount(self.this)
    }

    #[inline]
    pub unsafe fn get_reverb_bus(&self) -> GodotString {
        Area_get_reverb_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_reverb_uniformity(&self) -> f64 {
        Area_get_reverb_uniformity(self.this)
    }

    #[inline]
    pub unsafe fn get_space_override_mode(&self) -> AreaSpaceOverride {
        Area_get_space_override_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_gravity_a_point(&self) -> bool {
        Area_is_gravity_a_point(self.this)
    }

    #[inline]
    pub unsafe fn is_monitorable(&self) -> bool {
        Area_is_monitorable(self.this)
    }

    #[inline]
    pub unsafe fn is_monitoring(&self) -> bool {
        Area_is_monitoring(self.this)
    }

    #[inline]
    pub unsafe fn is_overriding_audio_bus(&self) -> bool {
        Area_is_overriding_audio_bus(self.this)
    }

    #[inline]
    pub unsafe fn is_using_reverb_bus(&self) -> bool {
        Area_is_using_reverb_bus(self.this)
    }

    #[inline]
    pub unsafe fn overlaps_area(&self, area: Option<Node>) -> bool {
        Area_overlaps_area(self.this, area)
    }

    #[inline]
    pub unsafe fn overlaps_body(&self, body: Option<Node>) -> bool {
        Area_overlaps_body(self.this, body)
    }

    #[inline]
    pub unsafe fn set_angular_damp(&mut self, angular_damp: f64) -> () {
        Area_set_angular_damp(self.this, angular_damp)
    }

    #[inline]
    pub unsafe fn set_audio_bus(&mut self, name: GodotString) -> () {
        Area_set_audio_bus(self.this, name)
    }

    #[inline]
    pub unsafe fn set_audio_bus_override(&mut self, enable: bool) -> () {
        Area_set_audio_bus_override(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, collision_layer: i64) -> () {
        Area_set_collision_layer(self.this, collision_layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        Area_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, collision_mask: i64) -> () {
        Area_set_collision_mask(self.this, collision_mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        Area_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_gravity(&mut self, gravity: f64) -> () {
        Area_set_gravity(self.this, gravity)
    }

    #[inline]
    pub unsafe fn set_gravity_distance_scale(&mut self, distance_scale: f64) -> () {
        Area_set_gravity_distance_scale(self.this, distance_scale)
    }

    #[inline]
    pub unsafe fn set_gravity_is_point(&mut self, enable: bool) -> () {
        Area_set_gravity_is_point(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_gravity_vector(&mut self, vector: Vector3) -> () {
        Area_set_gravity_vector(self.this, vector)
    }

    #[inline]
    pub unsafe fn set_linear_damp(&mut self, linear_damp: f64) -> () {
        Area_set_linear_damp(self.this, linear_damp)
    }

    #[inline]
    pub unsafe fn set_monitorable(&mut self, enable: bool) -> () {
        Area_set_monitorable(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_monitoring(&mut self, enable: bool) -> () {
        Area_set_monitoring(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_priority(&mut self, priority: f64) -> () {
        Area_set_priority(self.this, priority)
    }

    #[inline]
    pub unsafe fn set_reverb_amount(&mut self, amount: f64) -> () {
        Area_set_reverb_amount(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_reverb_bus(&mut self, name: GodotString) -> () {
        Area_set_reverb_bus(self.this, name)
    }

    #[inline]
    pub unsafe fn set_reverb_uniformity(&mut self, amount: f64) -> () {
        Area_set_reverb_uniformity(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_space_override_mode(&mut self, enable: i64) -> () {
        Area_set_space_override_mode(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_use_reverb_bus(&mut self, enable: bool) -> () {
        Area_set_use_reverb_bus(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Area2D` inherits `CollisionObject2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_area2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Area2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Area2D::free`.
///
/// ## Class hierarchy
///
/// Area2D inherits methods from:
/// - [CollisionObject2D](struct.CollisionObject2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Area2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Area2DSpaceOverride {
    Disabled = 0,
    Combine = 1,
    CombineReplace = 2,
    Replace = 3,
    ReplaceCombine = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Area2D {
    pub const SPACE_OVERRIDE_DISABLED: i64 = 0;
    pub const SPACE_OVERRIDE_REPLACE: i64 = 3;
    pub const SPACE_OVERRIDE_REPLACE_COMBINE: i64 = 4;
    pub const SPACE_OVERRIDE_COMBINE: i64 = 1;
    pub const SPACE_OVERRIDE_COMBINE_REPLACE: i64 = 2;
}
impl Area2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Area2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Area2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Area2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _area_enter_tree(&mut self, id: i64) -> () {
        Area2D__area_enter_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _area_exit_tree(&mut self, id: i64) -> () {
        Area2D__area_exit_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _area_inout(&mut self, arg0: i64, arg1: Rid, arg2: i64, arg3: i64, arg4: i64) -> () {
        Area2D__area_inout(self.this, arg0, arg1, arg2, arg3, arg4)
    }

    #[inline]
    pub unsafe fn _body_enter_tree(&mut self, id: i64) -> () {
        Area2D__body_enter_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _body_exit_tree(&mut self, id: i64) -> () {
        Area2D__body_exit_tree(self.this, id)
    }

    #[inline]
    pub unsafe fn _body_inout(&mut self, arg0: i64, arg1: Rid, arg2: i64, arg3: i64, arg4: i64) -> () {
        Area2D__body_inout(self.this, arg0, arg1, arg2, arg3, arg4)
    }

    #[inline]
    pub unsafe fn get_angular_damp(&self) -> f64 {
        Area2D_get_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_audio_bus_name(&self) -> GodotString {
        Area2D_get_audio_bus_name(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        Area2D_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        Area2D_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        Area2D_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        Area2D_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_gravity(&self) -> f64 {
        Area2D_get_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_distance_scale(&self) -> f64 {
        Area2D_get_gravity_distance_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_vector(&self) -> Vector2 {
        Area2D_get_gravity_vector(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_damp(&self) -> f64 {
        Area2D_get_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_overlapping_areas(&self) -> VariantArray {
        Area2D_get_overlapping_areas(self.this)
    }

    #[inline]
    pub unsafe fn get_overlapping_bodies(&self) -> VariantArray {
        Area2D_get_overlapping_bodies(self.this)
    }

    #[inline]
    pub unsafe fn get_priority(&self) -> f64 {
        Area2D_get_priority(self.this)
    }

    #[inline]
    pub unsafe fn get_space_override_mode(&self) -> Area2DSpaceOverride {
        Area2D_get_space_override_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_gravity_a_point(&self) -> bool {
        Area2D_is_gravity_a_point(self.this)
    }

    #[inline]
    pub unsafe fn is_monitorable(&self) -> bool {
        Area2D_is_monitorable(self.this)
    }

    #[inline]
    pub unsafe fn is_monitoring(&self) -> bool {
        Area2D_is_monitoring(self.this)
    }

    #[inline]
    pub unsafe fn is_overriding_audio_bus(&self) -> bool {
        Area2D_is_overriding_audio_bus(self.this)
    }

    #[inline]
    pub unsafe fn overlaps_area(&self, area: Option<Node>) -> bool {
        Area2D_overlaps_area(self.this, area)
    }

    #[inline]
    pub unsafe fn overlaps_body(&self, body: Option<Node>) -> bool {
        Area2D_overlaps_body(self.this, body)
    }

    #[inline]
    pub unsafe fn set_angular_damp(&mut self, angular_damp: f64) -> () {
        Area2D_set_angular_damp(self.this, angular_damp)
    }

    #[inline]
    pub unsafe fn set_audio_bus_name(&mut self, name: GodotString) -> () {
        Area2D_set_audio_bus_name(self.this, name)
    }

    #[inline]
    pub unsafe fn set_audio_bus_override(&mut self, enable: bool) -> () {
        Area2D_set_audio_bus_override(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, collision_layer: i64) -> () {
        Area2D_set_collision_layer(self.this, collision_layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        Area2D_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, collision_mask: i64) -> () {
        Area2D_set_collision_mask(self.this, collision_mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        Area2D_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_gravity(&mut self, gravity: f64) -> () {
        Area2D_set_gravity(self.this, gravity)
    }

    #[inline]
    pub unsafe fn set_gravity_distance_scale(&mut self, distance_scale: f64) -> () {
        Area2D_set_gravity_distance_scale(self.this, distance_scale)
    }

    #[inline]
    pub unsafe fn set_gravity_is_point(&mut self, enable: bool) -> () {
        Area2D_set_gravity_is_point(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_gravity_vector(&mut self, vector: Vector2) -> () {
        Area2D_set_gravity_vector(self.this, vector)
    }

    #[inline]
    pub unsafe fn set_linear_damp(&mut self, linear_damp: f64) -> () {
        Area2D_set_linear_damp(self.this, linear_damp)
    }

    #[inline]
    pub unsafe fn set_monitorable(&mut self, enable: bool) -> () {
        Area2D_set_monitorable(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_monitoring(&mut self, enable: bool) -> () {
        Area2D_set_monitoring(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_priority(&mut self, priority: f64) -> () {
        Area2D_set_priority(self.this, priority)
    }

    #[inline]
    pub unsafe fn set_space_override_mode(&mut self, space_override_mode: i64) -> () {
        Area2D_set_space_override_mode(self.this, space_override_mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object_2d(&self) -> CollisionObject2D {
        // Not reference-counted.
        CollisionObject2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ArrayMesh` inherits `Mesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_arraymesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ArrayMesh inherits methods from:
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ArrayMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ArrayMeshArrayFormat {
    Vertex = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    TexUv = 16,
    TexUv2 = 32,
    Bones = 64,
    Weights = 128,
    Index = 256,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ArrayMeshArrayType {
    ArrayVertex = 0,
    ArrayNormal = 1,
    ArrayTangent = 2,
    ArrayColor = 3,
    ArrayTexUv = 4,
    ArrayTexUv2 = 5,
    ArrayBones = 6,
    ArrayWeights = 7,
    ArrayIndex = 8,
    ArrayMax = 9,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ArrayMesh {
    pub const ARRAY_FORMAT_TEX_UV2: i64 = 32;
    pub const ARRAY_INDEX: i64 = 8;
    pub const ARRAY_MAX: i64 = 9;
    pub const ARRAY_FORMAT_WEIGHTS: i64 = 128;
    pub const ARRAY_FORMAT_NORMAL: i64 = 2;
    pub const ARRAY_BONES: i64 = 6;
    pub const ARRAY_FORMAT_TANGENT: i64 = 4;
    pub const ARRAY_NORMAL: i64 = 1;
    pub const ARRAY_FORMAT_BONES: i64 = 64;
    pub const ARRAY_FORMAT_COLOR: i64 = 8;
    pub const ARRAY_FORMAT_INDEX: i64 = 256;
    pub const ARRAY_FORMAT_TEX_UV: i64 = 16;
    pub const ARRAY_VERTEX: i64 = 0;
    pub const ARRAY_WEIGHTS: i64 = 7;
    pub const ARRAY_COLOR: i64 = 3;
    pub const ARRAY_WEIGHTS_SIZE: i64 = 4;
    pub const ARRAY_TEX_UV2: i64 = 5;
    pub const ARRAY_TANGENT: i64 = 2;
    pub const ARRAY_TEX_UV: i64 = 4;
    pub const NO_INDEX_ARRAY: i64 = -1;
    pub const ARRAY_FORMAT_VERTEX: i64 = 1;
}
impl ArrayMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ArrayMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ArrayMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_blend_shape(&mut self, name: GodotString) -> () {
        unsafe { ArrayMesh_add_blend_shape(self.this, name) }
    }

    #[inline]
    pub fn add_surface_from_arrays(&mut self, primitive: i64, arrays: VariantArray, blend_shapes: VariantArray, compress_flags: i64) -> () {
        unsafe { ArrayMesh_add_surface_from_arrays(self.this, primitive, arrays, blend_shapes, compress_flags) }
    }

    #[inline]
    pub fn clear_blend_shapes(&mut self) -> () {
        unsafe { ArrayMesh_clear_blend_shapes(self.this) }
    }

    #[inline]
    pub fn get_blend_shape_count(&self) -> i64 {
        unsafe { ArrayMesh_get_blend_shape_count(self.this) }
    }

    #[inline]
    pub fn get_blend_shape_mode(&self) -> MeshBlendShapeMode {
        unsafe { ArrayMesh_get_blend_shape_mode(self.this) }
    }

    #[inline]
    pub fn get_blend_shape_name(&self, index: i64) -> GodotString {
        unsafe { ArrayMesh_get_blend_shape_name(self.this, index) }
    }

    #[inline]
    pub fn get_custom_aabb(&self) -> Aabb {
        unsafe { ArrayMesh_get_custom_aabb(self.this) }
    }

    #[inline]
    pub fn lightmap_unwrap(&mut self, transform: Transform, texel_size: f64) -> GodotResult {
        unsafe { ArrayMesh_lightmap_unwrap(self.this, transform, texel_size) }
    }

    #[inline]
    pub fn regen_normalmaps(&mut self) -> () {
        unsafe { ArrayMesh_regen_normalmaps(self.this) }
    }

    #[inline]
    pub fn set_blend_shape_mode(&mut self, mode: i64) -> () {
        unsafe { ArrayMesh_set_blend_shape_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_custom_aabb(&mut self, aabb: Aabb) -> () {
        unsafe { ArrayMesh_set_custom_aabb(self.this, aabb) }
    }

    #[inline]
    pub fn surface_find_by_name(&self, name: GodotString) -> i64 {
        unsafe { ArrayMesh_surface_find_by_name(self.this, name) }
    }

    #[inline]
    pub fn surface_get_array_index_len(&self, surf_idx: i64) -> i64 {
        unsafe { ArrayMesh_surface_get_array_index_len(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_array_len(&self, surf_idx: i64) -> i64 {
        unsafe { ArrayMesh_surface_get_array_len(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_format(&self, surf_idx: i64) -> i64 {
        unsafe { ArrayMesh_surface_get_format(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_name(&self, surf_idx: i64) -> GodotString {
        unsafe { ArrayMesh_surface_get_name(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_primitive_type(&self, surf_idx: i64) -> MeshPrimitiveType {
        unsafe { ArrayMesh_surface_get_primitive_type(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_remove(&mut self, surf_idx: i64) -> () {
        unsafe { ArrayMesh_surface_remove(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_set_name(&mut self, surf_idx: i64, name: GodotString) -> () {
        unsafe { ArrayMesh_surface_set_name(self.this, surf_idx, name) }
    }

    #[inline]
    pub fn surface_update_region(&mut self, surf_idx: i64, offset: i64, data: ByteArray) -> () {
        unsafe { ArrayMesh_surface_update_region(self.this, surf_idx, offset, data) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AtlasTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_atlastexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AtlasTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AtlasTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AtlasTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AtlasTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AtlasTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_atlas(&self) -> Option<Texture> {
        unsafe { AtlasTexture_get_atlas(self.this) }
    }

    #[inline]
    pub fn get_margin(&self) -> Rect2 {
        unsafe { AtlasTexture_get_margin(self.this) }
    }

    #[inline]
    pub fn get_region(&self) -> Rect2 {
        unsafe { AtlasTexture_get_region(self.this) }
    }

    #[inline]
    pub fn has_filter_clip(&self) -> bool {
        unsafe { AtlasTexture_has_filter_clip(self.this) }
    }

    #[inline]
    pub fn set_atlas(&mut self, atlas: Option<Texture>) -> () {
        unsafe { AtlasTexture_set_atlas(self.this, atlas) }
    }

    #[inline]
    pub fn set_filter_clip(&mut self, enable: bool) -> () {
        unsafe { AtlasTexture_set_filter_clip(self.this, enable) }
    }

    #[inline]
    pub fn set_margin(&mut self, margin: Rect2) -> () {
        unsafe { AtlasTexture_set_margin(self.this, margin) }
    }

    #[inline]
    pub fn set_region(&mut self, region: Rect2) -> () {
        unsafe { AtlasTexture_set_region(self.this, region) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioBusLayout` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiobuslayout.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioBusLayout inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioBusLayout {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioBusLayout {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioBusLayoutMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioBusLayout {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffect` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffect inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffect {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectAmplify` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectamplify.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectAmplify inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectAmplify {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectAmplify {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectAmplifyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectAmplify {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_volume_db(&self) -> f64 {
        unsafe { AudioEffectAmplify_get_volume_db(self.this) }
    }

    #[inline]
    pub fn set_volume_db(&mut self, volume: f64) -> () {
        unsafe { AudioEffectAmplify_set_volume_db(self.this, volume) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectBandLimitFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectbandlimitfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectBandLimitFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectBandLimitFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectBandLimitFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectBandLimitFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectBandLimitFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectBandPassFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectbandpassfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectBandPassFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectBandPassFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectBandPassFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectBandPassFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectBandPassFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectChorus` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectchorus.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectChorus inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectChorus {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectChorus {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectChorusMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectChorus {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_dry(&self) -> f64 {
        unsafe { AudioEffectChorus_get_dry(self.this) }
    }

    #[inline]
    pub fn get_voice_count(&self) -> i64 {
        unsafe { AudioEffectChorus_get_voice_count(self.this) }
    }

    #[inline]
    pub fn get_voice_cutoff_hz(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_cutoff_hz(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_voice_delay_ms(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_delay_ms(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_voice_depth_ms(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_depth_ms(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_voice_level_db(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_level_db(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_voice_pan(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_pan(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_voice_rate_hz(&self, voice_idx: i64) -> f64 {
        unsafe { AudioEffectChorus_get_voice_rate_hz(self.this, voice_idx) }
    }

    #[inline]
    pub fn get_wet(&self) -> f64 {
        unsafe { AudioEffectChorus_get_wet(self.this) }
    }

    #[inline]
    pub fn set_dry(&mut self, amount: f64) -> () {
        unsafe { AudioEffectChorus_set_dry(self.this, amount) }
    }

    #[inline]
    pub fn set_voice_count(&mut self, voices: i64) -> () {
        unsafe { AudioEffectChorus_set_voice_count(self.this, voices) }
    }

    #[inline]
    pub fn set_voice_cutoff_hz(&mut self, voice_idx: i64, cutoff_hz: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_cutoff_hz(self.this, voice_idx, cutoff_hz) }
    }

    #[inline]
    pub fn set_voice_delay_ms(&mut self, voice_idx: i64, delay_ms: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_delay_ms(self.this, voice_idx, delay_ms) }
    }

    #[inline]
    pub fn set_voice_depth_ms(&mut self, voice_idx: i64, depth_ms: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_depth_ms(self.this, voice_idx, depth_ms) }
    }

    #[inline]
    pub fn set_voice_level_db(&mut self, voice_idx: i64, level_db: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_level_db(self.this, voice_idx, level_db) }
    }

    #[inline]
    pub fn set_voice_pan(&mut self, voice_idx: i64, pan: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_pan(self.this, voice_idx, pan) }
    }

    #[inline]
    pub fn set_voice_rate_hz(&mut self, voice_idx: i64, rate_hz: f64) -> () {
        unsafe { AudioEffectChorus_set_voice_rate_hz(self.this, voice_idx, rate_hz) }
    }

    #[inline]
    pub fn set_wet(&mut self, amount: f64) -> () {
        unsafe { AudioEffectChorus_set_wet(self.this, amount) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectCompressor` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectcompressor.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectCompressor inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectCompressor {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectCompressor {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectCompressorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectCompressor {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_attack_us(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_attack_us(self.this) }
    }

    #[inline]
    pub fn get_gain(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_gain(self.this) }
    }

    #[inline]
    pub fn get_mix(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_mix(self.this) }
    }

    #[inline]
    pub fn get_ratio(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_ratio(self.this) }
    }

    #[inline]
    pub fn get_release_ms(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_release_ms(self.this) }
    }

    #[inline]
    pub fn get_sidechain(&self) -> GodotString {
        unsafe { AudioEffectCompressor_get_sidechain(self.this) }
    }

    #[inline]
    pub fn get_threshold(&self) -> f64 {
        unsafe { AudioEffectCompressor_get_threshold(self.this) }
    }

    #[inline]
    pub fn set_attack_us(&mut self, attack_us: f64) -> () {
        unsafe { AudioEffectCompressor_set_attack_us(self.this, attack_us) }
    }

    #[inline]
    pub fn set_gain(&mut self, gain: f64) -> () {
        unsafe { AudioEffectCompressor_set_gain(self.this, gain) }
    }

    #[inline]
    pub fn set_mix(&mut self, mix: f64) -> () {
        unsafe { AudioEffectCompressor_set_mix(self.this, mix) }
    }

    #[inline]
    pub fn set_ratio(&mut self, ratio: f64) -> () {
        unsafe { AudioEffectCompressor_set_ratio(self.this, ratio) }
    }

    #[inline]
    pub fn set_release_ms(&mut self, release_ms: f64) -> () {
        unsafe { AudioEffectCompressor_set_release_ms(self.this, release_ms) }
    }

    #[inline]
    pub fn set_sidechain(&mut self, sidechain: GodotString) -> () {
        unsafe { AudioEffectCompressor_set_sidechain(self.this, sidechain) }
    }

    #[inline]
    pub fn set_threshold(&mut self, threshold: f64) -> () {
        unsafe { AudioEffectCompressor_set_threshold(self.this, threshold) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectDelay` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectdelay.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectDelay inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectDelay {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectDelay {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectDelayMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectDelay {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_dry(&mut self) -> f64 {
        unsafe { AudioEffectDelay_get_dry(self.this) }
    }

    #[inline]
    pub fn get_feedback_delay_ms(&self) -> f64 {
        unsafe { AudioEffectDelay_get_feedback_delay_ms(self.this) }
    }

    #[inline]
    pub fn get_feedback_level_db(&self) -> f64 {
        unsafe { AudioEffectDelay_get_feedback_level_db(self.this) }
    }

    #[inline]
    pub fn get_feedback_lowpass(&self) -> f64 {
        unsafe { AudioEffectDelay_get_feedback_lowpass(self.this) }
    }

    #[inline]
    pub fn get_tap1_delay_ms(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap1_delay_ms(self.this) }
    }

    #[inline]
    pub fn get_tap1_level_db(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap1_level_db(self.this) }
    }

    #[inline]
    pub fn get_tap1_pan(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap1_pan(self.this) }
    }

    #[inline]
    pub fn get_tap2_delay_ms(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap2_delay_ms(self.this) }
    }

    #[inline]
    pub fn get_tap2_level_db(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap2_level_db(self.this) }
    }

    #[inline]
    pub fn get_tap2_pan(&self) -> f64 {
        unsafe { AudioEffectDelay_get_tap2_pan(self.this) }
    }

    #[inline]
    pub fn is_feedback_active(&self) -> bool {
        unsafe { AudioEffectDelay_is_feedback_active(self.this) }
    }

    #[inline]
    pub fn is_tap1_active(&self) -> bool {
        unsafe { AudioEffectDelay_is_tap1_active(self.this) }
    }

    #[inline]
    pub fn is_tap2_active(&self) -> bool {
        unsafe { AudioEffectDelay_is_tap2_active(self.this) }
    }

    #[inline]
    pub fn set_dry(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_dry(self.this, amount) }
    }

    #[inline]
    pub fn set_feedback_active(&mut self, amount: bool) -> () {
        unsafe { AudioEffectDelay_set_feedback_active(self.this, amount) }
    }

    #[inline]
    pub fn set_feedback_delay_ms(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_feedback_delay_ms(self.this, amount) }
    }

    #[inline]
    pub fn set_feedback_level_db(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_feedback_level_db(self.this, amount) }
    }

    #[inline]
    pub fn set_feedback_lowpass(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_feedback_lowpass(self.this, amount) }
    }

    #[inline]
    pub fn set_tap1_active(&mut self, amount: bool) -> () {
        unsafe { AudioEffectDelay_set_tap1_active(self.this, amount) }
    }

    #[inline]
    pub fn set_tap1_delay_ms(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap1_delay_ms(self.this, amount) }
    }

    #[inline]
    pub fn set_tap1_level_db(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap1_level_db(self.this, amount) }
    }

    #[inline]
    pub fn set_tap1_pan(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap1_pan(self.this, amount) }
    }

    #[inline]
    pub fn set_tap2_active(&mut self, amount: bool) -> () {
        unsafe { AudioEffectDelay_set_tap2_active(self.this, amount) }
    }

    #[inline]
    pub fn set_tap2_delay_ms(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap2_delay_ms(self.this, amount) }
    }

    #[inline]
    pub fn set_tap2_level_db(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap2_level_db(self.this, amount) }
    }

    #[inline]
    pub fn set_tap2_pan(&mut self, amount: f64) -> () {
        unsafe { AudioEffectDelay_set_tap2_pan(self.this, amount) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectDistortion` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectdistortion.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectDistortion inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectDistortion {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioEffectDistortionMode {
    ModeClip = 0,
    ModeAtan = 1,
    ModeLofi = 2,
    ModeOverdrive = 3,
    ModeWaveshape = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioEffectDistortion {
    pub const MODE_CLIP: i64 = 0;
    pub const MODE_LOFI: i64 = 2;
    pub const MODE_ATAN: i64 = 1;
    pub const MODE_OVERDRIVE: i64 = 3;
    pub const MODE_WAVESHAPE: i64 = 4;
}
impl AudioEffectDistortion {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectDistortionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectDistortion {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_drive(&self) -> f64 {
        unsafe { AudioEffectDistortion_get_drive(self.this) }
    }

    #[inline]
    pub fn get_keep_hf_hz(&self) -> f64 {
        unsafe { AudioEffectDistortion_get_keep_hf_hz(self.this) }
    }

    #[inline]
    pub fn get_mode(&self) -> AudioEffectDistortionMode {
        unsafe { AudioEffectDistortion_get_mode(self.this) }
    }

    #[inline]
    pub fn get_post_gain(&self) -> f64 {
        unsafe { AudioEffectDistortion_get_post_gain(self.this) }
    }

    #[inline]
    pub fn get_pre_gain(&self) -> f64 {
        unsafe { AudioEffectDistortion_get_pre_gain(self.this) }
    }

    #[inline]
    pub fn set_drive(&mut self, drive: f64) -> () {
        unsafe { AudioEffectDistortion_set_drive(self.this, drive) }
    }

    #[inline]
    pub fn set_keep_hf_hz(&mut self, keep_hf_hz: f64) -> () {
        unsafe { AudioEffectDistortion_set_keep_hf_hz(self.this, keep_hf_hz) }
    }

    #[inline]
    pub fn set_mode(&mut self, mode: i64) -> () {
        unsafe { AudioEffectDistortion_set_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_post_gain(&mut self, post_gain: f64) -> () {
        unsafe { AudioEffectDistortion_set_post_gain(self.this, post_gain) }
    }

    #[inline]
    pub fn set_pre_gain(&mut self, pre_gain: f64) -> () {
        unsafe { AudioEffectDistortion_set_pre_gain(self.this, pre_gain) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectEQ` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecteq.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectEQ inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectEQ {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectEQ {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectEQMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectEQ {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_band_count(&self) -> i64 {
        unsafe { AudioEffectEQ_get_band_count(self.this) }
    }

    #[inline]
    pub fn get_band_gain_db(&self, band_idx: i64) -> f64 {
        unsafe { AudioEffectEQ_get_band_gain_db(self.this, band_idx) }
    }

    #[inline]
    pub fn set_band_gain_db(&mut self, band_idx: i64, volume_db: f64) -> () {
        unsafe { AudioEffectEQ_set_band_gain_db(self.this, band_idx, volume_db) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectEQ10` inherits `AudioEffectEQ` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecteq10.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectEQ10 inherits methods from:
/// - [AudioEffectEQ](struct.AudioEffectEQ.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectEQ10 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectEQ10 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectEQ10MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectEQ10 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_eq(&self) -> AudioEffectEQ {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectEQ { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectEQ21` inherits `AudioEffectEQ` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecteq21.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectEQ21 inherits methods from:
/// - [AudioEffectEQ](struct.AudioEffectEQ.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectEQ21 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectEQ21 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectEQ21MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectEQ21 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_eq(&self) -> AudioEffectEQ {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectEQ { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectEQ6` inherits `AudioEffectEQ` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecteq6.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectEQ6 inherits methods from:
/// - [AudioEffectEQ](struct.AudioEffectEQ.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectEQ6 {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectEQ6 {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectEQ6MethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectEQ6 {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_eq(&self) -> AudioEffectEQ {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectEQ { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectFilter` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectFilter inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioEffectFilterFilterDB {
    Filter6db = 0,
    Filter12db = 1,
    Filter18db = 2,
    Filter24db = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioEffectFilter {
    pub const FILTER_18DB: i64 = 2;
    pub const FILTER_24DB: i64 = 3;
    pub const FILTER_6DB: i64 = 0;
    pub const FILTER_12DB: i64 = 1;
}
impl AudioEffectFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_cutoff(&self) -> f64 {
        unsafe { AudioEffectFilter_get_cutoff(self.this) }
    }

    #[inline]
    pub fn get_db(&self) -> AudioEffectFilterFilterDB {
        unsafe { AudioEffectFilter_get_db(self.this) }
    }

    #[inline]
    pub fn get_gain(&self) -> f64 {
        unsafe { AudioEffectFilter_get_gain(self.this) }
    }

    #[inline]
    pub fn get_resonance(&self) -> f64 {
        unsafe { AudioEffectFilter_get_resonance(self.this) }
    }

    #[inline]
    pub fn set_cutoff(&mut self, freq: f64) -> () {
        unsafe { AudioEffectFilter_set_cutoff(self.this, freq) }
    }

    #[inline]
    pub fn set_db(&mut self, amount: i64) -> () {
        unsafe { AudioEffectFilter_set_db(self.this, amount) }
    }

    #[inline]
    pub fn set_gain(&mut self, amount: f64) -> () {
        unsafe { AudioEffectFilter_set_gain(self.this, amount) }
    }

    #[inline]
    pub fn set_resonance(&mut self, amount: f64) -> () {
        unsafe { AudioEffectFilter_set_resonance(self.this, amount) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectHighPassFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecthighpassfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectHighPassFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectHighPassFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectHighPassFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectHighPassFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectHighPassFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectHighShelfFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffecthighshelffilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectHighShelfFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectHighShelfFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectHighShelfFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectHighShelfFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectHighShelfFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectInstance` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectinstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectInstance inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectInstance {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectLimiter` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectlimiter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectLimiter inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectLimiter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectLimiter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectLimiterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectLimiter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_ceiling_db(&self) -> f64 {
        unsafe { AudioEffectLimiter_get_ceiling_db(self.this) }
    }

    #[inline]
    pub fn get_soft_clip_db(&self) -> f64 {
        unsafe { AudioEffectLimiter_get_soft_clip_db(self.this) }
    }

    #[inline]
    pub fn get_soft_clip_ratio(&self) -> f64 {
        unsafe { AudioEffectLimiter_get_soft_clip_ratio(self.this) }
    }

    #[inline]
    pub fn get_threshold_db(&self) -> f64 {
        unsafe { AudioEffectLimiter_get_threshold_db(self.this) }
    }

    #[inline]
    pub fn set_ceiling_db(&mut self, ceiling: f64) -> () {
        unsafe { AudioEffectLimiter_set_ceiling_db(self.this, ceiling) }
    }

    #[inline]
    pub fn set_soft_clip_db(&mut self, soft_clip: f64) -> () {
        unsafe { AudioEffectLimiter_set_soft_clip_db(self.this, soft_clip) }
    }

    #[inline]
    pub fn set_soft_clip_ratio(&mut self, soft_clip: f64) -> () {
        unsafe { AudioEffectLimiter_set_soft_clip_ratio(self.this, soft_clip) }
    }

    #[inline]
    pub fn set_threshold_db(&mut self, threshold: f64) -> () {
        unsafe { AudioEffectLimiter_set_threshold_db(self.this, threshold) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectLowPassFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectlowpassfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectLowPassFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectLowPassFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectLowPassFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectLowPassFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectLowPassFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectLowShelfFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectlowshelffilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectLowShelfFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectLowShelfFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectLowShelfFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectLowShelfFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectLowShelfFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectNotchFilter` inherits `AudioEffectFilter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectnotchfilter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectNotchFilter inherits methods from:
/// - [AudioEffectFilter](struct.AudioEffectFilter.html)
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectNotchFilter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectNotchFilter {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectNotchFilterMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectNotchFilter {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_filter(&self) -> AudioEffectFilter {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectFilter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectPanner` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectpanner.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectPanner inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectPanner {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectPanner {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectPannerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectPanner {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_pan(&self) -> f64 {
        unsafe { AudioEffectPanner_get_pan(self.this) }
    }

    #[inline]
    pub fn set_pan(&mut self, cpanume: f64) -> () {
        unsafe { AudioEffectPanner_set_pan(self.this, cpanume) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectPhaser` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectphaser.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectPhaser inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectPhaser {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectPhaser {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectPhaserMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectPhaser {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_depth(&self) -> f64 {
        unsafe { AudioEffectPhaser_get_depth(self.this) }
    }

    #[inline]
    pub fn get_feedback(&self) -> f64 {
        unsafe { AudioEffectPhaser_get_feedback(self.this) }
    }

    #[inline]
    pub fn get_range_max_hz(&self) -> f64 {
        unsafe { AudioEffectPhaser_get_range_max_hz(self.this) }
    }

    #[inline]
    pub fn get_range_min_hz(&self) -> f64 {
        unsafe { AudioEffectPhaser_get_range_min_hz(self.this) }
    }

    #[inline]
    pub fn get_rate_hz(&self) -> f64 {
        unsafe { AudioEffectPhaser_get_rate_hz(self.this) }
    }

    #[inline]
    pub fn set_depth(&mut self, depth: f64) -> () {
        unsafe { AudioEffectPhaser_set_depth(self.this, depth) }
    }

    #[inline]
    pub fn set_feedback(&mut self, fbk: f64) -> () {
        unsafe { AudioEffectPhaser_set_feedback(self.this, fbk) }
    }

    #[inline]
    pub fn set_range_max_hz(&mut self, hz: f64) -> () {
        unsafe { AudioEffectPhaser_set_range_max_hz(self.this, hz) }
    }

    #[inline]
    pub fn set_range_min_hz(&mut self, hz: f64) -> () {
        unsafe { AudioEffectPhaser_set_range_min_hz(self.this, hz) }
    }

    #[inline]
    pub fn set_rate_hz(&mut self, hz: f64) -> () {
        unsafe { AudioEffectPhaser_set_rate_hz(self.this, hz) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectPitchShift` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectpitchshift.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectPitchShift inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectPitchShift {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioEffectPitchShiftFFT_Size {
    FftSize256 = 0,
    FftSize512 = 1,
    FftSize1024 = 2,
    FftSize2048 = 3,
    FftSize4096 = 4,
    FftSizeMax = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioEffectPitchShift {
    pub const FFT_SIZE_MAX: i64 = 5;
    pub const FFT_SIZE_512: i64 = 1;
    pub const FFT_SIZE_1024: i64 = 2;
    pub const FFT_SIZE_2048: i64 = 3;
    pub const FFT_SIZE_4096: i64 = 4;
    pub const FFT_SIZE_256: i64 = 0;
}
impl AudioEffectPitchShift {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectPitchShiftMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectPitchShift {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_fft_size(&self) -> AudioEffectPitchShiftFFT_Size {
        unsafe { AudioEffectPitchShift_get_fft_size(self.this) }
    }

    #[inline]
    pub fn get_oversampling(&self) -> i64 {
        unsafe { AudioEffectPitchShift_get_oversampling(self.this) }
    }

    #[inline]
    pub fn get_pitch_scale(&self) -> f64 {
        unsafe { AudioEffectPitchShift_get_pitch_scale(self.this) }
    }

    #[inline]
    pub fn set_fft_size(&mut self, size: i64) -> () {
        unsafe { AudioEffectPitchShift_set_fft_size(self.this, size) }
    }

    #[inline]
    pub fn set_oversampling(&mut self, amount: i64) -> () {
        unsafe { AudioEffectPitchShift_set_oversampling(self.this, amount) }
    }

    #[inline]
    pub fn set_pitch_scale(&mut self, rate: f64) -> () {
        unsafe { AudioEffectPitchShift_set_pitch_scale(self.this, rate) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectRecord` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectrecord.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectRecord inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectRecord {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectRecord {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectRecordMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectRecord {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_format(&self) -> AudioStreamSampleFormat {
        unsafe { AudioEffectRecord_get_format(self.this) }
    }

    #[inline]
    pub fn get_recording(&self) -> Option<AudioStreamSample> {
        unsafe { AudioEffectRecord_get_recording(self.this) }
    }

    #[inline]
    pub fn is_recording_active(&self) -> bool {
        unsafe { AudioEffectRecord_is_recording_active(self.this) }
    }

    #[inline]
    pub fn set_format(&mut self, format: i64) -> () {
        unsafe { AudioEffectRecord_set_format(self.this, format) }
    }

    #[inline]
    pub fn set_recording_active(&mut self, record: bool) -> () {
        unsafe { AudioEffectRecord_set_recording_active(self.this, record) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectReverb` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectreverb.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectReverb inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectReverb {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectReverb {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectReverbMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectReverb {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_damping(&self) -> f64 {
        unsafe { AudioEffectReverb_get_damping(self.this) }
    }

    #[inline]
    pub fn get_dry(&self) -> f64 {
        unsafe { AudioEffectReverb_get_dry(self.this) }
    }

    #[inline]
    pub fn get_hpf(&self) -> f64 {
        unsafe { AudioEffectReverb_get_hpf(self.this) }
    }

    #[inline]
    pub fn get_predelay_feedback(&self) -> f64 {
        unsafe { AudioEffectReverb_get_predelay_feedback(self.this) }
    }

    #[inline]
    pub fn get_predelay_msec(&self) -> f64 {
        unsafe { AudioEffectReverb_get_predelay_msec(self.this) }
    }

    #[inline]
    pub fn get_room_size(&self) -> f64 {
        unsafe { AudioEffectReverb_get_room_size(self.this) }
    }

    #[inline]
    pub fn get_spread(&self) -> f64 {
        unsafe { AudioEffectReverb_get_spread(self.this) }
    }

    #[inline]
    pub fn get_wet(&self) -> f64 {
        unsafe { AudioEffectReverb_get_wet(self.this) }
    }

    #[inline]
    pub fn set_damping(&mut self, amount: f64) -> () {
        unsafe { AudioEffectReverb_set_damping(self.this, amount) }
    }

    #[inline]
    pub fn set_dry(&mut self, amount: f64) -> () {
        unsafe { AudioEffectReverb_set_dry(self.this, amount) }
    }

    #[inline]
    pub fn set_hpf(&mut self, amount: f64) -> () {
        unsafe { AudioEffectReverb_set_hpf(self.this, amount) }
    }

    #[inline]
    pub fn set_predelay_feedback(&mut self, feedback: f64) -> () {
        unsafe { AudioEffectReverb_set_predelay_feedback(self.this, feedback) }
    }

    #[inline]
    pub fn set_predelay_msec(&mut self, msec: f64) -> () {
        unsafe { AudioEffectReverb_set_predelay_msec(self.this, msec) }
    }

    #[inline]
    pub fn set_room_size(&mut self, size: f64) -> () {
        unsafe { AudioEffectReverb_set_room_size(self.this, size) }
    }

    #[inline]
    pub fn set_spread(&mut self, amount: f64) -> () {
        unsafe { AudioEffectReverb_set_spread(self.this, amount) }
    }

    #[inline]
    pub fn set_wet(&mut self, amount: f64) -> () {
        unsafe { AudioEffectReverb_set_wet(self.this, amount) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectSpectrumAnalyzer` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectspectrumanalyzer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectSpectrumAnalyzer inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectSpectrumAnalyzer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioEffectSpectrumAnalyzerFFT_Size {
    FftSize256 = 0,
    FftSize512 = 1,
    FftSize1024 = 2,
    FftSize2048 = 3,
    FftSize4096 = 4,
    FftSizeMax = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioEffectSpectrumAnalyzer {
    pub const FFT_SIZE_256: i64 = 0;
    pub const FFT_SIZE_1024: i64 = 2;
    pub const FFT_SIZE_2048: i64 = 3;
    pub const FFT_SIZE_4096: i64 = 4;
    pub const FFT_SIZE_512: i64 = 1;
    pub const FFT_SIZE_MAX: i64 = 5;
}
impl AudioEffectSpectrumAnalyzer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectSpectrumAnalyzerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectSpectrumAnalyzer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_buffer_length(&self) -> f64 {
        unsafe { AudioEffectSpectrumAnalyzer_get_buffer_length(self.this) }
    }

    #[inline]
    pub fn get_fft_size(&self) -> AudioEffectSpectrumAnalyzerFFT_Size {
        unsafe { AudioEffectSpectrumAnalyzer_get_fft_size(self.this) }
    }

    #[inline]
    pub fn get_tap_back_pos(&self) -> f64 {
        unsafe { AudioEffectSpectrumAnalyzer_get_tap_back_pos(self.this) }
    }

    #[inline]
    pub fn set_buffer_length(&mut self, seconds: f64) -> () {
        unsafe { AudioEffectSpectrumAnalyzer_set_buffer_length(self.this, seconds) }
    }

    #[inline]
    pub fn set_fft_size(&mut self, size: i64) -> () {
        unsafe { AudioEffectSpectrumAnalyzer_set_fft_size(self.this, size) }
    }

    #[inline]
    pub fn set_tap_back_pos(&mut self, seconds: f64) -> () {
        unsafe { AudioEffectSpectrumAnalyzer_set_tap_back_pos(self.this, seconds) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectSpectrumAnalyzerInstance` inherits `AudioEffectInstance` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectspectrumanalyzerinstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectSpectrumAnalyzerInstance inherits methods from:
/// - [AudioEffectInstance](struct.AudioEffectInstance.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectSpectrumAnalyzerInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioEffectSpectrumAnalyzerInstanceMagnitudeMode {
    Average = 0,
    Max = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioEffectSpectrumAnalyzerInstance {
    pub const MAGNITUDE_AVERAGE: i64 = 0;
    pub const MAGNITUDE_MAX: i64 = 1;
}
impl AudioEffectSpectrumAnalyzerInstance {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_magnitude_for_frequency_range(&self, from_hz: f64, to_hz: f64, mode: i64) -> Vector2 {
        unsafe { AudioEffectSpectrumAnalyzerInstance_get_magnitude_for_frequency_range(self.this, from_hz, to_hz, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect_instance(&self) -> AudioEffectInstance {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffectInstance { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioEffectStereoEnhance` inherits `AudioEffect` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioeffectstereoenhance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioEffectStereoEnhance inherits methods from:
/// - [AudioEffect](struct.AudioEffect.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioEffectStereoEnhance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioEffectStereoEnhance {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioEffectStereoEnhanceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioEffectStereoEnhance {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_pan_pullout(&self) -> f64 {
        unsafe { AudioEffectStereoEnhance_get_pan_pullout(self.this) }
    }

    #[inline]
    pub fn get_surround(&self) -> f64 {
        unsafe { AudioEffectStereoEnhance_get_surround(self.this) }
    }

    #[inline]
    pub fn get_time_pullout(&self) -> f64 {
        unsafe { AudioEffectStereoEnhance_get_time_pullout(self.this) }
    }

    #[inline]
    pub fn set_pan_pullout(&mut self, amount: f64) -> () {
        unsafe { AudioEffectStereoEnhance_set_pan_pullout(self.this, amount) }
    }

    #[inline]
    pub fn set_surround(&mut self, amount: f64) -> () {
        unsafe { AudioEffectStereoEnhance_set_surround(self.this, amount) }
    }

    #[inline]
    pub fn set_time_pullout(&mut self, amount: f64) -> () {
        unsafe { AudioEffectStereoEnhance_set_time_pullout(self.this, amount) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_effect(&self) -> AudioEffect {
        unsafe {{ object::add_ref(self.this); }}
        AudioEffect { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class AudioServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audioserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// AudioServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioServerSpeakerMode {
    ModeStereo = 0,
    Surround31 = 1,
    Surround51 = 2,
    Surround71 = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioServer {
    pub const SPEAKER_MODE_STEREO: i64 = 0;
    pub const SPEAKER_SURROUND_71: i64 = 3;
    pub const SPEAKER_SURROUND_51: i64 = 2;
    pub const SPEAKER_SURROUND_31: i64 = 1;
}
impl AudioServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"AudioServer\0".as_ptr() as *mut _);

            AudioServer {
                this
            }
        }
    }
    #[inline]
    pub fn add_bus(&mut self, at_position: i64) -> () {
        unsafe { AudioServer_add_bus(self.this, at_position) }
    }

    #[inline]
    pub fn add_bus_effect(&mut self, bus_idx: i64, effect: Option<AudioEffect>, at_position: i64) -> () {
        unsafe { AudioServer_add_bus_effect(self.this, bus_idx, effect, at_position) }
    }

    #[inline]
    pub fn capture_get_device(&mut self) -> GodotString {
        unsafe { AudioServer_capture_get_device(self.this) }
    }

    #[inline]
    pub fn capture_get_device_list(&mut self) -> VariantArray {
        unsafe { AudioServer_capture_get_device_list(self.this) }
    }

    #[inline]
    pub fn capture_set_device(&mut self, name: GodotString) -> () {
        unsafe { AudioServer_capture_set_device(self.this, name) }
    }

    #[inline]
    pub fn generate_bus_layout(&self) -> Option<AudioBusLayout> {
        unsafe { AudioServer_generate_bus_layout(self.this) }
    }

    #[inline]
    pub fn get_bus_channels(&self, bus_idx: i64) -> i64 {
        unsafe { AudioServer_get_bus_channels(self.this, bus_idx) }
    }

    #[inline]
    pub fn get_bus_count(&self) -> i64 {
        unsafe { AudioServer_get_bus_count(self.this) }
    }

    #[inline]
    pub fn get_bus_effect(&mut self, bus_idx: i64, effect_idx: i64) -> Option<AudioEffect> {
        unsafe { AudioServer_get_bus_effect(self.this, bus_idx, effect_idx) }
    }

    #[inline]
    pub fn get_bus_effect_count(&mut self, bus_idx: i64) -> i64 {
        unsafe { AudioServer_get_bus_effect_count(self.this, bus_idx) }
    }

    #[inline]
    pub fn get_bus_effect_instance(&mut self, bus_idx: i64, effect_idx: i64, channel: i64) -> Option<AudioEffectInstance> {
        unsafe { AudioServer_get_bus_effect_instance(self.this, bus_idx, effect_idx, channel) }
    }

    #[inline]
    pub fn get_bus_index(&self, bus_name: GodotString) -> i64 {
        unsafe { AudioServer_get_bus_index(self.this, bus_name) }
    }

    #[inline]
    pub fn get_bus_name(&self, bus_idx: i64) -> GodotString {
        unsafe { AudioServer_get_bus_name(self.this, bus_idx) }
    }

    #[inline]
    pub fn get_bus_peak_volume_left_db(&self, bus_idx: i64, channel: i64) -> f64 {
        unsafe { AudioServer_get_bus_peak_volume_left_db(self.this, bus_idx, channel) }
    }

    #[inline]
    pub fn get_bus_peak_volume_right_db(&self, bus_idx: i64, channel: i64) -> f64 {
        unsafe { AudioServer_get_bus_peak_volume_right_db(self.this, bus_idx, channel) }
    }

    #[inline]
    pub fn get_bus_send(&self, bus_idx: i64) -> GodotString {
        unsafe { AudioServer_get_bus_send(self.this, bus_idx) }
    }

    #[inline]
    pub fn get_bus_volume_db(&self, bus_idx: i64) -> f64 {
        unsafe { AudioServer_get_bus_volume_db(self.this, bus_idx) }
    }

    #[inline]
    pub fn get_device(&mut self) -> GodotString {
        unsafe { AudioServer_get_device(self.this) }
    }

    #[inline]
    pub fn get_device_list(&mut self) -> VariantArray {
        unsafe { AudioServer_get_device_list(self.this) }
    }

    #[inline]
    pub fn get_global_rate_scale(&self) -> f64 {
        unsafe { AudioServer_get_global_rate_scale(self.this) }
    }

    #[inline]
    pub fn get_mix_rate(&self) -> f64 {
        unsafe { AudioServer_get_mix_rate(self.this) }
    }

    #[inline]
    pub fn get_output_latency(&self) -> f64 {
        unsafe { AudioServer_get_output_latency(self.this) }
    }

    #[inline]
    pub fn get_speaker_mode(&self) -> AudioServerSpeakerMode {
        unsafe { AudioServer_get_speaker_mode(self.this) }
    }

    #[inline]
    pub fn get_time_since_last_mix(&self) -> f64 {
        unsafe { AudioServer_get_time_since_last_mix(self.this) }
    }

    #[inline]
    pub fn get_time_to_next_mix(&self) -> f64 {
        unsafe { AudioServer_get_time_to_next_mix(self.this) }
    }

    #[inline]
    pub fn is_bus_bypassing_effects(&self, bus_idx: i64) -> bool {
        unsafe { AudioServer_is_bus_bypassing_effects(self.this, bus_idx) }
    }

    #[inline]
    pub fn is_bus_effect_enabled(&self, bus_idx: i64, effect_idx: i64) -> bool {
        unsafe { AudioServer_is_bus_effect_enabled(self.this, bus_idx, effect_idx) }
    }

    #[inline]
    pub fn is_bus_mute(&self, bus_idx: i64) -> bool {
        unsafe { AudioServer_is_bus_mute(self.this, bus_idx) }
    }

    #[inline]
    pub fn is_bus_solo(&self, bus_idx: i64) -> bool {
        unsafe { AudioServer_is_bus_solo(self.this, bus_idx) }
    }

    #[inline]
    pub fn lock(&mut self) -> () {
        unsafe { AudioServer_lock(self.this) }
    }

    #[inline]
    pub fn move_bus(&mut self, index: i64, to_index: i64) -> () {
        unsafe { AudioServer_move_bus(self.this, index, to_index) }
    }

    #[inline]
    pub fn remove_bus(&mut self, index: i64) -> () {
        unsafe { AudioServer_remove_bus(self.this, index) }
    }

    #[inline]
    pub fn remove_bus_effect(&mut self, bus_idx: i64, effect_idx: i64) -> () {
        unsafe { AudioServer_remove_bus_effect(self.this, bus_idx, effect_idx) }
    }

    #[inline]
    pub fn set_bus_bypass_effects(&mut self, bus_idx: i64, enable: bool) -> () {
        unsafe { AudioServer_set_bus_bypass_effects(self.this, bus_idx, enable) }
    }

    #[inline]
    pub fn set_bus_count(&mut self, amount: i64) -> () {
        unsafe { AudioServer_set_bus_count(self.this, amount) }
    }

    #[inline]
    pub fn set_bus_effect_enabled(&mut self, bus_idx: i64, effect_idx: i64, enabled: bool) -> () {
        unsafe { AudioServer_set_bus_effect_enabled(self.this, bus_idx, effect_idx, enabled) }
    }

    #[inline]
    pub fn set_bus_layout(&mut self, bus_layout: Option<AudioBusLayout>) -> () {
        unsafe { AudioServer_set_bus_layout(self.this, bus_layout) }
    }

    #[inline]
    pub fn set_bus_mute(&mut self, bus_idx: i64, enable: bool) -> () {
        unsafe { AudioServer_set_bus_mute(self.this, bus_idx, enable) }
    }

    #[inline]
    pub fn set_bus_name(&mut self, bus_idx: i64, name: GodotString) -> () {
        unsafe { AudioServer_set_bus_name(self.this, bus_idx, name) }
    }

    #[inline]
    pub fn set_bus_send(&mut self, bus_idx: i64, send: GodotString) -> () {
        unsafe { AudioServer_set_bus_send(self.this, bus_idx, send) }
    }

    #[inline]
    pub fn set_bus_solo(&mut self, bus_idx: i64, enable: bool) -> () {
        unsafe { AudioServer_set_bus_solo(self.this, bus_idx, enable) }
    }

    #[inline]
    pub fn set_bus_volume_db(&mut self, bus_idx: i64, volume_db: f64) -> () {
        unsafe { AudioServer_set_bus_volume_db(self.this, bus_idx, volume_db) }
    }

    #[inline]
    pub fn set_device(&mut self, device: GodotString) -> () {
        unsafe { AudioServer_set_device(self.this, device) }
    }

    #[inline]
    pub fn set_global_rate_scale(&mut self, scale: f64) -> () {
        unsafe { AudioServer_set_global_rate_scale(self.this, scale) }
    }

    #[inline]
    pub fn swap_bus_effects(&mut self, bus_idx: i64, effect_idx: i64, by_effect_idx: i64) -> () {
        unsafe { AudioServer_swap_bus_effects(self.this, bus_idx, effect_idx, by_effect_idx) }
    }

    #[inline]
    pub fn unlock(&mut self) -> () {
        unsafe { AudioServer_unlock(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStream` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostream.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStream inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStream {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStream {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_length(&self) -> f64 {
        unsafe { AudioStream_get_length(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamGenerator` inherits `AudioStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamgenerator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamGenerator inherits methods from:
/// - [AudioStream](struct.AudioStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamGenerator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamGenerator {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamGeneratorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioStreamGenerator {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_buffer_length(&self) -> f64 {
        unsafe { AudioStreamGenerator_get_buffer_length(self.this) }
    }

    #[inline]
    pub fn get_mix_rate(&self) -> f64 {
        unsafe { AudioStreamGenerator_get_mix_rate(self.this) }
    }

    #[inline]
    pub fn set_buffer_length(&mut self, seconds: f64) -> () {
        unsafe { AudioStreamGenerator_set_buffer_length(self.this, seconds) }
    }

    #[inline]
    pub fn set_mix_rate(&mut self, hz: f64) -> () {
        unsafe { AudioStreamGenerator_set_mix_rate(self.this, hz) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream(&self) -> AudioStream {
        unsafe {{ object::add_ref(self.this); }}
        AudioStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamGeneratorPlayback` inherits `AudioStreamPlaybackResampled` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamgeneratorplayback.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamGeneratorPlayback inherits methods from:
/// - [AudioStreamPlaybackResampled](struct.AudioStreamPlaybackResampled.html)
/// - [AudioStreamPlayback](struct.AudioStreamPlayback.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamGeneratorPlayback {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamGeneratorPlayback {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn can_push_buffer(&self, amount: i64) -> bool {
        unsafe { AudioStreamGeneratorPlayback_can_push_buffer(self.this, amount) }
    }

    #[inline]
    pub fn clear_buffer(&mut self) -> () {
        unsafe { AudioStreamGeneratorPlayback_clear_buffer(self.this) }
    }

    #[inline]
    pub fn get_frames_available(&self) -> i64 {
        unsafe { AudioStreamGeneratorPlayback_get_frames_available(self.this) }
    }

    #[inline]
    pub fn get_skips(&self) -> i64 {
        unsafe { AudioStreamGeneratorPlayback_get_skips(self.this) }
    }

    #[inline]
    pub fn push_buffer(&mut self, frames: Vector2Array) -> bool {
        unsafe { AudioStreamGeneratorPlayback_push_buffer(self.this, frames) }
    }

    #[inline]
    pub fn push_frame(&mut self, frame: Vector2) -> bool {
        unsafe { AudioStreamGeneratorPlayback_push_frame(self.this, frame) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream_playback_resampled(&self) -> AudioStreamPlaybackResampled {
        unsafe {{ object::add_ref(self.this); }}
        AudioStreamPlaybackResampled { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_audio_stream_playback(&self) -> AudioStreamPlayback {
        unsafe {{ object::add_ref(self.this); }}
        AudioStreamPlayback { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamMicrophone` inherits `AudioStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreammicrophone.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamMicrophone inherits methods from:
/// - [AudioStream](struct.AudioStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamMicrophone {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamMicrophone {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamMicrophoneMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioStreamMicrophone {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream(&self) -> AudioStream {
        unsafe {{ object::add_ref(self.this); }}
        AudioStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamOGGVorbis` inherits `AudioStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamoggvorbis.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamOGGVorbis inherits methods from:
/// - [AudioStream](struct.AudioStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamOGGVorbis {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamOGGVorbis {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamOGGVorbisMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioStreamOGGVorbis {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_data(&self) -> ByteArray {
        unsafe { AudioStreamOGGVorbis_get_data(self.this) }
    }

    #[inline]
    pub fn get_loop_offset(&self) -> f64 {
        unsafe { AudioStreamOGGVorbis_get_loop_offset(self.this) }
    }

    #[inline]
    pub fn has_loop(&self) -> bool {
        unsafe { AudioStreamOGGVorbis_has_loop(self.this) }
    }

    #[inline]
    pub fn set_data(&mut self, data: ByteArray) -> () {
        unsafe { AudioStreamOGGVorbis_set_data(self.this, data) }
    }

    #[inline]
    pub fn set_loop(&mut self, enable: bool) -> () {
        unsafe { AudioStreamOGGVorbis_set_loop(self.this, enable) }
    }

    #[inline]
    pub fn set_loop_offset(&mut self, seconds: f64) -> () {
        unsafe { AudioStreamOGGVorbis_set_loop_offset(self.this, seconds) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream(&self) -> AudioStream {
        unsafe {{ object::add_ref(self.this); }}
        AudioStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamPlayback` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamplayback.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamPlayback inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamPlayback {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamPlayback {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamPlaybackResampled` inherits `AudioStreamPlayback` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamplaybackresampled.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamPlaybackResampled inherits methods from:
/// - [AudioStreamPlayback](struct.AudioStreamPlayback.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamPlaybackResampled {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamPlaybackResampled {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream_playback(&self) -> AudioStreamPlayback {
        unsafe {{ object::add_ref(self.this); }}
        AudioStreamPlayback { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamPlayer` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamplayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AudioStreamPlayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AudioStreamPlayer::free`.
///
/// ## Class hierarchy
///
/// AudioStreamPlayer inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamPlayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamPlayerMixTarget {
    Stereo = 0,
    Surround = 1,
    Center = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioStreamPlayer {
    pub const MIX_TARGET_SURROUND: i64 = 1;
    pub const MIX_TARGET_STEREO: i64 = 0;
    pub const MIX_TARGET_CENTER: i64 = 2;
}
impl AudioStreamPlayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AudioStreamPlayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamPlayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AudioStreamPlayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _bus_layout_changed(&mut self) -> () {
        AudioStreamPlayer__bus_layout_changed(self.this)
    }

    #[inline]
    pub unsafe fn _is_active(&self) -> bool {
        AudioStreamPlayer__is_active(self.this)
    }

    #[inline]
    pub unsafe fn _set_playing(&mut self, enable: bool) -> () {
        AudioStreamPlayer__set_playing(self.this, enable)
    }

    #[inline]
    pub unsafe fn get_bus(&self) -> GodotString {
        AudioStreamPlayer_get_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_mix_target(&self) -> AudioStreamPlayerMixTarget {
        AudioStreamPlayer_get_mix_target(self.this)
    }

    #[inline]
    pub unsafe fn get_pitch_scale(&self) -> f64 {
        AudioStreamPlayer_get_pitch_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_playback_position(&mut self) -> f64 {
        AudioStreamPlayer_get_playback_position(self.this)
    }

    #[inline]
    pub unsafe fn get_stream(&self) -> Option<AudioStream> {
        AudioStreamPlayer_get_stream(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_paused(&self) -> bool {
        AudioStreamPlayer_get_stream_paused(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_playback(&mut self) -> Option<AudioStreamPlayback> {
        AudioStreamPlayer_get_stream_playback(self.this)
    }

    #[inline]
    pub unsafe fn get_volume_db(&self) -> f64 {
        AudioStreamPlayer_get_volume_db(self.this)
    }

    #[inline]
    pub unsafe fn is_autoplay_enabled(&mut self) -> bool {
        AudioStreamPlayer_is_autoplay_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AudioStreamPlayer_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, from_position: f64) -> () {
        AudioStreamPlayer_play(self.this, from_position)
    }

    #[inline]
    pub unsafe fn seek(&mut self, to_position: f64) -> () {
        AudioStreamPlayer_seek(self.this, to_position)
    }

    #[inline]
    pub unsafe fn set_autoplay(&mut self, enable: bool) -> () {
        AudioStreamPlayer_set_autoplay(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_bus(&mut self, bus: GodotString) -> () {
        AudioStreamPlayer_set_bus(self.this, bus)
    }

    #[inline]
    pub unsafe fn set_mix_target(&mut self, mix_target: i64) -> () {
        AudioStreamPlayer_set_mix_target(self.this, mix_target)
    }

    #[inline]
    pub unsafe fn set_pitch_scale(&mut self, pitch_scale: f64) -> () {
        AudioStreamPlayer_set_pitch_scale(self.this, pitch_scale)
    }

    #[inline]
    pub unsafe fn set_stream(&mut self, stream: Option<AudioStream>) -> () {
        AudioStreamPlayer_set_stream(self.this, stream)
    }

    #[inline]
    pub unsafe fn set_stream_paused(&mut self, pause: bool) -> () {
        AudioStreamPlayer_set_stream_paused(self.this, pause)
    }

    #[inline]
    pub unsafe fn set_volume_db(&mut self, volume_db: f64) -> () {
        AudioStreamPlayer_set_volume_db(self.this, volume_db)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        AudioStreamPlayer_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamPlayer2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamplayer2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AudioStreamPlayer2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AudioStreamPlayer2D::free`.
///
/// ## Class hierarchy
///
/// AudioStreamPlayer2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamPlayer2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamPlayer2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AudioStreamPlayer2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamPlayer2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AudioStreamPlayer2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _bus_layout_changed(&mut self) -> () {
        AudioStreamPlayer2D__bus_layout_changed(self.this)
    }

    #[inline]
    pub unsafe fn _is_active(&self) -> bool {
        AudioStreamPlayer2D__is_active(self.this)
    }

    #[inline]
    pub unsafe fn _set_playing(&mut self, enable: bool) -> () {
        AudioStreamPlayer2D__set_playing(self.this, enable)
    }

    #[inline]
    pub unsafe fn get_area_mask(&self) -> i64 {
        AudioStreamPlayer2D_get_area_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_attenuation(&self) -> f64 {
        AudioStreamPlayer2D_get_attenuation(self.this)
    }

    #[inline]
    pub unsafe fn get_bus(&self) -> GodotString {
        AudioStreamPlayer2D_get_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_max_distance(&self) -> f64 {
        AudioStreamPlayer2D_get_max_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_pitch_scale(&self) -> f64 {
        AudioStreamPlayer2D_get_pitch_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_playback_position(&mut self) -> f64 {
        AudioStreamPlayer2D_get_playback_position(self.this)
    }

    #[inline]
    pub unsafe fn get_stream(&self) -> Option<AudioStream> {
        AudioStreamPlayer2D_get_stream(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_paused(&self) -> bool {
        AudioStreamPlayer2D_get_stream_paused(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_playback(&mut self) -> Option<AudioStreamPlayback> {
        AudioStreamPlayer2D_get_stream_playback(self.this)
    }

    #[inline]
    pub unsafe fn get_volume_db(&self) -> f64 {
        AudioStreamPlayer2D_get_volume_db(self.this)
    }

    #[inline]
    pub unsafe fn is_autoplay_enabled(&mut self) -> bool {
        AudioStreamPlayer2D_is_autoplay_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AudioStreamPlayer2D_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, from_position: f64) -> () {
        AudioStreamPlayer2D_play(self.this, from_position)
    }

    #[inline]
    pub unsafe fn seek(&mut self, to_position: f64) -> () {
        AudioStreamPlayer2D_seek(self.this, to_position)
    }

    #[inline]
    pub unsafe fn set_area_mask(&mut self, mask: i64) -> () {
        AudioStreamPlayer2D_set_area_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_attenuation(&mut self, curve: f64) -> () {
        AudioStreamPlayer2D_set_attenuation(self.this, curve)
    }

    #[inline]
    pub unsafe fn set_autoplay(&mut self, enable: bool) -> () {
        AudioStreamPlayer2D_set_autoplay(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_bus(&mut self, bus: GodotString) -> () {
        AudioStreamPlayer2D_set_bus(self.this, bus)
    }

    #[inline]
    pub unsafe fn set_max_distance(&mut self, pixels: f64) -> () {
        AudioStreamPlayer2D_set_max_distance(self.this, pixels)
    }

    #[inline]
    pub unsafe fn set_pitch_scale(&mut self, pitch_scale: f64) -> () {
        AudioStreamPlayer2D_set_pitch_scale(self.this, pitch_scale)
    }

    #[inline]
    pub unsafe fn set_stream(&mut self, stream: Option<AudioStream>) -> () {
        AudioStreamPlayer2D_set_stream(self.this, stream)
    }

    #[inline]
    pub unsafe fn set_stream_paused(&mut self, pause: bool) -> () {
        AudioStreamPlayer2D_set_stream_paused(self.this, pause)
    }

    #[inline]
    pub unsafe fn set_volume_db(&mut self, volume_db: f64) -> () {
        AudioStreamPlayer2D_set_volume_db(self.this, volume_db)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        AudioStreamPlayer2D_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamPlayer3D` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamplayer3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `AudioStreamPlayer3D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `AudioStreamPlayer3D::free`.
///
/// ## Class hierarchy
///
/// AudioStreamPlayer3D inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamPlayer3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamPlayer3DAttenuationModel {
    AttenuationInverseDistance = 0,
    AttenuationInverseSquareDistance = 1,
    AttenuationLogarithmic = 2,
    AttenuationDisabled = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamPlayer3DOutOfRangeMode {
    Mix = 0,
    Pause = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamPlayer3DDopplerTracking {
    Disabled = 0,
    IdleStep = 1,
    PhysicsStep = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioStreamPlayer3D {
    pub const OUT_OF_RANGE_PAUSE: i64 = 1;
    pub const OUT_OF_RANGE_MIX: i64 = 0;
    pub const ATTENUATION_LOGARITHMIC: i64 = 2;
    pub const ATTENUATION_INVERSE_SQUARE_DISTANCE: i64 = 1;
    pub const DOPPLER_TRACKING_DISABLED: i64 = 0;
    pub const ATTENUATION_DISABLED: i64 = 3;
    pub const DOPPLER_TRACKING_PHYSICS_STEP: i64 = 2;
    pub const DOPPLER_TRACKING_IDLE_STEP: i64 = 1;
    pub const ATTENUATION_INVERSE_DISTANCE: i64 = 0;
}
impl AudioStreamPlayer3D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `AudioStreamPlayer3D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamPlayer3DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            AudioStreamPlayer3D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _bus_layout_changed(&mut self) -> () {
        AudioStreamPlayer3D__bus_layout_changed(self.this)
    }

    #[inline]
    pub unsafe fn _is_active(&self) -> bool {
        AudioStreamPlayer3D__is_active(self.this)
    }

    #[inline]
    pub unsafe fn _set_playing(&mut self, enable: bool) -> () {
        AudioStreamPlayer3D__set_playing(self.this, enable)
    }

    #[inline]
    pub unsafe fn get_area_mask(&self) -> i64 {
        AudioStreamPlayer3D_get_area_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_attenuation_filter_cutoff_hz(&self) -> f64 {
        AudioStreamPlayer3D_get_attenuation_filter_cutoff_hz(self.this)
    }

    #[inline]
    pub unsafe fn get_attenuation_filter_db(&self) -> f64 {
        AudioStreamPlayer3D_get_attenuation_filter_db(self.this)
    }

    #[inline]
    pub unsafe fn get_attenuation_model(&self) -> AudioStreamPlayer3DAttenuationModel {
        AudioStreamPlayer3D_get_attenuation_model(self.this)
    }

    #[inline]
    pub unsafe fn get_bus(&self) -> GodotString {
        AudioStreamPlayer3D_get_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_doppler_tracking(&self) -> AudioStreamPlayer3DDopplerTracking {
        AudioStreamPlayer3D_get_doppler_tracking(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_angle(&self) -> f64 {
        AudioStreamPlayer3D_get_emission_angle(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_angle_filter_attenuation_db(&self) -> f64 {
        AudioStreamPlayer3D_get_emission_angle_filter_attenuation_db(self.this)
    }

    #[inline]
    pub unsafe fn get_max_db(&self) -> f64 {
        AudioStreamPlayer3D_get_max_db(self.this)
    }

    #[inline]
    pub unsafe fn get_max_distance(&self) -> f64 {
        AudioStreamPlayer3D_get_max_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_out_of_range_mode(&self) -> AudioStreamPlayer3DOutOfRangeMode {
        AudioStreamPlayer3D_get_out_of_range_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_pitch_scale(&self) -> f64 {
        AudioStreamPlayer3D_get_pitch_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_playback_position(&mut self) -> f64 {
        AudioStreamPlayer3D_get_playback_position(self.this)
    }

    #[inline]
    pub unsafe fn get_stream(&self) -> Option<AudioStream> {
        AudioStreamPlayer3D_get_stream(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_paused(&self) -> bool {
        AudioStreamPlayer3D_get_stream_paused(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_playback(&mut self) -> Option<AudioStreamPlayback> {
        AudioStreamPlayer3D_get_stream_playback(self.this)
    }

    #[inline]
    pub unsafe fn get_unit_db(&self) -> f64 {
        AudioStreamPlayer3D_get_unit_db(self.this)
    }

    #[inline]
    pub unsafe fn get_unit_size(&self) -> f64 {
        AudioStreamPlayer3D_get_unit_size(self.this)
    }

    #[inline]
    pub unsafe fn is_autoplay_enabled(&mut self) -> bool {
        AudioStreamPlayer3D_is_autoplay_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_emission_angle_enabled(&self) -> bool {
        AudioStreamPlayer3D_is_emission_angle_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        AudioStreamPlayer3D_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self, from_position: f64) -> () {
        AudioStreamPlayer3D_play(self.this, from_position)
    }

    #[inline]
    pub unsafe fn seek(&mut self, to_position: f64) -> () {
        AudioStreamPlayer3D_seek(self.this, to_position)
    }

    #[inline]
    pub unsafe fn set_area_mask(&mut self, mask: i64) -> () {
        AudioStreamPlayer3D_set_area_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_attenuation_filter_cutoff_hz(&mut self, degrees: f64) -> () {
        AudioStreamPlayer3D_set_attenuation_filter_cutoff_hz(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_attenuation_filter_db(&mut self, db: f64) -> () {
        AudioStreamPlayer3D_set_attenuation_filter_db(self.this, db)
    }

    #[inline]
    pub unsafe fn set_attenuation_model(&mut self, model: i64) -> () {
        AudioStreamPlayer3D_set_attenuation_model(self.this, model)
    }

    #[inline]
    pub unsafe fn set_autoplay(&mut self, enable: bool) -> () {
        AudioStreamPlayer3D_set_autoplay(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_bus(&mut self, bus: GodotString) -> () {
        AudioStreamPlayer3D_set_bus(self.this, bus)
    }

    #[inline]
    pub unsafe fn set_doppler_tracking(&mut self, mode: i64) -> () {
        AudioStreamPlayer3D_set_doppler_tracking(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_emission_angle(&mut self, degrees: f64) -> () {
        AudioStreamPlayer3D_set_emission_angle(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_emission_angle_enabled(&mut self, enabled: bool) -> () {
        AudioStreamPlayer3D_set_emission_angle_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_emission_angle_filter_attenuation_db(&mut self, db: f64) -> () {
        AudioStreamPlayer3D_set_emission_angle_filter_attenuation_db(self.this, db)
    }

    #[inline]
    pub unsafe fn set_max_db(&mut self, max_db: f64) -> () {
        AudioStreamPlayer3D_set_max_db(self.this, max_db)
    }

    #[inline]
    pub unsafe fn set_max_distance(&mut self, metres: f64) -> () {
        AudioStreamPlayer3D_set_max_distance(self.this, metres)
    }

    #[inline]
    pub unsafe fn set_out_of_range_mode(&mut self, mode: i64) -> () {
        AudioStreamPlayer3D_set_out_of_range_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_pitch_scale(&mut self, pitch_scale: f64) -> () {
        AudioStreamPlayer3D_set_pitch_scale(self.this, pitch_scale)
    }

    #[inline]
    pub unsafe fn set_stream(&mut self, stream: Option<AudioStream>) -> () {
        AudioStreamPlayer3D_set_stream(self.this, stream)
    }

    #[inline]
    pub unsafe fn set_stream_paused(&mut self, pause: bool) -> () {
        AudioStreamPlayer3D_set_stream_paused(self.this, pause)
    }

    #[inline]
    pub unsafe fn set_unit_db(&mut self, unit_db: f64) -> () {
        AudioStreamPlayer3D_set_unit_db(self.this, unit_db)
    }

    #[inline]
    pub unsafe fn set_unit_size(&mut self, unit_size: f64) -> () {
        AudioStreamPlayer3D_set_unit_size(self.this, unit_size)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        AudioStreamPlayer3D_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamRandomPitch` inherits `AudioStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamrandompitch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamRandomPitch inherits methods from:
/// - [AudioStream](struct.AudioStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamRandomPitch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl AudioStreamRandomPitch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamRandomPitchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioStreamRandomPitch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_audio_stream(&self) -> Option<AudioStream> {
        unsafe { AudioStreamRandomPitch_get_audio_stream(self.this) }
    }

    #[inline]
    pub fn get_random_pitch(&self) -> f64 {
        unsafe { AudioStreamRandomPitch_get_random_pitch(self.this) }
    }

    #[inline]
    pub fn set_audio_stream(&mut self, stream: Option<AudioStream>) -> () {
        unsafe { AudioStreamRandomPitch_set_audio_stream(self.this, stream) }
    }

    #[inline]
    pub fn set_random_pitch(&mut self, scale: f64) -> () {
        unsafe { AudioStreamRandomPitch_set_random_pitch(self.this, scale) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream(&self) -> AudioStream {
        unsafe {{ object::add_ref(self.this); }}
        AudioStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class AudioStreamSample` inherits `AudioStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_audiostreamsample.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// AudioStreamSample inherits methods from:
/// - [AudioStream](struct.AudioStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct AudioStreamSample {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamSampleLoopMode {
    Disabled = 0,
    Forward = 1,
    PingPong = 2,
    Backward = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioStreamSampleFormat {
    Format8Bits = 0,
    Format16Bits = 1,
    ImaAdpcm = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl AudioStreamSample {
    pub const LOOP_DISABLED: i64 = 0;
    pub const LOOP_FORWARD: i64 = 1;
    pub const FORMAT_16_BITS: i64 = 1;
    pub const FORMAT_IMA_ADPCM: i64 = 2;
    pub const LOOP_BACKWARD: i64 = 3;
    pub const LOOP_PING_PONG: i64 = 2;
    pub const FORMAT_8_BITS: i64 = 0;
}
impl AudioStreamSample {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = AudioStreamSampleMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            AudioStreamSample {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_data(&self) -> ByteArray {
        unsafe { AudioStreamSample_get_data(self.this) }
    }

    #[inline]
    pub fn get_format(&self) -> AudioStreamSampleFormat {
        unsafe { AudioStreamSample_get_format(self.this) }
    }

    #[inline]
    pub fn get_loop_begin(&self) -> i64 {
        unsafe { AudioStreamSample_get_loop_begin(self.this) }
    }

    #[inline]
    pub fn get_loop_end(&self) -> i64 {
        unsafe { AudioStreamSample_get_loop_end(self.this) }
    }

    #[inline]
    pub fn get_loop_mode(&self) -> AudioStreamSampleLoopMode {
        unsafe { AudioStreamSample_get_loop_mode(self.this) }
    }

    #[inline]
    pub fn get_mix_rate(&self) -> i64 {
        unsafe { AudioStreamSample_get_mix_rate(self.this) }
    }

    #[inline]
    pub fn is_stereo(&self) -> bool {
        unsafe { AudioStreamSample_is_stereo(self.this) }
    }

    #[inline]
    pub fn save_to_wav(&mut self, path: GodotString) -> GodotResult {
        unsafe { AudioStreamSample_save_to_wav(self.this, path) }
    }

    #[inline]
    pub fn set_data(&mut self, data: ByteArray) -> () {
        unsafe { AudioStreamSample_set_data(self.this, data) }
    }

    #[inline]
    pub fn set_format(&mut self, format: i64) -> () {
        unsafe { AudioStreamSample_set_format(self.this, format) }
    }

    #[inline]
    pub fn set_loop_begin(&mut self, loop_begin: i64) -> () {
        unsafe { AudioStreamSample_set_loop_begin(self.this, loop_begin) }
    }

    #[inline]
    pub fn set_loop_end(&mut self, loop_end: i64) -> () {
        unsafe { AudioStreamSample_set_loop_end(self.this, loop_end) }
    }

    #[inline]
    pub fn set_loop_mode(&mut self, loop_mode: i64) -> () {
        unsafe { AudioStreamSample_set_loop_mode(self.this, loop_mode) }
    }

    #[inline]
    pub fn set_mix_rate(&mut self, mix_rate: i64) -> () {
        unsafe { AudioStreamSample_set_mix_rate(self.this, mix_rate) }
    }

    #[inline]
    pub fn set_stereo(&mut self, stereo: bool) -> () {
        unsafe { AudioStreamSample_set_stereo(self.this, stereo) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_audio_stream(&self) -> AudioStream {
        unsafe {{ object::add_ref(self.this); }}
        AudioStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BackBufferCopy` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_backbuffercopy.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `BackBufferCopy` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `BackBufferCopy::free`.
///
/// ## Class hierarchy
///
/// BackBufferCopy inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BackBufferCopy {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BackBufferCopyCopyMode {
    ModeDisabled = 0,
    ModeRect = 1,
    ModeViewport = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl BackBufferCopy {
    pub const COPY_MODE_DISABLED: i64 = 0;
    pub const COPY_MODE_RECT: i64 = 1;
    pub const COPY_MODE_VIEWPORT: i64 = 2;
}
impl BackBufferCopy {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `BackBufferCopy::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BackBufferCopyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            BackBufferCopy {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_copy_mode(&self) -> BackBufferCopyCopyMode {
        BackBufferCopy_get_copy_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_rect(&self) -> Rect2 {
        BackBufferCopy_get_rect(self.this)
    }

    #[inline]
    pub unsafe fn set_copy_mode(&mut self, copy_mode: i64) -> () {
        BackBufferCopy_set_copy_mode(self.this, copy_mode)
    }

    #[inline]
    pub unsafe fn set_rect(&mut self, rect: Rect2) -> () {
        BackBufferCopy_set_rect(self.this, rect)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BakedLightmap` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bakedlightmap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `BakedLightmap` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `BakedLightmap::free`.
///
/// ## Class hierarchy
///
/// BakedLightmap inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BakedLightmap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BakedLightmapBakeQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BakedLightmapBakeError {
    Ok = 0,
    NoSavePath = 1,
    NoMeshes = 2,
    CantCreateImage = 3,
    UserAborted = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BakedLightmapBakeMode {
    ModeConeTrace = 0,
    ModeRayTrace = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl BakedLightmap {
    pub const BAKE_ERROR_NO_SAVE_PATH: i64 = 1;
    pub const BAKE_MODE_RAY_TRACE: i64 = 1;
    pub const BAKE_ERROR_OK: i64 = 0;
    pub const BAKE_ERROR_USER_ABORTED: i64 = 4;
    pub const BAKE_ERROR_CANT_CREATE_IMAGE: i64 = 3;
    pub const BAKE_ERROR_NO_MESHES: i64 = 2;
    pub const BAKE_QUALITY_LOW: i64 = 0;
    pub const BAKE_QUALITY_HIGH: i64 = 2;
    pub const BAKE_QUALITY_MEDIUM: i64 = 1;
    pub const BAKE_MODE_CONE_TRACE: i64 = 0;
}
impl BakedLightmap {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `BakedLightmap::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BakedLightmapMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            BakedLightmap {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn bake(&mut self, from_node: Option<Node>, create_visual_debug: bool) -> BakedLightmapBakeError {
        BakedLightmap_bake(self.this, from_node, create_visual_debug)
    }

    #[inline]
    pub unsafe fn debug_bake(&mut self) -> () {
        BakedLightmap_debug_bake(self.this)
    }

    #[inline]
    pub unsafe fn get_bake_cell_size(&self) -> f64 {
        BakedLightmap_get_bake_cell_size(self.this)
    }

    #[inline]
    pub unsafe fn get_bake_default_texels_per_unit(&self) -> f64 {
        BakedLightmap_get_bake_default_texels_per_unit(self.this)
    }

    #[inline]
    pub unsafe fn get_bake_mode(&self) -> BakedLightmapBakeMode {
        BakedLightmap_get_bake_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_bake_quality(&self) -> BakedLightmapBakeQuality {
        BakedLightmap_get_bake_quality(self.this)
    }

    #[inline]
    pub unsafe fn get_capture_cell_size(&self) -> f64 {
        BakedLightmap_get_capture_cell_size(self.this)
    }

    #[inline]
    pub unsafe fn get_energy(&self) -> f64 {
        BakedLightmap_get_energy(self.this)
    }

    #[inline]
    pub unsafe fn get_extents(&self) -> Vector3 {
        BakedLightmap_get_extents(self.this)
    }

    #[inline]
    pub unsafe fn get_image_path(&self) -> GodotString {
        BakedLightmap_get_image_path(self.this)
    }

    #[inline]
    pub unsafe fn get_light_data(&self) -> Option<BakedLightmapData> {
        BakedLightmap_get_light_data(self.this)
    }

    #[inline]
    pub unsafe fn get_propagation(&self) -> f64 {
        BakedLightmap_get_propagation(self.this)
    }

    #[inline]
    pub unsafe fn is_hdr(&self) -> bool {
        BakedLightmap_is_hdr(self.this)
    }

    #[inline]
    pub unsafe fn set_bake_cell_size(&mut self, bake_cell_size: f64) -> () {
        BakedLightmap_set_bake_cell_size(self.this, bake_cell_size)
    }

    #[inline]
    pub unsafe fn set_bake_default_texels_per_unit(&mut self, texels: f64) -> () {
        BakedLightmap_set_bake_default_texels_per_unit(self.this, texels)
    }

    #[inline]
    pub unsafe fn set_bake_mode(&mut self, bake_mode: i64) -> () {
        BakedLightmap_set_bake_mode(self.this, bake_mode)
    }

    #[inline]
    pub unsafe fn set_bake_quality(&mut self, bake_quality: i64) -> () {
        BakedLightmap_set_bake_quality(self.this, bake_quality)
    }

    #[inline]
    pub unsafe fn set_capture_cell_size(&mut self, capture_cell_size: f64) -> () {
        BakedLightmap_set_capture_cell_size(self.this, capture_cell_size)
    }

    #[inline]
    pub unsafe fn set_energy(&mut self, energy: f64) -> () {
        BakedLightmap_set_energy(self.this, energy)
    }

    #[inline]
    pub unsafe fn set_extents(&mut self, extents: Vector3) -> () {
        BakedLightmap_set_extents(self.this, extents)
    }

    #[inline]
    pub unsafe fn set_hdr(&mut self, hdr: bool) -> () {
        BakedLightmap_set_hdr(self.this, hdr)
    }

    #[inline]
    pub unsafe fn set_image_path(&mut self, image_path: GodotString) -> () {
        BakedLightmap_set_image_path(self.this, image_path)
    }

    #[inline]
    pub unsafe fn set_light_data(&mut self, data: Option<BakedLightmapData>) -> () {
        BakedLightmap_set_light_data(self.this, data)
    }

    #[inline]
    pub unsafe fn set_propagation(&mut self, propagation: f64) -> () {
        BakedLightmap_set_propagation(self.this, propagation)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BakedLightmapData` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bakedlightmapdata.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// BakedLightmapData inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BakedLightmapData {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BakedLightmapData {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BakedLightmapDataMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            BakedLightmapData {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_user_data(&self) -> VariantArray {
        unsafe { BakedLightmapData__get_user_data(self.this) }
    }

    #[inline]
    pub fn _set_user_data(&mut self, data: VariantArray) -> () {
        unsafe { BakedLightmapData__set_user_data(self.this, data) }
    }

    #[inline]
    pub fn add_user(&mut self, path: NodePath, lightmap: Option<Texture>, instance: i64) -> () {
        unsafe { BakedLightmapData_add_user(self.this, path, lightmap, instance) }
    }

    #[inline]
    pub fn clear_users(&mut self) -> () {
        unsafe { BakedLightmapData_clear_users(self.this) }
    }

    #[inline]
    pub fn get_bounds(&self) -> Aabb {
        unsafe { BakedLightmapData_get_bounds(self.this) }
    }

    #[inline]
    pub fn get_cell_space_transform(&self) -> Transform {
        unsafe { BakedLightmapData_get_cell_space_transform(self.this) }
    }

    #[inline]
    pub fn get_cell_subdiv(&self) -> i64 {
        unsafe { BakedLightmapData_get_cell_subdiv(self.this) }
    }

    #[inline]
    pub fn get_energy(&self) -> f64 {
        unsafe { BakedLightmapData_get_energy(self.this) }
    }

    #[inline]
    pub fn get_octree(&self) -> ByteArray {
        unsafe { BakedLightmapData_get_octree(self.this) }
    }

    #[inline]
    pub fn get_user_count(&self) -> i64 {
        unsafe { BakedLightmapData_get_user_count(self.this) }
    }

    #[inline]
    pub fn get_user_lightmap(&self, user_idx: i64) -> Option<Texture> {
        unsafe { BakedLightmapData_get_user_lightmap(self.this, user_idx) }
    }

    #[inline]
    pub fn get_user_path(&self, user_idx: i64) -> NodePath {
        unsafe { BakedLightmapData_get_user_path(self.this, user_idx) }
    }

    #[inline]
    pub fn set_bounds(&mut self, bounds: Aabb) -> () {
        unsafe { BakedLightmapData_set_bounds(self.this, bounds) }
    }

    #[inline]
    pub fn set_cell_space_transform(&mut self, xform: Transform) -> () {
        unsafe { BakedLightmapData_set_cell_space_transform(self.this, xform) }
    }

    #[inline]
    pub fn set_cell_subdiv(&mut self, cell_subdiv: i64) -> () {
        unsafe { BakedLightmapData_set_cell_subdiv(self.this, cell_subdiv) }
    }

    #[inline]
    pub fn set_energy(&mut self, energy: f64) -> () {
        unsafe { BakedLightmapData_set_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_octree(&mut self, octree: ByteArray) -> () {
        unsafe { BakedLightmapData_set_octree(self.this, octree) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BaseButton` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_basebutton.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// BaseButton inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BaseButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BaseButtonActionMode {
    ModeButtonPress = 0,
    ModeButtonRelease = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BaseButtonDrawMode {
    Normal = 0,
    Pressed = 1,
    Hover = 2,
    Disabled = 3,
    HoverPressed = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl BaseButton {
    pub const DRAW_HOVER: i64 = 2;
    pub const DRAW_HOVER_PRESSED: i64 = 4;
    pub const ACTION_MODE_BUTTON_RELEASE: i64 = 1;
    pub const ACTION_MODE_BUTTON_PRESS: i64 = 0;
    pub const DRAW_NORMAL: i64 = 0;
    pub const DRAW_PRESSED: i64 = 1;
    pub const DRAW_DISABLED: i64 = 3;
}
impl BaseButton {
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        BaseButton__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _pressed(&mut self) -> () {
        BaseButton__pressed(self.this)
    }

    #[inline]
    pub unsafe fn _toggled(&mut self, button_pressed: bool) -> () {
        BaseButton__toggled(self.this, button_pressed)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, arg0: Option<InputEvent>) -> () {
        BaseButton__unhandled_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_action_mode(&self) -> BaseButtonActionMode {
        BaseButton_get_action_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_button_group(&self) -> Option<ButtonGroup> {
        BaseButton_get_button_group(self.this)
    }

    #[inline]
    pub unsafe fn get_button_mask(&self) -> i64 {
        BaseButton_get_button_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_mode(&self) -> BaseButtonDrawMode {
        BaseButton_get_draw_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_enabled_focus_mode(&self) -> ControlFocusMode {
        BaseButton_get_enabled_focus_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_shortcut(&self) -> Option<ShortCut> {
        BaseButton_get_shortcut(self.this)
    }

    #[inline]
    pub unsafe fn is_disabled(&self) -> bool {
        BaseButton_is_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_hovered(&self) -> bool {
        BaseButton_is_hovered(self.this)
    }

    #[inline]
    pub unsafe fn is_keep_pressed_outside(&self) -> bool {
        BaseButton_is_keep_pressed_outside(self.this)
    }

    #[inline]
    pub unsafe fn is_pressed(&self) -> bool {
        BaseButton_is_pressed(self.this)
    }

    #[inline]
    pub unsafe fn is_shortcut_in_tooltip_enabled(&self) -> bool {
        BaseButton_is_shortcut_in_tooltip_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_toggle_mode(&self) -> bool {
        BaseButton_is_toggle_mode(self.this)
    }

    #[inline]
    pub unsafe fn set_action_mode(&mut self, mode: i64) -> () {
        BaseButton_set_action_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_button_group(&mut self, button_group: Option<ButtonGroup>) -> () {
        BaseButton_set_button_group(self.this, button_group)
    }

    #[inline]
    pub unsafe fn set_button_mask(&mut self, mask: i64) -> () {
        BaseButton_set_button_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_disabled(&mut self, disabled: bool) -> () {
        BaseButton_set_disabled(self.this, disabled)
    }

    #[inline]
    pub unsafe fn set_enabled_focus_mode(&mut self, mode: i64) -> () {
        BaseButton_set_enabled_focus_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_keep_pressed_outside(&mut self, enabled: bool) -> () {
        BaseButton_set_keep_pressed_outside(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_pressed(&mut self, pressed: bool) -> () {
        BaseButton_set_pressed(self.this, pressed)
    }

    #[inline]
    pub unsafe fn set_shortcut(&mut self, shortcut: Option<ShortCut>) -> () {
        BaseButton_set_shortcut(self.this, shortcut)
    }

    #[inline]
    pub unsafe fn set_shortcut_in_tooltip(&mut self, enabled: bool) -> () {
        BaseButton_set_shortcut_in_tooltip(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_toggle_mode(&mut self, enabled: bool) -> () {
        BaseButton_set_toggle_mode(self.this, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BitMap` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bitmap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// BitMap inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BitMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BitMap {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BitMapMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            BitMap {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { BitMap__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, arg0: Dictionary) -> () {
        unsafe { BitMap__set_data(self.this, arg0) }
    }

    #[inline]
    pub fn create(&mut self, size: Vector2) -> () {
        unsafe { BitMap_create(self.this, size) }
    }

    #[inline]
    pub fn create_from_image_alpha(&mut self, image: Option<Image>, threshold: f64) -> () {
        unsafe { BitMap_create_from_image_alpha(self.this, image, threshold) }
    }

    #[inline]
    pub fn get_bit(&self, position: Vector2) -> bool {
        unsafe { BitMap_get_bit(self.this, position) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { BitMap_get_size(self.this) }
    }

    #[inline]
    pub fn get_true_bit_count(&self) -> i64 {
        unsafe { BitMap_get_true_bit_count(self.this) }
    }

    #[inline]
    pub fn grow_mask(&mut self, pixels: i64, rect: Rect2) -> () {
        unsafe { BitMap_grow_mask(self.this, pixels, rect) }
    }

    #[inline]
    pub fn opaque_to_polygons(&self, rect: Rect2, epsilon: f64) -> VariantArray {
        unsafe { BitMap_opaque_to_polygons(self.this, rect, epsilon) }
    }

    #[inline]
    pub fn set_bit(&mut self, position: Vector2, bit: bool) -> () {
        unsafe { BitMap_set_bit(self.this, position, bit) }
    }

    #[inline]
    pub fn set_bit_rect(&mut self, rect: Rect2, bit: bool) -> () {
        unsafe { BitMap_set_bit_rect(self.this, rect, bit) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BitmapFont` inherits `Font` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bitmapfont.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// BitmapFont inherits methods from:
/// - [Font](struct.Font.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BitmapFont {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BitmapFont {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BitmapFontMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            BitmapFont {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_chars(&self) -> Int32Array {
        unsafe { BitmapFont__get_chars(self.this) }
    }

    #[inline]
    pub fn _get_kernings(&self) -> Int32Array {
        unsafe { BitmapFont__get_kernings(self.this) }
    }

    #[inline]
    pub fn _get_textures(&self) -> VariantArray {
        unsafe { BitmapFont__get_textures(self.this) }
    }

    #[inline]
    pub fn _set_chars(&mut self, arg0: Int32Array) -> () {
        unsafe { BitmapFont__set_chars(self.this, arg0) }
    }

    #[inline]
    pub fn _set_kernings(&mut self, arg0: Int32Array) -> () {
        unsafe { BitmapFont__set_kernings(self.this, arg0) }
    }

    #[inline]
    pub fn _set_textures(&mut self, arg0: VariantArray) -> () {
        unsafe { BitmapFont__set_textures(self.this, arg0) }
    }

    #[inline]
    pub fn add_char(&mut self, character: i64, texture: i64, rect: Rect2, align: Vector2, advance: f64) -> () {
        unsafe { BitmapFont_add_char(self.this, character, texture, rect, align, advance) }
    }

    #[inline]
    pub fn add_kerning_pair(&mut self, char_a: i64, char_b: i64, kerning: i64) -> () {
        unsafe { BitmapFont_add_kerning_pair(self.this, char_a, char_b, kerning) }
    }

    #[inline]
    pub fn add_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { BitmapFont_add_texture(self.this, texture) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { BitmapFont_clear(self.this) }
    }

    #[inline]
    pub fn create_from_fnt(&mut self, path: GodotString) -> GodotResult {
        unsafe { BitmapFont_create_from_fnt(self.this, path) }
    }

    #[inline]
    pub fn get_char_size(&self, char: i64, next: i64) -> Vector2 {
        unsafe { BitmapFont_get_char_size(self.this, char, next) }
    }

    #[inline]
    pub fn get_fallback(&self) -> Option<BitmapFont> {
        unsafe { BitmapFont_get_fallback(self.this) }
    }

    #[inline]
    pub fn get_kerning_pair(&self, char_a: i64, char_b: i64) -> i64 {
        unsafe { BitmapFont_get_kerning_pair(self.this, char_a, char_b) }
    }

    #[inline]
    pub fn get_texture(&self, idx: i64) -> Option<Texture> {
        unsafe { BitmapFont_get_texture(self.this, idx) }
    }

    #[inline]
    pub fn get_texture_count(&self) -> i64 {
        unsafe { BitmapFont_get_texture_count(self.this) }
    }

    #[inline]
    pub fn set_ascent(&mut self, px: f64) -> () {
        unsafe { BitmapFont_set_ascent(self.this, px) }
    }

    #[inline]
    pub fn set_distance_field_hint(&mut self, enable: bool) -> () {
        unsafe { BitmapFont_set_distance_field_hint(self.this, enable) }
    }

    #[inline]
    pub fn set_fallback(&mut self, fallback: Option<BitmapFont>) -> () {
        unsafe { BitmapFont_set_fallback(self.this, fallback) }
    }

    #[inline]
    pub fn set_height(&mut self, px: f64) -> () {
        unsafe { BitmapFont_set_height(self.this, px) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_font(&self) -> Font {
        unsafe {{ object::add_ref(self.this); }}
        Font { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Bone2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bone2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Bone2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Bone2D::free`.
///
/// ## Class hierarchy
///
/// Bone2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Bone2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Bone2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Bone2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Bone2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Bone2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn apply_rest(&mut self) -> () {
        Bone2D_apply_rest(self.this)
    }

    #[inline]
    pub unsafe fn get_default_length(&self) -> f64 {
        Bone2D_get_default_length(self.this)
    }

    #[inline]
    pub unsafe fn get_index_in_skeleton(&self) -> i64 {
        Bone2D_get_index_in_skeleton(self.this)
    }

    #[inline]
    pub unsafe fn get_rest(&self) -> Transform2D {
        Bone2D_get_rest(self.this)
    }

    #[inline]
    pub unsafe fn get_skeleton_rest(&self) -> Transform2D {
        Bone2D_get_skeleton_rest(self.this)
    }

    #[inline]
    pub unsafe fn set_default_length(&mut self, default_length: f64) -> () {
        Bone2D_set_default_length(self.this, default_length)
    }

    #[inline]
    pub unsafe fn set_rest(&mut self, rest: Transform2D) -> () {
        Bone2D_set_rest(self.this, rest)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BoneAttachment` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_boneattachment.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `BoneAttachment` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `BoneAttachment::free`.
///
/// ## Class hierarchy
///
/// BoneAttachment inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BoneAttachment {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BoneAttachment {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `BoneAttachment::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BoneAttachmentMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            BoneAttachment {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_bone_name(&self) -> GodotString {
        BoneAttachment_get_bone_name(self.this)
    }

    #[inline]
    pub unsafe fn set_bone_name(&mut self, bone_name: GodotString) -> () {
        BoneAttachment_set_bone_name(self.this, bone_name)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BoxContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_boxcontainer.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// BoxContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BoxContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum BoxContainerAlignMode {
    Begin = 0,
    Center = 1,
    End = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl BoxContainer {
    pub const ALIGN_END: i64 = 2;
    pub const ALIGN_CENTER: i64 = 1;
    pub const ALIGN_BEGIN: i64 = 0;
}
impl BoxContainer {
    #[inline]
    pub unsafe fn add_spacer(&mut self, begin: bool) -> () {
        BoxContainer_add_spacer(self.this, begin)
    }

    #[inline]
    pub unsafe fn get_alignment(&self) -> BoxContainerAlignMode {
        BoxContainer_get_alignment(self.this)
    }

    #[inline]
    pub unsafe fn set_alignment(&mut self, alignment: i64) -> () {
        BoxContainer_set_alignment(self.this, alignment)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BoxShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_boxshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// BoxShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BoxShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BoxShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = BoxShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            BoxShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_extents(&self) -> Vector3 {
        unsafe { BoxShape_get_extents(self.this) }
    }

    #[inline]
    pub fn set_extents(&mut self, extents: Vector3) -> () {
        unsafe { BoxShape_set_extents(self.this, extents) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BulletPhysicsDirectBodyState` inherits `PhysicsDirectBodyState` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bulletphysicsdirectbodystate.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// BulletPhysicsDirectBodyState inherits methods from:
/// - [PhysicsDirectBodyState](struct.PhysicsDirectBodyState.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BulletPhysicsDirectBodyState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BulletPhysicsDirectBodyState {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_direct_body_state(&self) -> PhysicsDirectBodyState {
        // Not reference-counted.
        PhysicsDirectBodyState { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class BulletPhysicsServer` inherits `PhysicsServer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_bulletphysicsserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// BulletPhysicsServer inherits methods from:
/// - [PhysicsServer](struct.PhysicsServer.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BulletPhysicsServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl BulletPhysicsServer {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_server(&self) -> PhysicsServer {
        // Not reference-counted.
        PhysicsServer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Button` inherits `BaseButton` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_button.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Button` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Button::free`.
///
/// ## Class hierarchy
///
/// Button inherits methods from:
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Button {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ButtonTextAlign {
    AlignLeft = 0,
    AlignCenter = 1,
    AlignRight = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Button {
    pub const ALIGN_LEFT: i64 = 0;
    pub const ALIGN_CENTER: i64 = 1;
    pub const ALIGN_RIGHT: i64 = 2;
}
impl Button {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Button::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Button {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_button_icon(&self) -> Option<Texture> {
        Button_get_button_icon(self.this)
    }

    #[inline]
    pub unsafe fn get_clip_text(&self) -> bool {
        Button_get_clip_text(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&self) -> GodotString {
        Button_get_text(self.this)
    }

    #[inline]
    pub unsafe fn get_text_align(&self) -> ButtonTextAlign {
        Button_get_text_align(self.this)
    }

    #[inline]
    pub unsafe fn is_expand_icon(&self) -> bool {
        Button_is_expand_icon(self.this)
    }

    #[inline]
    pub unsafe fn is_flat(&self) -> bool {
        Button_is_flat(self.this)
    }

    #[inline]
    pub unsafe fn set_button_icon(&mut self, texture: Option<Texture>) -> () {
        Button_set_button_icon(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_clip_text(&mut self, enabled: bool) -> () {
        Button_set_clip_text(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_expand_icon(&mut self, arg0: bool) -> () {
        Button_set_expand_icon(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_flat(&mut self, enabled: bool) -> () {
        Button_set_flat(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        Button_set_text(self.this, text)
    }

    #[inline]
    pub unsafe fn set_text_align(&mut self, align: i64) -> () {
        Button_set_text_align(self.this, align)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ButtonGroup` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_buttongroup.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ButtonGroup inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ButtonGroup {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ButtonGroup {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ButtonGroupMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ButtonGroup {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_buttons(&mut self) -> VariantArray {
        unsafe { ButtonGroup_get_buttons(self.this) }
    }

    #[inline]
    pub fn get_pressed_button(&mut self) -> Option<BaseButton> {
        unsafe { ButtonGroup_get_pressed_button(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CPUParticles` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cpuparticles.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CPUParticles` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CPUParticles::free`.
///
/// ## Class hierarchy
///
/// CPUParticles inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CPUParticles {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticlesFlags {
    FlagAlignYToVelocity = 0,
    FlagRotateY = 1,
    FlagDisableZ = 2,
    FlagMax = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticlesEmissionShape {
    Point = 0,
    Sphere = 1,
    Box = 2,
    Points = 3,
    DirectedPoints = 4,
    Max = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticlesParameter {
    ParamInitialLinearVelocity = 0,
    ParamAngularVelocity = 1,
    ParamOrbitVelocity = 2,
    ParamLinearAccel = 3,
    ParamRadialAccel = 4,
    ParamTangentialAccel = 5,
    ParamDamping = 6,
    ParamAngle = 7,
    ParamScale = 8,
    ParamHueVariation = 9,
    ParamAnimSpeed = 10,
    ParamAnimOffset = 11,
    ParamMax = 12,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticlesDrawOrder {
    Index = 0,
    Lifetime = 1,
    ViewDepth = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CPUParticles {
    pub const PARAM_ANIM_OFFSET: i64 = 11;
    pub const FLAG_DISABLE_Z: i64 = 2;
    pub const PARAM_LINEAR_ACCEL: i64 = 3;
    pub const PARAM_ORBIT_VELOCITY: i64 = 2;
    pub const EMISSION_SHAPE_POINT: i64 = 0;
    pub const FLAG_MAX: i64 = 3;
    pub const FLAG_ROTATE_Y: i64 = 1;
    pub const EMISSION_SHAPE_BOX: i64 = 2;
    pub const PARAM_ANGULAR_VELOCITY: i64 = 1;
    pub const PARAM_ANIM_SPEED: i64 = 10;
    pub const PARAM_RADIAL_ACCEL: i64 = 4;
    pub const PARAM_TANGENTIAL_ACCEL: i64 = 5;
    pub const PARAM_HUE_VARIATION: i64 = 9;
    pub const PARAM_DAMPING: i64 = 6;
    pub const PARAM_ANGLE: i64 = 7;
    pub const PARAM_MAX: i64 = 12;
    pub const DRAW_ORDER_INDEX: i64 = 0;
    pub const EMISSION_SHAPE_SPHERE: i64 = 1;
    pub const DRAW_ORDER_LIFETIME: i64 = 1;
    pub const DRAW_ORDER_VIEW_DEPTH: i64 = 2;
    pub const FLAG_ALIGN_Y_TO_VELOCITY: i64 = 0;
    pub const PARAM_SCALE: i64 = 8;
    pub const PARAM_INITIAL_LINEAR_VELOCITY: i64 = 0;
    pub const EMISSION_SHAPE_POINTS: i64 = 3;
    pub const EMISSION_SHAPE_DIRECTED_POINTS: i64 = 4;
    pub const EMISSION_SHAPE_MAX: i64 = 5;
}
impl CPUParticles {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CPUParticles::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CPUParticlesMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CPUParticles {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _update_render_thread(&mut self) -> () {
        CPUParticles__update_render_thread(self.this)
    }

    #[inline]
    pub unsafe fn convert_from_particles(&mut self, particles: Option<Node>) -> () {
        CPUParticles_convert_from_particles(self.this, particles)
    }

    #[inline]
    pub unsafe fn get_amount(&self) -> i64 {
        CPUParticles_get_amount(self.this)
    }

    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        CPUParticles_get_color(self.this)
    }

    #[inline]
    pub unsafe fn get_color_ramp(&self) -> Option<Gradient> {
        CPUParticles_get_color_ramp(self.this)
    }

    #[inline]
    pub unsafe fn get_direction(&self) -> Vector3 {
        CPUParticles_get_direction(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_order(&self) -> CPUParticlesDrawOrder {
        CPUParticles_get_draw_order(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_box_extents(&self) -> Vector3 {
        CPUParticles_get_emission_box_extents(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_colors(&self) -> ColorArray {
        CPUParticles_get_emission_colors(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_normals(&self) -> Vector3Array {
        CPUParticles_get_emission_normals(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_points(&self) -> Vector3Array {
        CPUParticles_get_emission_points(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_shape(&self) -> CPUParticlesEmissionShape {
        CPUParticles_get_emission_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_sphere_radius(&self) -> f64 {
        CPUParticles_get_emission_sphere_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_explosiveness_ratio(&self) -> f64 {
        CPUParticles_get_explosiveness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_fps(&self) -> i64 {
        CPUParticles_get_fixed_fps(self.this)
    }

    #[inline]
    pub unsafe fn get_flatness(&self) -> f64 {
        CPUParticles_get_flatness(self.this)
    }

    #[inline]
    pub unsafe fn get_fractional_delta(&self) -> bool {
        CPUParticles_get_fractional_delta(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity(&self) -> Vector3 {
        CPUParticles_get_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime(&self) -> f64 {
        CPUParticles_get_lifetime(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime_randomness(&self) -> f64 {
        CPUParticles_get_lifetime_randomness(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        CPUParticles_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_one_shot(&self) -> bool {
        CPUParticles_get_one_shot(self.this)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        CPUParticles_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_curve(&self, param: i64) -> Option<Curve> {
        CPUParticles_get_param_curve(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_randomness(&self, param: i64) -> f64 {
        CPUParticles_get_param_randomness(self.this, param)
    }

    #[inline]
    pub unsafe fn get_particle_flag(&self, flag: i64) -> bool {
        CPUParticles_get_particle_flag(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_pre_process_time(&self) -> f64 {
        CPUParticles_get_pre_process_time(self.this)
    }

    #[inline]
    pub unsafe fn get_randomness_ratio(&self) -> f64 {
        CPUParticles_get_randomness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        CPUParticles_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_spread(&self) -> f64 {
        CPUParticles_get_spread(self.this)
    }

    #[inline]
    pub unsafe fn get_use_local_coordinates(&self) -> bool {
        CPUParticles_get_use_local_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn is_emitting(&self) -> bool {
        CPUParticles_is_emitting(self.this)
    }

    #[inline]
    pub unsafe fn restart(&mut self) -> () {
        CPUParticles_restart(self.this)
    }

    #[inline]
    pub unsafe fn set_amount(&mut self, amount: i64) -> () {
        CPUParticles_set_amount(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        CPUParticles_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_color_ramp(&mut self, ramp: Option<Gradient>) -> () {
        CPUParticles_set_color_ramp(self.this, ramp)
    }

    #[inline]
    pub unsafe fn set_direction(&mut self, direction: Vector3) -> () {
        CPUParticles_set_direction(self.this, direction)
    }

    #[inline]
    pub unsafe fn set_draw_order(&mut self, order: i64) -> () {
        CPUParticles_set_draw_order(self.this, order)
    }

    #[inline]
    pub unsafe fn set_emission_box_extents(&mut self, extents: Vector3) -> () {
        CPUParticles_set_emission_box_extents(self.this, extents)
    }

    #[inline]
    pub unsafe fn set_emission_colors(&mut self, array: ColorArray) -> () {
        CPUParticles_set_emission_colors(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_normals(&mut self, array: Vector3Array) -> () {
        CPUParticles_set_emission_normals(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_points(&mut self, array: Vector3Array) -> () {
        CPUParticles_set_emission_points(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_shape(&mut self, shape: i64) -> () {
        CPUParticles_set_emission_shape(self.this, shape)
    }

    #[inline]
    pub unsafe fn set_emission_sphere_radius(&mut self, radius: f64) -> () {
        CPUParticles_set_emission_sphere_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_emitting(&mut self, emitting: bool) -> () {
        CPUParticles_set_emitting(self.this, emitting)
    }

    #[inline]
    pub unsafe fn set_explosiveness_ratio(&mut self, ratio: f64) -> () {
        CPUParticles_set_explosiveness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_fixed_fps(&mut self, fps: i64) -> () {
        CPUParticles_set_fixed_fps(self.this, fps)
    }

    #[inline]
    pub unsafe fn set_flatness(&mut self, amount: f64) -> () {
        CPUParticles_set_flatness(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_fractional_delta(&mut self, enable: bool) -> () {
        CPUParticles_set_fractional_delta(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_gravity(&mut self, accel_vec: Vector3) -> () {
        CPUParticles_set_gravity(self.this, accel_vec)
    }

    #[inline]
    pub unsafe fn set_lifetime(&mut self, secs: f64) -> () {
        CPUParticles_set_lifetime(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_lifetime_randomness(&mut self, random: f64) -> () {
        CPUParticles_set_lifetime_randomness(self.this, random)
    }

    #[inline]
    pub unsafe fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        CPUParticles_set_mesh(self.this, mesh)
    }

    #[inline]
    pub unsafe fn set_one_shot(&mut self, enable: bool) -> () {
        CPUParticles_set_one_shot(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        CPUParticles_set_param(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_param_curve(&mut self, param: i64, curve: Option<Curve>) -> () {
        CPUParticles_set_param_curve(self.this, param, curve)
    }

    #[inline]
    pub unsafe fn set_param_randomness(&mut self, param: i64, randomness: f64) -> () {
        CPUParticles_set_param_randomness(self.this, param, randomness)
    }

    #[inline]
    pub unsafe fn set_particle_flag(&mut self, flag: i64, enable: bool) -> () {
        CPUParticles_set_particle_flag(self.this, flag, enable)
    }

    #[inline]
    pub unsafe fn set_pre_process_time(&mut self, secs: f64) -> () {
        CPUParticles_set_pre_process_time(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_randomness_ratio(&mut self, ratio: f64) -> () {
        CPUParticles_set_randomness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, scale: f64) -> () {
        CPUParticles_set_speed_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_spread(&mut self, degrees: f64) -> () {
        CPUParticles_set_spread(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_use_local_coordinates(&mut self, enable: bool) -> () {
        CPUParticles_set_use_local_coordinates(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CPUParticles2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cpuparticles2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CPUParticles2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CPUParticles2D::free`.
///
/// ## Class hierarchy
///
/// CPUParticles2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CPUParticles2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticles2DFlags {
    FlagAlignYToVelocity = 0,
    FlagRotateY = 1,
    FlagDisableZ = 2,
    FlagMax = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticles2DEmissionShape {
    Point = 0,
    Sphere = 1,
    Rectangle = 2,
    Points = 3,
    DirectedPoints = 4,
    Max = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticles2DParameter {
    ParamInitialLinearVelocity = 0,
    ParamAngularVelocity = 1,
    ParamOrbitVelocity = 2,
    ParamLinearAccel = 3,
    ParamRadialAccel = 4,
    ParamTangentialAccel = 5,
    ParamDamping = 6,
    ParamAngle = 7,
    ParamScale = 8,
    ParamHueVariation = 9,
    ParamAnimSpeed = 10,
    ParamAnimOffset = 11,
    ParamMax = 12,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CPUParticles2DDrawOrder {
    Index = 0,
    Lifetime = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CPUParticles2D {
    pub const EMISSION_SHAPE_MAX: i64 = 5;
    pub const FLAG_MAX: i64 = 3;
    pub const FLAG_DISABLE_Z: i64 = 2;
    pub const PARAM_ANGLE: i64 = 7;
    pub const PARAM_DAMPING: i64 = 6;
    pub const PARAM_HUE_VARIATION: i64 = 9;
    pub const DRAW_ORDER_LIFETIME: i64 = 1;
    pub const PARAM_ORBIT_VELOCITY: i64 = 2;
    pub const PARAM_LINEAR_ACCEL: i64 = 3;
    pub const EMISSION_SHAPE_RECTANGLE: i64 = 2;
    pub const PARAM_SCALE: i64 = 8;
    pub const EMISSION_SHAPE_POINT: i64 = 0;
    pub const EMISSION_SHAPE_DIRECTED_POINTS: i64 = 4;
    pub const EMISSION_SHAPE_POINTS: i64 = 3;
    pub const PARAM_ANIM_SPEED: i64 = 10;
    pub const PARAM_RADIAL_ACCEL: i64 = 4;
    pub const FLAG_ALIGN_Y_TO_VELOCITY: i64 = 0;
    pub const FLAG_ROTATE_Y: i64 = 1;
    pub const PARAM_MAX: i64 = 12;
    pub const DRAW_ORDER_INDEX: i64 = 0;
    pub const PARAM_ANGULAR_VELOCITY: i64 = 1;
    pub const EMISSION_SHAPE_SPHERE: i64 = 1;
    pub const PARAM_TANGENTIAL_ACCEL: i64 = 5;
    pub const PARAM_ANIM_OFFSET: i64 = 11;
    pub const PARAM_INITIAL_LINEAR_VELOCITY: i64 = 0;
}
impl CPUParticles2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CPUParticles2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CPUParticles2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CPUParticles2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _update_render_thread(&mut self) -> () {
        CPUParticles2D__update_render_thread(self.this)
    }

    #[inline]
    pub unsafe fn convert_from_particles(&mut self, particles: Option<Node>) -> () {
        CPUParticles2D_convert_from_particles(self.this, particles)
    }

    #[inline]
    pub unsafe fn get_amount(&self) -> i64 {
        CPUParticles2D_get_amount(self.this)
    }

    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        CPUParticles2D_get_color(self.this)
    }

    #[inline]
    pub unsafe fn get_color_ramp(&self) -> Option<Gradient> {
        CPUParticles2D_get_color_ramp(self.this)
    }

    #[inline]
    pub unsafe fn get_direction(&self) -> Vector2 {
        CPUParticles2D_get_direction(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_order(&self) -> CPUParticles2DDrawOrder {
        CPUParticles2D_get_draw_order(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_colors(&self) -> ColorArray {
        CPUParticles2D_get_emission_colors(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_normals(&self) -> Vector2Array {
        CPUParticles2D_get_emission_normals(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_points(&self) -> Vector2Array {
        CPUParticles2D_get_emission_points(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_rect_extents(&self) -> Vector2 {
        CPUParticles2D_get_emission_rect_extents(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_shape(&self) -> CPUParticles2DEmissionShape {
        CPUParticles2D_get_emission_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_emission_sphere_radius(&self) -> f64 {
        CPUParticles2D_get_emission_sphere_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_explosiveness_ratio(&self) -> f64 {
        CPUParticles2D_get_explosiveness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_fps(&self) -> i64 {
        CPUParticles2D_get_fixed_fps(self.this)
    }

    #[inline]
    pub unsafe fn get_fractional_delta(&self) -> bool {
        CPUParticles2D_get_fractional_delta(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity(&self) -> Vector2 {
        CPUParticles2D_get_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime(&self) -> f64 {
        CPUParticles2D_get_lifetime(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime_randomness(&self) -> f64 {
        CPUParticles2D_get_lifetime_randomness(self.this)
    }

    #[inline]
    pub unsafe fn get_normalmap(&self) -> Option<Texture> {
        CPUParticles2D_get_normalmap(self.this)
    }

    #[inline]
    pub unsafe fn get_one_shot(&self) -> bool {
        CPUParticles2D_get_one_shot(self.this)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        CPUParticles2D_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_curve(&self, param: i64) -> Option<Curve> {
        CPUParticles2D_get_param_curve(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_randomness(&self, param: i64) -> f64 {
        CPUParticles2D_get_param_randomness(self.this, param)
    }

    #[inline]
    pub unsafe fn get_particle_flag(&self, flag: i64) -> bool {
        CPUParticles2D_get_particle_flag(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_pre_process_time(&self) -> f64 {
        CPUParticles2D_get_pre_process_time(self.this)
    }

    #[inline]
    pub unsafe fn get_randomness_ratio(&self) -> f64 {
        CPUParticles2D_get_randomness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        CPUParticles2D_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_spread(&self) -> f64 {
        CPUParticles2D_get_spread(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        CPUParticles2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_use_local_coordinates(&self) -> bool {
        CPUParticles2D_get_use_local_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn is_emitting(&self) -> bool {
        CPUParticles2D_is_emitting(self.this)
    }

    #[inline]
    pub unsafe fn restart(&mut self) -> () {
        CPUParticles2D_restart(self.this)
    }

    #[inline]
    pub unsafe fn set_amount(&mut self, amount: i64) -> () {
        CPUParticles2D_set_amount(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        CPUParticles2D_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_color_ramp(&mut self, ramp: Option<Gradient>) -> () {
        CPUParticles2D_set_color_ramp(self.this, ramp)
    }

    #[inline]
    pub unsafe fn set_direction(&mut self, direction: Vector2) -> () {
        CPUParticles2D_set_direction(self.this, direction)
    }

    #[inline]
    pub unsafe fn set_draw_order(&mut self, order: i64) -> () {
        CPUParticles2D_set_draw_order(self.this, order)
    }

    #[inline]
    pub unsafe fn set_emission_colors(&mut self, array: ColorArray) -> () {
        CPUParticles2D_set_emission_colors(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_normals(&mut self, array: Vector2Array) -> () {
        CPUParticles2D_set_emission_normals(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_points(&mut self, array: Vector2Array) -> () {
        CPUParticles2D_set_emission_points(self.this, array)
    }

    #[inline]
    pub unsafe fn set_emission_rect_extents(&mut self, extents: Vector2) -> () {
        CPUParticles2D_set_emission_rect_extents(self.this, extents)
    }

    #[inline]
    pub unsafe fn set_emission_shape(&mut self, shape: i64) -> () {
        CPUParticles2D_set_emission_shape(self.this, shape)
    }

    #[inline]
    pub unsafe fn set_emission_sphere_radius(&mut self, radius: f64) -> () {
        CPUParticles2D_set_emission_sphere_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_emitting(&mut self, emitting: bool) -> () {
        CPUParticles2D_set_emitting(self.this, emitting)
    }

    #[inline]
    pub unsafe fn set_explosiveness_ratio(&mut self, ratio: f64) -> () {
        CPUParticles2D_set_explosiveness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_fixed_fps(&mut self, fps: i64) -> () {
        CPUParticles2D_set_fixed_fps(self.this, fps)
    }

    #[inline]
    pub unsafe fn set_fractional_delta(&mut self, enable: bool) -> () {
        CPUParticles2D_set_fractional_delta(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_gravity(&mut self, accel_vec: Vector2) -> () {
        CPUParticles2D_set_gravity(self.this, accel_vec)
    }

    #[inline]
    pub unsafe fn set_lifetime(&mut self, secs: f64) -> () {
        CPUParticles2D_set_lifetime(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_lifetime_randomness(&mut self, random: f64) -> () {
        CPUParticles2D_set_lifetime_randomness(self.this, random)
    }

    #[inline]
    pub unsafe fn set_normalmap(&mut self, normalmap: Option<Texture>) -> () {
        CPUParticles2D_set_normalmap(self.this, normalmap)
    }

    #[inline]
    pub unsafe fn set_one_shot(&mut self, enable: bool) -> () {
        CPUParticles2D_set_one_shot(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        CPUParticles2D_set_param(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_param_curve(&mut self, param: i64, curve: Option<Curve>) -> () {
        CPUParticles2D_set_param_curve(self.this, param, curve)
    }

    #[inline]
    pub unsafe fn set_param_randomness(&mut self, param: i64, randomness: f64) -> () {
        CPUParticles2D_set_param_randomness(self.this, param, randomness)
    }

    #[inline]
    pub unsafe fn set_particle_flag(&mut self, flag: i64, enable: bool) -> () {
        CPUParticles2D_set_particle_flag(self.this, flag, enable)
    }

    #[inline]
    pub unsafe fn set_pre_process_time(&mut self, secs: f64) -> () {
        CPUParticles2D_set_pre_process_time(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_randomness_ratio(&mut self, ratio: f64) -> () {
        CPUParticles2D_set_randomness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, scale: f64) -> () {
        CPUParticles2D_set_speed_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_spread(&mut self, degrees: f64) -> () {
        CPUParticles2D_set_spread(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        CPUParticles2D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_use_local_coordinates(&mut self, enable: bool) -> () {
        CPUParticles2D_set_use_local_coordinates(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGBox` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgbox.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGBox` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGBox::free`.
///
/// ## Class hierarchy
///
/// CSGBox inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGBox {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGBox {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGBox::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGBoxMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGBox {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_depth(&self) -> f64 {
        CSGBox_get_depth(self.this)
    }

    #[inline]
    pub unsafe fn get_height(&self) -> f64 {
        CSGBox_get_height(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGBox_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_width(&self) -> f64 {
        CSGBox_get_width(self.this)
    }

    #[inline]
    pub unsafe fn set_depth(&mut self, depth: f64) -> () {
        CSGBox_set_depth(self.this, depth)
    }

    #[inline]
    pub unsafe fn set_height(&mut self, height: f64) -> () {
        CSGBox_set_height(self.this, height)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGBox_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_width(&mut self, width: f64) -> () {
        CSGBox_set_width(self.this, width)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGCombiner` inherits `CSGShape` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgcombiner.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGCombiner` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGCombiner::free`.
///
/// ## Class hierarchy
///
/// CSGCombiner inherits methods from:
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGCombiner {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGCombiner {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGCombiner::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGCombinerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGCombiner {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGCylinder` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgcylinder.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGCylinder` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGCylinder::free`.
///
/// ## Class hierarchy
///
/// CSGCylinder inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGCylinder {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGCylinder {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGCylinder::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGCylinderMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGCylinder {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_height(&self) -> f64 {
        CSGCylinder_get_height(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGCylinder_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_radius(&self) -> f64 {
        CSGCylinder_get_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_sides(&self) -> i64 {
        CSGCylinder_get_sides(self.this)
    }

    #[inline]
    pub unsafe fn get_smooth_faces(&self) -> bool {
        CSGCylinder_get_smooth_faces(self.this)
    }

    #[inline]
    pub unsafe fn is_cone(&self) -> bool {
        CSGCylinder_is_cone(self.this)
    }

    #[inline]
    pub unsafe fn set_cone(&mut self, cone: bool) -> () {
        CSGCylinder_set_cone(self.this, cone)
    }

    #[inline]
    pub unsafe fn set_height(&mut self, height: f64) -> () {
        CSGCylinder_set_height(self.this, height)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGCylinder_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_radius(&mut self, radius: f64) -> () {
        CSGCylinder_set_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_sides(&mut self, sides: i64) -> () {
        CSGCylinder_set_sides(self.this, sides)
    }

    #[inline]
    pub unsafe fn set_smooth_faces(&mut self, smooth_faces: bool) -> () {
        CSGCylinder_set_smooth_faces(self.this, smooth_faces)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGMesh` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgmesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGMesh` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGMesh::free`.
///
/// ## Class hierarchy
///
/// CSGMesh inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGMesh {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGMesh::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGMesh {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _mesh_changed(&mut self) -> () {
        CSGMesh__mesh_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGMesh_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&mut self) -> Option<Mesh> {
        CSGMesh_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGMesh_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        CSGMesh_set_mesh(self.this, mesh)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGPolygon` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgpolygon.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGPolygon` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGPolygon::free`.
///
/// ## Class hierarchy
///
/// CSGPolygon inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGPolygon {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CSGPolygonPathRotation {
    Polygon = 0,
    Path = 1,
    PathFollow = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CSGPolygonMode {
    ModeDepth = 0,
    ModeSpin = 1,
    ModePath = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CSGPolygon {
    pub const MODE_PATH: i64 = 2;
    pub const MODE_DEPTH: i64 = 0;
    pub const MODE_SPIN: i64 = 1;
    pub const PATH_ROTATION_PATH_FOLLOW: i64 = 2;
    pub const PATH_ROTATION_PATH: i64 = 1;
    pub const PATH_ROTATION_POLYGON: i64 = 0;
}
impl CSGPolygon {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGPolygon::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGPolygonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGPolygon {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _has_editable_3d_polygon_no_depth(&self) -> bool {
        CSGPolygon__has_editable_3d_polygon_no_depth(self.this)
    }

    #[inline]
    pub unsafe fn _is_editable_3d_polygon(&self) -> bool {
        CSGPolygon__is_editable_3d_polygon(self.this)
    }

    #[inline]
    pub unsafe fn _path_changed(&mut self) -> () {
        CSGPolygon__path_changed(self.this)
    }

    #[inline]
    pub unsafe fn _path_exited(&mut self) -> () {
        CSGPolygon__path_exited(self.this)
    }

    #[inline]
    pub unsafe fn get_depth(&self) -> f64 {
        CSGPolygon_get_depth(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGPolygon_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> CSGPolygonMode {
        CSGPolygon_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_path_interval(&self) -> f64 {
        CSGPolygon_get_path_interval(self.this)
    }

    #[inline]
    pub unsafe fn get_path_node(&self) -> NodePath {
        CSGPolygon_get_path_node(self.this)
    }

    #[inline]
    pub unsafe fn get_path_rotation(&self) -> CSGPolygonPathRotation {
        CSGPolygon_get_path_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_polygon(&self) -> Vector2Array {
        CSGPolygon_get_polygon(self.this)
    }

    #[inline]
    pub unsafe fn get_smooth_faces(&self) -> bool {
        CSGPolygon_get_smooth_faces(self.this)
    }

    #[inline]
    pub unsafe fn get_spin_degrees(&self) -> f64 {
        CSGPolygon_get_spin_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_spin_sides(&self) -> i64 {
        CSGPolygon_get_spin_sides(self.this)
    }

    #[inline]
    pub unsafe fn is_path_continuous_u(&self) -> bool {
        CSGPolygon_is_path_continuous_u(self.this)
    }

    #[inline]
    pub unsafe fn is_path_joined(&self) -> bool {
        CSGPolygon_is_path_joined(self.this)
    }

    #[inline]
    pub unsafe fn is_path_local(&self) -> bool {
        CSGPolygon_is_path_local(self.this)
    }

    #[inline]
    pub unsafe fn set_depth(&mut self, depth: f64) -> () {
        CSGPolygon_set_depth(self.this, depth)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGPolygon_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        CSGPolygon_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_path_continuous_u(&mut self, enable: bool) -> () {
        CSGPolygon_set_path_continuous_u(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_path_interval(&mut self, distance: f64) -> () {
        CSGPolygon_set_path_interval(self.this, distance)
    }

    #[inline]
    pub unsafe fn set_path_joined(&mut self, enable: bool) -> () {
        CSGPolygon_set_path_joined(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_path_local(&mut self, enable: bool) -> () {
        CSGPolygon_set_path_local(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_path_node(&mut self, path: NodePath) -> () {
        CSGPolygon_set_path_node(self.this, path)
    }

    #[inline]
    pub unsafe fn set_path_rotation(&mut self, mode: i64) -> () {
        CSGPolygon_set_path_rotation(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_polygon(&mut self, polygon: Vector2Array) -> () {
        CSGPolygon_set_polygon(self.this, polygon)
    }

    #[inline]
    pub unsafe fn set_smooth_faces(&mut self, smooth_faces: bool) -> () {
        CSGPolygon_set_smooth_faces(self.this, smooth_faces)
    }

    #[inline]
    pub unsafe fn set_spin_degrees(&mut self, degrees: f64) -> () {
        CSGPolygon_set_spin_degrees(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_spin_sides(&mut self, spin_sides: i64) -> () {
        CSGPolygon_set_spin_sides(self.this, spin_sides)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGPrimitive` inherits `CSGShape` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgprimitive.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CSGPrimitive inherits methods from:
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGPrimitive {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGPrimitive {
    #[inline]
    pub unsafe fn is_inverting_faces(&mut self) -> bool {
        CSGPrimitive_is_inverting_faces(self.this)
    }

    #[inline]
    pub unsafe fn set_invert_faces(&mut self, invert_faces: bool) -> () {
        CSGPrimitive_set_invert_faces(self.this, invert_faces)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGShape` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgshape.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CSGShape inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CSGShapeOperation {
    Union = 0,
    Intersection = 1,
    Subtraction = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CSGShape {
    pub const OPERATION_INTERSECTION: i64 = 1;
    pub const OPERATION_UNION: i64 = 0;
    pub const OPERATION_SUBTRACTION: i64 = 2;
}
impl CSGShape {
    #[inline]
    pub unsafe fn _update_shape(&mut self) -> () {
        CSGShape__update_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        CSGShape_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        CSGShape_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        CSGShape_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        CSGShape_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_meshes(&self) -> VariantArray {
        CSGShape_get_meshes(self.this)
    }

    #[inline]
    pub unsafe fn get_operation(&self) -> CSGShapeOperation {
        CSGShape_get_operation(self.this)
    }

    #[inline]
    pub unsafe fn get_snap(&self) -> f64 {
        CSGShape_get_snap(self.this)
    }

    #[inline]
    pub unsafe fn is_calculating_tangents(&self) -> bool {
        CSGShape_is_calculating_tangents(self.this)
    }

    #[inline]
    pub unsafe fn is_root_shape(&self) -> bool {
        CSGShape_is_root_shape(self.this)
    }

    #[inline]
    pub unsafe fn is_using_collision(&self) -> bool {
        CSGShape_is_using_collision(self.this)
    }

    #[inline]
    pub unsafe fn set_calculate_tangents(&mut self, enabled: bool) -> () {
        CSGShape_set_calculate_tangents(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, layer: i64) -> () {
        CSGShape_set_collision_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        CSGShape_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        CSGShape_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        CSGShape_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_operation(&mut self, operation: i64) -> () {
        CSGShape_set_operation(self.this, operation)
    }

    #[inline]
    pub unsafe fn set_snap(&mut self, snap: f64) -> () {
        CSGShape_set_snap(self.this, snap)
    }

    #[inline]
    pub unsafe fn set_use_collision(&mut self, operation: bool) -> () {
        CSGShape_set_use_collision(self.this, operation)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGSphere` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgsphere.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGSphere` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGSphere::free`.
///
/// ## Class hierarchy
///
/// CSGSphere inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGSphere {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGSphere {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGSphere::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGSphereMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGSphere {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGSphere_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_radial_segments(&self) -> i64 {
        CSGSphere_get_radial_segments(self.this)
    }

    #[inline]
    pub unsafe fn get_radius(&self) -> f64 {
        CSGSphere_get_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_rings(&self) -> i64 {
        CSGSphere_get_rings(self.this)
    }

    #[inline]
    pub unsafe fn get_smooth_faces(&self) -> bool {
        CSGSphere_get_smooth_faces(self.this)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGSphere_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_radial_segments(&mut self, radial_segments: i64) -> () {
        CSGSphere_set_radial_segments(self.this, radial_segments)
    }

    #[inline]
    pub unsafe fn set_radius(&mut self, radius: f64) -> () {
        CSGSphere_set_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_rings(&mut self, rings: i64) -> () {
        CSGSphere_set_rings(self.this, rings)
    }

    #[inline]
    pub unsafe fn set_smooth_faces(&mut self, smooth_faces: bool) -> () {
        CSGSphere_set_smooth_faces(self.this, smooth_faces)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CSGTorus` inherits `CSGPrimitive` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_csgtorus.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CSGTorus` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CSGTorus::free`.
///
/// ## Class hierarchy
///
/// CSGTorus inherits methods from:
/// - [CSGPrimitive](struct.CSGPrimitive.html)
/// - [CSGShape](struct.CSGShape.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CSGTorus {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CSGTorus {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CSGTorus::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CSGTorusMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CSGTorus {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_inner_radius(&self) -> f64 {
        CSGTorus_get_inner_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CSGTorus_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_outer_radius(&self) -> f64 {
        CSGTorus_get_outer_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_ring_sides(&self) -> i64 {
        CSGTorus_get_ring_sides(self.this)
    }

    #[inline]
    pub unsafe fn get_sides(&self) -> i64 {
        CSGTorus_get_sides(self.this)
    }

    #[inline]
    pub unsafe fn get_smooth_faces(&self) -> bool {
        CSGTorus_get_smooth_faces(self.this)
    }

    #[inline]
    pub unsafe fn set_inner_radius(&mut self, radius: f64) -> () {
        CSGTorus_set_inner_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CSGTorus_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_outer_radius(&mut self, radius: f64) -> () {
        CSGTorus_set_outer_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_ring_sides(&mut self, sides: i64) -> () {
        CSGTorus_set_ring_sides(self.this, sides)
    }

    #[inline]
    pub unsafe fn set_sides(&mut self, sides: i64) -> () {
        CSGTorus_set_sides(self.this, sides)
    }

    #[inline]
    pub unsafe fn set_smooth_faces(&mut self, smooth_faces: bool) -> () {
        CSGTorus_set_smooth_faces(self.this, smooth_faces)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_primitive(&self) -> CSGPrimitive {
        // Not reference-counted.
        CSGPrimitive { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_csg_shape(&self) -> CSGShape {
        // Not reference-counted.
        CSGShape { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Camera` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_camera.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Camera` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Camera::free`.
///
/// ## Class hierarchy
///
/// Camera inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Camera {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraKeepAspect {
    KeepWidth = 0,
    KeepHeight = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraProjection {
    Perspective = 0,
    Orthogonal = 1,
    Frustum = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraDopplerTracking {
    Disabled = 0,
    IdleStep = 1,
    PhysicsStep = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Camera {
    pub const KEEP_WIDTH: i64 = 0;
    pub const PROJECTION_ORTHOGONAL: i64 = 1;
    pub const DOPPLER_TRACKING_PHYSICS_STEP: i64 = 2;
    pub const DOPPLER_TRACKING_IDLE_STEP: i64 = 1;
    pub const PROJECTION_PERSPECTIVE: i64 = 0;
    pub const PROJECTION_FRUSTUM: i64 = 2;
    pub const KEEP_HEIGHT: i64 = 1;
    pub const DOPPLER_TRACKING_DISABLED: i64 = 0;
}
impl Camera {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Camera::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CameraMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Camera {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn clear_current(&mut self, enable_next: bool) -> () {
        Camera_clear_current(self.this, enable_next)
    }

    #[inline]
    pub unsafe fn get_camera_rid(&self) -> Rid {
        Camera_get_camera_rid(self.this)
    }

    #[inline]
    pub unsafe fn get_camera_transform(&self) -> Transform {
        Camera_get_camera_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_cull_mask(&self) -> i64 {
        Camera_get_cull_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_cull_mask_bit(&self, layer: i64) -> bool {
        Camera_get_cull_mask_bit(self.this, layer)
    }

    #[inline]
    pub unsafe fn get_doppler_tracking(&self) -> CameraDopplerTracking {
        Camera_get_doppler_tracking(self.this)
    }

    #[inline]
    pub unsafe fn get_environment(&self) -> Option<Environment> {
        Camera_get_environment(self.this)
    }

    #[inline]
    pub unsafe fn get_fov(&self) -> f64 {
        Camera_get_fov(self.this)
    }

    #[inline]
    pub unsafe fn get_frustum(&self) -> VariantArray {
        Camera_get_frustum(self.this)
    }

    #[inline]
    pub unsafe fn get_frustum_offset(&self) -> Vector2 {
        Camera_get_frustum_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_h_offset(&self) -> f64 {
        Camera_get_h_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_keep_aspect_mode(&self) -> CameraKeepAspect {
        Camera_get_keep_aspect_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_projection(&self) -> CameraProjection {
        Camera_get_projection(self.this)
    }

    #[inline]
    pub unsafe fn get_size(&self) -> f64 {
        Camera_get_size(self.this)
    }

    #[inline]
    pub unsafe fn get_v_offset(&self) -> f64 {
        Camera_get_v_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_zfar(&self) -> f64 {
        Camera_get_zfar(self.this)
    }

    #[inline]
    pub unsafe fn get_znear(&self) -> f64 {
        Camera_get_znear(self.this)
    }

    #[inline]
    pub unsafe fn is_current(&self) -> bool {
        Camera_is_current(self.this)
    }

    #[inline]
    pub unsafe fn is_position_behind(&self, world_point: Vector3) -> bool {
        Camera_is_position_behind(self.this, world_point)
    }

    #[inline]
    pub unsafe fn make_current(&mut self) -> () {
        Camera_make_current(self.this)
    }

    #[inline]
    pub unsafe fn project_local_ray_normal(&self, screen_point: Vector2) -> Vector3 {
        Camera_project_local_ray_normal(self.this, screen_point)
    }

    #[inline]
    pub unsafe fn project_position(&self, screen_point: Vector2, z_depth: f64) -> Vector3 {
        Camera_project_position(self.this, screen_point, z_depth)
    }

    #[inline]
    pub unsafe fn project_ray_normal(&self, screen_point: Vector2) -> Vector3 {
        Camera_project_ray_normal(self.this, screen_point)
    }

    #[inline]
    pub unsafe fn project_ray_origin(&self, screen_point: Vector2) -> Vector3 {
        Camera_project_ray_origin(self.this, screen_point)
    }

    #[inline]
    pub unsafe fn set_cull_mask(&mut self, mask: i64) -> () {
        Camera_set_cull_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_cull_mask_bit(&mut self, layer: i64, enable: bool) -> () {
        Camera_set_cull_mask_bit(self.this, layer, enable)
    }

    #[inline]
    pub unsafe fn set_current(&mut self, arg0: bool) -> () {
        Camera_set_current(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_doppler_tracking(&mut self, mode: i64) -> () {
        Camera_set_doppler_tracking(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_environment(&mut self, env: Option<Environment>) -> () {
        Camera_set_environment(self.this, env)
    }

    #[inline]
    pub unsafe fn set_fov(&mut self, arg0: f64) -> () {
        Camera_set_fov(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_frustum(&mut self, size: f64, offset: Vector2, z_near: f64, z_far: f64) -> () {
        Camera_set_frustum(self.this, size, offset, z_near, z_far)
    }

    #[inline]
    pub unsafe fn set_frustum_offset(&mut self, arg0: Vector2) -> () {
        Camera_set_frustum_offset(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_h_offset(&mut self, ofs: f64) -> () {
        Camera_set_h_offset(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_keep_aspect_mode(&mut self, mode: i64) -> () {
        Camera_set_keep_aspect_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_orthogonal(&mut self, size: f64, z_near: f64, z_far: f64) -> () {
        Camera_set_orthogonal(self.this, size, z_near, z_far)
    }

    #[inline]
    pub unsafe fn set_perspective(&mut self, fov: f64, z_near: f64, z_far: f64) -> () {
        Camera_set_perspective(self.this, fov, z_near, z_far)
    }

    #[inline]
    pub unsafe fn set_projection(&mut self, arg0: i64) -> () {
        Camera_set_projection(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_size(&mut self, arg0: f64) -> () {
        Camera_set_size(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_v_offset(&mut self, ofs: f64) -> () {
        Camera_set_v_offset(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_zfar(&mut self, arg0: f64) -> () {
        Camera_set_zfar(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_znear(&mut self, arg0: f64) -> () {
        Camera_set_znear(self.this, arg0)
    }

    #[inline]
    pub unsafe fn unproject_position(&self, world_point: Vector3) -> Vector2 {
        Camera_unproject_position(self.this, world_point)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Camera2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_camera2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Camera2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Camera2D::free`.
///
/// ## Class hierarchy
///
/// Camera2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Camera2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Camera2DCamera2DProcessMode {
    Physics = 0,
    Idle = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Camera2DAnchorMode {
    ModeFixedTopLeft = 0,
    ModeDragCenter = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Camera2D {
    pub const CAMERA2D_PROCESS_PHYSICS: i64 = 0;
    pub const ANCHOR_MODE_FIXED_TOP_LEFT: i64 = 0;
    pub const CAMERA2D_PROCESS_IDLE: i64 = 1;
    pub const ANCHOR_MODE_DRAG_CENTER: i64 = 1;
}
impl Camera2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Camera2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Camera2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Camera2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _make_current(&mut self, arg0: Option<Object>) -> () {
        Camera2D__make_current(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _set_current(&mut self, current: bool) -> () {
        Camera2D__set_current(self.this, current)
    }

    #[inline]
    pub unsafe fn _set_old_smoothing(&mut self, follow_smoothing: f64) -> () {
        Camera2D__set_old_smoothing(self.this, follow_smoothing)
    }

    #[inline]
    pub unsafe fn _update_scroll(&mut self) -> () {
        Camera2D__update_scroll(self.this)
    }

    #[inline]
    pub unsafe fn align(&mut self) -> () {
        Camera2D_align(self.this)
    }

    #[inline]
    pub unsafe fn clear_current(&mut self) -> () {
        Camera2D_clear_current(self.this)
    }

    #[inline]
    pub unsafe fn force_update_scroll(&mut self) -> () {
        Camera2D_force_update_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_anchor_mode(&self) -> Camera2DAnchorMode {
        Camera2D_get_anchor_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_camera_position(&self) -> Vector2 {
        Camera2D_get_camera_position(self.this)
    }

    #[inline]
    pub unsafe fn get_camera_screen_center(&self) -> Vector2 {
        Camera2D_get_camera_screen_center(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_viewport(&self) -> Option<Node> {
        Camera2D_get_custom_viewport(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_margin(&self, margin: i64) -> f64 {
        Camera2D_get_drag_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_follow_smoothing(&self) -> f64 {
        Camera2D_get_follow_smoothing(self.this)
    }

    #[inline]
    pub unsafe fn get_h_offset(&self) -> f64 {
        Camera2D_get_h_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_limit(&self, margin: i64) -> i64 {
        Camera2D_get_limit(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        Camera2D_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_process_mode(&self) -> Camera2DCamera2DProcessMode {
        Camera2D_get_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_v_offset(&self) -> f64 {
        Camera2D_get_v_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_zoom(&self) -> Vector2 {
        Camera2D_get_zoom(self.this)
    }

    #[inline]
    pub unsafe fn is_current(&self) -> bool {
        Camera2D_is_current(self.this)
    }

    #[inline]
    pub unsafe fn is_follow_smoothing_enabled(&self) -> bool {
        Camera2D_is_follow_smoothing_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_h_drag_enabled(&self) -> bool {
        Camera2D_is_h_drag_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_limit_drawing_enabled(&self) -> bool {
        Camera2D_is_limit_drawing_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_limit_smoothing_enabled(&self) -> bool {
        Camera2D_is_limit_smoothing_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_margin_drawing_enabled(&self) -> bool {
        Camera2D_is_margin_drawing_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_rotating(&self) -> bool {
        Camera2D_is_rotating(self.this)
    }

    #[inline]
    pub unsafe fn is_screen_drawing_enabled(&self) -> bool {
        Camera2D_is_screen_drawing_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_v_drag_enabled(&self) -> bool {
        Camera2D_is_v_drag_enabled(self.this)
    }

    #[inline]
    pub unsafe fn make_current(&mut self) -> () {
        Camera2D_make_current(self.this)
    }

    #[inline]
    pub unsafe fn reset_smoothing(&mut self) -> () {
        Camera2D_reset_smoothing(self.this)
    }

    #[inline]
    pub unsafe fn set_anchor_mode(&mut self, anchor_mode: i64) -> () {
        Camera2D_set_anchor_mode(self.this, anchor_mode)
    }

    #[inline]
    pub unsafe fn set_custom_viewport(&mut self, viewport: Option<Node>) -> () {
        Camera2D_set_custom_viewport(self.this, viewport)
    }

    #[inline]
    pub unsafe fn set_drag_margin(&mut self, margin: i64, drag_margin: f64) -> () {
        Camera2D_set_drag_margin(self.this, margin, drag_margin)
    }

    #[inline]
    pub unsafe fn set_enable_follow_smoothing(&mut self, follow_smoothing: bool) -> () {
        Camera2D_set_enable_follow_smoothing(self.this, follow_smoothing)
    }

    #[inline]
    pub unsafe fn set_follow_smoothing(&mut self, follow_smoothing: f64) -> () {
        Camera2D_set_follow_smoothing(self.this, follow_smoothing)
    }

    #[inline]
    pub unsafe fn set_h_drag_enabled(&mut self, enabled: bool) -> () {
        Camera2D_set_h_drag_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_h_offset(&mut self, ofs: f64) -> () {
        Camera2D_set_h_offset(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_limit(&mut self, margin: i64, limit: i64) -> () {
        Camera2D_set_limit(self.this, margin, limit)
    }

    #[inline]
    pub unsafe fn set_limit_drawing_enabled(&mut self, limit_drawing_enabled: bool) -> () {
        Camera2D_set_limit_drawing_enabled(self.this, limit_drawing_enabled)
    }

    #[inline]
    pub unsafe fn set_limit_smoothing_enabled(&mut self, limit_smoothing_enabled: bool) -> () {
        Camera2D_set_limit_smoothing_enabled(self.this, limit_smoothing_enabled)
    }

    #[inline]
    pub unsafe fn set_margin_drawing_enabled(&mut self, margin_drawing_enabled: bool) -> () {
        Camera2D_set_margin_drawing_enabled(self.this, margin_drawing_enabled)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        Camera2D_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_process_mode(&mut self, mode: i64) -> () {
        Camera2D_set_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_rotating(&mut self, rotating: bool) -> () {
        Camera2D_set_rotating(self.this, rotating)
    }

    #[inline]
    pub unsafe fn set_screen_drawing_enabled(&mut self, screen_drawing_enabled: bool) -> () {
        Camera2D_set_screen_drawing_enabled(self.this, screen_drawing_enabled)
    }

    #[inline]
    pub unsafe fn set_v_drag_enabled(&mut self, enabled: bool) -> () {
        Camera2D_set_v_drag_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_v_offset(&mut self, ofs: f64) -> () {
        Camera2D_set_v_offset(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_zoom(&mut self, zoom: Vector2) -> () {
        Camera2D_set_zoom(self.this, zoom)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CameraFeed` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_camerafeed.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CameraFeed inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CameraFeed {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraFeedFeedDataType {
    FeedNoimage = 0,
    FeedRgb = 1,
    FeedYcbcr = 2,
    FeedYcbcrSep = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraFeedFeedPosition {
    FeedUnspecified = 0,
    FeedFront = 1,
    FeedBack = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CameraFeed {
    pub const FEED_YCBCR: i64 = 2;
    pub const FEED_YCBCR_SEP: i64 = 3;
    pub const FEED_BACK: i64 = 2;
    pub const FEED_FRONT: i64 = 1;
    pub const FEED_RGB: i64 = 1;
    pub const FEED_NOIMAGE: i64 = 0;
    pub const FEED_UNSPECIFIED: i64 = 0;
}
impl CameraFeed {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CameraFeedMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CameraFeed {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _allocate_texture(&mut self, width: i64, height: i64, format: i64, texture_type: i64, data_type: i64) -> () {
        unsafe { CameraFeed__allocate_texture(self.this, width, height, format, texture_type, data_type) }
    }

    #[inline]
    pub fn _set_RGB_img(&mut self, rgb_img: Option<Image>) -> () {
        unsafe { CameraFeed__set_RGB_img(self.this, rgb_img) }
    }

    #[inline]
    pub fn _set_YCbCr_img(&mut self, ycbcr_img: Option<Image>) -> () {
        unsafe { CameraFeed__set_YCbCr_img(self.this, ycbcr_img) }
    }

    #[inline]
    pub fn _set_YCbCr_imgs(&mut self, y_img: Option<Image>, cbcr_img: Option<Image>) -> () {
        unsafe { CameraFeed__set_YCbCr_imgs(self.this, y_img, cbcr_img) }
    }

    #[inline]
    pub fn _set_name(&mut self, name: GodotString) -> () {
        unsafe { CameraFeed__set_name(self.this, name) }
    }

    #[inline]
    pub fn _set_position(&mut self, position: i64) -> () {
        unsafe { CameraFeed__set_position(self.this, position) }
    }

    #[inline]
    pub fn get_id(&self) -> i64 {
        unsafe { CameraFeed_get_id(self.this) }
    }

    #[inline]
    pub fn get_name(&self) -> GodotString {
        unsafe { CameraFeed_get_name(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> CameraFeedFeedPosition {
        unsafe { CameraFeed_get_position(self.this) }
    }

    #[inline]
    pub fn get_transform(&self) -> Transform2D {
        unsafe { CameraFeed_get_transform(self.this) }
    }

    #[inline]
    pub fn is_active(&self) -> bool {
        unsafe { CameraFeed_is_active(self.this) }
    }

    #[inline]
    pub fn set_active(&mut self, active: bool) -> () {
        unsafe { CameraFeed_set_active(self.this, active) }
    }

    #[inline]
    pub fn set_transform(&mut self, transform: Transform2D) -> () {
        unsafe { CameraFeed_set_transform(self.this, transform) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class CameraServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cameraserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CameraServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CameraServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CameraServerFeedImage {
    FeedRgbaImage = 0,
    FeedCbcrImage = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CameraServer {
    pub const FEED_RGBA_IMAGE: i64 = 0;
    pub const FEED_CBCR_IMAGE: i64 = 1;
    pub const FEED_Y_IMAGE: i64 = 0;
    pub const FEED_YCBCR_IMAGE: i64 = 0;
}
impl CameraServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"CameraServer\0".as_ptr() as *mut _);

            CameraServer {
                this
            }
        }
    }
    #[inline]
    pub fn add_feed(&mut self, feed: Option<CameraFeed>) -> () {
        unsafe { CameraServer_add_feed(self.this, feed) }
    }

    #[inline]
    pub fn feeds(&mut self) -> VariantArray {
        unsafe { CameraServer_feeds(self.this) }
    }

    #[inline]
    pub fn get_feed(&mut self, index: i64) -> Option<CameraFeed> {
        unsafe { CameraServer_get_feed(self.this, index) }
    }

    #[inline]
    pub fn get_feed_count(&mut self) -> i64 {
        unsafe { CameraServer_get_feed_count(self.this) }
    }

    #[inline]
    pub fn remove_feed(&mut self, feed: Option<CameraFeed>) -> () {
        unsafe { CameraServer_remove_feed(self.this, feed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CameraTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cameratexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CameraTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CameraTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CameraTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CameraTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CameraTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_camera_active(&self) -> bool {
        unsafe { CameraTexture_get_camera_active(self.this) }
    }

    #[inline]
    pub fn get_camera_feed_id(&self) -> i64 {
        unsafe { CameraTexture_get_camera_feed_id(self.this) }
    }

    #[inline]
    pub fn get_which_feed(&self) -> CameraServerFeedImage {
        unsafe { CameraTexture_get_which_feed(self.this) }
    }

    #[inline]
    pub fn set_camera_active(&mut self, active: bool) -> () {
        unsafe { CameraTexture_set_camera_active(self.this, active) }
    }

    #[inline]
    pub fn set_camera_feed_id(&mut self, feed_id: i64) -> () {
        unsafe { CameraTexture_set_camera_feed_id(self.this, feed_id) }
    }

    #[inline]
    pub fn set_which_feed(&mut self, which_feed: i64) -> () {
        unsafe { CameraTexture_set_which_feed(self.this, which_feed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CanvasItem` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_canvasitem.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CanvasItem inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CanvasItem {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CanvasItemBlendMode {
    ModeMix = 0,
    ModeAdd = 1,
    ModeSub = 2,
    ModeMul = 3,
    ModePremultAlpha = 4,
    ModeDisabled = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CanvasItem {
    pub const BLEND_MODE_ADD: i64 = 1;
    pub const NOTIFICATION_EXIT_CANVAS: i64 = 33;
    pub const BLEND_MODE_DISABLED: i64 = 5;
    pub const NOTIFICATION_VISIBILITY_CHANGED: i64 = 31;
    pub const NOTIFICATION_DRAW: i64 = 30;
    pub const BLEND_MODE_MIX: i64 = 0;
    pub const BLEND_MODE_PREMULT_ALPHA: i64 = 4;
    pub const BLEND_MODE_SUB: i64 = 2;
    pub const NOTIFICATION_ENTER_CANVAS: i64 = 32;
    pub const NOTIFICATION_TRANSFORM_CHANGED: i64 = 2000;
    pub const BLEND_MODE_MUL: i64 = 3;
}
impl CanvasItem {
    #[inline]
    pub unsafe fn _draw(&mut self) -> () {
        CanvasItem__draw(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_pivot(&self) -> Vector2 {
        CanvasItem__edit_get_pivot(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_position(&self) -> Vector2 {
        CanvasItem__edit_get_position(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_rect(&self) -> Rect2 {
        CanvasItem__edit_get_rect(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_rotation(&self) -> f64 {
        CanvasItem__edit_get_rotation(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_scale(&self) -> Vector2 {
        CanvasItem__edit_get_scale(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_state(&self) -> Dictionary {
        CanvasItem__edit_get_state(self.this)
    }

    #[inline]
    pub unsafe fn _edit_get_transform(&self) -> Transform2D {
        CanvasItem__edit_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn _edit_set_pivot(&mut self, pivot: Vector2) -> () {
        CanvasItem__edit_set_pivot(self.this, pivot)
    }

    #[inline]
    pub unsafe fn _edit_set_position(&mut self, position: Vector2) -> () {
        CanvasItem__edit_set_position(self.this, position)
    }

    #[inline]
    pub unsafe fn _edit_set_rect(&mut self, rect: Rect2) -> () {
        CanvasItem__edit_set_rect(self.this, rect)
    }

    #[inline]
    pub unsafe fn _edit_set_rotation(&mut self, degrees: f64) -> () {
        CanvasItem__edit_set_rotation(self.this, degrees)
    }

    #[inline]
    pub unsafe fn _edit_set_scale(&mut self, scale: Vector2) -> () {
        CanvasItem__edit_set_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn _edit_set_state(&mut self, state: Dictionary) -> () {
        CanvasItem__edit_set_state(self.this, state)
    }

    #[inline]
    pub unsafe fn _edit_use_pivot(&self) -> bool {
        CanvasItem__edit_use_pivot(self.this)
    }

    #[inline]
    pub unsafe fn _edit_use_rect(&self) -> bool {
        CanvasItem__edit_use_rect(self.this)
    }

    #[inline]
    pub unsafe fn _edit_use_rotation(&self) -> bool {
        CanvasItem__edit_use_rotation(self.this)
    }

    #[inline]
    pub unsafe fn _is_on_top(&self) -> bool {
        CanvasItem__is_on_top(self.this)
    }

    #[inline]
    pub unsafe fn _set_on_top(&mut self, on_top: bool) -> () {
        CanvasItem__set_on_top(self.this, on_top)
    }

    #[inline]
    pub unsafe fn _toplevel_raise_self(&mut self) -> () {
        CanvasItem__toplevel_raise_self(self.this)
    }

    #[inline]
    pub unsafe fn _update_callback(&mut self) -> () {
        CanvasItem__update_callback(self.this)
    }

    #[inline]
    pub unsafe fn draw_arc(&mut self, center: Vector2, radius: f64, start_angle: f64, end_angle: f64, point_count: i64, color: Color, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_arc(self.this, center, radius, start_angle, end_angle, point_count, color, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_char(&mut self, font: Option<Font>, position: Vector2, char: GodotString, next: GodotString, modulate: Color) -> f64 {
        CanvasItem_draw_char(self.this, font, position, char, next, modulate)
    }

    #[inline]
    pub unsafe fn draw_circle(&mut self, position: Vector2, radius: f64, color: Color) -> () {
        CanvasItem_draw_circle(self.this, position, radius, color)
    }

    #[inline]
    pub unsafe fn draw_colored_polygon(&mut self, points: Vector2Array, color: Color, uvs: Vector2Array, texture: Option<Texture>, normal_map: Option<Texture>, antialiased: bool) -> () {
        CanvasItem_draw_colored_polygon(self.this, points, color, uvs, texture, normal_map, antialiased)
    }

    #[inline]
    pub unsafe fn draw_line(&mut self, from: Vector2, to: Vector2, color: Color, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_line(self.this, from, to, color, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_mesh(&mut self, mesh: Option<Mesh>, texture: Option<Texture>, normal_map: Option<Texture>, transform: Transform2D, modulate: Color) -> () {
        CanvasItem_draw_mesh(self.this, mesh, texture, normal_map, transform, modulate)
    }

    #[inline]
    pub unsafe fn draw_multiline(&mut self, points: Vector2Array, color: Color, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_multiline(self.this, points, color, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_multiline_colors(&mut self, points: Vector2Array, colors: ColorArray, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_multiline_colors(self.this, points, colors, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_multimesh(&mut self, multimesh: Option<MultiMesh>, texture: Option<Texture>, normal_map: Option<Texture>) -> () {
        CanvasItem_draw_multimesh(self.this, multimesh, texture, normal_map)
    }

    #[inline]
    pub unsafe fn draw_polygon(&mut self, points: Vector2Array, colors: ColorArray, uvs: Vector2Array, texture: Option<Texture>, normal_map: Option<Texture>, antialiased: bool) -> () {
        CanvasItem_draw_polygon(self.this, points, colors, uvs, texture, normal_map, antialiased)
    }

    #[inline]
    pub unsafe fn draw_polyline(&mut self, points: Vector2Array, color: Color, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_polyline(self.this, points, color, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_polyline_colors(&mut self, points: Vector2Array, colors: ColorArray, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_polyline_colors(self.this, points, colors, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_primitive(&mut self, points: Vector2Array, colors: ColorArray, uvs: Vector2Array, texture: Option<Texture>, width: f64, normal_map: Option<Texture>) -> () {
        CanvasItem_draw_primitive(self.this, points, colors, uvs, texture, width, normal_map)
    }

    #[inline]
    pub unsafe fn draw_rect(&mut self, rect: Rect2, color: Color, filled: bool, width: f64, antialiased: bool) -> () {
        CanvasItem_draw_rect(self.this, rect, color, filled, width, antialiased)
    }

    #[inline]
    pub unsafe fn draw_set_transform(&mut self, position: Vector2, rotation: f64, scale: Vector2) -> () {
        CanvasItem_draw_set_transform(self.this, position, rotation, scale)
    }

    #[inline]
    pub unsafe fn draw_set_transform_matrix(&mut self, xform: Transform2D) -> () {
        CanvasItem_draw_set_transform_matrix(self.this, xform)
    }

    #[inline]
    pub unsafe fn draw_string(&mut self, font: Option<Font>, position: Vector2, text: GodotString, modulate: Color, clip_w: i64) -> () {
        CanvasItem_draw_string(self.this, font, position, text, modulate, clip_w)
    }

    #[inline]
    pub unsafe fn draw_style_box(&mut self, style_box: Option<StyleBox>, rect: Rect2) -> () {
        CanvasItem_draw_style_box(self.this, style_box, rect)
    }

    #[inline]
    pub unsafe fn draw_texture(&mut self, texture: Option<Texture>, position: Vector2, modulate: Color, normal_map: Option<Texture>) -> () {
        CanvasItem_draw_texture(self.this, texture, position, modulate, normal_map)
    }

    #[inline]
    pub unsafe fn draw_texture_rect(&mut self, texture: Option<Texture>, rect: Rect2, tile: bool, modulate: Color, transpose: bool, normal_map: Option<Texture>) -> () {
        CanvasItem_draw_texture_rect(self.this, texture, rect, tile, modulate, transpose, normal_map)
    }

    #[inline]
    pub unsafe fn draw_texture_rect_region(&mut self, texture: Option<Texture>, rect: Rect2, src_rect: Rect2, modulate: Color, transpose: bool, normal_map: Option<Texture>, clip_uv: bool) -> () {
        CanvasItem_draw_texture_rect_region(self.this, texture, rect, src_rect, modulate, transpose, normal_map, clip_uv)
    }

    #[inline]
    pub unsafe fn force_update_transform(&mut self) -> () {
        CanvasItem_force_update_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_canvas(&self) -> Rid {
        CanvasItem_get_canvas(self.this)
    }

    #[inline]
    pub unsafe fn get_canvas_item(&self) -> Rid {
        CanvasItem_get_canvas_item(self.this)
    }

    #[inline]
    pub unsafe fn get_canvas_transform(&self) -> Transform2D {
        CanvasItem_get_canvas_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_global_mouse_position(&self) -> Vector2 {
        CanvasItem_get_global_mouse_position(self.this)
    }

    #[inline]
    pub unsafe fn get_global_transform(&self) -> Transform2D {
        CanvasItem_get_global_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_global_transform_with_canvas(&self) -> Transform2D {
        CanvasItem_get_global_transform_with_canvas(self.this)
    }

    #[inline]
    pub unsafe fn get_light_mask(&self) -> i64 {
        CanvasItem_get_light_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_local_mouse_position(&self) -> Vector2 {
        CanvasItem_get_local_mouse_position(self.this)
    }

    #[inline]
    pub unsafe fn get_material(&self) -> Option<Material> {
        CanvasItem_get_material(self.this)
    }

    #[inline]
    pub unsafe fn get_modulate(&self) -> Color {
        CanvasItem_get_modulate(self.this)
    }

    #[inline]
    pub unsafe fn get_self_modulate(&self) -> Color {
        CanvasItem_get_self_modulate(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self) -> Transform2D {
        CanvasItem_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_use_parent_material(&self) -> bool {
        CanvasItem_get_use_parent_material(self.this)
    }

    #[inline]
    pub unsafe fn get_viewport_rect(&self) -> Rect2 {
        CanvasItem_get_viewport_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_viewport_transform(&self) -> Transform2D {
        CanvasItem_get_viewport_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_world_2d(&self) -> Option<World2D> {
        CanvasItem_get_world_2d(self.this)
    }

    #[inline]
    pub unsafe fn hide(&mut self) -> () {
        CanvasItem_hide(self.this)
    }

    #[inline]
    pub unsafe fn is_draw_behind_parent_enabled(&self) -> bool {
        CanvasItem_is_draw_behind_parent_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_local_transform_notification_enabled(&self) -> bool {
        CanvasItem_is_local_transform_notification_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_set_as_toplevel(&self) -> bool {
        CanvasItem_is_set_as_toplevel(self.this)
    }

    #[inline]
    pub unsafe fn is_transform_notification_enabled(&self) -> bool {
        CanvasItem_is_transform_notification_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_visible(&self) -> bool {
        CanvasItem_is_visible(self.this)
    }

    #[inline]
    pub unsafe fn is_visible_in_tree(&self) -> bool {
        CanvasItem_is_visible_in_tree(self.this)
    }

    #[inline]
    pub unsafe fn make_canvas_position_local(&self, screen_point: Vector2) -> Vector2 {
        CanvasItem_make_canvas_position_local(self.this, screen_point)
    }

    #[inline]
    pub unsafe fn make_input_local(&self, event: Option<InputEvent>) -> Option<InputEvent> {
        CanvasItem_make_input_local(self.this, event)
    }

    #[inline]
    pub unsafe fn set_as_toplevel(&mut self, enable: bool) -> () {
        CanvasItem_set_as_toplevel(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_draw_behind_parent(&mut self, enable: bool) -> () {
        CanvasItem_set_draw_behind_parent(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_light_mask(&mut self, light_mask: i64) -> () {
        CanvasItem_set_light_mask(self.this, light_mask)
    }

    #[inline]
    pub unsafe fn set_material(&mut self, material: Option<Material>) -> () {
        CanvasItem_set_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_modulate(&mut self, modulate: Color) -> () {
        CanvasItem_set_modulate(self.this, modulate)
    }

    #[inline]
    pub unsafe fn set_notify_local_transform(&mut self, enable: bool) -> () {
        CanvasItem_set_notify_local_transform(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_notify_transform(&mut self, enable: bool) -> () {
        CanvasItem_set_notify_transform(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_self_modulate(&mut self, self_modulate: Color) -> () {
        CanvasItem_set_self_modulate(self.this, self_modulate)
    }

    #[inline]
    pub unsafe fn set_use_parent_material(&mut self, enable: bool) -> () {
        CanvasItem_set_use_parent_material(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_visible(&mut self, visible: bool) -> () {
        CanvasItem_set_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn show(&mut self) -> () {
        CanvasItem_show(self.this)
    }

    #[inline]
    pub unsafe fn update(&mut self) -> () {
        CanvasItem_update(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CanvasItemMaterial` inherits `Material` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_canvasitemmaterial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CanvasItemMaterial inherits methods from:
/// - [Material](struct.Material.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CanvasItemMaterial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CanvasItemMaterialLightMode {
    ModeNormal = 0,
    ModeUnshaded = 1,
    ModeLightOnly = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CanvasItemMaterialBlendMode {
    ModeMix = 0,
    ModeAdd = 1,
    ModeSub = 2,
    ModeMul = 3,
    ModePremultAlpha = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CanvasItemMaterial {
    pub const LIGHT_MODE_LIGHT_ONLY: i64 = 2;
    pub const BLEND_MODE_ADD: i64 = 1;
    pub const BLEND_MODE_MUL: i64 = 3;
    pub const LIGHT_MODE_UNSHADED: i64 = 1;
    pub const LIGHT_MODE_NORMAL: i64 = 0;
    pub const BLEND_MODE_SUB: i64 = 2;
    pub const BLEND_MODE_MIX: i64 = 0;
    pub const BLEND_MODE_PREMULT_ALPHA: i64 = 4;
}
impl CanvasItemMaterial {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CanvasItemMaterialMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CanvasItemMaterial {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_blend_mode(&self) -> CanvasItemMaterialBlendMode {
        unsafe { CanvasItemMaterial_get_blend_mode(self.this) }
    }

    #[inline]
    pub fn get_light_mode(&self) -> CanvasItemMaterialLightMode {
        unsafe { CanvasItemMaterial_get_light_mode(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_h_frames(&self) -> i64 {
        unsafe { CanvasItemMaterial_get_particles_anim_h_frames(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_loop(&self) -> bool {
        unsafe { CanvasItemMaterial_get_particles_anim_loop(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_v_frames(&self) -> i64 {
        unsafe { CanvasItemMaterial_get_particles_anim_v_frames(self.this) }
    }

    #[inline]
    pub fn get_particles_animation(&self) -> bool {
        unsafe { CanvasItemMaterial_get_particles_animation(self.this) }
    }

    #[inline]
    pub fn set_blend_mode(&mut self, blend_mode: i64) -> () {
        unsafe { CanvasItemMaterial_set_blend_mode(self.this, blend_mode) }
    }

    #[inline]
    pub fn set_light_mode(&mut self, light_mode: i64) -> () {
        unsafe { CanvasItemMaterial_set_light_mode(self.this, light_mode) }
    }

    #[inline]
    pub fn set_particles_anim_h_frames(&mut self, frames: i64) -> () {
        unsafe { CanvasItemMaterial_set_particles_anim_h_frames(self.this, frames) }
    }

    #[inline]
    pub fn set_particles_anim_loop(&mut self, _loop: bool) -> () {
        unsafe { CanvasItemMaterial_set_particles_anim_loop(self.this, _loop) }
    }

    #[inline]
    pub fn set_particles_anim_v_frames(&mut self, frames: i64) -> () {
        unsafe { CanvasItemMaterial_set_particles_anim_v_frames(self.this, frames) }
    }

    #[inline]
    pub fn set_particles_animation(&mut self, particles_anim: bool) -> () {
        unsafe { CanvasItemMaterial_set_particles_animation(self.this, particles_anim) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_material(&self) -> Material {
        unsafe {{ object::add_ref(self.this); }}
        Material { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CanvasLayer` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_canvaslayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CanvasLayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CanvasLayer::free`.
///
/// ## Class hierarchy
///
/// CanvasLayer inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CanvasLayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CanvasLayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CanvasLayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CanvasLayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CanvasLayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_canvas(&self) -> Rid {
        CanvasLayer_get_canvas(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_viewport(&self) -> Option<Node> {
        CanvasLayer_get_custom_viewport(self.this)
    }

    #[inline]
    pub unsafe fn get_follow_viewport_scale(&self) -> f64 {
        CanvasLayer_get_follow_viewport_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_layer(&self) -> i64 {
        CanvasLayer_get_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        CanvasLayer_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation(&self) -> f64 {
        CanvasLayer_get_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation_degrees(&self) -> f64 {
        CanvasLayer_get_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_scale(&self) -> Vector2 {
        CanvasLayer_get_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self) -> Transform2D {
        CanvasLayer_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn is_following_viewport(&self) -> bool {
        CanvasLayer_is_following_viewport(self.this)
    }

    #[inline]
    pub unsafe fn set_custom_viewport(&mut self, viewport: Option<Node>) -> () {
        CanvasLayer_set_custom_viewport(self.this, viewport)
    }

    #[inline]
    pub unsafe fn set_follow_viewport(&mut self, enable: bool) -> () {
        CanvasLayer_set_follow_viewport(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_follow_viewport_scale(&mut self, scale: f64) -> () {
        CanvasLayer_set_follow_viewport_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_layer(&mut self, layer: i64) -> () {
        CanvasLayer_set_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        CanvasLayer_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_rotation(&mut self, radians: f64) -> () {
        CanvasLayer_set_rotation(self.this, radians)
    }

    #[inline]
    pub unsafe fn set_rotation_degrees(&mut self, degrees: f64) -> () {
        CanvasLayer_set_rotation_degrees(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_scale(&mut self, scale: Vector2) -> () {
        CanvasLayer_set_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_transform(&mut self, transform: Transform2D) -> () {
        CanvasLayer_set_transform(self.this, transform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CanvasModulate` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_canvasmodulate.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CanvasModulate` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CanvasModulate::free`.
///
/// ## Class hierarchy
///
/// CanvasModulate inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CanvasModulate {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CanvasModulate {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CanvasModulate::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CanvasModulateMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CanvasModulate {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        CanvasModulate_get_color(self.this)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        CanvasModulate_set_color(self.this, color)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CapsuleMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_capsulemesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CapsuleMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CapsuleMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CapsuleMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CapsuleMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CapsuleMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_mid_height(&self) -> f64 {
        unsafe { CapsuleMesh_get_mid_height(self.this) }
    }

    #[inline]
    pub fn get_radial_segments(&self) -> i64 {
        unsafe { CapsuleMesh_get_radial_segments(self.this) }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { CapsuleMesh_get_radius(self.this) }
    }

    #[inline]
    pub fn get_rings(&self) -> i64 {
        unsafe { CapsuleMesh_get_rings(self.this) }
    }

    #[inline]
    pub fn set_mid_height(&mut self, mid_height: f64) -> () {
        unsafe { CapsuleMesh_set_mid_height(self.this, mid_height) }
    }

    #[inline]
    pub fn set_radial_segments(&mut self, segments: i64) -> () {
        unsafe { CapsuleMesh_set_radial_segments(self.this, segments) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { CapsuleMesh_set_radius(self.this, radius) }
    }

    #[inline]
    pub fn set_rings(&mut self, rings: i64) -> () {
        unsafe { CapsuleMesh_set_rings(self.this, rings) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CapsuleShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_capsuleshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CapsuleShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CapsuleShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CapsuleShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CapsuleShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CapsuleShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { CapsuleShape_get_height(self.this) }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { CapsuleShape_get_radius(self.this) }
    }

    #[inline]
    pub fn set_height(&mut self, height: f64) -> () {
        unsafe { CapsuleShape_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { CapsuleShape_set_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CapsuleShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_capsuleshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CapsuleShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CapsuleShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CapsuleShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CapsuleShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CapsuleShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { CapsuleShape2D_get_height(self.this) }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { CapsuleShape2D_get_radius(self.this) }
    }

    #[inline]
    pub fn set_height(&mut self, height: f64) -> () {
        unsafe { CapsuleShape2D_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { CapsuleShape2D_set_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CenterContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_centercontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CenterContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CenterContainer::free`.
///
/// ## Class hierarchy
///
/// CenterContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CenterContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CenterContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CenterContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CenterContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CenterContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn is_using_top_left(&self) -> bool {
        CenterContainer_is_using_top_left(self.this)
    }

    #[inline]
    pub unsafe fn set_use_top_left(&mut self, enable: bool) -> () {
        CenterContainer_set_use_top_left(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CharFXTransform` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_charfxtransform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CharFXTransform inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CharFXTransform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CharFXTransform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CharFXTransformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CharFXTransform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_absolute_index(&mut self) -> i64 {
        unsafe { CharFXTransform_get_absolute_index(self.this) }
    }

    #[inline]
    pub fn get_character(&mut self) -> i64 {
        unsafe { CharFXTransform_get_character(self.this) }
    }

    #[inline]
    pub fn get_color(&mut self) -> Color {
        unsafe { CharFXTransform_get_color(self.this) }
    }

    #[inline]
    pub fn get_elapsed_time(&mut self) -> f64 {
        unsafe { CharFXTransform_get_elapsed_time(self.this) }
    }

    #[inline]
    pub fn get_environment(&mut self) -> Dictionary {
        unsafe { CharFXTransform_get_environment(self.this) }
    }

    #[inline]
    pub fn get_offset(&mut self) -> Vector2 {
        unsafe { CharFXTransform_get_offset(self.this) }
    }

    #[inline]
    pub fn get_relative_index(&mut self) -> i64 {
        unsafe { CharFXTransform_get_relative_index(self.this) }
    }

    #[inline]
    pub fn is_visible(&mut self) -> bool {
        unsafe { CharFXTransform_is_visible(self.this) }
    }

    #[inline]
    pub fn set_absolute_index(&mut self, index: i64) -> () {
        unsafe { CharFXTransform_set_absolute_index(self.this, index) }
    }

    #[inline]
    pub fn set_character(&mut self, character: i64) -> () {
        unsafe { CharFXTransform_set_character(self.this, character) }
    }

    #[inline]
    pub fn set_color(&mut self, color: Color) -> () {
        unsafe { CharFXTransform_set_color(self.this, color) }
    }

    #[inline]
    pub fn set_elapsed_time(&mut self, time: f64) -> () {
        unsafe { CharFXTransform_set_elapsed_time(self.this, time) }
    }

    #[inline]
    pub fn set_environment(&mut self, environment: Dictionary) -> () {
        unsafe { CharFXTransform_set_environment(self.this, environment) }
    }

    #[inline]
    pub fn set_offset(&mut self, offset: Vector2) -> () {
        unsafe { CharFXTransform_set_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_relative_index(&mut self, index: i64) -> () {
        unsafe { CharFXTransform_set_relative_index(self.this, index) }
    }

    #[inline]
    pub fn set_visibility(&mut self, visibility: bool) -> () {
        unsafe { CharFXTransform_set_visibility(self.this, visibility) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CheckBox` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_checkbox.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CheckBox` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CheckBox::free`.
///
/// ## Class hierarchy
///
/// CheckBox inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CheckBox {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CheckBox {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CheckBox::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CheckBoxMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CheckBox {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CheckButton` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_checkbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CheckButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CheckButton::free`.
///
/// ## Class hierarchy
///
/// CheckButton inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CheckButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CheckButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CheckButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CheckButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CheckButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CircleShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_circleshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CircleShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CircleShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CircleShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CircleShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CircleShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { CircleShape2D_get_radius(self.this) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { CircleShape2D_set_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ClippedCamera` inherits `Camera` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_clippedcamera.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ClippedCamera` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ClippedCamera::free`.
///
/// ## Class hierarchy
///
/// ClippedCamera inherits methods from:
/// - [Camera](struct.Camera.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ClippedCamera {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ClippedCameraProcessMode {
    ClipProcessPhysics = 0,
    ClipProcessIdle = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ClippedCamera {
    pub const CLIP_PROCESS_IDLE: i64 = 1;
    pub const CLIP_PROCESS_PHYSICS: i64 = 0;
}
impl ClippedCamera {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ClippedCamera::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ClippedCameraMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ClippedCamera {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_exception(&mut self, node: Option<Object>) -> () {
        ClippedCamera_add_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn add_exception_rid(&mut self, rid: Rid) -> () {
        ClippedCamera_add_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn clear_exceptions(&mut self) -> () {
        ClippedCamera_clear_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn get_clip_offset(&self) -> f64 {
        ClippedCamera_get_clip_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        ClippedCamera_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        ClippedCamera_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_margin(&self) -> f64 {
        ClippedCamera_get_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_process_mode(&self) -> ClippedCameraProcessMode {
        ClippedCamera_get_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_clip_to_areas_enabled(&self) -> bool {
        ClippedCamera_is_clip_to_areas_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_clip_to_bodies_enabled(&self) -> bool {
        ClippedCamera_is_clip_to_bodies_enabled(self.this)
    }

    #[inline]
    pub unsafe fn remove_exception(&mut self, node: Option<Object>) -> () {
        ClippedCamera_remove_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn remove_exception_rid(&mut self, rid: Rid) -> () {
        ClippedCamera_remove_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn set_clip_to_areas(&mut self, enable: bool) -> () {
        ClippedCamera_set_clip_to_areas(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_clip_to_bodies(&mut self, enable: bool) -> () {
        ClippedCamera_set_clip_to_bodies(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        ClippedCamera_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        ClippedCamera_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_margin(&mut self, margin: f64) -> () {
        ClippedCamera_set_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn set_process_mode(&mut self, process_mode: i64) -> () {
        ClippedCamera_set_process_mode(self.this, process_mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_camera(&self) -> Camera {
        // Not reference-counted.
        Camera { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionObject` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionobject.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CollisionObject inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionObject {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CollisionObject {
    #[inline]
    pub unsafe fn _input_event(&mut self, camera: Option<Object>, event: Option<InputEvent>, click_position: Vector3, click_normal: Vector3, shape_idx: i64) -> () {
        CollisionObject__input_event(self.this, camera, event, click_position, click_normal, shape_idx)
    }

    #[inline]
    pub unsafe fn create_shape_owner(&mut self, owner: Option<Object>) -> i64 {
        CollisionObject_create_shape_owner(self.this, owner)
    }

    #[inline]
    pub unsafe fn get_capture_input_on_drag(&self) -> bool {
        CollisionObject_get_capture_input_on_drag(self.this)
    }

    #[inline]
    pub unsafe fn get_rid(&self) -> Rid {
        CollisionObject_get_rid(self.this)
    }

    #[inline]
    pub unsafe fn get_shape_owners(&mut self) -> VariantArray {
        CollisionObject_get_shape_owners(self.this)
    }

    #[inline]
    pub unsafe fn is_ray_pickable(&self) -> bool {
        CollisionObject_is_ray_pickable(self.this)
    }

    #[inline]
    pub unsafe fn is_shape_owner_disabled(&self, owner_id: i64) -> bool {
        CollisionObject_is_shape_owner_disabled(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn remove_shape_owner(&mut self, owner_id: i64) -> () {
        CollisionObject_remove_shape_owner(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn set_capture_input_on_drag(&mut self, enable: bool) -> () {
        CollisionObject_set_capture_input_on_drag(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_ray_pickable(&mut self, ray_pickable: bool) -> () {
        CollisionObject_set_ray_pickable(self.this, ray_pickable)
    }

    #[inline]
    pub unsafe fn shape_find_owner(&self, shape_index: i64) -> i64 {
        CollisionObject_shape_find_owner(self.this, shape_index)
    }

    #[inline]
    pub unsafe fn shape_owner_add_shape(&mut self, owner_id: i64, shape: Option<Shape>) -> () {
        CollisionObject_shape_owner_add_shape(self.this, owner_id, shape)
    }

    #[inline]
    pub unsafe fn shape_owner_clear_shapes(&mut self, owner_id: i64) -> () {
        CollisionObject_shape_owner_clear_shapes(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_owner(&self, owner_id: i64) -> Option<Object> {
        CollisionObject_shape_owner_get_owner(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape(&self, owner_id: i64, shape_id: i64) -> Option<Shape> {
        CollisionObject_shape_owner_get_shape(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape_count(&self, owner_id: i64) -> i64 {
        CollisionObject_shape_owner_get_shape_count(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape_index(&self, owner_id: i64, shape_id: i64) -> i64 {
        CollisionObject_shape_owner_get_shape_index(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_transform(&self, owner_id: i64) -> Transform {
        CollisionObject_shape_owner_get_transform(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_remove_shape(&mut self, owner_id: i64, shape_id: i64) -> () {
        CollisionObject_shape_owner_remove_shape(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_set_disabled(&mut self, owner_id: i64, disabled: bool) -> () {
        CollisionObject_shape_owner_set_disabled(self.this, owner_id, disabled)
    }

    #[inline]
    pub unsafe fn shape_owner_set_transform(&mut self, owner_id: i64, transform: Transform) -> () {
        CollisionObject_shape_owner_set_transform(self.this, owner_id, transform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionObject2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionobject2d.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// CollisionObject2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionObject2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CollisionObject2D {
    #[inline]
    pub unsafe fn _input_event(&mut self, viewport: Option<Object>, event: Option<InputEvent>, shape_idx: i64) -> () {
        CollisionObject2D__input_event(self.this, viewport, event, shape_idx)
    }

    #[inline]
    pub unsafe fn create_shape_owner(&mut self, owner: Option<Object>) -> i64 {
        CollisionObject2D_create_shape_owner(self.this, owner)
    }

    #[inline]
    pub unsafe fn get_rid(&self) -> Rid {
        CollisionObject2D_get_rid(self.this)
    }

    #[inline]
    pub unsafe fn get_shape_owner_one_way_collision_margin(&self, owner_id: i64) -> f64 {
        CollisionObject2D_get_shape_owner_one_way_collision_margin(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn get_shape_owners(&mut self) -> VariantArray {
        CollisionObject2D_get_shape_owners(self.this)
    }

    #[inline]
    pub unsafe fn is_pickable(&self) -> bool {
        CollisionObject2D_is_pickable(self.this)
    }

    #[inline]
    pub unsafe fn is_shape_owner_disabled(&self, owner_id: i64) -> bool {
        CollisionObject2D_is_shape_owner_disabled(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn is_shape_owner_one_way_collision_enabled(&self, owner_id: i64) -> bool {
        CollisionObject2D_is_shape_owner_one_way_collision_enabled(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn remove_shape_owner(&mut self, owner_id: i64) -> () {
        CollisionObject2D_remove_shape_owner(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn set_pickable(&mut self, enabled: bool) -> () {
        CollisionObject2D_set_pickable(self.this, enabled)
    }

    #[inline]
    pub unsafe fn shape_find_owner(&self, shape_index: i64) -> i64 {
        CollisionObject2D_shape_find_owner(self.this, shape_index)
    }

    #[inline]
    pub unsafe fn shape_owner_add_shape(&mut self, owner_id: i64, shape: Option<Shape2D>) -> () {
        CollisionObject2D_shape_owner_add_shape(self.this, owner_id, shape)
    }

    #[inline]
    pub unsafe fn shape_owner_clear_shapes(&mut self, owner_id: i64) -> () {
        CollisionObject2D_shape_owner_clear_shapes(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_owner(&self, owner_id: i64) -> Option<Object> {
        CollisionObject2D_shape_owner_get_owner(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape(&self, owner_id: i64, shape_id: i64) -> Option<Shape2D> {
        CollisionObject2D_shape_owner_get_shape(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape_count(&self, owner_id: i64) -> i64 {
        CollisionObject2D_shape_owner_get_shape_count(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_shape_index(&self, owner_id: i64, shape_id: i64) -> i64 {
        CollisionObject2D_shape_owner_get_shape_index(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_get_transform(&self, owner_id: i64) -> Transform2D {
        CollisionObject2D_shape_owner_get_transform(self.this, owner_id)
    }

    #[inline]
    pub unsafe fn shape_owner_remove_shape(&mut self, owner_id: i64, shape_id: i64) -> () {
        CollisionObject2D_shape_owner_remove_shape(self.this, owner_id, shape_id)
    }

    #[inline]
    pub unsafe fn shape_owner_set_disabled(&mut self, owner_id: i64, disabled: bool) -> () {
        CollisionObject2D_shape_owner_set_disabled(self.this, owner_id, disabled)
    }

    #[inline]
    pub unsafe fn shape_owner_set_one_way_collision(&mut self, owner_id: i64, enable: bool) -> () {
        CollisionObject2D_shape_owner_set_one_way_collision(self.this, owner_id, enable)
    }

    #[inline]
    pub unsafe fn shape_owner_set_one_way_collision_margin(&mut self, owner_id: i64, margin: f64) -> () {
        CollisionObject2D_shape_owner_set_one_way_collision_margin(self.this, owner_id, margin)
    }

    #[inline]
    pub unsafe fn shape_owner_set_transform(&mut self, owner_id: i64, transform: Transform2D) -> () {
        CollisionObject2D_shape_owner_set_transform(self.this, owner_id, transform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionPolygon` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionpolygon.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CollisionPolygon` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CollisionPolygon::free`.
///
/// ## Class hierarchy
///
/// CollisionPolygon inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionPolygon {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CollisionPolygon {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CollisionPolygon::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CollisionPolygonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CollisionPolygon {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _is_editable_3d_polygon(&self) -> bool {
        CollisionPolygon__is_editable_3d_polygon(self.this)
    }

    #[inline]
    pub unsafe fn get_depth(&self) -> f64 {
        CollisionPolygon_get_depth(self.this)
    }

    #[inline]
    pub unsafe fn get_polygon(&self) -> Vector2Array {
        CollisionPolygon_get_polygon(self.this)
    }

    #[inline]
    pub unsafe fn is_disabled(&self) -> bool {
        CollisionPolygon_is_disabled(self.this)
    }

    #[inline]
    pub unsafe fn set_depth(&mut self, depth: f64) -> () {
        CollisionPolygon_set_depth(self.this, depth)
    }

    #[inline]
    pub unsafe fn set_disabled(&mut self, disabled: bool) -> () {
        CollisionPolygon_set_disabled(self.this, disabled)
    }

    #[inline]
    pub unsafe fn set_polygon(&mut self, polygon: Vector2Array) -> () {
        CollisionPolygon_set_polygon(self.this, polygon)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionPolygon2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionpolygon2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CollisionPolygon2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CollisionPolygon2D::free`.
///
/// ## Class hierarchy
///
/// CollisionPolygon2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionPolygon2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CollisionPolygon2DBuildMode {
    Solids = 0,
    Segments = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CollisionPolygon2D {
    pub const BUILD_SOLIDS: i64 = 0;
    pub const BUILD_SEGMENTS: i64 = 1;
}
impl CollisionPolygon2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CollisionPolygon2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CollisionPolygon2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CollisionPolygon2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_build_mode(&self) -> CollisionPolygon2DBuildMode {
        CollisionPolygon2D_get_build_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_one_way_collision_margin(&self) -> f64 {
        CollisionPolygon2D_get_one_way_collision_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_polygon(&self) -> Vector2Array {
        CollisionPolygon2D_get_polygon(self.this)
    }

    #[inline]
    pub unsafe fn is_disabled(&self) -> bool {
        CollisionPolygon2D_is_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_one_way_collision_enabled(&self) -> bool {
        CollisionPolygon2D_is_one_way_collision_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_build_mode(&mut self, build_mode: i64) -> () {
        CollisionPolygon2D_set_build_mode(self.this, build_mode)
    }

    #[inline]
    pub unsafe fn set_disabled(&mut self, disabled: bool) -> () {
        CollisionPolygon2D_set_disabled(self.this, disabled)
    }

    #[inline]
    pub unsafe fn set_one_way_collision(&mut self, enabled: bool) -> () {
        CollisionPolygon2D_set_one_way_collision(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_one_way_collision_margin(&mut self, margin: f64) -> () {
        CollisionPolygon2D_set_one_way_collision_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn set_polygon(&mut self, polygon: Vector2Array) -> () {
        CollisionPolygon2D_set_polygon(self.this, polygon)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionShape` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CollisionShape` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CollisionShape::free`.
///
/// ## Class hierarchy
///
/// CollisionShape inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CollisionShape {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CollisionShape::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CollisionShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CollisionShape {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _shape_changed(&mut self) -> () {
        CollisionShape__shape_changed(self.this)
    }

    #[inline]
    pub unsafe fn _update_debug_shape(&mut self) -> () {
        CollisionShape__update_debug_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_shape(&self) -> Option<Shape> {
        CollisionShape_get_shape(self.this)
    }

    #[inline]
    pub unsafe fn is_disabled(&self) -> bool {
        CollisionShape_is_disabled(self.this)
    }

    #[inline]
    pub unsafe fn make_convex_from_brothers(&mut self) -> () {
        CollisionShape_make_convex_from_brothers(self.this)
    }

    #[inline]
    pub unsafe fn resource_changed(&mut self, resource: Option<Resource>) -> () {
        CollisionShape_resource_changed(self.this, resource)
    }

    #[inline]
    pub unsafe fn set_disabled(&mut self, enable: bool) -> () {
        CollisionShape_set_disabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_shape(&mut self, shape: Option<Shape>) -> () {
        CollisionShape_set_shape(self.this, shape)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CollisionShape2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_collisionshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `CollisionShape2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `CollisionShape2D::free`.
///
/// ## Class hierarchy
///
/// CollisionShape2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CollisionShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CollisionShape2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `CollisionShape2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CollisionShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            CollisionShape2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _shape_changed(&mut self) -> () {
        CollisionShape2D__shape_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_one_way_collision_margin(&self) -> f64 {
        CollisionShape2D_get_one_way_collision_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_shape(&self) -> Option<Shape2D> {
        CollisionShape2D_get_shape(self.this)
    }

    #[inline]
    pub unsafe fn is_disabled(&self) -> bool {
        CollisionShape2D_is_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_one_way_collision_enabled(&self) -> bool {
        CollisionShape2D_is_one_way_collision_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_disabled(&mut self, disabled: bool) -> () {
        CollisionShape2D_set_disabled(self.this, disabled)
    }

    #[inline]
    pub unsafe fn set_one_way_collision(&mut self, enabled: bool) -> () {
        CollisionShape2D_set_one_way_collision(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_one_way_collision_margin(&mut self, margin: f64) -> () {
        CollisionShape2D_set_one_way_collision_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn set_shape(&mut self, shape: Option<Shape2D>) -> () {
        CollisionShape2D_set_shape(self.this, shape)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ColorPicker` inherits `BoxContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_colorpicker.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ColorPicker` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ColorPicker::free`.
///
/// ## Class hierarchy
///
/// ColorPicker inherits methods from:
/// - [BoxContainer](struct.BoxContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ColorPicker {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ColorPicker {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ColorPicker::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ColorPickerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ColorPicker {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _add_preset_pressed(&mut self) -> () {
        ColorPicker__add_preset_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _focus_enter(&mut self) -> () {
        ColorPicker__focus_enter(self.this)
    }

    #[inline]
    pub unsafe fn _focus_exit(&mut self) -> () {
        ColorPicker__focus_exit(self.this)
    }

    #[inline]
    pub unsafe fn _hsv_draw(&mut self, arg0: i64, arg1: Option<Control>) -> () {
        ColorPicker__hsv_draw(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _html_entered(&mut self, arg0: GodotString) -> () {
        ColorPicker__html_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _html_focus_exit(&mut self) -> () {
        ColorPicker__html_focus_exit(self.this)
    }

    #[inline]
    pub unsafe fn _preset_input(&mut self, arg0: Option<InputEvent>) -> () {
        ColorPicker__preset_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _sample_draw(&mut self) -> () {
        ColorPicker__sample_draw(self.this)
    }

    #[inline]
    pub unsafe fn _screen_input(&mut self, arg0: Option<InputEvent>) -> () {
        ColorPicker__screen_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _screen_pick_pressed(&mut self) -> () {
        ColorPicker__screen_pick_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _text_type_toggled(&mut self) -> () {
        ColorPicker__text_type_toggled(self.this)
    }

    #[inline]
    pub unsafe fn _update_presets(&mut self) -> () {
        ColorPicker__update_presets(self.this)
    }

    #[inline]
    pub unsafe fn _uv_input(&mut self, arg0: Option<InputEvent>) -> () {
        ColorPicker__uv_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _value_changed(&mut self, arg0: f64) -> () {
        ColorPicker__value_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _w_input(&mut self, arg0: Option<InputEvent>) -> () {
        ColorPicker__w_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_preset(&mut self, color: Color) -> () {
        ColorPicker_add_preset(self.this, color)
    }

    #[inline]
    pub unsafe fn are_presets_enabled(&self) -> bool {
        ColorPicker_are_presets_enabled(self.this)
    }

    #[inline]
    pub unsafe fn are_presets_visible(&self) -> bool {
        ColorPicker_are_presets_visible(self.this)
    }

    #[inline]
    pub unsafe fn erase_preset(&mut self, color: Color) -> () {
        ColorPicker_erase_preset(self.this, color)
    }

    #[inline]
    pub unsafe fn get_pick_color(&self) -> Color {
        ColorPicker_get_pick_color(self.this)
    }

    #[inline]
    pub unsafe fn get_presets(&self) -> ColorArray {
        ColorPicker_get_presets(self.this)
    }

    #[inline]
    pub unsafe fn is_deferred_mode(&self) -> bool {
        ColorPicker_is_deferred_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_editing_alpha(&self) -> bool {
        ColorPicker_is_editing_alpha(self.this)
    }

    #[inline]
    pub unsafe fn is_hsv_mode(&self) -> bool {
        ColorPicker_is_hsv_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_raw_mode(&self) -> bool {
        ColorPicker_is_raw_mode(self.this)
    }

    #[inline]
    pub unsafe fn set_deferred_mode(&mut self, mode: bool) -> () {
        ColorPicker_set_deferred_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_edit_alpha(&mut self, show: bool) -> () {
        ColorPicker_set_edit_alpha(self.this, show)
    }

    #[inline]
    pub unsafe fn set_hsv_mode(&mut self, mode: bool) -> () {
        ColorPicker_set_hsv_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_pick_color(&mut self, color: Color) -> () {
        ColorPicker_set_pick_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_presets_enabled(&mut self, enabled: bool) -> () {
        ColorPicker_set_presets_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_presets_visible(&mut self, visible: bool) -> () {
        ColorPicker_set_presets_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn set_raw_mode(&mut self, mode: bool) -> () {
        ColorPicker_set_raw_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_box_container(&self) -> BoxContainer {
        // Not reference-counted.
        BoxContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ColorPickerButton` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_colorpickerbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ColorPickerButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ColorPickerButton::free`.
///
/// ## Class hierarchy
///
/// ColorPickerButton inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ColorPickerButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ColorPickerButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ColorPickerButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ColorPickerButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ColorPickerButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _color_changed(&mut self, arg0: Color) -> () {
        ColorPickerButton__color_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _modal_closed(&mut self) -> () {
        ColorPickerButton__modal_closed(self.this)
    }

    #[inline]
    pub unsafe fn get_pick_color(&self) -> Color {
        ColorPickerButton_get_pick_color(self.this)
    }

    #[inline]
    pub unsafe fn get_picker(&mut self) -> Option<ColorPicker> {
        ColorPickerButton_get_picker(self.this)
    }

    #[inline]
    pub unsafe fn get_popup(&mut self) -> Option<PopupPanel> {
        ColorPickerButton_get_popup(self.this)
    }

    #[inline]
    pub unsafe fn is_editing_alpha(&self) -> bool {
        ColorPickerButton_is_editing_alpha(self.this)
    }

    #[inline]
    pub unsafe fn set_edit_alpha(&mut self, show: bool) -> () {
        ColorPickerButton_set_edit_alpha(self.this, show)
    }

    #[inline]
    pub unsafe fn set_pick_color(&mut self, color: Color) -> () {
        ColorPickerButton_set_pick_color(self.this, color)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ColorRect` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_colorrect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ColorRect` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ColorRect::free`.
///
/// ## Class hierarchy
///
/// ColorRect inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ColorRect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ColorRect {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ColorRect::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ColorRectMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ColorRect {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_frame_color(&self) -> Color {
        ColorRect_get_frame_color(self.this)
    }

    #[inline]
    pub unsafe fn set_frame_color(&mut self, color: Color) -> () {
        ColorRect_set_frame_color(self.this, color)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConcavePolygonShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_concavepolygonshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ConcavePolygonShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConcavePolygonShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConcavePolygonShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConcavePolygonShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ConcavePolygonShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_faces(&self) -> Vector3Array {
        unsafe { ConcavePolygonShape_get_faces(self.this) }
    }

    #[inline]
    pub fn set_faces(&mut self, faces: Vector3Array) -> () {
        unsafe { ConcavePolygonShape_set_faces(self.this, faces) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConcavePolygonShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_concavepolygonshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ConcavePolygonShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConcavePolygonShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConcavePolygonShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConcavePolygonShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ConcavePolygonShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_segments(&self) -> Vector2Array {
        unsafe { ConcavePolygonShape2D_get_segments(self.this) }
    }

    #[inline]
    pub fn set_segments(&mut self, segments: Vector2Array) -> () {
        unsafe { ConcavePolygonShape2D_set_segments(self.this, segments) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConeTwistJoint` inherits `Joint` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_conetwistjoint.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ConeTwistJoint` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ConeTwistJoint::free`.
///
/// ## Class hierarchy
///
/// ConeTwistJoint inherits methods from:
/// - [Joint](struct.Joint.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConeTwistJoint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ConeTwistJointParam {
    SwingSpan = 0,
    TwistSpan = 1,
    Bias = 2,
    Softness = 3,
    Relaxation = 4,
    Max = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ConeTwistJoint {
    pub const PARAM_RELAXATION: i64 = 4;
    pub const PARAM_TWIST_SPAN: i64 = 1;
    pub const PARAM_MAX: i64 = 5;
    pub const PARAM_BIAS: i64 = 2;
    pub const PARAM_SOFTNESS: i64 = 3;
    pub const PARAM_SWING_SPAN: i64 = 0;
}
impl ConeTwistJoint {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ConeTwistJoint::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConeTwistJointMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ConeTwistJoint {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_swing_span(&self) -> f64 {
        ConeTwistJoint__get_swing_span(self.this)
    }

    #[inline]
    pub unsafe fn _get_twist_span(&self) -> f64 {
        ConeTwistJoint__get_twist_span(self.this)
    }

    #[inline]
    pub unsafe fn _set_swing_span(&mut self, swing_span: f64) -> () {
        ConeTwistJoint__set_swing_span(self.this, swing_span)
    }

    #[inline]
    pub unsafe fn _set_twist_span(&mut self, twist_span: f64) -> () {
        ConeTwistJoint__set_twist_span(self.this, twist_span)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        ConeTwistJoint_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        ConeTwistJoint_set_param(self.this, param, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint(&self) -> Joint {
        // Not reference-counted.
        Joint { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConfigFile` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_configfile.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ConfigFile inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConfigFile {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConfigFile {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConfigFileMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ConfigFile {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn erase_section(&mut self, section: GodotString) -> () {
        unsafe { ConfigFile_erase_section(self.this, section) }
    }

    #[inline]
    pub fn erase_section_key(&mut self, section: GodotString, key: GodotString) -> () {
        unsafe { ConfigFile_erase_section_key(self.this, section, key) }
    }

    #[inline]
    pub fn get_section_keys(&self, section: GodotString) -> StringArray {
        unsafe { ConfigFile_get_section_keys(self.this, section) }
    }

    #[inline]
    pub fn get_sections(&self) -> StringArray {
        unsafe { ConfigFile_get_sections(self.this) }
    }

    #[inline]
    pub fn get_value(&self, section: GodotString, key: GodotString, default: Variant) -> Variant {
        unsafe { ConfigFile_get_value(self.this, section, key, default) }
    }

    #[inline]
    pub fn has_section(&self, section: GodotString) -> bool {
        unsafe { ConfigFile_has_section(self.this, section) }
    }

    #[inline]
    pub fn has_section_key(&self, section: GodotString, key: GodotString) -> bool {
        unsafe { ConfigFile_has_section_key(self.this, section, key) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { ConfigFile_load(self.this, path) }
    }

    #[inline]
    pub fn load_encrypted(&mut self, path: GodotString, key: ByteArray) -> GodotResult {
        unsafe { ConfigFile_load_encrypted(self.this, path, key) }
    }

    #[inline]
    pub fn load_encrypted_pass(&mut self, path: GodotString, pass: GodotString) -> GodotResult {
        unsafe { ConfigFile_load_encrypted_pass(self.this, path, pass) }
    }

    #[inline]
    pub fn save(&mut self, path: GodotString) -> GodotResult {
        unsafe { ConfigFile_save(self.this, path) }
    }

    #[inline]
    pub fn save_encrypted(&mut self, path: GodotString, key: ByteArray) -> GodotResult {
        unsafe { ConfigFile_save_encrypted(self.this, path, key) }
    }

    #[inline]
    pub fn save_encrypted_pass(&mut self, path: GodotString, pass: GodotString) -> GodotResult {
        unsafe { ConfigFile_save_encrypted_pass(self.this, path, pass) }
    }

    #[inline]
    pub fn set_value(&mut self, section: GodotString, key: GodotString, value: Variant) -> () {
        unsafe { ConfigFile_set_value(self.this, section, key, value) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConfirmationDialog` inherits `AcceptDialog` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_confirmationdialog.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ConfirmationDialog` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ConfirmationDialog::free`.
///
/// ## Class hierarchy
///
/// ConfirmationDialog inherits methods from:
/// - [AcceptDialog](struct.AcceptDialog.html)
/// - [WindowDialog](struct.WindowDialog.html)
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConfirmationDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConfirmationDialog {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ConfirmationDialog::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConfirmationDialogMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ConfirmationDialog {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_cancel(&mut self) -> Option<Button> {
        ConfirmationDialog_get_cancel(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_accept_dialog(&self) -> AcceptDialog {
        // Not reference-counted.
        AcceptDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_window_dialog(&self) -> WindowDialog {
        // Not reference-counted.
        WindowDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Container` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_container.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Container` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Container::free`.
///
/// ## Class hierarchy
///
/// Container inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Container {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl Container {
    pub const NOTIFICATION_SORT_CHILDREN: i64 = 50;
}
impl Container {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Container::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Container {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _child_minsize_changed(&mut self) -> () {
        Container__child_minsize_changed(self.this)
    }

    #[inline]
    pub unsafe fn _sort_children(&mut self) -> () {
        Container__sort_children(self.this)
    }

    #[inline]
    pub unsafe fn fit_child_in_rect(&mut self, child: Option<Control>, rect: Rect2) -> () {
        Container_fit_child_in_rect(self.this, child, rect)
    }

    #[inline]
    pub unsafe fn queue_sort(&mut self) -> () {
        Container_queue_sort(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Control` inherits `CanvasItem` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_control.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Control` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Control::free`.
///
/// ## Class hierarchy
///
/// Control inherits methods from:
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Control {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlAnchor {
    Begin = 0,
    End = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlFocusMode {
    None = 0,
    Click = 1,
    All = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlLayoutPresetMode {
    PresetModeMinsize = 0,
    PresetModeKeepWidth = 1,
    PresetModeKeepHeight = 2,
    PresetModeKeepSize = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlMouseFilter {
    Stop = 0,
    Pass = 1,
    Ignore = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlCursorShape {
    CursorArrow = 0,
    CursorIbeam = 1,
    CursorPointingHand = 2,
    CursorCross = 3,
    CursorWait = 4,
    CursorBusy = 5,
    CursorDrag = 6,
    CursorCanDrop = 7,
    CursorForbidden = 8,
    CursorVsize = 9,
    CursorHsize = 10,
    CursorBdiagsize = 11,
    CursorFdiagsize = 12,
    CursorMove = 13,
    CursorVsplit = 14,
    CursorHsplit = 15,
    CursorHelp = 16,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlGrowDirection {
    Begin = 0,
    End = 1,
    Both = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlSizeFlags {
    SizeFill = 1,
    SizeExpand = 2,
    SizeExpandFill = 3,
    SizeShrinkCenter = 4,
    SizeShrinkEnd = 8,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ControlLayoutPreset {
    PresetTopLeft = 0,
    PresetTopRight = 1,
    PresetBottomLeft = 2,
    PresetBottomRight = 3,
    PresetCenterLeft = 4,
    PresetCenterTop = 5,
    PresetCenterRight = 6,
    PresetCenterBottom = 7,
    PresetCenter = 8,
    PresetLeftWide = 9,
    PresetTopWide = 10,
    PresetRightWide = 11,
    PresetBottomWide = 12,
    PresetVcenterWide = 13,
    PresetHcenterWide = 14,
    PresetWide = 15,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Control {
    pub const CURSOR_WAIT: i64 = 4;
    pub const SIZE_EXPAND_FILL: i64 = 3;
    pub const PRESET_TOP_LEFT: i64 = 0;
    pub const NOTIFICATION_MODAL_CLOSE: i64 = 46;
    pub const PRESET_VCENTER_WIDE: i64 = 13;
    pub const FOCUS_CLICK: i64 = 1;
    pub const CURSOR_FORBIDDEN: i64 = 8;
    pub const NOTIFICATION_FOCUS_EXIT: i64 = 44;
    pub const NOTIFICATION_RESIZED: i64 = 40;
    pub const CURSOR_POINTING_HAND: i64 = 2;
    pub const PRESET_RIGHT_WIDE: i64 = 11;
    pub const GROW_DIRECTION_BOTH: i64 = 2;
    pub const MOUSE_FILTER_IGNORE: i64 = 2;
    pub const PRESET_BOTTOM_RIGHT: i64 = 3;
    pub const PRESET_CENTER_BOTTOM: i64 = 7;
    pub const CURSOR_CROSS: i64 = 3;
    pub const ANCHOR_BEGIN: i64 = 0;
    pub const NOTIFICATION_FOCUS_ENTER: i64 = 43;
    pub const PRESET_BOTTOM_WIDE: i64 = 12;
    pub const PRESET_MODE_KEEP_SIZE: i64 = 3;
    pub const SIZE_SHRINK_END: i64 = 8;
    pub const CURSOR_HELP: i64 = 16;
    pub const CURSOR_FDIAGSIZE: i64 = 12;
    pub const SIZE_FILL: i64 = 1;
    pub const NOTIFICATION_SCROLL_BEGIN: i64 = 47;
    pub const FOCUS_ALL: i64 = 2;
    pub const NOTIFICATION_SCROLL_END: i64 = 48;
    pub const GROW_DIRECTION_END: i64 = 1;
    pub const CURSOR_VSIZE: i64 = 9;
    pub const CURSOR_IBEAM: i64 = 1;
    pub const CURSOR_DRAG: i64 = 6;
    pub const NOTIFICATION_MOUSE_ENTER: i64 = 41;
    pub const MOUSE_FILTER_STOP: i64 = 0;
    pub const PRESET_CENTER_RIGHT: i64 = 6;
    pub const SIZE_EXPAND: i64 = 2;
    pub const CURSOR_MOVE: i64 = 13;
    pub const CURSOR_BDIAGSIZE: i64 = 11;
    pub const CURSOR_VSPLIT: i64 = 14;
    pub const CURSOR_HSIZE: i64 = 10;
    pub const FOCUS_NONE: i64 = 0;
    pub const PRESET_CENTER: i64 = 8;
    pub const PRESET_CENTER_LEFT: i64 = 4;
    pub const PRESET_TOP_WIDE: i64 = 10;
    pub const ANCHOR_END: i64 = 1;
    pub const CURSOR_ARROW: i64 = 0;
    pub const CURSOR_HSPLIT: i64 = 15;
    pub const PRESET_MODE_KEEP_HEIGHT: i64 = 2;
    pub const GROW_DIRECTION_BEGIN: i64 = 0;
    pub const CURSOR_CAN_DROP: i64 = 7;
    pub const CURSOR_BUSY: i64 = 5;
    pub const PRESET_HCENTER_WIDE: i64 = 14;
    pub const PRESET_CENTER_TOP: i64 = 5;
    pub const PRESET_WIDE: i64 = 15;
    pub const NOTIFICATION_MOUSE_EXIT: i64 = 42;
    pub const NOTIFICATION_THEME_CHANGED: i64 = 45;
    pub const MOUSE_FILTER_PASS: i64 = 1;
    pub const SIZE_SHRINK_CENTER: i64 = 4;
    pub const PRESET_BOTTOM_LEFT: i64 = 2;
    pub const PRESET_MODE_KEEP_WIDTH: i64 = 1;
    pub const PRESET_MODE_MINSIZE: i64 = 0;
    pub const PRESET_LEFT_WIDE: i64 = 9;
    pub const PRESET_TOP_RIGHT: i64 = 1;
}
impl Control {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Control::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ControlMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Control {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _clips_input(&mut self) -> bool {
        Control__clips_input(self.this)
    }

    #[inline]
    pub unsafe fn _get_minimum_size(&mut self) -> Vector2 {
        Control__get_minimum_size(self.this)
    }

    #[inline]
    pub unsafe fn _get_tooltip(&self) -> GodotString {
        Control__get_tooltip(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, event: Option<InputEvent>) -> () {
        Control__gui_input(self.this, event)
    }

    #[inline]
    pub unsafe fn _make_custom_tooltip(&mut self, for_text: GodotString) -> Option<Object> {
        Control__make_custom_tooltip(self.this, for_text)
    }

    #[inline]
    pub unsafe fn _override_changed(&mut self) -> () {
        Control__override_changed(self.this)
    }

    #[inline]
    pub unsafe fn _set_anchor(&mut self, margin: i64, anchor: f64) -> () {
        Control__set_anchor(self.this, margin, anchor)
    }

    #[inline]
    pub unsafe fn _set_global_position(&mut self, position: Vector2) -> () {
        Control__set_global_position(self.this, position)
    }

    #[inline]
    pub unsafe fn _set_position(&mut self, margin: Vector2) -> () {
        Control__set_position(self.this, margin)
    }

    #[inline]
    pub unsafe fn _set_size(&mut self, size: Vector2) -> () {
        Control__set_size(self.this, size)
    }

    #[inline]
    pub unsafe fn _size_changed(&mut self) -> () {
        Control__size_changed(self.this)
    }

    #[inline]
    pub unsafe fn _theme_changed(&mut self) -> () {
        Control__theme_changed(self.this)
    }

    #[inline]
    pub unsafe fn _update_minimum_size(&mut self) -> () {
        Control__update_minimum_size(self.this)
    }

    #[inline]
    pub unsafe fn accept_event(&mut self) -> () {
        Control_accept_event(self.this)
    }

    #[inline]
    pub unsafe fn add_color_override(&mut self, name: GodotString, color: Color) -> () {
        Control_add_color_override(self.this, name, color)
    }

    #[inline]
    pub unsafe fn add_constant_override(&mut self, name: GodotString, constant: i64) -> () {
        Control_add_constant_override(self.this, name, constant)
    }

    #[inline]
    pub unsafe fn add_font_override(&mut self, name: GodotString, font: Option<Font>) -> () {
        Control_add_font_override(self.this, name, font)
    }

    #[inline]
    pub unsafe fn add_icon_override(&mut self, name: GodotString, texture: Option<Texture>) -> () {
        Control_add_icon_override(self.this, name, texture)
    }

    #[inline]
    pub unsafe fn add_shader_override(&mut self, name: GodotString, shader: Option<Shader>) -> () {
        Control_add_shader_override(self.this, name, shader)
    }

    #[inline]
    pub unsafe fn add_stylebox_override(&mut self, name: GodotString, stylebox: Option<StyleBox>) -> () {
        Control_add_stylebox_override(self.this, name, stylebox)
    }

    #[inline]
    pub unsafe fn can_drop_data(&mut self, position: Vector2, data: Variant) -> bool {
        Control_can_drop_data(self.this, position, data)
    }

    #[inline]
    pub unsafe fn drop_data(&mut self, position: Vector2, data: Variant) -> () {
        Control_drop_data(self.this, position, data)
    }

    #[inline]
    pub unsafe fn force_drag(&mut self, data: Variant, preview: Option<Control>) -> () {
        Control_force_drag(self.this, data, preview)
    }

    #[inline]
    pub unsafe fn get_anchor(&self, margin: i64) -> f64 {
        Control_get_anchor(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_begin(&self) -> Vector2 {
        Control_get_begin(self.this)
    }

    #[inline]
    pub unsafe fn get_color(&self, name: GodotString, _type: GodotString) -> Color {
        Control_get_color(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn get_combined_minimum_size(&self) -> Vector2 {
        Control_get_combined_minimum_size(self.this)
    }

    #[inline]
    pub unsafe fn get_constant(&self, name: GodotString, _type: GodotString) -> i64 {
        Control_get_constant(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn get_cursor_shape(&self, position: Vector2) -> ControlCursorShape {
        Control_get_cursor_shape(self.this, position)
    }

    #[inline]
    pub unsafe fn get_custom_minimum_size(&self) -> Vector2 {
        Control_get_custom_minimum_size(self.this)
    }

    #[inline]
    pub unsafe fn get_default_cursor_shape(&self) -> ControlCursorShape {
        Control_get_default_cursor_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_data(&mut self, position: Vector2) -> Variant {
        Control_get_drag_data(self.this, position)
    }

    #[inline]
    pub unsafe fn get_end(&self) -> Vector2 {
        Control_get_end(self.this)
    }

    #[inline]
    pub unsafe fn get_focus_mode(&self) -> ControlFocusMode {
        Control_get_focus_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_focus_neighbour(&self, margin: i64) -> NodePath {
        Control_get_focus_neighbour(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_focus_next(&self) -> NodePath {
        Control_get_focus_next(self.this)
    }

    #[inline]
    pub unsafe fn get_focus_owner(&self) -> Option<Control> {
        Control_get_focus_owner(self.this)
    }

    #[inline]
    pub unsafe fn get_focus_previous(&self) -> NodePath {
        Control_get_focus_previous(self.this)
    }

    #[inline]
    pub unsafe fn get_font(&self, name: GodotString, _type: GodotString) -> Option<Font> {
        Control_get_font(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn get_global_position(&self) -> Vector2 {
        Control_get_global_position(self.this)
    }

    #[inline]
    pub unsafe fn get_global_rect(&self) -> Rect2 {
        Control_get_global_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_h_grow_direction(&self) -> ControlGrowDirection {
        Control_get_h_grow_direction(self.this)
    }

    #[inline]
    pub unsafe fn get_h_size_flags(&self) -> i64 {
        Control_get_h_size_flags(self.this)
    }

    #[inline]
    pub unsafe fn get_icon(&self, name: GodotString, _type: GodotString) -> Option<Texture> {
        Control_get_icon(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn get_margin(&self, margin: i64) -> f64 {
        Control_get_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_minimum_size(&self) -> Vector2 {
        Control_get_minimum_size(self.this)
    }

    #[inline]
    pub unsafe fn get_mouse_filter(&self) -> ControlMouseFilter {
        Control_get_mouse_filter(self.this)
    }

    #[inline]
    pub unsafe fn get_parent_area_size(&self) -> Vector2 {
        Control_get_parent_area_size(self.this)
    }

    #[inline]
    pub unsafe fn get_parent_control(&self) -> Option<Control> {
        Control_get_parent_control(self.this)
    }

    #[inline]
    pub unsafe fn get_pivot_offset(&self) -> Vector2 {
        Control_get_pivot_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_position(&self) -> Vector2 {
        Control_get_position(self.this)
    }

    #[inline]
    pub unsafe fn get_rect(&self) -> Rect2 {
        Control_get_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation(&self) -> f64 {
        Control_get_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation_degrees(&self) -> f64 {
        Control_get_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_scale(&self) -> Vector2 {
        Control_get_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_size(&self) -> Vector2 {
        Control_get_size(self.this)
    }

    #[inline]
    pub unsafe fn get_stretch_ratio(&self) -> f64 {
        Control_get_stretch_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_stylebox(&self, name: GodotString, _type: GodotString) -> Option<StyleBox> {
        Control_get_stylebox(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn get_theme(&self) -> Option<Theme> {
        Control_get_theme(self.this)
    }

    #[inline]
    pub unsafe fn get_tooltip(&self, at_position: Vector2) -> GodotString {
        Control_get_tooltip(self.this, at_position)
    }

    #[inline]
    pub unsafe fn get_v_grow_direction(&self) -> ControlGrowDirection {
        Control_get_v_grow_direction(self.this)
    }

    #[inline]
    pub unsafe fn get_v_size_flags(&self) -> i64 {
        Control_get_v_size_flags(self.this)
    }

    #[inline]
    pub unsafe fn grab_click_focus(&mut self) -> () {
        Control_grab_click_focus(self.this)
    }

    #[inline]
    pub unsafe fn grab_focus(&mut self) -> () {
        Control_grab_focus(self.this)
    }

    #[inline]
    pub unsafe fn has_color(&self, name: GodotString, _type: GodotString) -> bool {
        Control_has_color(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn has_color_override(&self, name: GodotString) -> bool {
        Control_has_color_override(self.this, name)
    }

    #[inline]
    pub unsafe fn has_constant(&self, name: GodotString, _type: GodotString) -> bool {
        Control_has_constant(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn has_constant_override(&self, name: GodotString) -> bool {
        Control_has_constant_override(self.this, name)
    }

    #[inline]
    pub unsafe fn has_focus(&self) -> bool {
        Control_has_focus(self.this)
    }

    #[inline]
    pub unsafe fn has_font(&self, name: GodotString, _type: GodotString) -> bool {
        Control_has_font(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn has_font_override(&self, name: GodotString) -> bool {
        Control_has_font_override(self.this, name)
    }

    #[inline]
    pub unsafe fn has_icon(&self, name: GodotString, _type: GodotString) -> bool {
        Control_has_icon(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn has_icon_override(&self, name: GodotString) -> bool {
        Control_has_icon_override(self.this, name)
    }

    #[inline]
    pub unsafe fn has_point(&mut self, point: Vector2) -> bool {
        Control_has_point(self.this, point)
    }

    #[inline]
    pub unsafe fn has_shader_override(&self, name: GodotString) -> bool {
        Control_has_shader_override(self.this, name)
    }

    #[inline]
    pub unsafe fn has_stylebox(&self, name: GodotString, _type: GodotString) -> bool {
        Control_has_stylebox(self.this, name, _type)
    }

    #[inline]
    pub unsafe fn has_stylebox_override(&self, name: GodotString) -> bool {
        Control_has_stylebox_override(self.this, name)
    }

    #[inline]
    pub unsafe fn is_clipping_contents(&mut self) -> bool {
        Control_is_clipping_contents(self.this)
    }

    #[inline]
    pub unsafe fn minimum_size_changed(&mut self) -> () {
        Control_minimum_size_changed(self.this)
    }

    #[inline]
    pub unsafe fn release_focus(&mut self) -> () {
        Control_release_focus(self.this)
    }

    #[inline]
    pub unsafe fn set_anchor(&mut self, margin: i64, anchor: f64, keep_margin: bool, push_opposite_anchor: bool) -> () {
        Control_set_anchor(self.this, margin, anchor, keep_margin, push_opposite_anchor)
    }

    #[inline]
    pub unsafe fn set_anchor_and_margin(&mut self, margin: i64, anchor: f64, offset: f64, push_opposite_anchor: bool) -> () {
        Control_set_anchor_and_margin(self.this, margin, anchor, offset, push_opposite_anchor)
    }

    #[inline]
    pub unsafe fn set_anchors_and_margins_preset(&mut self, preset: i64, resize_mode: i64, margin: i64) -> () {
        Control_set_anchors_and_margins_preset(self.this, preset, resize_mode, margin)
    }

    #[inline]
    pub unsafe fn set_anchors_preset(&mut self, preset: i64, keep_margins: bool) -> () {
        Control_set_anchors_preset(self.this, preset, keep_margins)
    }

    #[inline]
    pub unsafe fn set_begin(&mut self, position: Vector2) -> () {
        Control_set_begin(self.this, position)
    }

    #[inline]
    pub unsafe fn set_clip_contents(&mut self, enable: bool) -> () {
        Control_set_clip_contents(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_custom_minimum_size(&mut self, size: Vector2) -> () {
        Control_set_custom_minimum_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_default_cursor_shape(&mut self, shape: i64) -> () {
        Control_set_default_cursor_shape(self.this, shape)
    }

    #[inline]
    pub unsafe fn set_drag_forwarding(&mut self, target: Option<Control>) -> () {
        Control_set_drag_forwarding(self.this, target)
    }

    #[inline]
    pub unsafe fn set_drag_preview(&mut self, control: Option<Control>) -> () {
        Control_set_drag_preview(self.this, control)
    }

    #[inline]
    pub unsafe fn set_end(&mut self, position: Vector2) -> () {
        Control_set_end(self.this, position)
    }

    #[inline]
    pub unsafe fn set_focus_mode(&mut self, mode: i64) -> () {
        Control_set_focus_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_focus_neighbour(&mut self, margin: i64, neighbour: NodePath) -> () {
        Control_set_focus_neighbour(self.this, margin, neighbour)
    }

    #[inline]
    pub unsafe fn set_focus_next(&mut self, next: NodePath) -> () {
        Control_set_focus_next(self.this, next)
    }

    #[inline]
    pub unsafe fn set_focus_previous(&mut self, previous: NodePath) -> () {
        Control_set_focus_previous(self.this, previous)
    }

    #[inline]
    pub unsafe fn set_global_position(&mut self, position: Vector2, keep_margins: bool) -> () {
        Control_set_global_position(self.this, position, keep_margins)
    }

    #[inline]
    pub unsafe fn set_h_grow_direction(&mut self, direction: i64) -> () {
        Control_set_h_grow_direction(self.this, direction)
    }

    #[inline]
    pub unsafe fn set_h_size_flags(&mut self, flags: i64) -> () {
        Control_set_h_size_flags(self.this, flags)
    }

    #[inline]
    pub unsafe fn set_margin(&mut self, margin: i64, offset: f64) -> () {
        Control_set_margin(self.this, margin, offset)
    }

    #[inline]
    pub unsafe fn set_margins_preset(&mut self, preset: i64, resize_mode: i64, margin: i64) -> () {
        Control_set_margins_preset(self.this, preset, resize_mode, margin)
    }

    #[inline]
    pub unsafe fn set_mouse_filter(&mut self, filter: i64) -> () {
        Control_set_mouse_filter(self.this, filter)
    }

    #[inline]
    pub unsafe fn set_pivot_offset(&mut self, pivot_offset: Vector2) -> () {
        Control_set_pivot_offset(self.this, pivot_offset)
    }

    #[inline]
    pub unsafe fn set_position(&mut self, position: Vector2, keep_margins: bool) -> () {
        Control_set_position(self.this, position, keep_margins)
    }

    #[inline]
    pub unsafe fn set_rotation(&mut self, radians: f64) -> () {
        Control_set_rotation(self.this, radians)
    }

    #[inline]
    pub unsafe fn set_rotation_degrees(&mut self, degrees: f64) -> () {
        Control_set_rotation_degrees(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_scale(&mut self, scale: Vector2) -> () {
        Control_set_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_size(&mut self, size: Vector2, keep_margins: bool) -> () {
        Control_set_size(self.this, size, keep_margins)
    }

    #[inline]
    pub unsafe fn set_stretch_ratio(&mut self, ratio: f64) -> () {
        Control_set_stretch_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_theme(&mut self, theme: Option<Theme>) -> () {
        Control_set_theme(self.this, theme)
    }

    #[inline]
    pub unsafe fn set_tooltip(&mut self, tooltip: GodotString) -> () {
        Control_set_tooltip(self.this, tooltip)
    }

    #[inline]
    pub unsafe fn set_v_grow_direction(&mut self, direction: i64) -> () {
        Control_set_v_grow_direction(self.this, direction)
    }

    #[inline]
    pub unsafe fn set_v_size_flags(&mut self, flags: i64) -> () {
        Control_set_v_size_flags(self.this, flags)
    }

    #[inline]
    pub unsafe fn show_modal(&mut self, exclusive: bool) -> () {
        Control_show_modal(self.this, exclusive)
    }

    #[inline]
    pub unsafe fn warp_mouse(&mut self, to_position: Vector2) -> () {
        Control_warp_mouse(self.this, to_position)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConvexPolygonShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_convexpolygonshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ConvexPolygonShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConvexPolygonShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConvexPolygonShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConvexPolygonShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ConvexPolygonShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_points(&self) -> Vector3Array {
        unsafe { ConvexPolygonShape_get_points(self.this) }
    }

    #[inline]
    pub fn set_points(&mut self, points: Vector3Array) -> () {
        unsafe { ConvexPolygonShape_set_points(self.this, points) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ConvexPolygonShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_convexpolygonshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ConvexPolygonShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ConvexPolygonShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ConvexPolygonShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ConvexPolygonShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ConvexPolygonShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_points(&self) -> Vector2Array {
        unsafe { ConvexPolygonShape2D_get_points(self.this) }
    }

    #[inline]
    pub fn set_point_cloud(&mut self, point_cloud: Vector2Array) -> () {
        unsafe { ConvexPolygonShape2D_set_point_cloud(self.this, point_cloud) }
    }

    #[inline]
    pub fn set_points(&mut self, points: Vector2Array) -> () {
        unsafe { ConvexPolygonShape2D_set_points(self.this, points) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Crypto` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_crypto.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Crypto inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Crypto {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Crypto {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CryptoMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Crypto {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn generate_random_bytes(&mut self, size: i64) -> ByteArray {
        unsafe { Crypto_generate_random_bytes(self.this, size) }
    }

    #[inline]
    pub fn generate_rsa(&mut self, size: i64) -> Option<CryptoKey> {
        unsafe { Crypto_generate_rsa(self.this, size) }
    }

    #[inline]
    pub fn generate_self_signed_certificate(&mut self, key: Option<CryptoKey>, issuer_name: GodotString, not_before: GodotString, not_after: GodotString) -> Option<X509Certificate> {
        unsafe { Crypto_generate_self_signed_certificate(self.this, key, issuer_name, not_before, not_after) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CryptoKey` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cryptokey.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CryptoKey inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CryptoKey {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CryptoKey {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CryptoKeyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CryptoKey {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { CryptoKey_load(self.this, path) }
    }

    #[inline]
    pub fn save(&mut self, path: GodotString) -> GodotResult {
        unsafe { CryptoKey_save(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CubeMap` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cubemap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CubeMap inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CubeMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CubeMapFlags {
    FlagMipmaps = 1,
    FlagRepeat = 2,
    FlagFilter = 4,
    Default = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CubeMapSide {
    Left = 0,
    Right = 1,
    Bottom = 2,
    Top = 3,
    Front = 4,
    Back = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CubeMapStorage {
    Raw = 0,
    CompressLossy = 1,
    CompressLossless = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl CubeMap {
    pub const FLAG_REPEAT: i64 = 2;
    pub const SIDE_FRONT: i64 = 4;
    pub const SIDE_LEFT: i64 = 0;
    pub const SIDE_TOP: i64 = 3;
    pub const STORAGE_COMPRESS_LOSSLESS: i64 = 2;
    pub const STORAGE_COMPRESS_LOSSY: i64 = 1;
    pub const STORAGE_RAW: i64 = 0;
    pub const SIDE_RIGHT: i64 = 1;
    pub const FLAG_FILTER: i64 = 4;
    pub const SIDE_BACK: i64 = 5;
    pub const FLAGS_DEFAULT: i64 = 7;
    pub const FLAG_MIPMAPS: i64 = 1;
    pub const SIDE_BOTTOM: i64 = 2;
}
impl CubeMap {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CubeMapMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CubeMap {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_flags(&self) -> i64 {
        unsafe { CubeMap_get_flags(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> i64 {
        unsafe { CubeMap_get_height(self.this) }
    }

    #[inline]
    pub fn get_lossy_storage_quality(&self) -> f64 {
        unsafe { CubeMap_get_lossy_storage_quality(self.this) }
    }

    #[inline]
    pub fn get_side(&self, side: i64) -> Option<Image> {
        unsafe { CubeMap_get_side(self.this, side) }
    }

    #[inline]
    pub fn get_storage(&self) -> CubeMapStorage {
        unsafe { CubeMap_get_storage(self.this) }
    }

    #[inline]
    pub fn get_width(&self) -> i64 {
        unsafe { CubeMap_get_width(self.this) }
    }

    #[inline]
    pub fn set_flags(&mut self, flags: i64) -> () {
        unsafe { CubeMap_set_flags(self.this, flags) }
    }

    #[inline]
    pub fn set_lossy_storage_quality(&mut self, quality: f64) -> () {
        unsafe { CubeMap_set_lossy_storage_quality(self.this, quality) }
    }

    #[inline]
    pub fn set_side(&mut self, side: i64, image: Option<Image>) -> () {
        unsafe { CubeMap_set_side(self.this, side, image) }
    }

    #[inline]
    pub fn set_storage(&mut self, mode: i64) -> () {
        unsafe { CubeMap_set_storage(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CubeMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cubemesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CubeMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CubeMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CubeMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CubeMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CubeMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_size(&self) -> Vector3 {
        unsafe { CubeMesh_get_size(self.this) }
    }

    #[inline]
    pub fn get_subdivide_depth(&self) -> i64 {
        unsafe { CubeMesh_get_subdivide_depth(self.this) }
    }

    #[inline]
    pub fn get_subdivide_height(&self) -> i64 {
        unsafe { CubeMesh_get_subdivide_height(self.this) }
    }

    #[inline]
    pub fn get_subdivide_width(&self) -> i64 {
        unsafe { CubeMesh_get_subdivide_width(self.this) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector3) -> () {
        unsafe { CubeMesh_set_size(self.this, size) }
    }

    #[inline]
    pub fn set_subdivide_depth(&mut self, divisions: i64) -> () {
        unsafe { CubeMesh_set_subdivide_depth(self.this, divisions) }
    }

    #[inline]
    pub fn set_subdivide_height(&mut self, divisions: i64) -> () {
        unsafe { CubeMesh_set_subdivide_height(self.this, divisions) }
    }

    #[inline]
    pub fn set_subdivide_width(&mut self, subdivide: i64) -> () {
        unsafe { CubeMesh_set_subdivide_width(self.this, subdivide) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Curve` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_curve.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Curve inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Curve {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum CurveTangentMode {
    Free = 0,
    Linear = 1,
    ModeCount = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Curve {
    pub const TANGENT_FREE: i64 = 0;
    pub const TANGENT_MODE_COUNT: i64 = 2;
    pub const TANGENT_LINEAR: i64 = 1;
}
impl Curve {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CurveMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Curve {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> VariantArray {
        unsafe { Curve__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, data: VariantArray) -> () {
        unsafe { Curve__set_data(self.this, data) }
    }

    #[inline]
    pub fn add_point(&mut self, position: Vector2, left_tangent: f64, right_tangent: f64, left_mode: i64, right_mode: i64) -> i64 {
        unsafe { Curve_add_point(self.this, position, left_tangent, right_tangent, left_mode, right_mode) }
    }

    #[inline]
    pub fn bake(&mut self) -> () {
        unsafe { Curve_bake(self.this) }
    }

    #[inline]
    pub fn clean_dupes(&mut self) -> () {
        unsafe { Curve_clean_dupes(self.this) }
    }

    #[inline]
    pub fn clear_points(&mut self) -> () {
        unsafe { Curve_clear_points(self.this) }
    }

    #[inline]
    pub fn get_bake_resolution(&self) -> i64 {
        unsafe { Curve_get_bake_resolution(self.this) }
    }

    #[inline]
    pub fn get_max_value(&self) -> f64 {
        unsafe { Curve_get_max_value(self.this) }
    }

    #[inline]
    pub fn get_min_value(&self) -> f64 {
        unsafe { Curve_get_min_value(self.this) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { Curve_get_point_count(self.this) }
    }

    #[inline]
    pub fn get_point_left_mode(&self, index: i64) -> CurveTangentMode {
        unsafe { Curve_get_point_left_mode(self.this, index) }
    }

    #[inline]
    pub fn get_point_left_tangent(&self, index: i64) -> f64 {
        unsafe { Curve_get_point_left_tangent(self.this, index) }
    }

    #[inline]
    pub fn get_point_position(&self, index: i64) -> Vector2 {
        unsafe { Curve_get_point_position(self.this, index) }
    }

    #[inline]
    pub fn get_point_right_mode(&self, index: i64) -> CurveTangentMode {
        unsafe { Curve_get_point_right_mode(self.this, index) }
    }

    #[inline]
    pub fn get_point_right_tangent(&self, index: i64) -> f64 {
        unsafe { Curve_get_point_right_tangent(self.this, index) }
    }

    #[inline]
    pub fn interpolate(&self, offset: f64) -> f64 {
        unsafe { Curve_interpolate(self.this, offset) }
    }

    #[inline]
    pub fn interpolate_baked(&mut self, offset: f64) -> f64 {
        unsafe { Curve_interpolate_baked(self.this, offset) }
    }

    #[inline]
    pub fn remove_point(&mut self, index: i64) -> () {
        unsafe { Curve_remove_point(self.this, index) }
    }

    #[inline]
    pub fn set_bake_resolution(&mut self, resolution: i64) -> () {
        unsafe { Curve_set_bake_resolution(self.this, resolution) }
    }

    #[inline]
    pub fn set_max_value(&mut self, max: f64) -> () {
        unsafe { Curve_set_max_value(self.this, max) }
    }

    #[inline]
    pub fn set_min_value(&mut self, min: f64) -> () {
        unsafe { Curve_set_min_value(self.this, min) }
    }

    #[inline]
    pub fn set_point_left_mode(&mut self, index: i64, mode: i64) -> () {
        unsafe { Curve_set_point_left_mode(self.this, index, mode) }
    }

    #[inline]
    pub fn set_point_left_tangent(&mut self, index: i64, tangent: f64) -> () {
        unsafe { Curve_set_point_left_tangent(self.this, index, tangent) }
    }

    #[inline]
    pub fn set_point_offset(&mut self, index: i64, offset: f64) -> i64 {
        unsafe { Curve_set_point_offset(self.this, index, offset) }
    }

    #[inline]
    pub fn set_point_right_mode(&mut self, index: i64, mode: i64) -> () {
        unsafe { Curve_set_point_right_mode(self.this, index, mode) }
    }

    #[inline]
    pub fn set_point_right_tangent(&mut self, index: i64, tangent: f64) -> () {
        unsafe { Curve_set_point_right_tangent(self.this, index, tangent) }
    }

    #[inline]
    pub fn set_point_value(&mut self, index: i64, y: f64) -> () {
        unsafe { Curve_set_point_value(self.this, index, y) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Curve2D` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_curve2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Curve2D inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Curve2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Curve2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Curve2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Curve2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { Curve2D__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, arg0: Dictionary) -> () {
        unsafe { Curve2D__set_data(self.this, arg0) }
    }

    #[inline]
    pub fn add_point(&mut self, position: Vector2, _in: Vector2, out: Vector2, at_position: i64) -> () {
        unsafe { Curve2D_add_point(self.this, position, _in, out, at_position) }
    }

    #[inline]
    pub fn clear_points(&mut self) -> () {
        unsafe { Curve2D_clear_points(self.this) }
    }

    #[inline]
    pub fn get_bake_interval(&self) -> f64 {
        unsafe { Curve2D_get_bake_interval(self.this) }
    }

    #[inline]
    pub fn get_baked_length(&self) -> f64 {
        unsafe { Curve2D_get_baked_length(self.this) }
    }

    #[inline]
    pub fn get_baked_points(&self) -> Vector2Array {
        unsafe { Curve2D_get_baked_points(self.this) }
    }

    #[inline]
    pub fn get_closest_offset(&self, to_point: Vector2) -> f64 {
        unsafe { Curve2D_get_closest_offset(self.this, to_point) }
    }

    #[inline]
    pub fn get_closest_point(&self, to_point: Vector2) -> Vector2 {
        unsafe { Curve2D_get_closest_point(self.this, to_point) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { Curve2D_get_point_count(self.this) }
    }

    #[inline]
    pub fn get_point_in(&self, idx: i64) -> Vector2 {
        unsafe { Curve2D_get_point_in(self.this, idx) }
    }

    #[inline]
    pub fn get_point_out(&self, idx: i64) -> Vector2 {
        unsafe { Curve2D_get_point_out(self.this, idx) }
    }

    #[inline]
    pub fn get_point_position(&self, idx: i64) -> Vector2 {
        unsafe { Curve2D_get_point_position(self.this, idx) }
    }

    #[inline]
    pub fn interpolate(&self, idx: i64, t: f64) -> Vector2 {
        unsafe { Curve2D_interpolate(self.this, idx, t) }
    }

    #[inline]
    pub fn interpolate_baked(&self, offset: f64, cubic: bool) -> Vector2 {
        unsafe { Curve2D_interpolate_baked(self.this, offset, cubic) }
    }

    #[inline]
    pub fn interpolatef(&self, fofs: f64) -> Vector2 {
        unsafe { Curve2D_interpolatef(self.this, fofs) }
    }

    #[inline]
    pub fn remove_point(&mut self, idx: i64) -> () {
        unsafe { Curve2D_remove_point(self.this, idx) }
    }

    #[inline]
    pub fn set_bake_interval(&mut self, distance: f64) -> () {
        unsafe { Curve2D_set_bake_interval(self.this, distance) }
    }

    #[inline]
    pub fn set_point_in(&mut self, idx: i64, position: Vector2) -> () {
        unsafe { Curve2D_set_point_in(self.this, idx, position) }
    }

    #[inline]
    pub fn set_point_out(&mut self, idx: i64, position: Vector2) -> () {
        unsafe { Curve2D_set_point_out(self.this, idx, position) }
    }

    #[inline]
    pub fn set_point_position(&mut self, idx: i64, position: Vector2) -> () {
        unsafe { Curve2D_set_point_position(self.this, idx, position) }
    }

    #[inline]
    pub fn tessellate(&self, max_stages: i64, tolerance_degrees: f64) -> Vector2Array {
        unsafe { Curve2D_tessellate(self.this, max_stages, tolerance_degrees) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Curve3D` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_curve3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Curve3D inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Curve3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Curve3D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Curve3DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Curve3D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { Curve3D__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, arg0: Dictionary) -> () {
        unsafe { Curve3D__set_data(self.this, arg0) }
    }

    #[inline]
    pub fn add_point(&mut self, position: Vector3, _in: Vector3, out: Vector3, at_position: i64) -> () {
        unsafe { Curve3D_add_point(self.this, position, _in, out, at_position) }
    }

    #[inline]
    pub fn clear_points(&mut self) -> () {
        unsafe { Curve3D_clear_points(self.this) }
    }

    #[inline]
    pub fn get_bake_interval(&self) -> f64 {
        unsafe { Curve3D_get_bake_interval(self.this) }
    }

    #[inline]
    pub fn get_baked_length(&self) -> f64 {
        unsafe { Curve3D_get_baked_length(self.this) }
    }

    #[inline]
    pub fn get_baked_points(&self) -> Vector3Array {
        unsafe { Curve3D_get_baked_points(self.this) }
    }

    #[inline]
    pub fn get_baked_tilts(&self) -> Float32Array {
        unsafe { Curve3D_get_baked_tilts(self.this) }
    }

    #[inline]
    pub fn get_baked_up_vectors(&self) -> Vector3Array {
        unsafe { Curve3D_get_baked_up_vectors(self.this) }
    }

    #[inline]
    pub fn get_closest_offset(&self, to_point: Vector3) -> f64 {
        unsafe { Curve3D_get_closest_offset(self.this, to_point) }
    }

    #[inline]
    pub fn get_closest_point(&self, to_point: Vector3) -> Vector3 {
        unsafe { Curve3D_get_closest_point(self.this, to_point) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { Curve3D_get_point_count(self.this) }
    }

    #[inline]
    pub fn get_point_in(&self, idx: i64) -> Vector3 {
        unsafe { Curve3D_get_point_in(self.this, idx) }
    }

    #[inline]
    pub fn get_point_out(&self, idx: i64) -> Vector3 {
        unsafe { Curve3D_get_point_out(self.this, idx) }
    }

    #[inline]
    pub fn get_point_position(&self, idx: i64) -> Vector3 {
        unsafe { Curve3D_get_point_position(self.this, idx) }
    }

    #[inline]
    pub fn get_point_tilt(&self, idx: i64) -> f64 {
        unsafe { Curve3D_get_point_tilt(self.this, idx) }
    }

    #[inline]
    pub fn interpolate(&self, idx: i64, t: f64) -> Vector3 {
        unsafe { Curve3D_interpolate(self.this, idx, t) }
    }

    #[inline]
    pub fn interpolate_baked(&self, offset: f64, cubic: bool) -> Vector3 {
        unsafe { Curve3D_interpolate_baked(self.this, offset, cubic) }
    }

    #[inline]
    pub fn interpolate_baked_up_vector(&self, offset: f64, apply_tilt: bool) -> Vector3 {
        unsafe { Curve3D_interpolate_baked_up_vector(self.this, offset, apply_tilt) }
    }

    #[inline]
    pub fn interpolatef(&self, fofs: f64) -> Vector3 {
        unsafe { Curve3D_interpolatef(self.this, fofs) }
    }

    #[inline]
    pub fn is_up_vector_enabled(&self) -> bool {
        unsafe { Curve3D_is_up_vector_enabled(self.this) }
    }

    #[inline]
    pub fn remove_point(&mut self, idx: i64) -> () {
        unsafe { Curve3D_remove_point(self.this, idx) }
    }

    #[inline]
    pub fn set_bake_interval(&mut self, distance: f64) -> () {
        unsafe { Curve3D_set_bake_interval(self.this, distance) }
    }

    #[inline]
    pub fn set_point_in(&mut self, idx: i64, position: Vector3) -> () {
        unsafe { Curve3D_set_point_in(self.this, idx, position) }
    }

    #[inline]
    pub fn set_point_out(&mut self, idx: i64, position: Vector3) -> () {
        unsafe { Curve3D_set_point_out(self.this, idx, position) }
    }

    #[inline]
    pub fn set_point_position(&mut self, idx: i64, position: Vector3) -> () {
        unsafe { Curve3D_set_point_position(self.this, idx, position) }
    }

    #[inline]
    pub fn set_point_tilt(&mut self, idx: i64, tilt: f64) -> () {
        unsafe { Curve3D_set_point_tilt(self.this, idx, tilt) }
    }

    #[inline]
    pub fn set_up_vector_enabled(&mut self, enable: bool) -> () {
        unsafe { Curve3D_set_up_vector_enabled(self.this, enable) }
    }

    #[inline]
    pub fn tessellate(&self, max_stages: i64, tolerance_degrees: f64) -> Vector3Array {
        unsafe { Curve3D_tessellate(self.this, max_stages, tolerance_degrees) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CurveTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_curvetexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CurveTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CurveTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CurveTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CurveTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CurveTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _update(&mut self) -> () {
        unsafe { CurveTexture__update(self.this) }
    }

    #[inline]
    pub fn get_curve(&self) -> Option<Curve> {
        unsafe { CurveTexture_get_curve(self.this) }
    }

    #[inline]
    pub fn set_curve(&mut self, curve: Option<Curve>) -> () {
        unsafe { CurveTexture_set_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_width(&mut self, width: i64) -> () {
        unsafe { CurveTexture_set_width(self.this, width) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CylinderMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cylindermesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CylinderMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CylinderMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CylinderMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CylinderMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CylinderMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_bottom_radius(&self) -> f64 {
        unsafe { CylinderMesh_get_bottom_radius(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { CylinderMesh_get_height(self.this) }
    }

    #[inline]
    pub fn get_radial_segments(&self) -> i64 {
        unsafe { CylinderMesh_get_radial_segments(self.this) }
    }

    #[inline]
    pub fn get_rings(&self) -> i64 {
        unsafe { CylinderMesh_get_rings(self.this) }
    }

    #[inline]
    pub fn get_top_radius(&self) -> f64 {
        unsafe { CylinderMesh_get_top_radius(self.this) }
    }

    #[inline]
    pub fn set_bottom_radius(&mut self, radius: f64) -> () {
        unsafe { CylinderMesh_set_bottom_radius(self.this, radius) }
    }

    #[inline]
    pub fn set_height(&mut self, height: f64) -> () {
        unsafe { CylinderMesh_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_radial_segments(&mut self, segments: i64) -> () {
        unsafe { CylinderMesh_set_radial_segments(self.this, segments) }
    }

    #[inline]
    pub fn set_rings(&mut self, rings: i64) -> () {
        unsafe { CylinderMesh_set_rings(self.this, rings) }
    }

    #[inline]
    pub fn set_top_radius(&mut self, radius: f64) -> () {
        unsafe { CylinderMesh_set_top_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class CylinderShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_cylindershape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// CylinderShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct CylinderShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl CylinderShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = CylinderShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            CylinderShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { CylinderShape_get_height(self.this) }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { CylinderShape_get_radius(self.this) }
    }

    #[inline]
    pub fn set_height(&mut self, height: f64) -> () {
        unsafe { CylinderShape_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { CylinderShape_set_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class DampedSpringJoint2D` inherits `Joint2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_dampedspringjoint2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `DampedSpringJoint2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `DampedSpringJoint2D::free`.
///
/// ## Class hierarchy
///
/// DampedSpringJoint2D inherits methods from:
/// - [Joint2D](struct.Joint2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct DampedSpringJoint2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl DampedSpringJoint2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `DampedSpringJoint2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = DampedSpringJoint2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            DampedSpringJoint2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_damping(&self) -> f64 {
        DampedSpringJoint2D_get_damping(self.this)
    }

    #[inline]
    pub unsafe fn get_length(&self) -> f64 {
        DampedSpringJoint2D_get_length(self.this)
    }

    #[inline]
    pub unsafe fn get_rest_length(&self) -> f64 {
        DampedSpringJoint2D_get_rest_length(self.this)
    }

    #[inline]
    pub unsafe fn get_stiffness(&self) -> f64 {
        DampedSpringJoint2D_get_stiffness(self.this)
    }

    #[inline]
    pub unsafe fn set_damping(&mut self, damping: f64) -> () {
        DampedSpringJoint2D_set_damping(self.this, damping)
    }

    #[inline]
    pub unsafe fn set_length(&mut self, length: f64) -> () {
        DampedSpringJoint2D_set_length(self.this, length)
    }

    #[inline]
    pub unsafe fn set_rest_length(&mut self, rest_length: f64) -> () {
        DampedSpringJoint2D_set_rest_length(self.this, rest_length)
    }

    #[inline]
    pub unsafe fn set_stiffness(&mut self, stiffness: f64) -> () {
        DampedSpringJoint2D_set_stiffness(self.this, stiffness)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint_2d(&self) -> Joint2D {
        // Not reference-counted.
        Joint2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class DirectionalLight` inherits `Light` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_directionallight.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `DirectionalLight` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `DirectionalLight::free`.
///
/// ## Class hierarchy
///
/// DirectionalLight inherits methods from:
/// - [Light](struct.Light.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct DirectionalLight {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum DirectionalLightShadowMode {
    Orthogonal = 0,
    Parallel2Splits = 1,
    Parallel4Splits = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum DirectionalLightShadowDepthRange {
    Stable = 0,
    Optimized = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl DirectionalLight {
    pub const SHADOW_PARALLEL_2_SPLITS: i64 = 1;
    pub const SHADOW_ORTHOGONAL: i64 = 0;
    pub const SHADOW_DEPTH_RANGE_OPTIMIZED: i64 = 1;
    pub const SHADOW_PARALLEL_4_SPLITS: i64 = 2;
    pub const SHADOW_DEPTH_RANGE_STABLE: i64 = 0;
}
impl DirectionalLight {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `DirectionalLight::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = DirectionalLightMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            DirectionalLight {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_shadow_depth_range(&self) -> DirectionalLightShadowDepthRange {
        DirectionalLight_get_shadow_depth_range(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_mode(&self) -> DirectionalLightShadowMode {
        DirectionalLight_get_shadow_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_blend_splits_enabled(&self) -> bool {
        DirectionalLight_is_blend_splits_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_blend_splits(&mut self, enabled: bool) -> () {
        DirectionalLight_set_blend_splits(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_shadow_depth_range(&mut self, mode: i64) -> () {
        DirectionalLight_set_shadow_depth_range(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_shadow_mode(&mut self, mode: i64) -> () {
        DirectionalLight_set_shadow_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_light(&self) -> Light {
        // Not reference-counted.
        Light { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class DynamicFont` inherits `Font` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_dynamicfont.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// DynamicFont inherits methods from:
/// - [Font](struct.Font.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct DynamicFont {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum DynamicFontSpacingType {
    SpacingTop = 0,
    SpacingBottom = 1,
    SpacingChar = 2,
    SpacingSpace = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl DynamicFont {
    pub const SPACING_SPACE: i64 = 3;
    pub const SPACING_CHAR: i64 = 2;
    pub const SPACING_BOTTOM: i64 = 1;
    pub const SPACING_TOP: i64 = 0;
}
impl DynamicFont {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = DynamicFontMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            DynamicFont {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_fallback(&mut self, data: Option<DynamicFontData>) -> () {
        unsafe { DynamicFont_add_fallback(self.this, data) }
    }

    #[inline]
    pub fn get_fallback(&self, idx: i64) -> Option<DynamicFontData> {
        unsafe { DynamicFont_get_fallback(self.this, idx) }
    }

    #[inline]
    pub fn get_fallback_count(&self) -> i64 {
        unsafe { DynamicFont_get_fallback_count(self.this) }
    }

    #[inline]
    pub fn get_font_data(&self) -> Option<DynamicFontData> {
        unsafe { DynamicFont_get_font_data(self.this) }
    }

    #[inline]
    pub fn get_outline_color(&self) -> Color {
        unsafe { DynamicFont_get_outline_color(self.this) }
    }

    #[inline]
    pub fn get_outline_size(&self) -> i64 {
        unsafe { DynamicFont_get_outline_size(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> i64 {
        unsafe { DynamicFont_get_size(self.this) }
    }

    #[inline]
    pub fn get_spacing(&self, _type: i64) -> i64 {
        unsafe { DynamicFont_get_spacing(self.this, _type) }
    }

    #[inline]
    pub fn get_use_filter(&self) -> bool {
        unsafe { DynamicFont_get_use_filter(self.this) }
    }

    #[inline]
    pub fn get_use_mipmaps(&self) -> bool {
        unsafe { DynamicFont_get_use_mipmaps(self.this) }
    }

    #[inline]
    pub fn remove_fallback(&mut self, idx: i64) -> () {
        unsafe { DynamicFont_remove_fallback(self.this, idx) }
    }

    #[inline]
    pub fn set_fallback(&mut self, idx: i64, data: Option<DynamicFontData>) -> () {
        unsafe { DynamicFont_set_fallback(self.this, idx, data) }
    }

    #[inline]
    pub fn set_font_data(&mut self, data: Option<DynamicFontData>) -> () {
        unsafe { DynamicFont_set_font_data(self.this, data) }
    }

    #[inline]
    pub fn set_outline_color(&mut self, color: Color) -> () {
        unsafe { DynamicFont_set_outline_color(self.this, color) }
    }

    #[inline]
    pub fn set_outline_size(&mut self, size: i64) -> () {
        unsafe { DynamicFont_set_outline_size(self.this, size) }
    }

    #[inline]
    pub fn set_size(&mut self, data: i64) -> () {
        unsafe { DynamicFont_set_size(self.this, data) }
    }

    #[inline]
    pub fn set_spacing(&mut self, _type: i64, value: i64) -> () {
        unsafe { DynamicFont_set_spacing(self.this, _type, value) }
    }

    #[inline]
    pub fn set_use_filter(&mut self, enable: bool) -> () {
        unsafe { DynamicFont_set_use_filter(self.this, enable) }
    }

    #[inline]
    pub fn set_use_mipmaps(&mut self, enable: bool) -> () {
        unsafe { DynamicFont_set_use_mipmaps(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_font(&self) -> Font {
        unsafe {{ object::add_ref(self.this); }}
        Font { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class DynamicFontData` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_dynamicfontdata.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// DynamicFontData inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct DynamicFontData {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum DynamicFontDataHinting {
    None = 0,
    Light = 1,
    Normal = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl DynamicFontData {
    pub const HINTING_NONE: i64 = 0;
    pub const HINTING_LIGHT: i64 = 1;
    pub const HINTING_NORMAL: i64 = 2;
}
impl DynamicFontData {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = DynamicFontDataMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            DynamicFontData {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_font_path(&self) -> GodotString {
        unsafe { DynamicFontData_get_font_path(self.this) }
    }

    #[inline]
    pub fn get_hinting(&self) -> DynamicFontDataHinting {
        unsafe { DynamicFontData_get_hinting(self.this) }
    }

    #[inline]
    pub fn is_antialiased(&self) -> bool {
        unsafe { DynamicFontData_is_antialiased(self.this) }
    }

    #[inline]
    pub fn set_antialiased(&mut self, antialiased: bool) -> () {
        unsafe { DynamicFontData_set_antialiased(self.this, antialiased) }
    }

    #[inline]
    pub fn set_font_path(&mut self, path: GodotString) -> () {
        unsafe { DynamicFontData_set_font_path(self.this, path) }
    }

    #[inline]
    pub fn set_hinting(&mut self, mode: i64) -> () {
        unsafe { DynamicFontData_set_hinting(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorExportPlugin` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorexportplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorExportPlugin inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorExportPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorExportPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _export_begin(&mut self, features: StringArray, is_debug: bool, path: GodotString, flags: i64) -> () {
        unsafe { EditorExportPlugin__export_begin(self.this, features, is_debug, path, flags) }
    }

    #[inline]
    pub fn _export_end(&mut self) -> () {
        unsafe { EditorExportPlugin__export_end(self.this) }
    }

    #[inline]
    pub fn _export_file(&mut self, path: GodotString, _type: GodotString, features: StringArray) -> () {
        unsafe { EditorExportPlugin__export_file(self.this, path, _type, features) }
    }

    #[inline]
    pub fn add_file(&mut self, path: GodotString, file: ByteArray, remap: bool) -> () {
        unsafe { EditorExportPlugin_add_file(self.this, path, file, remap) }
    }

    #[inline]
    pub fn add_ios_bundle_file(&mut self, path: GodotString) -> () {
        unsafe { EditorExportPlugin_add_ios_bundle_file(self.this, path) }
    }

    #[inline]
    pub fn add_ios_cpp_code(&mut self, code: GodotString) -> () {
        unsafe { EditorExportPlugin_add_ios_cpp_code(self.this, code) }
    }

    #[inline]
    pub fn add_ios_framework(&mut self, path: GodotString) -> () {
        unsafe { EditorExportPlugin_add_ios_framework(self.this, path) }
    }

    #[inline]
    pub fn add_ios_linker_flags(&mut self, flags: GodotString) -> () {
        unsafe { EditorExportPlugin_add_ios_linker_flags(self.this, flags) }
    }

    #[inline]
    pub fn add_ios_plist_content(&mut self, plist_content: GodotString) -> () {
        unsafe { EditorExportPlugin_add_ios_plist_content(self.this, plist_content) }
    }

    #[inline]
    pub fn add_shared_object(&mut self, path: GodotString, tags: StringArray) -> () {
        unsafe { EditorExportPlugin_add_shared_object(self.this, path, tags) }
    }

    #[inline]
    pub fn skip(&mut self) -> () {
        unsafe { EditorExportPlugin_skip(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorFeatureProfile` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorfeatureprofile.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorFeatureProfile inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorFeatureProfile {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorFeatureProfileFeature {
    Feature3d = 0,
    Script = 1,
    AssetLib = 2,
    SceneTree = 3,
    ImportDock = 4,
    NodeDock = 5,
    FilesystemDock = 6,
    Max = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl EditorFeatureProfile {
    pub const FEATURE_3D: i64 = 0;
    pub const FEATURE_MAX: i64 = 7;
    pub const FEATURE_NODE_DOCK: i64 = 5;
    pub const FEATURE_ASSET_LIB: i64 = 2;
    pub const FEATURE_FILESYSTEM_DOCK: i64 = 6;
    pub const FEATURE_IMPORT_DOCK: i64 = 4;
    pub const FEATURE_SCENE_TREE: i64 = 3;
    pub const FEATURE_SCRIPT: i64 = 1;
}
impl EditorFeatureProfile {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_feature_name(&mut self, feature: i64) -> GodotString {
        unsafe { EditorFeatureProfile_get_feature_name(self.this, feature) }
    }

    #[inline]
    pub fn is_class_disabled(&self, class_name: GodotString) -> bool {
        unsafe { EditorFeatureProfile_is_class_disabled(self.this, class_name) }
    }

    #[inline]
    pub fn is_class_editor_disabled(&self, class_name: GodotString) -> bool {
        unsafe { EditorFeatureProfile_is_class_editor_disabled(self.this, class_name) }
    }

    #[inline]
    pub fn is_class_property_disabled(&self, class_name: GodotString, property: GodotString) -> bool {
        unsafe { EditorFeatureProfile_is_class_property_disabled(self.this, class_name, property) }
    }

    #[inline]
    pub fn is_feature_disabled(&self, feature: i64) -> bool {
        unsafe { EditorFeatureProfile_is_feature_disabled(self.this, feature) }
    }

    #[inline]
    pub fn load_from_file(&mut self, path: GodotString) -> GodotResult {
        unsafe { EditorFeatureProfile_load_from_file(self.this, path) }
    }

    #[inline]
    pub fn save_to_file(&mut self, path: GodotString) -> GodotResult {
        unsafe { EditorFeatureProfile_save_to_file(self.this, path) }
    }

    #[inline]
    pub fn set_disable_class(&mut self, class_name: GodotString, disable: bool) -> () {
        unsafe { EditorFeatureProfile_set_disable_class(self.this, class_name, disable) }
    }

    #[inline]
    pub fn set_disable_class_editor(&mut self, class_name: GodotString, disable: bool) -> () {
        unsafe { EditorFeatureProfile_set_disable_class_editor(self.this, class_name, disable) }
    }

    #[inline]
    pub fn set_disable_class_property(&mut self, class_name: GodotString, property: GodotString, disable: bool) -> () {
        unsafe { EditorFeatureProfile_set_disable_class_property(self.this, class_name, property, disable) }
    }

    #[inline]
    pub fn set_disable_feature(&mut self, feature: i64, disable: bool) -> () {
        unsafe { EditorFeatureProfile_set_disable_feature(self.this, feature, disable) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorFileDialog` inherits `ConfirmationDialog` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorfiledialog.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorFileDialog inherits methods from:
/// - [ConfirmationDialog](struct.ConfirmationDialog.html)
/// - [AcceptDialog](struct.AcceptDialog.html)
/// - [WindowDialog](struct.WindowDialog.html)
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorFileDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorFileDialogDisplayMode {
    Thumbnails = 0,
    List = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorFileDialogMode {
    ModeOpenFile = 0,
    ModeOpenFiles = 1,
    ModeOpenDir = 2,
    ModeOpenAny = 3,
    ModeSaveFile = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorFileDialogAccess {
    Resources = 0,
    Userdata = 1,
    Filesystem = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl EditorFileDialog {
    pub const DISPLAY_LIST: i64 = 1;
    pub const ACCESS_USERDATA: i64 = 1;
    pub const ACCESS_FILESYSTEM: i64 = 2;
    pub const MODE_OPEN_ANY: i64 = 3;
    pub const DISPLAY_THUMBNAILS: i64 = 0;
    pub const ACCESS_RESOURCES: i64 = 0;
    pub const MODE_OPEN_FILES: i64 = 1;
    pub const MODE_OPEN_FILE: i64 = 0;
    pub const MODE_SAVE_FILE: i64 = 4;
    pub const MODE_OPEN_DIR: i64 = 2;
}
impl EditorFileDialog {
    #[inline]
    pub unsafe fn _action_pressed(&mut self) -> () {
        EditorFileDialog__action_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _cancel_pressed(&mut self) -> () {
        EditorFileDialog__cancel_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _dir_entered(&mut self, arg0: GodotString) -> () {
        EditorFileDialog__dir_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _favorite_move_down(&mut self) -> () {
        EditorFileDialog__favorite_move_down(self.this)
    }

    #[inline]
    pub unsafe fn _favorite_move_up(&mut self) -> () {
        EditorFileDialog__favorite_move_up(self.this)
    }

    #[inline]
    pub unsafe fn _favorite_pressed(&mut self) -> () {
        EditorFileDialog__favorite_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _favorite_selected(&mut self, arg0: i64) -> () {
        EditorFileDialog__favorite_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _file_entered(&mut self, arg0: GodotString) -> () {
        EditorFileDialog__file_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _filter_selected(&mut self, arg0: i64) -> () {
        EditorFileDialog__filter_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _go_back(&mut self) -> () {
        EditorFileDialog__go_back(self.this)
    }

    #[inline]
    pub unsafe fn _go_forward(&mut self) -> () {
        EditorFileDialog__go_forward(self.this)
    }

    #[inline]
    pub unsafe fn _go_up(&mut self) -> () {
        EditorFileDialog__go_up(self.this)
    }

    #[inline]
    pub unsafe fn _item_db_selected(&mut self, arg0: i64) -> () {
        EditorFileDialog__item_db_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _item_list_item_rmb_selected(&mut self, arg0: i64, arg1: Vector2) -> () {
        EditorFileDialog__item_list_item_rmb_selected(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _item_list_rmb_clicked(&mut self, arg0: Vector2) -> () {
        EditorFileDialog__item_list_rmb_clicked(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _item_menu_id_pressed(&mut self, arg0: i64) -> () {
        EditorFileDialog__item_menu_id_pressed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _item_selected(&mut self, arg0: i64) -> () {
        EditorFileDialog__item_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _items_clear_selection(&mut self) -> () {
        EditorFileDialog__items_clear_selection(self.this)
    }

    #[inline]
    pub unsafe fn _make_dir(&mut self) -> () {
        EditorFileDialog__make_dir(self.this)
    }

    #[inline]
    pub unsafe fn _make_dir_confirm(&mut self) -> () {
        EditorFileDialog__make_dir_confirm(self.this)
    }

    #[inline]
    pub unsafe fn _multi_selected(&mut self, arg0: i64, arg1: bool) -> () {
        EditorFileDialog__multi_selected(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _recent_selected(&mut self, arg0: i64) -> () {
        EditorFileDialog__recent_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _save_confirm_pressed(&mut self) -> () {
        EditorFileDialog__save_confirm_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _select_drive(&mut self, arg0: i64) -> () {
        EditorFileDialog__select_drive(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _thumbnail_done(&mut self, arg0: GodotString, arg1: Option<Texture>, arg2: Option<Texture>, arg3: Variant) -> () {
        EditorFileDialog__thumbnail_done(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _thumbnail_result(&mut self, arg0: GodotString, arg1: Option<Texture>, arg2: Option<Texture>, arg3: Variant) -> () {
        EditorFileDialog__thumbnail_result(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, arg0: Option<InputEvent>) -> () {
        EditorFileDialog__unhandled_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _update_dir(&mut self) -> () {
        EditorFileDialog__update_dir(self.this)
    }

    #[inline]
    pub unsafe fn _update_file_list(&mut self) -> () {
        EditorFileDialog__update_file_list(self.this)
    }

    #[inline]
    pub unsafe fn _update_file_name(&mut self) -> () {
        EditorFileDialog__update_file_name(self.this)
    }

    #[inline]
    pub unsafe fn add_filter(&mut self, filter: GodotString) -> () {
        EditorFileDialog_add_filter(self.this, filter)
    }

    #[inline]
    pub unsafe fn clear_filters(&mut self) -> () {
        EditorFileDialog_clear_filters(self.this)
    }

    #[inline]
    pub unsafe fn get_access(&self) -> EditorFileDialogAccess {
        EditorFileDialog_get_access(self.this)
    }

    #[inline]
    pub unsafe fn get_current_dir(&self) -> GodotString {
        EditorFileDialog_get_current_dir(self.this)
    }

    #[inline]
    pub unsafe fn get_current_file(&self) -> GodotString {
        EditorFileDialog_get_current_file(self.this)
    }

    #[inline]
    pub unsafe fn get_current_path(&self) -> GodotString {
        EditorFileDialog_get_current_path(self.this)
    }

    #[inline]
    pub unsafe fn get_display_mode(&self) -> EditorFileDialogDisplayMode {
        EditorFileDialog_get_display_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> EditorFileDialogMode {
        EditorFileDialog_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_vbox(&mut self) -> Option<VBoxContainer> {
        EditorFileDialog_get_vbox(self.this)
    }

    #[inline]
    pub unsafe fn invalidate(&mut self) -> () {
        EditorFileDialog_invalidate(self.this)
    }

    #[inline]
    pub unsafe fn is_overwrite_warning_disabled(&self) -> bool {
        EditorFileDialog_is_overwrite_warning_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_showing_hidden_files(&self) -> bool {
        EditorFileDialog_is_showing_hidden_files(self.this)
    }

    #[inline]
    pub unsafe fn set_access(&mut self, access: i64) -> () {
        EditorFileDialog_set_access(self.this, access)
    }

    #[inline]
    pub unsafe fn set_current_dir(&mut self, dir: GodotString) -> () {
        EditorFileDialog_set_current_dir(self.this, dir)
    }

    #[inline]
    pub unsafe fn set_current_file(&mut self, file: GodotString) -> () {
        EditorFileDialog_set_current_file(self.this, file)
    }

    #[inline]
    pub unsafe fn set_current_path(&mut self, path: GodotString) -> () {
        EditorFileDialog_set_current_path(self.this, path)
    }

    #[inline]
    pub unsafe fn set_disable_overwrite_warning(&mut self, disable: bool) -> () {
        EditorFileDialog_set_disable_overwrite_warning(self.this, disable)
    }

    #[inline]
    pub unsafe fn set_display_mode(&mut self, mode: i64) -> () {
        EditorFileDialog_set_display_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        EditorFileDialog_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_show_hidden_files(&mut self, show: bool) -> () {
        EditorFileDialog_set_show_hidden_files(self.this, show)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_confirmation_dialog(&self) -> ConfirmationDialog {
        // Not reference-counted.
        ConfirmationDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_accept_dialog(&self) -> AcceptDialog {
        // Not reference-counted.
        AcceptDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_window_dialog(&self) -> WindowDialog {
        // Not reference-counted.
        WindowDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorFileSystem` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorfilesystem.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorFileSystem inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorFileSystem {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorFileSystem {
    #[inline]
    pub unsafe fn get_file_type(&self, path: GodotString) -> GodotString {
        EditorFileSystem_get_file_type(self.this, path)
    }

    #[inline]
    pub unsafe fn get_filesystem(&mut self) -> Option<EditorFileSystemDirectory> {
        EditorFileSystem_get_filesystem(self.this)
    }

    #[inline]
    pub unsafe fn get_filesystem_path(&mut self, path: GodotString) -> Option<EditorFileSystemDirectory> {
        EditorFileSystem_get_filesystem_path(self.this, path)
    }

    #[inline]
    pub unsafe fn get_scanning_progress(&self) -> f64 {
        EditorFileSystem_get_scanning_progress(self.this)
    }

    #[inline]
    pub unsafe fn is_scanning(&self) -> bool {
        EditorFileSystem_is_scanning(self.this)
    }

    #[inline]
    pub unsafe fn scan(&mut self) -> () {
        EditorFileSystem_scan(self.this)
    }

    #[inline]
    pub unsafe fn scan_sources(&mut self) -> () {
        EditorFileSystem_scan_sources(self.this)
    }

    #[inline]
    pub unsafe fn update_file(&mut self, path: GodotString) -> () {
        EditorFileSystem_update_file(self.this, path)
    }

    #[inline]
    pub unsafe fn update_script_classes(&mut self) -> () {
        EditorFileSystem_update_script_classes(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorFileSystemDirectory` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorfilesystemdirectory.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorFileSystemDirectory inherits methods from:
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorFileSystemDirectory {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorFileSystemDirectory {
    #[inline]
    pub unsafe fn find_dir_index(&self, name: GodotString) -> i64 {
        EditorFileSystemDirectory_find_dir_index(self.this, name)
    }

    #[inline]
    pub unsafe fn find_file_index(&self, name: GodotString) -> i64 {
        EditorFileSystemDirectory_find_file_index(self.this, name)
    }

    #[inline]
    pub unsafe fn get_file(&self, idx: i64) -> GodotString {
        EditorFileSystemDirectory_get_file(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_file_count(&self) -> i64 {
        EditorFileSystemDirectory_get_file_count(self.this)
    }

    #[inline]
    pub unsafe fn get_file_import_is_valid(&self, idx: i64) -> bool {
        EditorFileSystemDirectory_get_file_import_is_valid(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_file_path(&self, idx: i64) -> GodotString {
        EditorFileSystemDirectory_get_file_path(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_file_script_class_extends(&self, idx: i64) -> GodotString {
        EditorFileSystemDirectory_get_file_script_class_extends(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_file_script_class_name(&self, idx: i64) -> GodotString {
        EditorFileSystemDirectory_get_file_script_class_name(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_file_type(&self, idx: i64) -> GodotString {
        EditorFileSystemDirectory_get_file_type(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_name(&mut self) -> GodotString {
        EditorFileSystemDirectory_get_name(self.this)
    }

    #[inline]
    pub unsafe fn get_parent(&mut self) -> Option<EditorFileSystemDirectory> {
        EditorFileSystemDirectory_get_parent(self.this)
    }

    #[inline]
    pub unsafe fn get_path(&self) -> GodotString {
        EditorFileSystemDirectory_get_path(self.this)
    }

    #[inline]
    pub unsafe fn get_subdir(&mut self, idx: i64) -> Option<EditorFileSystemDirectory> {
        EditorFileSystemDirectory_get_subdir(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_subdir_count(&self) -> i64 {
        EditorFileSystemDirectory_get_subdir_count(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorImportPlugin` inherits `ResourceImporter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorimportplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorImportPlugin inherits methods from:
/// - [ResourceImporter](struct.ResourceImporter.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorImportPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorImportPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_import_options(&mut self, preset: i64) -> VariantArray {
        unsafe { EditorImportPlugin_get_import_options(self.this, preset) }
    }

    #[inline]
    pub fn get_import_order(&mut self) -> i64 {
        unsafe { EditorImportPlugin_get_import_order(self.this) }
    }

    #[inline]
    pub fn get_importer_name(&mut self) -> GodotString {
        unsafe { EditorImportPlugin_get_importer_name(self.this) }
    }

    #[inline]
    pub fn get_option_visibility(&mut self, option: GodotString, options: Dictionary) -> bool {
        unsafe { EditorImportPlugin_get_option_visibility(self.this, option, options) }
    }

    #[inline]
    pub fn get_preset_count(&mut self) -> i64 {
        unsafe { EditorImportPlugin_get_preset_count(self.this) }
    }

    #[inline]
    pub fn get_preset_name(&mut self, preset: i64) -> GodotString {
        unsafe { EditorImportPlugin_get_preset_name(self.this, preset) }
    }

    #[inline]
    pub fn get_priority(&mut self) -> f64 {
        unsafe { EditorImportPlugin_get_priority(self.this) }
    }

    #[inline]
    pub fn get_recognized_extensions(&mut self) -> VariantArray {
        unsafe { EditorImportPlugin_get_recognized_extensions(self.this) }
    }

    #[inline]
    pub fn get_resource_type(&mut self) -> GodotString {
        unsafe { EditorImportPlugin_get_resource_type(self.this) }
    }

    #[inline]
    pub fn get_save_extension(&mut self) -> GodotString {
        unsafe { EditorImportPlugin_get_save_extension(self.this) }
    }

    #[inline]
    pub fn get_visible_name(&mut self) -> GodotString {
        unsafe { EditorImportPlugin_get_visible_name(self.this) }
    }

    #[inline]
    pub fn import(&mut self, source_file: GodotString, save_path: GodotString, options: Dictionary, platform_variants: VariantArray, gen_files: VariantArray) -> i64 {
        unsafe { EditorImportPlugin_import(self.this, source_file, save_path, options, platform_variants, gen_files) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource_importer(&self) -> ResourceImporter {
        unsafe {{ object::add_ref(self.this); }}
        ResourceImporter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorInspector` inherits `ScrollContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorinspector.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorInspector inherits methods from:
/// - [ScrollContainer](struct.ScrollContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorInspector {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorInspector {
    #[inline]
    pub unsafe fn _edit_request_change(&mut self, arg0: Option<Object>, arg1: GodotString) -> () {
        EditorInspector__edit_request_change(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _feature_profile_changed(&mut self) -> () {
        EditorInspector__feature_profile_changed(self.this)
    }

    #[inline]
    pub unsafe fn _filter_changed(&mut self, arg0: GodotString) -> () {
        EditorInspector__filter_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _multiple_properties_changed(&mut self, arg0: StringArray, arg1: VariantArray) -> () {
        EditorInspector__multiple_properties_changed(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        EditorInspector__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _object_id_selected(&mut self, arg0: GodotString, arg1: i64) -> () {
        EditorInspector__object_id_selected(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _property_changed(&mut self, arg0: GodotString, arg1: Variant, arg2: GodotString, arg3: bool) -> () {
        EditorInspector__property_changed(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _property_changed_update_all(&mut self, arg0: GodotString, arg1: Variant, arg2: GodotString, arg3: bool) -> () {
        EditorInspector__property_changed_update_all(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _property_checked(&mut self, arg0: GodotString, arg1: bool) -> () {
        EditorInspector__property_checked(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _property_keyed(&mut self, arg0: GodotString, arg1: bool) -> () {
        EditorInspector__property_keyed(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _property_keyed_with_value(&mut self, arg0: GodotString, arg1: Variant, arg2: bool) -> () {
        EditorInspector__property_keyed_with_value(self.this, arg0, arg1, arg2)
    }

    #[inline]
    pub unsafe fn _property_selected(&mut self, arg0: GodotString, arg1: i64) -> () {
        EditorInspector__property_selected(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _resource_selected(&mut self, arg0: GodotString, arg1: Option<Resource>) -> () {
        EditorInspector__resource_selected(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _vscroll_changed(&mut self, arg0: f64) -> () {
        EditorInspector__vscroll_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn refresh(&mut self) -> () {
        EditorInspector_refresh(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_scroll_container(&self) -> ScrollContainer {
        // Not reference-counted.
        ScrollContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorInspectorPlugin` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorinspectorplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorInspectorPlugin inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorInspectorPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorInspectorPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_custom_control(&mut self, control: Option<Control>) -> () {
        unsafe { EditorInspectorPlugin_add_custom_control(self.this, control) }
    }

    #[inline]
    pub fn add_property_editor(&mut self, property: GodotString, editor: Option<Control>) -> () {
        unsafe { EditorInspectorPlugin_add_property_editor(self.this, property, editor) }
    }

    #[inline]
    pub fn add_property_editor_for_multiple_properties(&mut self, label: GodotString, properties: StringArray, editor: Option<Control>) -> () {
        unsafe { EditorInspectorPlugin_add_property_editor_for_multiple_properties(self.this, label, properties, editor) }
    }

    #[inline]
    pub fn can_handle(&mut self, object: Option<Object>) -> bool {
        unsafe { EditorInspectorPlugin_can_handle(self.this, object) }
    }

    #[inline]
    pub fn parse_begin(&mut self, object: Option<Object>) -> () {
        unsafe { EditorInspectorPlugin_parse_begin(self.this, object) }
    }

    #[inline]
    pub fn parse_category(&mut self, object: Option<Object>, category: GodotString) -> () {
        unsafe { EditorInspectorPlugin_parse_category(self.this, object, category) }
    }

    #[inline]
    pub fn parse_end(&mut self) -> () {
        unsafe { EditorInspectorPlugin_parse_end(self.this) }
    }

    #[inline]
    pub fn parse_property(&mut self, object: Option<Object>, _type: i64, path: GodotString, hint: i64, hint_text: GodotString, usage: i64) -> bool {
        unsafe { EditorInspectorPlugin_parse_property(self.this, object, _type, path, hint, hint_text, usage) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorInterface` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorinterface.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorInterface inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorInterface {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorInterface {
    #[inline]
    pub unsafe fn edit_resource(&mut self, resource: Option<Resource>) -> () {
        EditorInterface_edit_resource(self.this, resource)
    }

    #[inline]
    pub unsafe fn get_base_control(&mut self) -> Option<Control> {
        EditorInterface_get_base_control(self.this)
    }

    #[inline]
    pub unsafe fn get_current_path(&self) -> GodotString {
        EditorInterface_get_current_path(self.this)
    }

    #[inline]
    pub unsafe fn get_edited_scene_root(&mut self) -> Option<Node> {
        EditorInterface_get_edited_scene_root(self.this)
    }

    #[inline]
    pub unsafe fn get_editor_settings(&mut self) -> Option<EditorSettings> {
        EditorInterface_get_editor_settings(self.this)
    }

    #[inline]
    pub unsafe fn get_editor_viewport(&mut self) -> Option<Control> {
        EditorInterface_get_editor_viewport(self.this)
    }

    #[inline]
    pub unsafe fn get_inspector(&self) -> Option<EditorInspector> {
        EditorInterface_get_inspector(self.this)
    }

    #[inline]
    pub unsafe fn get_open_scenes(&self) -> VariantArray {
        EditorInterface_get_open_scenes(self.this)
    }

    #[inline]
    pub unsafe fn get_resource_filesystem(&mut self) -> Option<EditorFileSystem> {
        EditorInterface_get_resource_filesystem(self.this)
    }

    #[inline]
    pub unsafe fn get_resource_previewer(&mut self) -> Option<EditorResourcePreview> {
        EditorInterface_get_resource_previewer(self.this)
    }

    #[inline]
    pub unsafe fn get_script_editor(&mut self) -> Option<ScriptEditor> {
        EditorInterface_get_script_editor(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_path(&self) -> GodotString {
        EditorInterface_get_selected_path(self.this)
    }

    #[inline]
    pub unsafe fn get_selection(&mut self) -> Option<EditorSelection> {
        EditorInterface_get_selection(self.this)
    }

    #[inline]
    pub unsafe fn inspect_object(&mut self, object: Option<Object>, for_property: GodotString) -> () {
        EditorInterface_inspect_object(self.this, object, for_property)
    }

    #[inline]
    pub unsafe fn is_plugin_enabled(&self, plugin: GodotString) -> bool {
        EditorInterface_is_plugin_enabled(self.this, plugin)
    }

    #[inline]
    pub unsafe fn make_mesh_previews(&mut self, meshes: VariantArray, preview_size: i64) -> VariantArray {
        EditorInterface_make_mesh_previews(self.this, meshes, preview_size)
    }

    #[inline]
    pub unsafe fn open_scene_from_path(&mut self, scene_filepath: GodotString) -> () {
        EditorInterface_open_scene_from_path(self.this, scene_filepath)
    }

    #[inline]
    pub unsafe fn reload_scene_from_path(&mut self, scene_filepath: GodotString) -> () {
        EditorInterface_reload_scene_from_path(self.this, scene_filepath)
    }

    #[inline]
    pub unsafe fn save_scene(&mut self) -> GodotResult {
        EditorInterface_save_scene(self.this)
    }

    #[inline]
    pub unsafe fn save_scene_as(&mut self, path: GodotString, with_preview: bool) -> () {
        EditorInterface_save_scene_as(self.this, path, with_preview)
    }

    #[inline]
    pub unsafe fn select_file(&mut self, file: GodotString) -> () {
        EditorInterface_select_file(self.this, file)
    }

    #[inline]
    pub unsafe fn set_distraction_free_mode(&mut self, enter: bool) -> () {
        EditorInterface_set_distraction_free_mode(self.this, enter)
    }

    #[inline]
    pub unsafe fn set_main_screen_editor(&mut self, name: GodotString) -> () {
        EditorInterface_set_main_screen_editor(self.this, name)
    }

    #[inline]
    pub unsafe fn set_plugin_enabled(&mut self, plugin: GodotString, enabled: bool) -> () {
        EditorInterface_set_plugin_enabled(self.this, plugin, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorNavigationMeshGenerator` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editornavigationmeshgenerator.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorNavigationMeshGenerator inherits methods from:
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorNavigationMeshGenerator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorNavigationMeshGenerator {
    #[inline]
    pub unsafe fn bake(&mut self, nav_mesh: Option<NavigationMesh>, root_node: Option<Node>) -> () {
        EditorNavigationMeshGenerator_bake(self.this, nav_mesh, root_node)
    }

    #[inline]
    pub unsafe fn clear(&mut self, nav_mesh: Option<NavigationMesh>) -> () {
        EditorNavigationMeshGenerator_clear(self.this, nav_mesh)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorPlugin` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorplugin.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorPlugin inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorPluginDockSlot {
    LeftUl = 0,
    LeftBl = 1,
    LeftUr = 2,
    LeftBr = 3,
    RightUl = 4,
    RightBl = 5,
    RightUr = 6,
    RightBr = 7,
    Max = 8,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EditorPluginCustomControlContainer {
    ContainerToolbar = 0,
    ContainerSpatialEditorMenu = 1,
    ContainerSpatialEditorSideLeft = 2,
    ContainerSpatialEditorSideRight = 3,
    ContainerSpatialEditorBottom = 4,
    ContainerCanvasEditorMenu = 5,
    ContainerCanvasEditorSideLeft = 6,
    ContainerCanvasEditorSideRight = 7,
    ContainerCanvasEditorBottom = 8,
    ContainerPropertyEditorBottom = 9,
    ContainerProjectSettingTabLeft = 10,
    ContainerProjectSettingTabRight = 11,
}
/// Constants
#[allow(non_upper_case_globals)]
impl EditorPlugin {
    pub const CONTAINER_PROJECT_SETTING_TAB_LEFT: i64 = 10;
    pub const DOCK_SLOT_LEFT_BL: i64 = 1;
    pub const DOCK_SLOT_MAX: i64 = 8;
    pub const CONTAINER_PROJECT_SETTING_TAB_RIGHT: i64 = 11;
    pub const CONTAINER_CANVAS_EDITOR_SIDE_RIGHT: i64 = 7;
    pub const CONTAINER_SPATIAL_EDITOR_SIDE_LEFT: i64 = 2;
    pub const DOCK_SLOT_RIGHT_UR: i64 = 6;
    pub const DOCK_SLOT_RIGHT_UL: i64 = 4;
    pub const CONTAINER_TOOLBAR: i64 = 0;
    pub const CONTAINER_CANVAS_EDITOR_SIDE_LEFT: i64 = 6;
    pub const DOCK_SLOT_LEFT_UR: i64 = 2;
    pub const DOCK_SLOT_RIGHT_BR: i64 = 7;
    pub const CONTAINER_SPATIAL_EDITOR_BOTTOM: i64 = 4;
    pub const CONTAINER_PROPERTY_EDITOR_BOTTOM: i64 = 9;
    pub const DOCK_SLOT_RIGHT_BL: i64 = 5;
    pub const CONTAINER_CANVAS_EDITOR_MENU: i64 = 5;
    pub const CONTAINER_SPATIAL_EDITOR_MENU: i64 = 1;
    pub const CONTAINER_SPATIAL_EDITOR_SIDE_RIGHT: i64 = 3;
    pub const DOCK_SLOT_LEFT_BR: i64 = 3;
    pub const CONTAINER_CANVAS_EDITOR_BOTTOM: i64 = 8;
    pub const DOCK_SLOT_LEFT_UL: i64 = 0;
}
impl EditorPlugin {
    #[inline]
    pub unsafe fn add_autoload_singleton(&mut self, name: GodotString, path: GodotString) -> () {
        EditorPlugin_add_autoload_singleton(self.this, name, path)
    }

    #[inline]
    pub unsafe fn add_control_to_bottom_panel(&mut self, control: Option<Control>, title: GodotString) -> Option<ToolButton> {
        EditorPlugin_add_control_to_bottom_panel(self.this, control, title)
    }

    #[inline]
    pub unsafe fn add_control_to_container(&mut self, container: i64, control: Option<Control>) -> () {
        EditorPlugin_add_control_to_container(self.this, container, control)
    }

    #[inline]
    pub unsafe fn add_control_to_dock(&mut self, slot: i64, control: Option<Control>) -> () {
        EditorPlugin_add_control_to_dock(self.this, slot, control)
    }

    #[inline]
    pub unsafe fn add_custom_type(&mut self, _type: GodotString, base: GodotString, script: Option<Script>, icon: Option<Texture>) -> () {
        EditorPlugin_add_custom_type(self.this, _type, base, script, icon)
    }

    #[inline]
    pub unsafe fn add_export_plugin(&mut self, plugin: Option<EditorExportPlugin>) -> () {
        EditorPlugin_add_export_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn add_import_plugin(&mut self, importer: Option<EditorImportPlugin>) -> () {
        EditorPlugin_add_import_plugin(self.this, importer)
    }

    #[inline]
    pub unsafe fn add_inspector_plugin(&mut self, plugin: Option<EditorInspectorPlugin>) -> () {
        EditorPlugin_add_inspector_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn add_scene_import_plugin(&mut self, scene_importer: Option<EditorSceneImporter>) -> () {
        EditorPlugin_add_scene_import_plugin(self.this, scene_importer)
    }

    #[inline]
    pub unsafe fn add_spatial_gizmo_plugin(&mut self, plugin: Option<EditorSpatialGizmoPlugin>) -> () {
        EditorPlugin_add_spatial_gizmo_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn add_tool_menu_item(&mut self, name: GodotString, handler: Option<Object>, callback: GodotString, ud: Variant) -> () {
        EditorPlugin_add_tool_menu_item(self.this, name, handler, callback, ud)
    }

    #[inline]
    pub unsafe fn add_tool_submenu_item(&mut self, name: GodotString, submenu: Option<Object>) -> () {
        EditorPlugin_add_tool_submenu_item(self.this, name, submenu)
    }

    #[inline]
    pub unsafe fn apply_changes(&mut self) -> () {
        EditorPlugin_apply_changes(self.this)
    }

    #[inline]
    pub unsafe fn build(&mut self) -> bool {
        EditorPlugin_build(self.this)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        EditorPlugin_clear(self.this)
    }

    #[inline]
    pub unsafe fn disable_plugin(&mut self) -> () {
        EditorPlugin_disable_plugin(self.this)
    }

    #[inline]
    pub unsafe fn edit(&mut self, object: Option<Object>) -> () {
        EditorPlugin_edit(self.this, object)
    }

    #[inline]
    pub unsafe fn enable_plugin(&mut self) -> () {
        EditorPlugin_enable_plugin(self.this)
    }

    #[inline]
    pub unsafe fn forward_canvas_draw_over_viewport(&mut self, overlay: Option<Control>) -> () {
        EditorPlugin_forward_canvas_draw_over_viewport(self.this, overlay)
    }

    #[inline]
    pub unsafe fn forward_canvas_force_draw_over_viewport(&mut self, overlay: Option<Control>) -> () {
        EditorPlugin_forward_canvas_force_draw_over_viewport(self.this, overlay)
    }

    #[inline]
    pub unsafe fn forward_canvas_gui_input(&mut self, event: Option<InputEvent>) -> bool {
        EditorPlugin_forward_canvas_gui_input(self.this, event)
    }

    #[inline]
    pub unsafe fn forward_spatial_gui_input(&mut self, camera: Option<Camera>, event: Option<InputEvent>) -> bool {
        EditorPlugin_forward_spatial_gui_input(self.this, camera, event)
    }

    #[inline]
    pub unsafe fn get_breakpoints(&mut self) -> StringArray {
        EditorPlugin_get_breakpoints(self.this)
    }

    #[inline]
    pub unsafe fn get_editor_interface(&mut self) -> Option<EditorInterface> {
        EditorPlugin_get_editor_interface(self.this)
    }

    #[inline]
    pub unsafe fn get_plugin_icon(&mut self) -> Option<Object> {
        EditorPlugin_get_plugin_icon(self.this)
    }

    #[inline]
    pub unsafe fn get_plugin_name(&mut self) -> GodotString {
        EditorPlugin_get_plugin_name(self.this)
    }

    #[inline]
    pub unsafe fn get_script_create_dialog(&mut self) -> Option<ScriptCreateDialog> {
        EditorPlugin_get_script_create_dialog(self.this)
    }

    #[inline]
    pub unsafe fn get_state(&mut self) -> Dictionary {
        EditorPlugin_get_state(self.this)
    }

    #[inline]
    pub unsafe fn get_undo_redo(&mut self) -> Option<UndoRedo> {
        EditorPlugin_get_undo_redo(self.this)
    }

    #[inline]
    pub unsafe fn get_window_layout(&mut self, layout: Option<ConfigFile>) -> () {
        EditorPlugin_get_window_layout(self.this, layout)
    }

    #[inline]
    pub unsafe fn handles(&mut self, object: Option<Object>) -> bool {
        EditorPlugin_handles(self.this, object)
    }

    #[inline]
    pub unsafe fn has_main_screen(&mut self) -> bool {
        EditorPlugin_has_main_screen(self.this)
    }

    #[inline]
    pub unsafe fn hide_bottom_panel(&mut self) -> () {
        EditorPlugin_hide_bottom_panel(self.this)
    }

    #[inline]
    pub unsafe fn make_bottom_panel_item_visible(&mut self, item: Option<Control>) -> () {
        EditorPlugin_make_bottom_panel_item_visible(self.this, item)
    }

    #[inline]
    pub unsafe fn make_visible(&mut self, visible: bool) -> () {
        EditorPlugin_make_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn queue_save_layout(&self) -> () {
        EditorPlugin_queue_save_layout(self.this)
    }

    #[inline]
    pub unsafe fn remove_autoload_singleton(&mut self, name: GodotString) -> () {
        EditorPlugin_remove_autoload_singleton(self.this, name)
    }

    #[inline]
    pub unsafe fn remove_control_from_bottom_panel(&mut self, control: Option<Control>) -> () {
        EditorPlugin_remove_control_from_bottom_panel(self.this, control)
    }

    #[inline]
    pub unsafe fn remove_control_from_container(&mut self, container: i64, control: Option<Control>) -> () {
        EditorPlugin_remove_control_from_container(self.this, container, control)
    }

    #[inline]
    pub unsafe fn remove_control_from_docks(&mut self, control: Option<Control>) -> () {
        EditorPlugin_remove_control_from_docks(self.this, control)
    }

    #[inline]
    pub unsafe fn remove_custom_type(&mut self, _type: GodotString) -> () {
        EditorPlugin_remove_custom_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn remove_export_plugin(&mut self, plugin: Option<EditorExportPlugin>) -> () {
        EditorPlugin_remove_export_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn remove_import_plugin(&mut self, importer: Option<EditorImportPlugin>) -> () {
        EditorPlugin_remove_import_plugin(self.this, importer)
    }

    #[inline]
    pub unsafe fn remove_inspector_plugin(&mut self, plugin: Option<EditorInspectorPlugin>) -> () {
        EditorPlugin_remove_inspector_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn remove_scene_import_plugin(&mut self, scene_importer: Option<EditorSceneImporter>) -> () {
        EditorPlugin_remove_scene_import_plugin(self.this, scene_importer)
    }

    #[inline]
    pub unsafe fn remove_spatial_gizmo_plugin(&mut self, plugin: Option<EditorSpatialGizmoPlugin>) -> () {
        EditorPlugin_remove_spatial_gizmo_plugin(self.this, plugin)
    }

    #[inline]
    pub unsafe fn remove_tool_menu_item(&mut self, name: GodotString) -> () {
        EditorPlugin_remove_tool_menu_item(self.this, name)
    }

    #[inline]
    pub unsafe fn save_external_data(&mut self) -> () {
        EditorPlugin_save_external_data(self.this)
    }

    #[inline]
    pub unsafe fn set_force_draw_over_forwarding_enabled(&mut self) -> () {
        EditorPlugin_set_force_draw_over_forwarding_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_input_event_forwarding_always_enabled(&mut self) -> () {
        EditorPlugin_set_input_event_forwarding_always_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_state(&mut self, state: Dictionary) -> () {
        EditorPlugin_set_state(self.this, state)
    }

    #[inline]
    pub unsafe fn set_window_layout(&mut self, layout: Option<ConfigFile>) -> () {
        EditorPlugin_set_window_layout(self.this, layout)
    }

    #[inline]
    pub unsafe fn update_overlays(&self) -> i64 {
        EditorPlugin_update_overlays(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorProperty` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorproperty.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorProperty inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorProperty {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorProperty {
    #[inline]
    pub unsafe fn _focusable_focused(&mut self, arg0: i64) -> () {
        EditorProperty__focusable_focused(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        EditorProperty__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_focusable(&mut self, control: Option<Control>) -> () {
        EditorProperty_add_focusable(self.this, control)
    }

    #[inline]
    pub unsafe fn emit_changed(&mut self, property: GodotString, value: Variant, field: GodotString, changing: bool) -> () {
        EditorProperty_emit_changed(self.this, property, value, field, changing)
    }

    #[inline]
    pub unsafe fn get_edited_object(&mut self) -> Option<Object> {
        EditorProperty_get_edited_object(self.this)
    }

    #[inline]
    pub unsafe fn get_edited_property(&mut self) -> GodotString {
        EditorProperty_get_edited_property(self.this)
    }

    #[inline]
    pub unsafe fn get_label(&self) -> GodotString {
        EditorProperty_get_label(self.this)
    }

    #[inline]
    pub unsafe fn get_tooltip_text(&self) -> GodotString {
        EditorProperty_get_tooltip_text(self.this)
    }

    #[inline]
    pub unsafe fn is_checkable(&self) -> bool {
        EditorProperty_is_checkable(self.this)
    }

    #[inline]
    pub unsafe fn is_checked(&self) -> bool {
        EditorProperty_is_checked(self.this)
    }

    #[inline]
    pub unsafe fn is_draw_red(&self) -> bool {
        EditorProperty_is_draw_red(self.this)
    }

    #[inline]
    pub unsafe fn is_keying(&self) -> bool {
        EditorProperty_is_keying(self.this)
    }

    #[inline]
    pub unsafe fn is_read_only(&self) -> bool {
        EditorProperty_is_read_only(self.this)
    }

    #[inline]
    pub unsafe fn set_bottom_editor(&mut self, editor: Option<Control>) -> () {
        EditorProperty_set_bottom_editor(self.this, editor)
    }

    #[inline]
    pub unsafe fn set_checkable(&mut self, checkable: bool) -> () {
        EditorProperty_set_checkable(self.this, checkable)
    }

    #[inline]
    pub unsafe fn set_checked(&mut self, checked: bool) -> () {
        EditorProperty_set_checked(self.this, checked)
    }

    #[inline]
    pub unsafe fn set_draw_red(&mut self, draw_red: bool) -> () {
        EditorProperty_set_draw_red(self.this, draw_red)
    }

    #[inline]
    pub unsafe fn set_keying(&mut self, keying: bool) -> () {
        EditorProperty_set_keying(self.this, keying)
    }

    #[inline]
    pub unsafe fn set_label(&mut self, text: GodotString) -> () {
        EditorProperty_set_label(self.this, text)
    }

    #[inline]
    pub unsafe fn set_read_only(&mut self, read_only: bool) -> () {
        EditorProperty_set_read_only(self.this, read_only)
    }

    #[inline]
    pub unsafe fn update_property(&mut self) -> () {
        EditorProperty_update_property(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorResourceConversionPlugin` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorresourceconversionplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorResourceConversionPlugin inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorResourceConversionPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorResourceConversionPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _convert(&mut self, resource: Option<Resource>) -> Option<Resource> {
        unsafe { EditorResourceConversionPlugin__convert(self.this, resource) }
    }

    #[inline]
    pub fn _converts_to(&mut self) -> GodotString {
        unsafe { EditorResourceConversionPlugin__converts_to(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorResourcePreview` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorresourcepreview.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorResourcePreview inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorResourcePreview {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorResourcePreview {
    #[inline]
    pub unsafe fn _preview_ready(&mut self, arg0: GodotString, arg1: Option<Texture>, arg2: Option<Texture>, arg3: i64, arg4: GodotString, arg5: Variant) -> () {
        EditorResourcePreview__preview_ready(self.this, arg0, arg1, arg2, arg3, arg4, arg5)
    }

    #[inline]
    pub unsafe fn add_preview_generator(&mut self, generator: Option<EditorResourcePreviewGenerator>) -> () {
        EditorResourcePreview_add_preview_generator(self.this, generator)
    }

    #[inline]
    pub unsafe fn check_for_invalidation(&mut self, path: GodotString) -> () {
        EditorResourcePreview_check_for_invalidation(self.this, path)
    }

    #[inline]
    pub unsafe fn queue_edited_resource_preview(&mut self, resource: Option<Resource>, receiver: Option<Object>, receiver_func: GodotString, userdata: Variant) -> () {
        EditorResourcePreview_queue_edited_resource_preview(self.this, resource, receiver, receiver_func, userdata)
    }

    #[inline]
    pub unsafe fn queue_resource_preview(&mut self, path: GodotString, receiver: Option<Object>, receiver_func: GodotString, userdata: Variant) -> () {
        EditorResourcePreview_queue_resource_preview(self.this, path, receiver, receiver_func, userdata)
    }

    #[inline]
    pub unsafe fn remove_preview_generator(&mut self, generator: Option<EditorResourcePreviewGenerator>) -> () {
        EditorResourcePreview_remove_preview_generator(self.this, generator)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorResourcePreviewGenerator` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorresourcepreviewgenerator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorResourcePreviewGenerator inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorResourcePreviewGenerator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorResourcePreviewGenerator {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn can_generate_small_preview(&mut self) -> bool {
        unsafe { EditorResourcePreviewGenerator_can_generate_small_preview(self.this) }
    }

    #[inline]
    pub fn generate(&mut self, from: Option<Resource>, size: Vector2) -> Option<Texture> {
        unsafe { EditorResourcePreviewGenerator_generate(self.this, from, size) }
    }

    #[inline]
    pub fn generate_from_path(&mut self, path: GodotString, size: Vector2) -> Option<Texture> {
        unsafe { EditorResourcePreviewGenerator_generate_from_path(self.this, path, size) }
    }

    #[inline]
    pub fn generate_small_preview_automatically(&mut self) -> bool {
        unsafe { EditorResourcePreviewGenerator_generate_small_preview_automatically(self.this) }
    }

    #[inline]
    pub fn handles(&mut self, _type: GodotString) -> bool {
        unsafe { EditorResourcePreviewGenerator_handles(self.this, _type) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSceneImporter` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorsceneimporter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorSceneImporter inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSceneImporter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl EditorSceneImporter {
    pub const IMPORT_FAIL_ON_MISSING_DEPENDENCIES: i64 = 512;
    pub const IMPORT_MATERIALS_IN_INSTANCES: i64 = 1024;
    pub const IMPORT_USE_COMPRESSION: i64 = 2048;
    pub const IMPORT_ANIMATION_DETECT_LOOP: i64 = 4;
    pub const IMPORT_ANIMATION_OPTIMIZE: i64 = 8;
    pub const IMPORT_ANIMATION: i64 = 2;
    pub const IMPORT_GENERATE_TANGENT_ARRAYS: i64 = 256;
    pub const IMPORT_ANIMATION_FORCE_ALL_TRACKS_IN_ALL_CLIPS: i64 = 16;
    pub const IMPORT_ANIMATION_KEEP_VALUE_TRACKS: i64 = 32;
    pub const IMPORT_SCENE: i64 = 1;
}
impl EditorSceneImporter {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_extensions(&mut self) -> VariantArray {
        unsafe { EditorSceneImporter__get_extensions(self.this) }
    }

    #[inline]
    pub fn _get_import_flags(&mut self) -> i64 {
        unsafe { EditorSceneImporter__get_import_flags(self.this) }
    }

    #[inline]
    pub fn _import_animation(&mut self, path: GodotString, flags: i64, bake_fps: i64) -> Option<Animation> {
        unsafe { EditorSceneImporter__import_animation(self.this, path, flags, bake_fps) }
    }

    #[inline]
    pub fn _import_scene(&mut self, path: GodotString, flags: i64, bake_fps: i64) -> Option<Node> {
        unsafe { EditorSceneImporter__import_scene(self.this, path, flags, bake_fps) }
    }

    #[inline]
    pub fn import_animation_from_other_importer(&mut self, path: GodotString, flags: i64, bake_fps: i64) -> Option<Animation> {
        unsafe { EditorSceneImporter_import_animation_from_other_importer(self.this, path, flags, bake_fps) }
    }

    #[inline]
    pub fn import_scene_from_other_importer(&mut self, path: GodotString, flags: i64, bake_fps: i64) -> Option<Node> {
        unsafe { EditorSceneImporter_import_scene_from_other_importer(self.this, path, flags, bake_fps) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSceneImporterAssimp` inherits `EditorSceneImporter` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorsceneimporterassimp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorSceneImporterAssimp inherits methods from:
/// - [EditorSceneImporter](struct.EditorSceneImporter.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSceneImporterAssimp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorSceneImporterAssimp {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_editor_scene_importer(&self) -> EditorSceneImporter {
        unsafe {{ object::add_ref(self.this); }}
        EditorSceneImporter { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorScenePostImport` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorscenepostimport.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorScenePostImport inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorScenePostImport {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorScenePostImport {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_source_file(&self) -> GodotString {
        unsafe { EditorScenePostImport_get_source_file(self.this) }
    }

    #[inline]
    pub fn get_source_folder(&self) -> GodotString {
        unsafe { EditorScenePostImport_get_source_folder(self.this) }
    }

    #[inline]
    pub fn post_import(&mut self, scene: Option<Object>) -> Option<Object> {
        unsafe { EditorScenePostImport_post_import(self.this, scene) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorScript` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorscript.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorScript inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorScript {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _run(&mut self) -> () {
        unsafe { EditorScript__run(self.this) }
    }

    #[inline]
    pub fn add_root_node(&mut self, node: Option<Node>) -> () {
        unsafe { EditorScript_add_root_node(self.this, node) }
    }

    #[inline]
    pub fn get_editor_interface(&mut self) -> Option<EditorInterface> {
        unsafe { EditorScript_get_editor_interface(self.this) }
    }

    #[inline]
    pub fn get_scene(&mut self) -> Option<Node> {
        unsafe { EditorScript_get_scene(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSelection` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorselection.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorSelection inherits methods from:
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSelection {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorSelection {
    #[inline]
    pub unsafe fn _emit_change(&mut self) -> () {
        EditorSelection__emit_change(self.this)
    }

    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        EditorSelection__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_node(&mut self, node: Option<Node>) -> () {
        EditorSelection_add_node(self.this, node)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        EditorSelection_clear(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_nodes(&mut self) -> VariantArray {
        EditorSelection_get_selected_nodes(self.this)
    }

    #[inline]
    pub unsafe fn get_transformable_selected_nodes(&mut self) -> VariantArray {
        EditorSelection_get_transformable_selected_nodes(self.this)
    }

    #[inline]
    pub unsafe fn remove_node(&mut self, node: Option<Node>) -> () {
        EditorSelection_remove_node(self.this, node)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSettings` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorsettings.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorSettings inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSettings {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl EditorSettings {
    pub const NOTIFICATION_EDITOR_SETTINGS_CHANGED: i64 = 10000;
}
impl EditorSettings {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_property_info(&mut self, info: Dictionary) -> () {
        unsafe { EditorSettings_add_property_info(self.this, info) }
    }

    #[inline]
    pub fn erase(&mut self, property: GodotString) -> () {
        unsafe { EditorSettings_erase(self.this, property) }
    }

    #[inline]
    pub fn get_favorites(&self) -> StringArray {
        unsafe { EditorSettings_get_favorites(self.this) }
    }

    #[inline]
    pub fn get_project_metadata(&self, section: GodotString, key: GodotString, default: Variant) -> Variant {
        unsafe { EditorSettings_get_project_metadata(self.this, section, key, default) }
    }

    #[inline]
    pub fn get_project_settings_dir(&self) -> GodotString {
        unsafe { EditorSettings_get_project_settings_dir(self.this) }
    }

    #[inline]
    pub fn get_recent_dirs(&self) -> StringArray {
        unsafe { EditorSettings_get_recent_dirs(self.this) }
    }

    #[inline]
    pub fn get_setting(&self, name: GodotString) -> Variant {
        unsafe { EditorSettings_get_setting(self.this, name) }
    }

    #[inline]
    pub fn get_settings_dir(&self) -> GodotString {
        unsafe { EditorSettings_get_settings_dir(self.this) }
    }

    #[inline]
    pub fn has_setting(&self, name: GodotString) -> bool {
        unsafe { EditorSettings_has_setting(self.this, name) }
    }

    #[inline]
    pub fn property_can_revert(&mut self, name: GodotString) -> bool {
        unsafe { EditorSettings_property_can_revert(self.this, name) }
    }

    #[inline]
    pub fn property_get_revert(&mut self, name: GodotString) -> Variant {
        unsafe { EditorSettings_property_get_revert(self.this, name) }
    }

    #[inline]
    pub fn set_favorites(&mut self, dirs: StringArray) -> () {
        unsafe { EditorSettings_set_favorites(self.this, dirs) }
    }

    #[inline]
    pub fn set_initial_value(&mut self, name: GodotString, value: Variant, update_current: bool) -> () {
        unsafe { EditorSettings_set_initial_value(self.this, name, value, update_current) }
    }

    #[inline]
    pub fn set_project_metadata(&mut self, section: GodotString, key: GodotString, data: Variant) -> () {
        unsafe { EditorSettings_set_project_metadata(self.this, section, key, data) }
    }

    #[inline]
    pub fn set_recent_dirs(&mut self, dirs: StringArray) -> () {
        unsafe { EditorSettings_set_recent_dirs(self.this, dirs) }
    }

    #[inline]
    pub fn set_setting(&mut self, name: GodotString, value: Variant) -> () {
        unsafe { EditorSettings_set_setting(self.this, name, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSpatialGizmo` inherits `SpatialGizmo` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorspatialgizmo.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorSpatialGizmo inherits methods from:
/// - [SpatialGizmo](struct.SpatialGizmo.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSpatialGizmo {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorSpatialGizmo {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_collision_segments(&mut self, segments: Vector3Array) -> () {
        unsafe { EditorSpatialGizmo_add_collision_segments(self.this, segments) }
    }

    #[inline]
    pub fn add_collision_triangles(&mut self, triangles: Option<TriangleMesh>) -> () {
        unsafe { EditorSpatialGizmo_add_collision_triangles(self.this, triangles) }
    }

    #[inline]
    pub fn add_handles(&mut self, handles: Vector3Array, material: Option<Material>, billboard: bool, secondary: bool) -> () {
        unsafe { EditorSpatialGizmo_add_handles(self.this, handles, material, billboard, secondary) }
    }

    #[inline]
    pub fn add_lines(&mut self, lines: Vector3Array, material: Option<Material>, billboard: bool, modulate: Color) -> () {
        unsafe { EditorSpatialGizmo_add_lines(self.this, lines, material, billboard, modulate) }
    }

    #[inline]
    pub fn add_mesh(&mut self, mesh: Option<ArrayMesh>, billboard: bool, skeleton: Option<SkinReference>, material: Option<Material>) -> () {
        unsafe { EditorSpatialGizmo_add_mesh(self.this, mesh, billboard, skeleton, material) }
    }

    #[inline]
    pub fn add_unscaled_billboard(&mut self, material: Option<Material>, default_scale: f64, modulate: Color) -> () {
        unsafe { EditorSpatialGizmo_add_unscaled_billboard(self.this, material, default_scale, modulate) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { EditorSpatialGizmo_clear(self.this) }
    }

    #[inline]
    pub fn commit_handle(&mut self, index: i64, restore: Variant, cancel: bool) -> () {
        unsafe { EditorSpatialGizmo_commit_handle(self.this, index, restore, cancel) }
    }

    #[inline]
    pub fn get_handle_name(&mut self, index: i64) -> GodotString {
        unsafe { EditorSpatialGizmo_get_handle_name(self.this, index) }
    }

    #[inline]
    pub fn get_handle_value(&mut self, index: i64) -> Variant {
        unsafe { EditorSpatialGizmo_get_handle_value(self.this, index) }
    }

    #[inline]
    pub fn get_plugin(&self) -> Option<EditorSpatialGizmoPlugin> {
        unsafe { EditorSpatialGizmo_get_plugin(self.this) }
    }

    #[inline]
    pub fn get_spatial_node(&self) -> Option<Spatial> {
        unsafe { EditorSpatialGizmo_get_spatial_node(self.this) }
    }

    #[inline]
    pub fn is_handle_highlighted(&mut self, index: i64) -> bool {
        unsafe { EditorSpatialGizmo_is_handle_highlighted(self.this, index) }
    }

    #[inline]
    pub fn redraw(&mut self) -> () {
        unsafe { EditorSpatialGizmo_redraw(self.this) }
    }

    #[inline]
    pub fn set_handle(&mut self, index: i64, camera: Option<Camera>, point: Vector2) -> () {
        unsafe { EditorSpatialGizmo_set_handle(self.this, index, camera, point) }
    }

    #[inline]
    pub fn set_hidden(&mut self, hidden: bool) -> () {
        unsafe { EditorSpatialGizmo_set_hidden(self.this, hidden) }
    }

    #[inline]
    pub fn set_spatial_node(&mut self, node: Option<Node>) -> () {
        unsafe { EditorSpatialGizmo_set_spatial_node(self.this, node) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_spatial_gizmo(&self) -> SpatialGizmo {
        unsafe {{ object::add_ref(self.this); }}
        SpatialGizmo { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSpatialGizmoPlugin` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorspatialgizmoplugin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EditorSpatialGizmoPlugin inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSpatialGizmoPlugin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorSpatialGizmoPlugin {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_material(&mut self, name: GodotString, material: Option<SpatialMaterial>) -> () {
        unsafe { EditorSpatialGizmoPlugin_add_material(self.this, name, material) }
    }

    #[inline]
    pub fn can_be_hidden(&mut self) -> bool {
        unsafe { EditorSpatialGizmoPlugin_can_be_hidden(self.this) }
    }

    #[inline]
    pub fn commit_handle(&mut self, gizmo: Option<EditorSpatialGizmo>, index: i64, restore: Variant, cancel: bool) -> () {
        unsafe { EditorSpatialGizmoPlugin_commit_handle(self.this, gizmo, index, restore, cancel) }
    }

    #[inline]
    pub fn create_gizmo(&mut self, spatial: Option<Spatial>) -> Option<EditorSpatialGizmo> {
        unsafe { EditorSpatialGizmoPlugin_create_gizmo(self.this, spatial) }
    }

    #[inline]
    pub fn create_handle_material(&mut self, name: GodotString, billboard: bool) -> () {
        unsafe { EditorSpatialGizmoPlugin_create_handle_material(self.this, name, billboard) }
    }

    #[inline]
    pub fn create_icon_material(&mut self, name: GodotString, texture: Option<Texture>, on_top: bool, color: Color) -> () {
        unsafe { EditorSpatialGizmoPlugin_create_icon_material(self.this, name, texture, on_top, color) }
    }

    #[inline]
    pub fn create_material(&mut self, name: GodotString, color: Color, billboard: bool, on_top: bool, use_vertex_color: bool) -> () {
        unsafe { EditorSpatialGizmoPlugin_create_material(self.this, name, color, billboard, on_top, use_vertex_color) }
    }

    #[inline]
    pub fn get_handle_name(&mut self, gizmo: Option<EditorSpatialGizmo>, index: i64) -> GodotString {
        unsafe { EditorSpatialGizmoPlugin_get_handle_name(self.this, gizmo, index) }
    }

    #[inline]
    pub fn get_handle_value(&mut self, gizmo: Option<EditorSpatialGizmo>, index: i64) -> Variant {
        unsafe { EditorSpatialGizmoPlugin_get_handle_value(self.this, gizmo, index) }
    }

    #[inline]
    pub fn get_material(&mut self, name: GodotString, gizmo: Option<EditorSpatialGizmo>) -> Option<SpatialMaterial> {
        unsafe { EditorSpatialGizmoPlugin_get_material(self.this, name, gizmo) }
    }

    #[inline]
    pub fn get_name(&mut self) -> GodotString {
        unsafe { EditorSpatialGizmoPlugin_get_name(self.this) }
    }

    #[inline]
    pub fn get_priority(&mut self) -> GodotString {
        unsafe { EditorSpatialGizmoPlugin_get_priority(self.this) }
    }

    #[inline]
    pub fn has_gizmo(&mut self, spatial: Option<Spatial>) -> bool {
        unsafe { EditorSpatialGizmoPlugin_has_gizmo(self.this, spatial) }
    }

    #[inline]
    pub fn is_handle_highlighted(&mut self, gizmo: Option<EditorSpatialGizmo>, index: i64) -> bool {
        unsafe { EditorSpatialGizmoPlugin_is_handle_highlighted(self.this, gizmo, index) }
    }

    #[inline]
    pub fn is_selectable_when_hidden(&mut self) -> bool {
        unsafe { EditorSpatialGizmoPlugin_is_selectable_when_hidden(self.this) }
    }

    #[inline]
    pub fn redraw(&mut self, gizmo: Option<EditorSpatialGizmo>) -> () {
        unsafe { EditorSpatialGizmoPlugin_redraw(self.this, gizmo) }
    }

    #[inline]
    pub fn set_handle(&mut self, gizmo: Option<EditorSpatialGizmo>, index: i64, camera: Option<Camera>, point: Vector2) -> () {
        unsafe { EditorSpatialGizmoPlugin_set_handle(self.this, gizmo, index, camera, point) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorSpinSlider` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorspinslider.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorSpinSlider inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorSpinSlider {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorSpinSlider {
    #[inline]
    pub unsafe fn _grabber_gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        EditorSpinSlider__grabber_gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _grabber_mouse_entered(&mut self) -> () {
        EditorSpinSlider__grabber_mouse_entered(self.this)
    }

    #[inline]
    pub unsafe fn _grabber_mouse_exited(&mut self) -> () {
        EditorSpinSlider__grabber_mouse_exited(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        EditorSpinSlider__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _value_focus_exited(&mut self) -> () {
        EditorSpinSlider__value_focus_exited(self.this)
    }

    #[inline]
    pub unsafe fn _value_input_closed(&mut self) -> () {
        EditorSpinSlider__value_input_closed(self.this)
    }

    #[inline]
    pub unsafe fn _value_input_entered(&mut self, arg0: GodotString) -> () {
        EditorSpinSlider__value_input_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_label(&self) -> GodotString {
        EditorSpinSlider_get_label(self.this)
    }

    #[inline]
    pub unsafe fn is_flat(&self) -> bool {
        EditorSpinSlider_is_flat(self.this)
    }

    #[inline]
    pub unsafe fn is_read_only(&self) -> bool {
        EditorSpinSlider_is_read_only(self.this)
    }

    #[inline]
    pub unsafe fn set_flat(&mut self, flat: bool) -> () {
        EditorSpinSlider_set_flat(self.this, flat)
    }

    #[inline]
    pub unsafe fn set_label(&mut self, label: GodotString) -> () {
        EditorSpinSlider_set_label(self.this, label)
    }

    #[inline]
    pub unsafe fn set_read_only(&mut self, read_only: bool) -> () {
        EditorSpinSlider_set_read_only(self.this, read_only)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class EditorVCSInterface` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_editorvcsinterface.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// EditorVCSInterface inherits methods from:
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EditorVCSInterface {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EditorVCSInterface {
    #[inline]
    pub unsafe fn _commit(&mut self, msg: GodotString) -> () {
        EditorVCSInterface__commit(self.this, msg)
    }

    #[inline]
    pub unsafe fn _get_file_diff(&mut self, file_path: GodotString) -> VariantArray {
        EditorVCSInterface__get_file_diff(self.this, file_path)
    }

    #[inline]
    pub unsafe fn _get_modified_files_data(&mut self) -> Dictionary {
        EditorVCSInterface__get_modified_files_data(self.this)
    }

    #[inline]
    pub unsafe fn _get_project_name(&mut self) -> GodotString {
        EditorVCSInterface__get_project_name(self.this)
    }

    #[inline]
    pub unsafe fn _get_vcs_name(&mut self) -> GodotString {
        EditorVCSInterface__get_vcs_name(self.this)
    }

    #[inline]
    pub unsafe fn _initialize(&mut self, project_root_path: GodotString) -> bool {
        EditorVCSInterface__initialize(self.this, project_root_path)
    }

    #[inline]
    pub unsafe fn _is_vcs_initialized(&mut self) -> bool {
        EditorVCSInterface__is_vcs_initialized(self.this)
    }

    #[inline]
    pub unsafe fn _shut_down(&mut self) -> bool {
        EditorVCSInterface__shut_down(self.this)
    }

    #[inline]
    pub unsafe fn _stage_file(&mut self, file_path: GodotString) -> () {
        EditorVCSInterface__stage_file(self.this, file_path)
    }

    #[inline]
    pub unsafe fn _unstage_file(&mut self, file_path: GodotString) -> () {
        EditorVCSInterface__unstage_file(self.this, file_path)
    }

    #[inline]
    pub unsafe fn commit(&mut self, msg: GodotString) -> () {
        EditorVCSInterface_commit(self.this, msg)
    }

    #[inline]
    pub unsafe fn get_file_diff(&mut self, file_path: GodotString) -> VariantArray {
        EditorVCSInterface_get_file_diff(self.this, file_path)
    }

    #[inline]
    pub unsafe fn get_modified_files_data(&mut self) -> Dictionary {
        EditorVCSInterface_get_modified_files_data(self.this)
    }

    #[inline]
    pub unsafe fn get_project_name(&mut self) -> GodotString {
        EditorVCSInterface_get_project_name(self.this)
    }

    #[inline]
    pub unsafe fn get_vcs_name(&mut self) -> GodotString {
        EditorVCSInterface_get_vcs_name(self.this)
    }

    #[inline]
    pub unsafe fn initialize(&mut self, project_root_path: GodotString) -> bool {
        EditorVCSInterface_initialize(self.this, project_root_path)
    }

    #[inline]
    pub unsafe fn is_addon_ready(&mut self) -> bool {
        EditorVCSInterface_is_addon_ready(self.this)
    }

    #[inline]
    pub unsafe fn is_vcs_initialized(&mut self) -> bool {
        EditorVCSInterface_is_vcs_initialized(self.this)
    }

    #[inline]
    pub unsafe fn shut_down(&mut self) -> bool {
        EditorVCSInterface_shut_down(self.this)
    }

    #[inline]
    pub unsafe fn stage_file(&mut self, file_path: GodotString) -> () {
        EditorVCSInterface_stage_file(self.this, file_path)
    }

    #[inline]
    pub unsafe fn unstage_file(&mut self, file_path: GodotString) -> () {
        EditorVCSInterface_unstage_file(self.this, file_path)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class EncodedObjectAsID` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_encodedobjectasid.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// EncodedObjectAsID inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct EncodedObjectAsID {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl EncodedObjectAsID {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = EncodedObjectAsIDMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            EncodedObjectAsID {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_object_id(&self) -> i64 {
        unsafe { EncodedObjectAsID_get_object_id(self.this) }
    }

    #[inline]
    pub fn set_object_id(&mut self, id: i64) -> () {
        unsafe { EncodedObjectAsID_set_object_id(self.this, id) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Environment` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_environment.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Environment inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Environment {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentSSAOBlur {
    Disabled = 0,
    SsaoBlur1x1 = 1,
    SsaoBlur2x2 = 2,
    SsaoBlur3x3 = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentToneMapper {
    Linear = 0,
    Reinhardt = 1,
    Filmic = 2,
    Aces = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentGlowBlendMode {
    ModeAdditive = 0,
    ModeScreen = 1,
    ModeSoftlight = 2,
    ModeReplace = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentBGMode {
    ClearColor = 0,
    Color = 1,
    Sky = 2,
    ColorSky = 3,
    Canvas = 4,
    Keep = 5,
    CameraFeed = 6,
    Max = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentSSAOQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum EnvironmentDOFBlurQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Environment {
    pub const BG_COLOR_SKY: i64 = 3;
    pub const GLOW_BLEND_MODE_SOFTLIGHT: i64 = 2;
    pub const SSAO_BLUR_DISABLED: i64 = 0;
    pub const SSAO_QUALITY_HIGH: i64 = 2;
    pub const TONE_MAPPER_FILMIC: i64 = 2;
    pub const TONE_MAPPER_REINHARDT: i64 = 1;
    pub const BG_SKY: i64 = 2;
    pub const GLOW_BLEND_MODE_ADDITIVE: i64 = 0;
    pub const SSAO_QUALITY_MEDIUM: i64 = 1;
    pub const TONE_MAPPER_LINEAR: i64 = 0;
    pub const GLOW_BLEND_MODE_REPLACE: i64 = 3;
    pub const TONE_MAPPER_ACES: i64 = 3;
    pub const GLOW_BLEND_MODE_SCREEN: i64 = 1;
    pub const BG_MAX: i64 = 7;
    pub const SSAO_BLUR_2x2: i64 = 2;
    pub const BG_COLOR: i64 = 1;
    pub const DOF_BLUR_QUALITY_HIGH: i64 = 2;
    pub const SSAO_QUALITY_LOW: i64 = 0;
    pub const BG_CANVAS: i64 = 4;
    pub const SSAO_BLUR_1x1: i64 = 1;
    pub const BG_CLEAR_COLOR: i64 = 0;
    pub const DOF_BLUR_QUALITY_LOW: i64 = 0;
    pub const BG_CAMERA_FEED: i64 = 6;
    pub const BG_KEEP: i64 = 5;
    pub const DOF_BLUR_QUALITY_MEDIUM: i64 = 1;
    pub const SSAO_BLUR_3x3: i64 = 3;
}
impl Environment {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = EnvironmentMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Environment {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_adjustment_brightness(&self) -> f64 {
        unsafe { Environment_get_adjustment_brightness(self.this) }
    }

    #[inline]
    pub fn get_adjustment_color_correction(&self) -> Option<Texture> {
        unsafe { Environment_get_adjustment_color_correction(self.this) }
    }

    #[inline]
    pub fn get_adjustment_contrast(&self) -> f64 {
        unsafe { Environment_get_adjustment_contrast(self.this) }
    }

    #[inline]
    pub fn get_adjustment_saturation(&self) -> f64 {
        unsafe { Environment_get_adjustment_saturation(self.this) }
    }

    #[inline]
    pub fn get_ambient_light_color(&self) -> Color {
        unsafe { Environment_get_ambient_light_color(self.this) }
    }

    #[inline]
    pub fn get_ambient_light_energy(&self) -> f64 {
        unsafe { Environment_get_ambient_light_energy(self.this) }
    }

    #[inline]
    pub fn get_ambient_light_sky_contribution(&self) -> f64 {
        unsafe { Environment_get_ambient_light_sky_contribution(self.this) }
    }

    #[inline]
    pub fn get_background(&self) -> EnvironmentBGMode {
        unsafe { Environment_get_background(self.this) }
    }

    #[inline]
    pub fn get_bg_color(&self) -> Color {
        unsafe { Environment_get_bg_color(self.this) }
    }

    #[inline]
    pub fn get_bg_energy(&self) -> f64 {
        unsafe { Environment_get_bg_energy(self.this) }
    }

    #[inline]
    pub fn get_camera_feed_id(&self) -> i64 {
        unsafe { Environment_get_camera_feed_id(self.this) }
    }

    #[inline]
    pub fn get_canvas_max_layer(&self) -> i64 {
        unsafe { Environment_get_canvas_max_layer(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_far_amount(&self) -> f64 {
        unsafe { Environment_get_dof_blur_far_amount(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_far_distance(&self) -> f64 {
        unsafe { Environment_get_dof_blur_far_distance(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_far_quality(&self) -> EnvironmentDOFBlurQuality {
        unsafe { Environment_get_dof_blur_far_quality(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_far_transition(&self) -> f64 {
        unsafe { Environment_get_dof_blur_far_transition(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_near_amount(&self) -> f64 {
        unsafe { Environment_get_dof_blur_near_amount(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_near_distance(&self) -> f64 {
        unsafe { Environment_get_dof_blur_near_distance(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_near_quality(&self) -> EnvironmentDOFBlurQuality {
        unsafe { Environment_get_dof_blur_near_quality(self.this) }
    }

    #[inline]
    pub fn get_dof_blur_near_transition(&self) -> f64 {
        unsafe { Environment_get_dof_blur_near_transition(self.this) }
    }

    #[inline]
    pub fn get_fog_color(&self) -> Color {
        unsafe { Environment_get_fog_color(self.this) }
    }

    #[inline]
    pub fn get_fog_depth_begin(&self) -> f64 {
        unsafe { Environment_get_fog_depth_begin(self.this) }
    }

    #[inline]
    pub fn get_fog_depth_curve(&self) -> f64 {
        unsafe { Environment_get_fog_depth_curve(self.this) }
    }

    #[inline]
    pub fn get_fog_depth_end(&self) -> f64 {
        unsafe { Environment_get_fog_depth_end(self.this) }
    }

    #[inline]
    pub fn get_fog_height_curve(&self) -> f64 {
        unsafe { Environment_get_fog_height_curve(self.this) }
    }

    #[inline]
    pub fn get_fog_height_max(&self) -> f64 {
        unsafe { Environment_get_fog_height_max(self.this) }
    }

    #[inline]
    pub fn get_fog_height_min(&self) -> f64 {
        unsafe { Environment_get_fog_height_min(self.this) }
    }

    #[inline]
    pub fn get_fog_sun_amount(&self) -> f64 {
        unsafe { Environment_get_fog_sun_amount(self.this) }
    }

    #[inline]
    pub fn get_fog_sun_color(&self) -> Color {
        unsafe { Environment_get_fog_sun_color(self.this) }
    }

    #[inline]
    pub fn get_fog_transmit_curve(&self) -> f64 {
        unsafe { Environment_get_fog_transmit_curve(self.this) }
    }

    #[inline]
    pub fn get_glow_blend_mode(&self) -> EnvironmentGlowBlendMode {
        unsafe { Environment_get_glow_blend_mode(self.this) }
    }

    #[inline]
    pub fn get_glow_bloom(&self) -> f64 {
        unsafe { Environment_get_glow_bloom(self.this) }
    }

    #[inline]
    pub fn get_glow_hdr_bleed_scale(&self) -> f64 {
        unsafe { Environment_get_glow_hdr_bleed_scale(self.this) }
    }

    #[inline]
    pub fn get_glow_hdr_bleed_threshold(&self) -> f64 {
        unsafe { Environment_get_glow_hdr_bleed_threshold(self.this) }
    }

    #[inline]
    pub fn get_glow_hdr_luminance_cap(&self) -> f64 {
        unsafe { Environment_get_glow_hdr_luminance_cap(self.this) }
    }

    #[inline]
    pub fn get_glow_intensity(&self) -> f64 {
        unsafe { Environment_get_glow_intensity(self.this) }
    }

    #[inline]
    pub fn get_glow_strength(&self) -> f64 {
        unsafe { Environment_get_glow_strength(self.this) }
    }

    #[inline]
    pub fn get_sky(&self) -> Option<Sky> {
        unsafe { Environment_get_sky(self.this) }
    }

    #[inline]
    pub fn get_sky_custom_fov(&self) -> f64 {
        unsafe { Environment_get_sky_custom_fov(self.this) }
    }

    #[inline]
    pub fn get_sky_orientation(&self) -> Basis {
        unsafe { Environment_get_sky_orientation(self.this) }
    }

    #[inline]
    pub fn get_sky_rotation(&self) -> Vector3 {
        unsafe { Environment_get_sky_rotation(self.this) }
    }

    #[inline]
    pub fn get_sky_rotation_degrees(&self) -> Vector3 {
        unsafe { Environment_get_sky_rotation_degrees(self.this) }
    }

    #[inline]
    pub fn get_ssao_ao_channel_affect(&self) -> f64 {
        unsafe { Environment_get_ssao_ao_channel_affect(self.this) }
    }

    #[inline]
    pub fn get_ssao_bias(&self) -> f64 {
        unsafe { Environment_get_ssao_bias(self.this) }
    }

    #[inline]
    pub fn get_ssao_blur(&self) -> EnvironmentSSAOBlur {
        unsafe { Environment_get_ssao_blur(self.this) }
    }

    #[inline]
    pub fn get_ssao_color(&self) -> Color {
        unsafe { Environment_get_ssao_color(self.this) }
    }

    #[inline]
    pub fn get_ssao_direct_light_affect(&self) -> f64 {
        unsafe { Environment_get_ssao_direct_light_affect(self.this) }
    }

    #[inline]
    pub fn get_ssao_edge_sharpness(&self) -> f64 {
        unsafe { Environment_get_ssao_edge_sharpness(self.this) }
    }

    #[inline]
    pub fn get_ssao_intensity(&self) -> f64 {
        unsafe { Environment_get_ssao_intensity(self.this) }
    }

    #[inline]
    pub fn get_ssao_intensity2(&self) -> f64 {
        unsafe { Environment_get_ssao_intensity2(self.this) }
    }

    #[inline]
    pub fn get_ssao_quality(&self) -> EnvironmentSSAOQuality {
        unsafe { Environment_get_ssao_quality(self.this) }
    }

    #[inline]
    pub fn get_ssao_radius(&self) -> f64 {
        unsafe { Environment_get_ssao_radius(self.this) }
    }

    #[inline]
    pub fn get_ssao_radius2(&self) -> f64 {
        unsafe { Environment_get_ssao_radius2(self.this) }
    }

    #[inline]
    pub fn get_ssr_depth_tolerance(&self) -> f64 {
        unsafe { Environment_get_ssr_depth_tolerance(self.this) }
    }

    #[inline]
    pub fn get_ssr_fade_in(&self) -> f64 {
        unsafe { Environment_get_ssr_fade_in(self.this) }
    }

    #[inline]
    pub fn get_ssr_fade_out(&self) -> f64 {
        unsafe { Environment_get_ssr_fade_out(self.this) }
    }

    #[inline]
    pub fn get_ssr_max_steps(&self) -> i64 {
        unsafe { Environment_get_ssr_max_steps(self.this) }
    }

    #[inline]
    pub fn get_tonemap_auto_exposure(&self) -> bool {
        unsafe { Environment_get_tonemap_auto_exposure(self.this) }
    }

    #[inline]
    pub fn get_tonemap_auto_exposure_grey(&self) -> f64 {
        unsafe { Environment_get_tonemap_auto_exposure_grey(self.this) }
    }

    #[inline]
    pub fn get_tonemap_auto_exposure_max(&self) -> f64 {
        unsafe { Environment_get_tonemap_auto_exposure_max(self.this) }
    }

    #[inline]
    pub fn get_tonemap_auto_exposure_min(&self) -> f64 {
        unsafe { Environment_get_tonemap_auto_exposure_min(self.this) }
    }

    #[inline]
    pub fn get_tonemap_auto_exposure_speed(&self) -> f64 {
        unsafe { Environment_get_tonemap_auto_exposure_speed(self.this) }
    }

    #[inline]
    pub fn get_tonemap_exposure(&self) -> f64 {
        unsafe { Environment_get_tonemap_exposure(self.this) }
    }

    #[inline]
    pub fn get_tonemap_white(&self) -> f64 {
        unsafe { Environment_get_tonemap_white(self.this) }
    }

    #[inline]
    pub fn get_tonemapper(&self) -> EnvironmentToneMapper {
        unsafe { Environment_get_tonemapper(self.this) }
    }

    #[inline]
    pub fn is_adjustment_enabled(&self) -> bool {
        unsafe { Environment_is_adjustment_enabled(self.this) }
    }

    #[inline]
    pub fn is_dof_blur_far_enabled(&self) -> bool {
        unsafe { Environment_is_dof_blur_far_enabled(self.this) }
    }

    #[inline]
    pub fn is_dof_blur_near_enabled(&self) -> bool {
        unsafe { Environment_is_dof_blur_near_enabled(self.this) }
    }

    #[inline]
    pub fn is_fog_depth_enabled(&self) -> bool {
        unsafe { Environment_is_fog_depth_enabled(self.this) }
    }

    #[inline]
    pub fn is_fog_enabled(&self) -> bool {
        unsafe { Environment_is_fog_enabled(self.this) }
    }

    #[inline]
    pub fn is_fog_height_enabled(&self) -> bool {
        unsafe { Environment_is_fog_height_enabled(self.this) }
    }

    #[inline]
    pub fn is_fog_transmit_enabled(&self) -> bool {
        unsafe { Environment_is_fog_transmit_enabled(self.this) }
    }

    #[inline]
    pub fn is_glow_bicubic_upscale_enabled(&self) -> bool {
        unsafe { Environment_is_glow_bicubic_upscale_enabled(self.this) }
    }

    #[inline]
    pub fn is_glow_enabled(&self) -> bool {
        unsafe { Environment_is_glow_enabled(self.this) }
    }

    #[inline]
    pub fn is_glow_level_enabled(&self, idx: i64) -> bool {
        unsafe { Environment_is_glow_level_enabled(self.this, idx) }
    }

    #[inline]
    pub fn is_ssao_enabled(&self) -> bool {
        unsafe { Environment_is_ssao_enabled(self.this) }
    }

    #[inline]
    pub fn is_ssr_enabled(&self) -> bool {
        unsafe { Environment_is_ssr_enabled(self.this) }
    }

    #[inline]
    pub fn is_ssr_rough(&self) -> bool {
        unsafe { Environment_is_ssr_rough(self.this) }
    }

    #[inline]
    pub fn set_adjustment_brightness(&mut self, brightness: f64) -> () {
        unsafe { Environment_set_adjustment_brightness(self.this, brightness) }
    }

    #[inline]
    pub fn set_adjustment_color_correction(&mut self, color_correction: Option<Texture>) -> () {
        unsafe { Environment_set_adjustment_color_correction(self.this, color_correction) }
    }

    #[inline]
    pub fn set_adjustment_contrast(&mut self, contrast: f64) -> () {
        unsafe { Environment_set_adjustment_contrast(self.this, contrast) }
    }

    #[inline]
    pub fn set_adjustment_enable(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_adjustment_enable(self.this, enabled) }
    }

    #[inline]
    pub fn set_adjustment_saturation(&mut self, saturation: f64) -> () {
        unsafe { Environment_set_adjustment_saturation(self.this, saturation) }
    }

    #[inline]
    pub fn set_ambient_light_color(&mut self, color: Color) -> () {
        unsafe { Environment_set_ambient_light_color(self.this, color) }
    }

    #[inline]
    pub fn set_ambient_light_energy(&mut self, energy: f64) -> () {
        unsafe { Environment_set_ambient_light_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_ambient_light_sky_contribution(&mut self, energy: f64) -> () {
        unsafe { Environment_set_ambient_light_sky_contribution(self.this, energy) }
    }

    #[inline]
    pub fn set_background(&mut self, mode: i64) -> () {
        unsafe { Environment_set_background(self.this, mode) }
    }

    #[inline]
    pub fn set_bg_color(&mut self, color: Color) -> () {
        unsafe { Environment_set_bg_color(self.this, color) }
    }

    #[inline]
    pub fn set_bg_energy(&mut self, energy: f64) -> () {
        unsafe { Environment_set_bg_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_camera_feed_id(&mut self, camera_feed_id: i64) -> () {
        unsafe { Environment_set_camera_feed_id(self.this, camera_feed_id) }
    }

    #[inline]
    pub fn set_canvas_max_layer(&mut self, layer: i64) -> () {
        unsafe { Environment_set_canvas_max_layer(self.this, layer) }
    }

    #[inline]
    pub fn set_dof_blur_far_amount(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_far_amount(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_far_distance(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_far_distance(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_far_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_dof_blur_far_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_dof_blur_far_quality(&mut self, intensity: i64) -> () {
        unsafe { Environment_set_dof_blur_far_quality(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_far_transition(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_far_transition(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_near_amount(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_near_amount(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_near_distance(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_near_distance(self.this, intensity) }
    }

    #[inline]
    pub fn set_dof_blur_near_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_dof_blur_near_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_dof_blur_near_quality(&mut self, level: i64) -> () {
        unsafe { Environment_set_dof_blur_near_quality(self.this, level) }
    }

    #[inline]
    pub fn set_dof_blur_near_transition(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_dof_blur_near_transition(self.this, intensity) }
    }

    #[inline]
    pub fn set_fog_color(&mut self, color: Color) -> () {
        unsafe { Environment_set_fog_color(self.this, color) }
    }

    #[inline]
    pub fn set_fog_depth_begin(&mut self, distance: f64) -> () {
        unsafe { Environment_set_fog_depth_begin(self.this, distance) }
    }

    #[inline]
    pub fn set_fog_depth_curve(&mut self, curve: f64) -> () {
        unsafe { Environment_set_fog_depth_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_fog_depth_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_fog_depth_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_fog_depth_end(&mut self, distance: f64) -> () {
        unsafe { Environment_set_fog_depth_end(self.this, distance) }
    }

    #[inline]
    pub fn set_fog_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_fog_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_fog_height_curve(&mut self, curve: f64) -> () {
        unsafe { Environment_set_fog_height_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_fog_height_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_fog_height_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_fog_height_max(&mut self, height: f64) -> () {
        unsafe { Environment_set_fog_height_max(self.this, height) }
    }

    #[inline]
    pub fn set_fog_height_min(&mut self, height: f64) -> () {
        unsafe { Environment_set_fog_height_min(self.this, height) }
    }

    #[inline]
    pub fn set_fog_sun_amount(&mut self, amount: f64) -> () {
        unsafe { Environment_set_fog_sun_amount(self.this, amount) }
    }

    #[inline]
    pub fn set_fog_sun_color(&mut self, color: Color) -> () {
        unsafe { Environment_set_fog_sun_color(self.this, color) }
    }

    #[inline]
    pub fn set_fog_transmit_curve(&mut self, curve: f64) -> () {
        unsafe { Environment_set_fog_transmit_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_fog_transmit_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_fog_transmit_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_glow_bicubic_upscale(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_glow_bicubic_upscale(self.this, enabled) }
    }

    #[inline]
    pub fn set_glow_blend_mode(&mut self, mode: i64) -> () {
        unsafe { Environment_set_glow_blend_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_glow_bloom(&mut self, amount: f64) -> () {
        unsafe { Environment_set_glow_bloom(self.this, amount) }
    }

    #[inline]
    pub fn set_glow_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_glow_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_glow_hdr_bleed_scale(&mut self, scale: f64) -> () {
        unsafe { Environment_set_glow_hdr_bleed_scale(self.this, scale) }
    }

    #[inline]
    pub fn set_glow_hdr_bleed_threshold(&mut self, threshold: f64) -> () {
        unsafe { Environment_set_glow_hdr_bleed_threshold(self.this, threshold) }
    }

    #[inline]
    pub fn set_glow_hdr_luminance_cap(&mut self, amount: f64) -> () {
        unsafe { Environment_set_glow_hdr_luminance_cap(self.this, amount) }
    }

    #[inline]
    pub fn set_glow_intensity(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_glow_intensity(self.this, intensity) }
    }

    #[inline]
    pub fn set_glow_level(&mut self, idx: i64, enabled: bool) -> () {
        unsafe { Environment_set_glow_level(self.this, idx, enabled) }
    }

    #[inline]
    pub fn set_glow_strength(&mut self, strength: f64) -> () {
        unsafe { Environment_set_glow_strength(self.this, strength) }
    }

    #[inline]
    pub fn set_sky(&mut self, sky: Option<Sky>) -> () {
        unsafe { Environment_set_sky(self.this, sky) }
    }

    #[inline]
    pub fn set_sky_custom_fov(&mut self, scale: f64) -> () {
        unsafe { Environment_set_sky_custom_fov(self.this, scale) }
    }

    #[inline]
    pub fn set_sky_orientation(&mut self, orientation: Basis) -> () {
        unsafe { Environment_set_sky_orientation(self.this, orientation) }
    }

    #[inline]
    pub fn set_sky_rotation(&mut self, euler_radians: Vector3) -> () {
        unsafe { Environment_set_sky_rotation(self.this, euler_radians) }
    }

    #[inline]
    pub fn set_sky_rotation_degrees(&mut self, euler_degrees: Vector3) -> () {
        unsafe { Environment_set_sky_rotation_degrees(self.this, euler_degrees) }
    }

    #[inline]
    pub fn set_ssao_ao_channel_affect(&mut self, amount: f64) -> () {
        unsafe { Environment_set_ssao_ao_channel_affect(self.this, amount) }
    }

    #[inline]
    pub fn set_ssao_bias(&mut self, bias: f64) -> () {
        unsafe { Environment_set_ssao_bias(self.this, bias) }
    }

    #[inline]
    pub fn set_ssao_blur(&mut self, mode: i64) -> () {
        unsafe { Environment_set_ssao_blur(self.this, mode) }
    }

    #[inline]
    pub fn set_ssao_color(&mut self, color: Color) -> () {
        unsafe { Environment_set_ssao_color(self.this, color) }
    }

    #[inline]
    pub fn set_ssao_direct_light_affect(&mut self, amount: f64) -> () {
        unsafe { Environment_set_ssao_direct_light_affect(self.this, amount) }
    }

    #[inline]
    pub fn set_ssao_edge_sharpness(&mut self, edge_sharpness: f64) -> () {
        unsafe { Environment_set_ssao_edge_sharpness(self.this, edge_sharpness) }
    }

    #[inline]
    pub fn set_ssao_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_ssao_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_ssao_intensity(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_ssao_intensity(self.this, intensity) }
    }

    #[inline]
    pub fn set_ssao_intensity2(&mut self, intensity: f64) -> () {
        unsafe { Environment_set_ssao_intensity2(self.this, intensity) }
    }

    #[inline]
    pub fn set_ssao_quality(&mut self, quality: i64) -> () {
        unsafe { Environment_set_ssao_quality(self.this, quality) }
    }

    #[inline]
    pub fn set_ssao_radius(&mut self, radius: f64) -> () {
        unsafe { Environment_set_ssao_radius(self.this, radius) }
    }

    #[inline]
    pub fn set_ssao_radius2(&mut self, radius: f64) -> () {
        unsafe { Environment_set_ssao_radius2(self.this, radius) }
    }

    #[inline]
    pub fn set_ssr_depth_tolerance(&mut self, depth_tolerance: f64) -> () {
        unsafe { Environment_set_ssr_depth_tolerance(self.this, depth_tolerance) }
    }

    #[inline]
    pub fn set_ssr_enabled(&mut self, enabled: bool) -> () {
        unsafe { Environment_set_ssr_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_ssr_fade_in(&mut self, fade_in: f64) -> () {
        unsafe { Environment_set_ssr_fade_in(self.this, fade_in) }
    }

    #[inline]
    pub fn set_ssr_fade_out(&mut self, fade_out: f64) -> () {
        unsafe { Environment_set_ssr_fade_out(self.this, fade_out) }
    }

    #[inline]
    pub fn set_ssr_max_steps(&mut self, max_steps: i64) -> () {
        unsafe { Environment_set_ssr_max_steps(self.this, max_steps) }
    }

    #[inline]
    pub fn set_ssr_rough(&mut self, rough: bool) -> () {
        unsafe { Environment_set_ssr_rough(self.this, rough) }
    }

    #[inline]
    pub fn set_tonemap_auto_exposure(&mut self, auto_exposure: bool) -> () {
        unsafe { Environment_set_tonemap_auto_exposure(self.this, auto_exposure) }
    }

    #[inline]
    pub fn set_tonemap_auto_exposure_grey(&mut self, exposure_grey: f64) -> () {
        unsafe { Environment_set_tonemap_auto_exposure_grey(self.this, exposure_grey) }
    }

    #[inline]
    pub fn set_tonemap_auto_exposure_max(&mut self, exposure_max: f64) -> () {
        unsafe { Environment_set_tonemap_auto_exposure_max(self.this, exposure_max) }
    }

    #[inline]
    pub fn set_tonemap_auto_exposure_min(&mut self, exposure_min: f64) -> () {
        unsafe { Environment_set_tonemap_auto_exposure_min(self.this, exposure_min) }
    }

    #[inline]
    pub fn set_tonemap_auto_exposure_speed(&mut self, exposure_speed: f64) -> () {
        unsafe { Environment_set_tonemap_auto_exposure_speed(self.this, exposure_speed) }
    }

    #[inline]
    pub fn set_tonemap_exposure(&mut self, exposure: f64) -> () {
        unsafe { Environment_set_tonemap_exposure(self.this, exposure) }
    }

    #[inline]
    pub fn set_tonemap_white(&mut self, white: f64) -> () {
        unsafe { Environment_set_tonemap_white(self.this, white) }
    }

    #[inline]
    pub fn set_tonemapper(&mut self, mode: i64) -> () {
        unsafe { Environment_set_tonemapper(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Expression` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_expression.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Expression inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Expression {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Expression {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ExpressionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Expression {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn execute(&mut self, inputs: VariantArray, base_instance: Option<Object>, show_error: bool) -> Variant {
        unsafe { Expression_execute(self.this, inputs, base_instance, show_error) }
    }

    #[inline]
    pub fn get_error_text(&self) -> GodotString {
        unsafe { Expression_get_error_text(self.this) }
    }

    #[inline]
    pub fn has_execute_failed(&self) -> bool {
        unsafe { Expression_has_execute_failed(self.this) }
    }

    #[inline]
    pub fn parse(&mut self, expression: GodotString, input_names: StringArray) -> GodotResult {
        unsafe { Expression_parse(self.this, expression, input_names) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class FileDialog` inherits `ConfirmationDialog` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_filedialog.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `FileDialog` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `FileDialog::free`.
///
/// ## Class hierarchy
///
/// FileDialog inherits methods from:
/// - [ConfirmationDialog](struct.ConfirmationDialog.html)
/// - [AcceptDialog](struct.AcceptDialog.html)
/// - [WindowDialog](struct.WindowDialog.html)
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct FileDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileDialogMode {
    ModeOpenFile = 0,
    ModeOpenFiles = 1,
    ModeOpenDir = 2,
    ModeOpenAny = 3,
    ModeSaveFile = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileDialogAccess {
    Resources = 0,
    Userdata = 1,
    Filesystem = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl FileDialog {
    pub const MODE_OPEN_FILE: i64 = 0;
    pub const MODE_OPEN_DIR: i64 = 2;
    pub const MODE_OPEN_FILES: i64 = 1;
    pub const ACCESS_RESOURCES: i64 = 0;
    pub const ACCESS_USERDATA: i64 = 1;
    pub const MODE_SAVE_FILE: i64 = 4;
    pub const MODE_OPEN_ANY: i64 = 3;
    pub const ACCESS_FILESYSTEM: i64 = 2;
}
impl FileDialog {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `FileDialog::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = FileDialogMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            FileDialog {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _action_pressed(&mut self) -> () {
        FileDialog__action_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _cancel_pressed(&mut self) -> () {
        FileDialog__cancel_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _dir_entered(&mut self, arg0: GodotString) -> () {
        FileDialog__dir_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _file_entered(&mut self, arg0: GodotString) -> () {
        FileDialog__file_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _filter_selected(&mut self, arg0: i64) -> () {
        FileDialog__filter_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _go_up(&mut self) -> () {
        FileDialog__go_up(self.this)
    }

    #[inline]
    pub unsafe fn _make_dir(&mut self) -> () {
        FileDialog__make_dir(self.this)
    }

    #[inline]
    pub unsafe fn _make_dir_confirm(&mut self) -> () {
        FileDialog__make_dir_confirm(self.this)
    }

    #[inline]
    pub unsafe fn _save_confirm_pressed(&mut self) -> () {
        FileDialog__save_confirm_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _select_drive(&mut self, arg0: i64) -> () {
        FileDialog__select_drive(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _tree_item_activated(&mut self) -> () {
        FileDialog__tree_item_activated(self.this)
    }

    #[inline]
    pub unsafe fn _tree_multi_selected(&mut self, arg0: Option<Object>, arg1: i64, arg2: bool) -> () {
        FileDialog__tree_multi_selected(self.this, arg0, arg1, arg2)
    }

    #[inline]
    pub unsafe fn _tree_selected(&mut self) -> () {
        FileDialog__tree_selected(self.this)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, arg0: Option<InputEvent>) -> () {
        FileDialog__unhandled_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _update_dir(&mut self) -> () {
        FileDialog__update_dir(self.this)
    }

    #[inline]
    pub unsafe fn _update_file_list(&mut self) -> () {
        FileDialog__update_file_list(self.this)
    }

    #[inline]
    pub unsafe fn _update_file_name(&mut self) -> () {
        FileDialog__update_file_name(self.this)
    }

    #[inline]
    pub unsafe fn add_filter(&mut self, filter: GodotString) -> () {
        FileDialog_add_filter(self.this, filter)
    }

    #[inline]
    pub unsafe fn clear_filters(&mut self) -> () {
        FileDialog_clear_filters(self.this)
    }

    #[inline]
    pub unsafe fn deselect_items(&mut self) -> () {
        FileDialog_deselect_items(self.this)
    }

    #[inline]
    pub unsafe fn get_access(&self) -> FileDialogAccess {
        FileDialog_get_access(self.this)
    }

    #[inline]
    pub unsafe fn get_current_dir(&self) -> GodotString {
        FileDialog_get_current_dir(self.this)
    }

    #[inline]
    pub unsafe fn get_current_file(&self) -> GodotString {
        FileDialog_get_current_file(self.this)
    }

    #[inline]
    pub unsafe fn get_current_path(&self) -> GodotString {
        FileDialog_get_current_path(self.this)
    }

    #[inline]
    pub unsafe fn get_filters(&self) -> StringArray {
        FileDialog_get_filters(self.this)
    }

    #[inline]
    pub unsafe fn get_line_edit(&mut self) -> Option<LineEdit> {
        FileDialog_get_line_edit(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> FileDialogMode {
        FileDialog_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_vbox(&mut self) -> Option<VBoxContainer> {
        FileDialog_get_vbox(self.this)
    }

    #[inline]
    pub unsafe fn invalidate(&mut self) -> () {
        FileDialog_invalidate(self.this)
    }

    #[inline]
    pub unsafe fn is_mode_overriding_title(&self) -> bool {
        FileDialog_is_mode_overriding_title(self.this)
    }

    #[inline]
    pub unsafe fn is_showing_hidden_files(&self) -> bool {
        FileDialog_is_showing_hidden_files(self.this)
    }

    #[inline]
    pub unsafe fn set_access(&mut self, access: i64) -> () {
        FileDialog_set_access(self.this, access)
    }

    #[inline]
    pub unsafe fn set_current_dir(&mut self, dir: GodotString) -> () {
        FileDialog_set_current_dir(self.this, dir)
    }

    #[inline]
    pub unsafe fn set_current_file(&mut self, file: GodotString) -> () {
        FileDialog_set_current_file(self.this, file)
    }

    #[inline]
    pub unsafe fn set_current_path(&mut self, path: GodotString) -> () {
        FileDialog_set_current_path(self.this, path)
    }

    #[inline]
    pub unsafe fn set_filters(&mut self, filters: StringArray) -> () {
        FileDialog_set_filters(self.this, filters)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        FileDialog_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_mode_overrides_title(&mut self, _override: bool) -> () {
        FileDialog_set_mode_overrides_title(self.this, _override)
    }

    #[inline]
    pub unsafe fn set_show_hidden_files(&mut self, show: bool) -> () {
        FileDialog_set_show_hidden_files(self.this, show)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_confirmation_dialog(&self) -> ConfirmationDialog {
        // Not reference-counted.
        ConfirmationDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_accept_dialog(&self) -> AcceptDialog {
        // Not reference-counted.
        AcceptDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_window_dialog(&self) -> WindowDialog {
        // Not reference-counted.
        WindowDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Font` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_font.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Font inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Font {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Font {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn draw(&self, canvas_item: Rid, position: Vector2, string: GodotString, modulate: Color, clip_w: i64, outline_modulate: Color) -> () {
        unsafe { Font_draw(self.this, canvas_item, position, string, modulate, clip_w, outline_modulate) }
    }

    #[inline]
    pub fn draw_char(&self, canvas_item: Rid, position: Vector2, char: i64, next: i64, modulate: Color, outline: bool) -> f64 {
        unsafe { Font_draw_char(self.this, canvas_item, position, char, next, modulate, outline) }
    }

    #[inline]
    pub fn get_ascent(&self) -> f64 {
        unsafe { Font_get_ascent(self.this) }
    }

    #[inline]
    pub fn get_descent(&self) -> f64 {
        unsafe { Font_get_descent(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { Font_get_height(self.this) }
    }

    #[inline]
    pub fn get_string_size(&self, string: GodotString) -> Vector2 {
        unsafe { Font_get_string_size(self.this, string) }
    }

    #[inline]
    pub fn get_wordwrap_string_size(&self, string: GodotString, width: f64) -> Vector2 {
        unsafe { Font_get_wordwrap_string_size(self.this, string, width) }
    }

    #[inline]
    pub fn has_outline(&self) -> bool {
        unsafe { Font_has_outline(self.this) }
    }

    #[inline]
    pub fn is_distance_field_hint(&self) -> bool {
        unsafe { Font_is_distance_field_hint(self.this) }
    }

    #[inline]
    pub fn update_changes(&mut self) -> () {
        unsafe { Font_update_changes(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class FuncRef` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_funcref.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// FuncRef inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct FuncRef {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl FuncRef {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = FuncRefMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            FuncRef {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn call_func(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { FuncRef_call_func(self.this, varargs) }
    }

    #[inline]
    pub fn call_funcv(&mut self, arg_array: VariantArray) -> Variant {
        unsafe { FuncRef_call_funcv(self.this, arg_array) }
    }

    #[inline]
    pub fn is_valid(&self) -> bool {
        unsafe { FuncRef_is_valid(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, name: GodotString) -> () {
        unsafe { FuncRef_set_function(self.this, name) }
    }

    #[inline]
    pub fn set_instance(&mut self, instance: Option<Object>) -> () {
        unsafe { FuncRef_set_instance(self.this, instance) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GDNative` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GDNative inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            GDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn call_native(&mut self, calling_type: GodotString, procedure_name: GodotString, arguments: VariantArray) -> Variant {
        unsafe { GDNative_call_native(self.this, calling_type, procedure_name, arguments) }
    }

    #[inline]
    pub fn get_library(&self) -> Option<GDNativeLibrary> {
        unsafe { GDNative_get_library(self.this) }
    }

    #[inline]
    pub fn initialize(&mut self) -> bool {
        unsafe { GDNative_initialize(self.this) }
    }

    #[inline]
    pub fn set_library(&mut self, library: Option<GDNativeLibrary>) -> () {
        unsafe { GDNative_set_library(self.this, library) }
    }

    #[inline]
    pub fn terminate(&mut self) -> bool {
        unsafe { GDNative_terminate(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GDNativeLibrary` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gdnativelibrary.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GDNativeLibrary inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GDNativeLibrary {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GDNativeLibrary {

/// Returns the GDNativeLibrary object of this library. Can be used to construct NativeScript objects.
/// 
/// See also `Instance::new` for a typed API.
#[inline]
pub fn current_library() -> Self {
    let this = get_gdnative_library_sys();

    Self {
        this
    }
}

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GDNativeLibraryMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            GDNativeLibrary {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_config_file(&mut self) -> Option<ConfigFile> {
        unsafe { GDNativeLibrary_get_config_file(self.this) }
    }

    #[inline]
    pub fn get_current_dependencies(&self) -> StringArray {
        unsafe { GDNativeLibrary_get_current_dependencies(self.this) }
    }

    #[inline]
    pub fn get_current_library_path(&self) -> GodotString {
        unsafe { GDNativeLibrary_get_current_library_path(self.this) }
    }

    #[inline]
    pub fn get_symbol_prefix(&self) -> GodotString {
        unsafe { GDNativeLibrary_get_symbol_prefix(self.this) }
    }

    #[inline]
    pub fn is_reloadable(&self) -> bool {
        unsafe { GDNativeLibrary_is_reloadable(self.this) }
    }

    #[inline]
    pub fn is_singleton(&self) -> bool {
        unsafe { GDNativeLibrary_is_singleton(self.this) }
    }

    #[inline]
    pub fn set_config_file(&mut self, config_file: Option<ConfigFile>) -> () {
        unsafe { GDNativeLibrary_set_config_file(self.this, config_file) }
    }

    #[inline]
    pub fn set_load_once(&mut self, load_once: bool) -> () {
        unsafe { GDNativeLibrary_set_load_once(self.this, load_once) }
    }

    #[inline]
    pub fn set_reloadable(&mut self, reloadable: bool) -> () {
        unsafe { GDNativeLibrary_set_reloadable(self.this, reloadable) }
    }

    #[inline]
    pub fn set_singleton(&mut self, singleton: bool) -> () {
        unsafe { GDNativeLibrary_set_singleton(self.this, singleton) }
    }

    #[inline]
    pub fn set_symbol_prefix(&mut self, symbol_prefix: GodotString) -> () {
        unsafe { GDNativeLibrary_set_symbol_prefix(self.this, symbol_prefix) }
    }

    #[inline]
    pub fn should_load_once(&self) -> bool {
        unsafe { GDNativeLibrary_should_load_once(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GDScript` inherits `Script` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gdscript.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GDScript inherits methods from:
/// - [Script](struct.Script.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GDScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GDScript {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GDScriptMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            GDScript {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_as_byte_code(&self) -> ByteArray {
        unsafe { GDScript_get_as_byte_code(self.this) }
    }

    #[inline]
    pub fn _new(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { GDScript__new(self.this, varargs) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_script(&self) -> Script {
        unsafe {{ object::add_ref(self.this); }}
        Script { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GDScriptFunctionState` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gdscriptfunctionstate.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GDScriptFunctionState inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GDScriptFunctionState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GDScriptFunctionState {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _signal_callback(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { GDScriptFunctionState__signal_callback(self.this, varargs) }
    }

    #[inline]
    pub fn is_valid(&self, extended_check: bool) -> bool {
        unsafe { GDScriptFunctionState_is_valid(self.this, extended_check) }
    }

    #[inline]
    pub fn resume(&mut self, arg: Variant) -> Variant {
        unsafe { GDScriptFunctionState_resume(self.this, arg) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GIProbe` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_giprobe.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GIProbe` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GIProbe::free`.
///
/// ## Class hierarchy
///
/// GIProbe inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GIProbe {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GIProbeSubdiv {
    Subdiv64 = 0,
    Subdiv128 = 1,
    Subdiv256 = 2,
    Subdiv512 = 3,
    Max = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl GIProbe {
    pub const SUBDIV_64: i64 = 0;
    pub const SUBDIV_256: i64 = 2;
    pub const SUBDIV_MAX: i64 = 4;
    pub const SUBDIV_128: i64 = 1;
    pub const SUBDIV_512: i64 = 3;
}
impl GIProbe {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GIProbe::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GIProbeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GIProbe {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn bake(&mut self, from_node: Option<Node>, create_visual_debug: bool) -> () {
        GIProbe_bake(self.this, from_node, create_visual_debug)
    }

    #[inline]
    pub unsafe fn debug_bake(&mut self) -> () {
        GIProbe_debug_bake(self.this)
    }

    #[inline]
    pub unsafe fn get_bias(&self) -> f64 {
        GIProbe_get_bias(self.this)
    }

    #[inline]
    pub unsafe fn get_dynamic_range(&self) -> i64 {
        GIProbe_get_dynamic_range(self.this)
    }

    #[inline]
    pub unsafe fn get_energy(&self) -> f64 {
        GIProbe_get_energy(self.this)
    }

    #[inline]
    pub unsafe fn get_extents(&self) -> Vector3 {
        GIProbe_get_extents(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_bias(&self) -> f64 {
        GIProbe_get_normal_bias(self.this)
    }

    #[inline]
    pub unsafe fn get_probe_data(&self) -> Option<GIProbeData> {
        GIProbe_get_probe_data(self.this)
    }

    #[inline]
    pub unsafe fn get_propagation(&self) -> f64 {
        GIProbe_get_propagation(self.this)
    }

    #[inline]
    pub unsafe fn get_subdiv(&self) -> GIProbeSubdiv {
        GIProbe_get_subdiv(self.this)
    }

    #[inline]
    pub unsafe fn is_compressed(&self) -> bool {
        GIProbe_is_compressed(self.this)
    }

    #[inline]
    pub unsafe fn is_interior(&self) -> bool {
        GIProbe_is_interior(self.this)
    }

    #[inline]
    pub unsafe fn set_bias(&mut self, max: f64) -> () {
        GIProbe_set_bias(self.this, max)
    }

    #[inline]
    pub unsafe fn set_compress(&mut self, enable: bool) -> () {
        GIProbe_set_compress(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_dynamic_range(&mut self, max: i64) -> () {
        GIProbe_set_dynamic_range(self.this, max)
    }

    #[inline]
    pub unsafe fn set_energy(&mut self, max: f64) -> () {
        GIProbe_set_energy(self.this, max)
    }

    #[inline]
    pub unsafe fn set_extents(&mut self, extents: Vector3) -> () {
        GIProbe_set_extents(self.this, extents)
    }

    #[inline]
    pub unsafe fn set_interior(&mut self, enable: bool) -> () {
        GIProbe_set_interior(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_normal_bias(&mut self, max: f64) -> () {
        GIProbe_set_normal_bias(self.this, max)
    }

    #[inline]
    pub unsafe fn set_probe_data(&mut self, data: Option<GIProbeData>) -> () {
        GIProbe_set_probe_data(self.this, data)
    }

    #[inline]
    pub unsafe fn set_propagation(&mut self, max: f64) -> () {
        GIProbe_set_propagation(self.this, max)
    }

    #[inline]
    pub unsafe fn set_subdiv(&mut self, subdiv: i64) -> () {
        GIProbe_set_subdiv(self.this, subdiv)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GIProbeData` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_giprobedata.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GIProbeData inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GIProbeData {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GIProbeData {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GIProbeDataMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            GIProbeData {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_bias(&self) -> f64 {
        unsafe { GIProbeData_get_bias(self.this) }
    }

    #[inline]
    pub fn get_bounds(&self) -> Aabb {
        unsafe { GIProbeData_get_bounds(self.this) }
    }

    #[inline]
    pub fn get_cell_size(&self) -> f64 {
        unsafe { GIProbeData_get_cell_size(self.this) }
    }

    #[inline]
    pub fn get_dynamic_data(&self) -> Int32Array {
        unsafe { GIProbeData_get_dynamic_data(self.this) }
    }

    #[inline]
    pub fn get_dynamic_range(&self) -> i64 {
        unsafe { GIProbeData_get_dynamic_range(self.this) }
    }

    #[inline]
    pub fn get_energy(&self) -> f64 {
        unsafe { GIProbeData_get_energy(self.this) }
    }

    #[inline]
    pub fn get_normal_bias(&self) -> f64 {
        unsafe { GIProbeData_get_normal_bias(self.this) }
    }

    #[inline]
    pub fn get_propagation(&self) -> f64 {
        unsafe { GIProbeData_get_propagation(self.this) }
    }

    #[inline]
    pub fn get_to_cell_xform(&self) -> Transform {
        unsafe { GIProbeData_get_to_cell_xform(self.this) }
    }

    #[inline]
    pub fn is_compressed(&self) -> bool {
        unsafe { GIProbeData_is_compressed(self.this) }
    }

    #[inline]
    pub fn is_interior(&self) -> bool {
        unsafe { GIProbeData_is_interior(self.this) }
    }

    #[inline]
    pub fn set_bias(&mut self, bias: f64) -> () {
        unsafe { GIProbeData_set_bias(self.this, bias) }
    }

    #[inline]
    pub fn set_bounds(&mut self, bounds: Aabb) -> () {
        unsafe { GIProbeData_set_bounds(self.this, bounds) }
    }

    #[inline]
    pub fn set_cell_size(&mut self, cell_size: f64) -> () {
        unsafe { GIProbeData_set_cell_size(self.this, cell_size) }
    }

    #[inline]
    pub fn set_compress(&mut self, compress: bool) -> () {
        unsafe { GIProbeData_set_compress(self.this, compress) }
    }

    #[inline]
    pub fn set_dynamic_data(&mut self, dynamic_data: Int32Array) -> () {
        unsafe { GIProbeData_set_dynamic_data(self.this, dynamic_data) }
    }

    #[inline]
    pub fn set_dynamic_range(&mut self, dynamic_range: i64) -> () {
        unsafe { GIProbeData_set_dynamic_range(self.this, dynamic_range) }
    }

    #[inline]
    pub fn set_energy(&mut self, energy: f64) -> () {
        unsafe { GIProbeData_set_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_interior(&mut self, interior: bool) -> () {
        unsafe { GIProbeData_set_interior(self.this, interior) }
    }

    #[inline]
    pub fn set_normal_bias(&mut self, bias: f64) -> () {
        unsafe { GIProbeData_set_normal_bias(self.this, bias) }
    }

    #[inline]
    pub fn set_propagation(&mut self, propagation: f64) -> () {
        unsafe { GIProbeData_set_propagation(self.this, propagation) }
    }

    #[inline]
    pub fn set_to_cell_xform(&mut self, to_cell_xform: Transform) -> () {
        unsafe { GIProbeData_set_to_cell_xform(self.this, to_cell_xform) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Generic6DOFJoint` inherits `Joint` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_generic6dofjoint.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Generic6DOFJoint` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Generic6DOFJoint::free`.
///
/// ## Class hierarchy
///
/// Generic6DOFJoint inherits methods from:
/// - [Joint](struct.Joint.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Generic6DOFJoint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Generic6DOFJointParam {
    LinearLowerLimit = 0,
    LinearUpperLimit = 1,
    LinearLimitSoftness = 2,
    LinearRestitution = 3,
    LinearDamping = 4,
    LinearMotorTargetVelocity = 5,
    LinearMotorForceLimit = 6,
    AngularLowerLimit = 10,
    AngularUpperLimit = 11,
    AngularLimitSoftness = 12,
    AngularDamping = 13,
    AngularRestitution = 14,
    AngularForceLimit = 15,
    AngularErp = 16,
    AngularMotorTargetVelocity = 17,
    AngularMotorForceLimit = 18,
    Max = 22,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Generic6DOFJointFlag {
    EnableLinearLimit = 0,
    EnableAngularLimit = 1,
    EnableAngularSpring = 2,
    EnableLinearSpring = 3,
    EnableMotor = 4,
    EnableLinearMotor = 5,
    Max = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Generic6DOFJoint {
    pub const FLAG_ENABLE_LINEAR_MOTOR: i64 = 5;
    pub const FLAG_ENABLE_LINEAR_LIMIT: i64 = 0;
    pub const PARAM_MAX: i64 = 22;
    pub const PARAM_LINEAR_LOWER_LIMIT: i64 = 0;
    pub const PARAM_ANGULAR_ERP: i64 = 16;
    pub const FLAG_ENABLE_MOTOR: i64 = 4;
    pub const PARAM_ANGULAR_LOWER_LIMIT: i64 = 10;
    pub const PARAM_LINEAR_MOTOR_TARGET_VELOCITY: i64 = 5;
    pub const PARAM_LINEAR_UPPER_LIMIT: i64 = 1;
    pub const PARAM_ANGULAR_MOTOR_TARGET_VELOCITY: i64 = 17;
    pub const FLAG_ENABLE_LINEAR_SPRING: i64 = 3;
    pub const PARAM_ANGULAR_DAMPING: i64 = 13;
    pub const PARAM_ANGULAR_UPPER_LIMIT: i64 = 11;
    pub const PARAM_LINEAR_LIMIT_SOFTNESS: i64 = 2;
    pub const PARAM_LINEAR_DAMPING: i64 = 4;
    pub const FLAG_ENABLE_ANGULAR_SPRING: i64 = 2;
    pub const FLAG_MAX: i64 = 6;
    pub const FLAG_ENABLE_ANGULAR_LIMIT: i64 = 1;
    pub const PARAM_ANGULAR_MOTOR_FORCE_LIMIT: i64 = 18;
    pub const PARAM_ANGULAR_RESTITUTION: i64 = 14;
    pub const PARAM_LINEAR_MOTOR_FORCE_LIMIT: i64 = 6;
    pub const PARAM_LINEAR_RESTITUTION: i64 = 3;
    pub const PARAM_ANGULAR_FORCE_LIMIT: i64 = 15;
    pub const PARAM_ANGULAR_LIMIT_SOFTNESS: i64 = 12;
}
impl Generic6DOFJoint {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Generic6DOFJoint::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Generic6DOFJointMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Generic6DOFJoint {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_angular_hi_limit_x(&self) -> f64 {
        Generic6DOFJoint__get_angular_hi_limit_x(self.this)
    }

    #[inline]
    pub unsafe fn _get_angular_hi_limit_y(&self) -> f64 {
        Generic6DOFJoint__get_angular_hi_limit_y(self.this)
    }

    #[inline]
    pub unsafe fn _get_angular_hi_limit_z(&self) -> f64 {
        Generic6DOFJoint__get_angular_hi_limit_z(self.this)
    }

    #[inline]
    pub unsafe fn _get_angular_lo_limit_x(&self) -> f64 {
        Generic6DOFJoint__get_angular_lo_limit_x(self.this)
    }

    #[inline]
    pub unsafe fn _get_angular_lo_limit_y(&self) -> f64 {
        Generic6DOFJoint__get_angular_lo_limit_y(self.this)
    }

    #[inline]
    pub unsafe fn _get_angular_lo_limit_z(&self) -> f64 {
        Generic6DOFJoint__get_angular_lo_limit_z(self.this)
    }

    #[inline]
    pub unsafe fn _set_angular_hi_limit_x(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_hi_limit_x(self.this, angle)
    }

    #[inline]
    pub unsafe fn _set_angular_hi_limit_y(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_hi_limit_y(self.this, angle)
    }

    #[inline]
    pub unsafe fn _set_angular_hi_limit_z(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_hi_limit_z(self.this, angle)
    }

    #[inline]
    pub unsafe fn _set_angular_lo_limit_x(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_lo_limit_x(self.this, angle)
    }

    #[inline]
    pub unsafe fn _set_angular_lo_limit_y(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_lo_limit_y(self.this, angle)
    }

    #[inline]
    pub unsafe fn _set_angular_lo_limit_z(&mut self, angle: f64) -> () {
        Generic6DOFJoint__set_angular_lo_limit_z(self.this, angle)
    }

    #[inline]
    pub unsafe fn get_flag_x(&self, flag: i64) -> bool {
        Generic6DOFJoint_get_flag_x(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_flag_y(&self, flag: i64) -> bool {
        Generic6DOFJoint_get_flag_y(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_flag_z(&self, flag: i64) -> bool {
        Generic6DOFJoint_get_flag_z(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_param_x(&self, param: i64) -> f64 {
        Generic6DOFJoint_get_param_x(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_y(&self, param: i64) -> f64 {
        Generic6DOFJoint_get_param_y(self.this, param)
    }

    #[inline]
    pub unsafe fn get_param_z(&self, param: i64) -> f64 {
        Generic6DOFJoint_get_param_z(self.this, param)
    }

    #[inline]
    pub unsafe fn get_precision(&self) -> i64 {
        Generic6DOFJoint_get_precision(self.this)
    }

    #[inline]
    pub unsafe fn set_flag_x(&mut self, flag: i64, value: bool) -> () {
        Generic6DOFJoint_set_flag_x(self.this, flag, value)
    }

    #[inline]
    pub unsafe fn set_flag_y(&mut self, flag: i64, value: bool) -> () {
        Generic6DOFJoint_set_flag_y(self.this, flag, value)
    }

    #[inline]
    pub unsafe fn set_flag_z(&mut self, flag: i64, value: bool) -> () {
        Generic6DOFJoint_set_flag_z(self.this, flag, value)
    }

    #[inline]
    pub unsafe fn set_param_x(&mut self, param: i64, value: f64) -> () {
        Generic6DOFJoint_set_param_x(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_param_y(&mut self, param: i64, value: f64) -> () {
        Generic6DOFJoint_set_param_y(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_param_z(&mut self, param: i64, value: f64) -> () {
        Generic6DOFJoint_set_param_z(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_precision(&mut self, precision: i64) -> () {
        Generic6DOFJoint_set_precision(self.this, precision)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint(&self) -> Joint {
        // Not reference-counted.
        Joint { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GeometryInstance` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_geometryinstance.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// GeometryInstance inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GeometryInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GeometryInstanceFlags {
    FlagUseBakedLight = 0,
    FlagDrawNextFrameIfVisible = 1,
    FlagMax = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GeometryInstanceShadowCastingSetting {
    Off = 0,
    On = 1,
    DoubleSided = 2,
    ShadowsOnly = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl GeometryInstance {
    pub const FLAG_DRAW_NEXT_FRAME_IF_VISIBLE: i64 = 1;
    pub const SHADOW_CASTING_SETTING_DOUBLE_SIDED: i64 = 2;
    pub const FLAG_USE_BAKED_LIGHT: i64 = 0;
    pub const SHADOW_CASTING_SETTING_OFF: i64 = 0;
    pub const SHADOW_CASTING_SETTING_ON: i64 = 1;
    pub const SHADOW_CASTING_SETTING_SHADOWS_ONLY: i64 = 3;
    pub const FLAG_MAX: i64 = 2;
}
impl GeometryInstance {
    #[inline]
    pub unsafe fn get_cast_shadows_setting(&self) -> GeometryInstanceShadowCastingSetting {
        GeometryInstance_get_cast_shadows_setting(self.this)
    }

    #[inline]
    pub unsafe fn get_extra_cull_margin(&self) -> f64 {
        GeometryInstance_get_extra_cull_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_flag(&self, flag: i64) -> bool {
        GeometryInstance_get_flag(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_lod_max_distance(&self) -> f64 {
        GeometryInstance_get_lod_max_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_lod_max_hysteresis(&self) -> f64 {
        GeometryInstance_get_lod_max_hysteresis(self.this)
    }

    #[inline]
    pub unsafe fn get_lod_min_distance(&self) -> f64 {
        GeometryInstance_get_lod_min_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_lod_min_hysteresis(&self) -> f64 {
        GeometryInstance_get_lod_min_hysteresis(self.this)
    }

    #[inline]
    pub unsafe fn get_material_override(&self) -> Option<Material> {
        GeometryInstance_get_material_override(self.this)
    }

    #[inline]
    pub unsafe fn set_cast_shadows_setting(&mut self, shadow_casting_setting: i64) -> () {
        GeometryInstance_set_cast_shadows_setting(self.this, shadow_casting_setting)
    }

    #[inline]
    pub unsafe fn set_custom_aabb(&mut self, aabb: Aabb) -> () {
        GeometryInstance_set_custom_aabb(self.this, aabb)
    }

    #[inline]
    pub unsafe fn set_extra_cull_margin(&mut self, margin: f64) -> () {
        GeometryInstance_set_extra_cull_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn set_flag(&mut self, flag: i64, value: bool) -> () {
        GeometryInstance_set_flag(self.this, flag, value)
    }

    #[inline]
    pub unsafe fn set_lod_max_distance(&mut self, mode: f64) -> () {
        GeometryInstance_set_lod_max_distance(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_lod_max_hysteresis(&mut self, mode: f64) -> () {
        GeometryInstance_set_lod_max_hysteresis(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_lod_min_distance(&mut self, mode: f64) -> () {
        GeometryInstance_set_lod_min_distance(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_lod_min_hysteresis(&mut self, mode: f64) -> () {
        GeometryInstance_set_lod_min_hysteresis(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_material_override(&mut self, material: Option<Material>) -> () {
        GeometryInstance_set_material_override(self.this, material)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Gradient` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gradient.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Gradient inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Gradient {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Gradient {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GradientMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Gradient {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_point(&mut self, offset: f64, color: Color) -> () {
        unsafe { Gradient_add_point(self.this, offset, color) }
    }

    #[inline]
    pub fn get_color(&self, point: i64) -> Color {
        unsafe { Gradient_get_color(self.this, point) }
    }

    #[inline]
    pub fn get_colors(&self) -> ColorArray {
        unsafe { Gradient_get_colors(self.this) }
    }

    #[inline]
    pub fn get_offset(&self, point: i64) -> f64 {
        unsafe { Gradient_get_offset(self.this, point) }
    }

    #[inline]
    pub fn get_offsets(&self) -> Float32Array {
        unsafe { Gradient_get_offsets(self.this) }
    }

    #[inline]
    pub fn get_point_count(&self) -> i64 {
        unsafe { Gradient_get_point_count(self.this) }
    }

    #[inline]
    pub fn interpolate(&mut self, offset: f64) -> Color {
        unsafe { Gradient_interpolate(self.this, offset) }
    }

    #[inline]
    pub fn remove_point(&mut self, offset: i64) -> () {
        unsafe { Gradient_remove_point(self.this, offset) }
    }

    #[inline]
    pub fn set_color(&mut self, point: i64, color: Color) -> () {
        unsafe { Gradient_set_color(self.this, point, color) }
    }

    #[inline]
    pub fn set_colors(&mut self, colors: ColorArray) -> () {
        unsafe { Gradient_set_colors(self.this, colors) }
    }

    #[inline]
    pub fn set_offset(&mut self, point: i64, offset: f64) -> () {
        unsafe { Gradient_set_offset(self.this, point, offset) }
    }

    #[inline]
    pub fn set_offsets(&mut self, offsets: Float32Array) -> () {
        unsafe { Gradient_set_offsets(self.this, offsets) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GradientTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gradienttexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// GradientTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GradientTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GradientTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GradientTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            GradientTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _update(&mut self) -> () {
        unsafe { GradientTexture__update(self.this) }
    }

    #[inline]
    pub fn get_gradient(&self) -> Option<Gradient> {
        unsafe { GradientTexture_get_gradient(self.this) }
    }

    #[inline]
    pub fn set_gradient(&mut self, gradient: Option<Gradient>) -> () {
        unsafe { GradientTexture_set_gradient(self.this, gradient) }
    }

    #[inline]
    pub fn set_width(&mut self, width: i64) -> () {
        unsafe { GradientTexture_set_width(self.this, width) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GraphEdit` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_graphedit.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GraphEdit` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GraphEdit::free`.
///
/// ## Class hierarchy
///
/// GraphEdit inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GraphEdit {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GraphEdit {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GraphEdit::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GraphEditMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GraphEdit {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _connections_layer_draw(&mut self) -> () {
        GraphEdit__connections_layer_draw(self.this)
    }

    #[inline]
    pub unsafe fn _graph_node_moved(&mut self, arg0: Option<Node>) -> () {
        GraphEdit__graph_node_moved(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _graph_node_raised(&mut self, arg0: Option<Node>) -> () {
        GraphEdit__graph_node_raised(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        GraphEdit__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _scroll_moved(&mut self, arg0: f64) -> () {
        GraphEdit__scroll_moved(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _snap_toggled(&mut self) -> () {
        GraphEdit__snap_toggled(self.this)
    }

    #[inline]
    pub unsafe fn _snap_value_changed(&mut self, arg0: f64) -> () {
        GraphEdit__snap_value_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _top_layer_draw(&mut self) -> () {
        GraphEdit__top_layer_draw(self.this)
    }

    #[inline]
    pub unsafe fn _top_layer_input(&mut self, arg0: Option<InputEvent>) -> () {
        GraphEdit__top_layer_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _update_scroll_offset(&mut self) -> () {
        GraphEdit__update_scroll_offset(self.this)
    }

    #[inline]
    pub unsafe fn _zoom_minus(&mut self) -> () {
        GraphEdit__zoom_minus(self.this)
    }

    #[inline]
    pub unsafe fn _zoom_plus(&mut self) -> () {
        GraphEdit__zoom_plus(self.this)
    }

    #[inline]
    pub unsafe fn _zoom_reset(&mut self) -> () {
        GraphEdit__zoom_reset(self.this)
    }

    #[inline]
    pub unsafe fn add_valid_connection_type(&mut self, from_type: i64, to_type: i64) -> () {
        GraphEdit_add_valid_connection_type(self.this, from_type, to_type)
    }

    #[inline]
    pub unsafe fn add_valid_left_disconnect_type(&mut self, _type: i64) -> () {
        GraphEdit_add_valid_left_disconnect_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn add_valid_right_disconnect_type(&mut self, _type: i64) -> () {
        GraphEdit_add_valid_right_disconnect_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn clear_connections(&mut self) -> () {
        GraphEdit_clear_connections(self.this)
    }

    #[inline]
    pub unsafe fn connect_node(&mut self, from: GodotString, from_port: i64, to: GodotString, to_port: i64) -> GodotResult {
        GraphEdit_connect_node(self.this, from, from_port, to, to_port)
    }

    #[inline]
    pub unsafe fn disconnect_node(&mut self, from: GodotString, from_port: i64, to: GodotString, to_port: i64) -> () {
        GraphEdit_disconnect_node(self.this, from, from_port, to, to_port)
    }

    #[inline]
    pub unsafe fn get_connection_list(&self) -> VariantArray {
        GraphEdit_get_connection_list(self.this)
    }

    #[inline]
    pub unsafe fn get_scroll_ofs(&self) -> Vector2 {
        GraphEdit_get_scroll_ofs(self.this)
    }

    #[inline]
    pub unsafe fn get_snap(&self) -> i64 {
        GraphEdit_get_snap(self.this)
    }

    #[inline]
    pub unsafe fn get_zoom(&self) -> f64 {
        GraphEdit_get_zoom(self.this)
    }

    #[inline]
    pub unsafe fn get_zoom_hbox(&mut self) -> Option<HBoxContainer> {
        GraphEdit_get_zoom_hbox(self.this)
    }

    #[inline]
    pub unsafe fn is_node_connected(&mut self, from: GodotString, from_port: i64, to: GodotString, to_port: i64) -> bool {
        GraphEdit_is_node_connected(self.this, from, from_port, to, to_port)
    }

    #[inline]
    pub unsafe fn is_right_disconnects_enabled(&self) -> bool {
        GraphEdit_is_right_disconnects_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_using_snap(&self) -> bool {
        GraphEdit_is_using_snap(self.this)
    }

    #[inline]
    pub unsafe fn is_valid_connection_type(&self, from_type: i64, to_type: i64) -> bool {
        GraphEdit_is_valid_connection_type(self.this, from_type, to_type)
    }

    #[inline]
    pub unsafe fn remove_valid_connection_type(&mut self, from_type: i64, to_type: i64) -> () {
        GraphEdit_remove_valid_connection_type(self.this, from_type, to_type)
    }

    #[inline]
    pub unsafe fn remove_valid_left_disconnect_type(&mut self, _type: i64) -> () {
        GraphEdit_remove_valid_left_disconnect_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn remove_valid_right_disconnect_type(&mut self, _type: i64) -> () {
        GraphEdit_remove_valid_right_disconnect_type(self.this, _type)
    }

    #[inline]
    pub unsafe fn set_connection_activity(&mut self, from: GodotString, from_port: i64, to: GodotString, to_port: i64, amount: f64) -> () {
        GraphEdit_set_connection_activity(self.this, from, from_port, to, to_port, amount)
    }

    #[inline]
    pub unsafe fn set_right_disconnects(&mut self, enable: bool) -> () {
        GraphEdit_set_right_disconnects(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_scroll_ofs(&mut self, ofs: Vector2) -> () {
        GraphEdit_set_scroll_ofs(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_selected(&mut self, node: Option<Node>) -> () {
        GraphEdit_set_selected(self.this, node)
    }

    #[inline]
    pub unsafe fn set_snap(&mut self, pixels: i64) -> () {
        GraphEdit_set_snap(self.this, pixels)
    }

    #[inline]
    pub unsafe fn set_use_snap(&mut self, enable: bool) -> () {
        GraphEdit_set_use_snap(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_zoom(&mut self, p_zoom: f64) -> () {
        GraphEdit_set_zoom(self.this, p_zoom)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GraphNode` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_graphnode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GraphNode` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GraphNode::free`.
///
/// ## Class hierarchy
///
/// GraphNode inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GraphNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GraphNodeOverlay {
    Disabled = 0,
    Breakpoint = 1,
    Position = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl GraphNode {
    pub const OVERLAY_POSITION: i64 = 2;
    pub const OVERLAY_BREAKPOINT: i64 = 1;
    pub const OVERLAY_DISABLED: i64 = 0;
}
impl GraphNode {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GraphNode::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GraphNodeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GraphNode {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        GraphNode__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn clear_all_slots(&mut self) -> () {
        GraphNode_clear_all_slots(self.this)
    }

    #[inline]
    pub unsafe fn clear_slot(&mut self, idx: i64) -> () {
        GraphNode_clear_slot(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_input_color(&mut self, idx: i64) -> Color {
        GraphNode_get_connection_input_color(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_input_count(&mut self) -> i64 {
        GraphNode_get_connection_input_count(self.this)
    }

    #[inline]
    pub unsafe fn get_connection_input_position(&mut self, idx: i64) -> Vector2 {
        GraphNode_get_connection_input_position(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_input_type(&mut self, idx: i64) -> i64 {
        GraphNode_get_connection_input_type(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_output_color(&mut self, idx: i64) -> Color {
        GraphNode_get_connection_output_color(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_output_count(&mut self) -> i64 {
        GraphNode_get_connection_output_count(self.this)
    }

    #[inline]
    pub unsafe fn get_connection_output_position(&mut self, idx: i64) -> Vector2 {
        GraphNode_get_connection_output_position(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_connection_output_type(&mut self, idx: i64) -> i64 {
        GraphNode_get_connection_output_type(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        GraphNode_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_overlay(&self) -> GraphNodeOverlay {
        GraphNode_get_overlay(self.this)
    }

    #[inline]
    pub unsafe fn get_slot_color_left(&self, idx: i64) -> Color {
        GraphNode_get_slot_color_left(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_slot_color_right(&self, idx: i64) -> Color {
        GraphNode_get_slot_color_right(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_slot_type_left(&self, idx: i64) -> i64 {
        GraphNode_get_slot_type_left(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_slot_type_right(&self, idx: i64) -> i64 {
        GraphNode_get_slot_type_right(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_title(&self) -> GodotString {
        GraphNode_get_title(self.this)
    }

    #[inline]
    pub unsafe fn is_close_button_visible(&self) -> bool {
        GraphNode_is_close_button_visible(self.this)
    }

    #[inline]
    pub unsafe fn is_comment(&self) -> bool {
        GraphNode_is_comment(self.this)
    }

    #[inline]
    pub unsafe fn is_resizable(&self) -> bool {
        GraphNode_is_resizable(self.this)
    }

    #[inline]
    pub unsafe fn is_selected(&mut self) -> bool {
        GraphNode_is_selected(self.this)
    }

    #[inline]
    pub unsafe fn is_slot_enabled_left(&self, idx: i64) -> bool {
        GraphNode_is_slot_enabled_left(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_slot_enabled_right(&self, idx: i64) -> bool {
        GraphNode_is_slot_enabled_right(self.this, idx)
    }

    #[inline]
    pub unsafe fn set_comment(&mut self, comment: bool) -> () {
        GraphNode_set_comment(self.this, comment)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        GraphNode_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_overlay(&mut self, overlay: i64) -> () {
        GraphNode_set_overlay(self.this, overlay)
    }

    #[inline]
    pub unsafe fn set_resizable(&mut self, resizable: bool) -> () {
        GraphNode_set_resizable(self.this, resizable)
    }

    #[inline]
    pub unsafe fn set_selected(&mut self, selected: bool) -> () {
        GraphNode_set_selected(self.this, selected)
    }

    #[inline]
    pub unsafe fn set_show_close_button(&mut self, show: bool) -> () {
        GraphNode_set_show_close_button(self.this, show)
    }

    #[inline]
    pub unsafe fn set_slot(&mut self, idx: i64, enable_left: bool, type_left: i64, color_left: Color, enable_right: bool, type_right: i64, color_right: Color, custom_left: Option<Texture>, custom_right: Option<Texture>) -> () {
        GraphNode_set_slot(self.this, idx, enable_left, type_left, color_left, enable_right, type_right, color_right, custom_left, custom_right)
    }

    #[inline]
    pub unsafe fn set_title(&mut self, title: GodotString) -> () {
        GraphNode_set_title(self.this, title)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GridContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gridcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GridContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GridContainer::free`.
///
/// ## Class hierarchy
///
/// GridContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GridContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GridContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GridContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GridContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GridContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_columns(&self) -> i64 {
        GridContainer_get_columns(self.this)
    }

    #[inline]
    pub unsafe fn set_columns(&mut self, columns: i64) -> () {
        GridContainer_set_columns(self.this, columns)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GridMap` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_gridmap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GridMap` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GridMap::free`.
///
/// ## Class hierarchy
///
/// GridMap inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GridMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl GridMap {
    pub const INVALID_CELL_ITEM: i64 = -1;
}
impl GridMap {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GridMap::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GridMapMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GridMap {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _update_octants_callback(&mut self) -> () {
        GridMap__update_octants_callback(self.this)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        GridMap_clear(self.this)
    }

    #[inline]
    pub unsafe fn clear_baked_meshes(&mut self) -> () {
        GridMap_clear_baked_meshes(self.this)
    }

    #[inline]
    pub unsafe fn get_bake_mesh_instance(&mut self, idx: i64) -> Rid {
        GridMap_get_bake_mesh_instance(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_bake_meshes(&mut self) -> VariantArray {
        GridMap_get_bake_meshes(self.this)
    }

    #[inline]
    pub unsafe fn get_cell_item(&self, x: i64, y: i64, z: i64) -> i64 {
        GridMap_get_cell_item(self.this, x, y, z)
    }

    #[inline]
    pub unsafe fn get_cell_item_orientation(&self, x: i64, y: i64, z: i64) -> i64 {
        GridMap_get_cell_item_orientation(self.this, x, y, z)
    }

    #[inline]
    pub unsafe fn get_cell_scale(&self) -> f64 {
        GridMap_get_cell_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_cell_size(&self) -> Vector3 {
        GridMap_get_cell_size(self.this)
    }

    #[inline]
    pub unsafe fn get_center_x(&self) -> bool {
        GridMap_get_center_x(self.this)
    }

    #[inline]
    pub unsafe fn get_center_y(&self) -> bool {
        GridMap_get_center_y(self.this)
    }

    #[inline]
    pub unsafe fn get_center_z(&self) -> bool {
        GridMap_get_center_z(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        GridMap_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        GridMap_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        GridMap_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        GridMap_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_mesh_library(&self) -> Option<MeshLibrary> {
        GridMap_get_mesh_library(self.this)
    }

    #[inline]
    pub unsafe fn get_meshes(&mut self) -> VariantArray {
        GridMap_get_meshes(self.this)
    }

    #[inline]
    pub unsafe fn get_octant_size(&self) -> i64 {
        GridMap_get_octant_size(self.this)
    }

    #[inline]
    pub unsafe fn get_used_cells(&self) -> VariantArray {
        GridMap_get_used_cells(self.this)
    }

    #[inline]
    pub unsafe fn make_baked_meshes(&mut self, gen_lightmap_uv: bool, lightmap_uv_texel_size: f64) -> () {
        GridMap_make_baked_meshes(self.this, gen_lightmap_uv, lightmap_uv_texel_size)
    }

    #[inline]
    pub unsafe fn map_to_world(&self, x: i64, y: i64, z: i64) -> Vector3 {
        GridMap_map_to_world(self.this, x, y, z)
    }

    #[inline]
    pub unsafe fn resource_changed(&mut self, resource: Option<Resource>) -> () {
        GridMap_resource_changed(self.this, resource)
    }

    #[inline]
    pub unsafe fn set_cell_item(&mut self, x: i64, y: i64, z: i64, item: i64, orientation: i64) -> () {
        GridMap_set_cell_item(self.this, x, y, z, item, orientation)
    }

    #[inline]
    pub unsafe fn set_cell_scale(&mut self, scale: f64) -> () {
        GridMap_set_cell_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_cell_size(&mut self, size: Vector3) -> () {
        GridMap_set_cell_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_center_x(&mut self, enable: bool) -> () {
        GridMap_set_center_x(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_center_y(&mut self, enable: bool) -> () {
        GridMap_set_center_y(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_center_z(&mut self, enable: bool) -> () {
        GridMap_set_center_z(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_clip(&mut self, enabled: bool, clipabove: bool, floor: i64, axis: i64) -> () {
        GridMap_set_clip(self.this, enabled, clipabove, floor, axis)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, layer: i64) -> () {
        GridMap_set_collision_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        GridMap_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        GridMap_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        GridMap_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_mesh_library(&mut self, mesh_library: Option<MeshLibrary>) -> () {
        GridMap_set_mesh_library(self.this, mesh_library)
    }

    #[inline]
    pub unsafe fn set_octant_size(&mut self, size: i64) -> () {
        GridMap_set_octant_size(self.this, size)
    }

    #[inline]
    pub unsafe fn world_to_map(&self, pos: Vector3) -> Vector3 {
        GridMap_world_to_map(self.this, pos)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class GrooveJoint2D` inherits `Joint2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_groovejoint2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `GrooveJoint2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `GrooveJoint2D::free`.
///
/// ## Class hierarchy
///
/// GrooveJoint2D inherits methods from:
/// - [Joint2D](struct.Joint2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct GrooveJoint2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl GrooveJoint2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `GrooveJoint2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = GrooveJoint2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            GrooveJoint2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_initial_offset(&self) -> f64 {
        GrooveJoint2D_get_initial_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_length(&self) -> f64 {
        GrooveJoint2D_get_length(self.this)
    }

    #[inline]
    pub unsafe fn set_initial_offset(&mut self, offset: f64) -> () {
        GrooveJoint2D_set_initial_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_length(&mut self, length: f64) -> () {
        GrooveJoint2D_set_length(self.this, length)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint_2d(&self) -> Joint2D {
        // Not reference-counted.
        Joint2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HBoxContainer` inherits `BoxContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hboxcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HBoxContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HBoxContainer::free`.
///
/// ## Class hierarchy
///
/// HBoxContainer inherits methods from:
/// - [BoxContainer](struct.BoxContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HBoxContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HBoxContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HBoxContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HBoxContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HBoxContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_box_container(&self) -> BoxContainer {
        // Not reference-counted.
        BoxContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HScrollBar` inherits `ScrollBar` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hscrollbar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HScrollBar` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HScrollBar::free`.
///
/// ## Class hierarchy
///
/// HScrollBar inherits methods from:
/// - [ScrollBar](struct.ScrollBar.html)
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HScrollBar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HScrollBar {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HScrollBar::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HScrollBarMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HScrollBar {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_scroll_bar(&self) -> ScrollBar {
        // Not reference-counted.
        ScrollBar { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HSeparator` inherits `Separator` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hseparator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HSeparator` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HSeparator::free`.
///
/// ## Class hierarchy
///
/// HSeparator inherits methods from:
/// - [Separator](struct.Separator.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HSeparator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HSeparator {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HSeparator::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HSeparatorMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HSeparator {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_separator(&self) -> Separator {
        // Not reference-counted.
        Separator { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HSlider` inherits `Slider` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hslider.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HSlider` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HSlider::free`.
///
/// ## Class hierarchy
///
/// HSlider inherits methods from:
/// - [Slider](struct.Slider.html)
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HSlider {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HSlider {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HSlider::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HSliderMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HSlider {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_slider(&self) -> Slider {
        // Not reference-counted.
        Slider { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HSplitContainer` inherits `SplitContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hsplitcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HSplitContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HSplitContainer::free`.
///
/// ## Class hierarchy
///
/// HSplitContainer inherits methods from:
/// - [SplitContainer](struct.SplitContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HSplitContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HSplitContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HSplitContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HSplitContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HSplitContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_split_container(&self) -> SplitContainer {
        // Not reference-counted.
        SplitContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HTTPClient` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_httpclient.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// HTTPClient inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HTTPClient {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HTTPClientStatus {
    Disconnected = 0,
    Resolving = 1,
    CantResolve = 2,
    Connecting = 3,
    CantConnect = 4,
    Connected = 5,
    Requesting = 6,
    Body = 7,
    ConnectionError = 8,
    SslHandshakeError = 9,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HTTPClientMethod {
    Get = 0,
    Head = 1,
    Post = 2,
    Put = 3,
    Delete = 4,
    Options = 5,
    Trace = 6,
    Connect = 7,
    Patch = 8,
    Max = 9,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HTTPClientResponseCode {
    ResponseContinue = 100,
    ResponseSwitchingProtocols = 101,
    ResponseProcessing = 102,
    ResponseOk = 200,
    ResponseCreated = 201,
    ResponseAccepted = 202,
    ResponseNonAuthoritativeInformation = 203,
    ResponseNoContent = 204,
    ResponseResetContent = 205,
    ResponsePartialContent = 206,
    ResponseMultiStatus = 207,
    ResponseAlreadyReported = 208,
    ResponseImUsed = 226,
    ResponseMultipleChoices = 300,
    ResponseMovedPermanently = 301,
    ResponseFound = 302,
    ResponseSeeOther = 303,
    ResponseNotModified = 304,
    ResponseUseProxy = 305,
    ResponseSwitchProxy = 306,
    ResponseTemporaryRedirect = 307,
    ResponsePermanentRedirect = 308,
    ResponseBadRequest = 400,
    ResponseUnauthorized = 401,
    ResponsePaymentRequired = 402,
    ResponseForbidden = 403,
    ResponseNotFound = 404,
    ResponseMethodNotAllowed = 405,
    ResponseNotAcceptable = 406,
    ResponseProxyAuthenticationRequired = 407,
    ResponseRequestTimeout = 408,
    ResponseConflict = 409,
    ResponseGone = 410,
    ResponseLengthRequired = 411,
    ResponsePreconditionFailed = 412,
    ResponseRequestEntityTooLarge = 413,
    ResponseRequestUriTooLong = 414,
    ResponseUnsupportedMediaType = 415,
    ResponseRequestedRangeNotSatisfiable = 416,
    ResponseExpectationFailed = 417,
    ResponseImATeapot = 418,
    ResponseMisdirectedRequest = 421,
    ResponseUnprocessableEntity = 422,
    ResponseLocked = 423,
    ResponseFailedDependency = 424,
    ResponseUpgradeRequired = 426,
    ResponsePreconditionRequired = 428,
    ResponseTooManyRequests = 429,
    ResponseRequestHeaderFieldsTooLarge = 431,
    ResponseUnavailableForLegalReasons = 451,
    ResponseInternalServerError = 500,
    ResponseNotImplemented = 501,
    ResponseBadGateway = 502,
    ResponseServiceUnavailable = 503,
    ResponseGatewayTimeout = 504,
    ResponseHttpVersionNotSupported = 505,
    ResponseVariantAlsoNegotiates = 506,
    ResponseInsufficientStorage = 507,
    ResponseLoopDetected = 508,
    ResponseNotExtended = 510,
    ResponseNetworkAuthRequired = 511,
}
/// Constants
#[allow(non_upper_case_globals)]
impl HTTPClient {
    pub const RESPONSE_IM_A_TEAPOT: i64 = 418;
    pub const RESPONSE_CONTINUE: i64 = 100;
    pub const STATUS_CONNECTION_ERROR: i64 = 8;
    pub const RESPONSE_GONE: i64 = 410;
    pub const STATUS_CONNECTING: i64 = 3;
    pub const RESPONSE_VARIANT_ALSO_NEGOTIATES: i64 = 506;
    pub const METHOD_PUT: i64 = 3;
    pub const RESPONSE_ALREADY_REPORTED: i64 = 208;
    pub const RESPONSE_NOT_EXTENDED: i64 = 510;
    pub const RESPONSE_PARTIAL_CONTENT: i64 = 206;
    pub const RESPONSE_NETWORK_AUTH_REQUIRED: i64 = 511;
    pub const RESPONSE_PRECONDITION_REQUIRED: i64 = 428;
    pub const METHOD_PATCH: i64 = 8;
    pub const RESPONSE_FAILED_DEPENDENCY: i64 = 424;
    pub const RESPONSE_UNSUPPORTED_MEDIA_TYPE: i64 = 415;
    pub const RESPONSE_MOVED_PERMANENTLY: i64 = 301;
    pub const RESPONSE_MULTI_STATUS: i64 = 207;
    pub const RESPONSE_NOT_ACCEPTABLE: i64 = 406;
    pub const RESPONSE_SWITCHING_PROTOCOLS: i64 = 101;
    pub const RESPONSE_ACCEPTED: i64 = 202;
    pub const METHOD_POST: i64 = 2;
    pub const RESPONSE_INTERNAL_SERVER_ERROR: i64 = 500;
    pub const RESPONSE_IM_USED: i64 = 226;
    pub const RESPONSE_UNAUTHORIZED: i64 = 401;
    pub const RESPONSE_UNPROCESSABLE_ENTITY: i64 = 422;
    pub const STATUS_CANT_RESOLVE: i64 = 2;
    pub const RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE: i64 = 416;
    pub const STATUS_CANT_CONNECT: i64 = 4;
    pub const RESPONSE_PAYMENT_REQUIRED: i64 = 402;
    pub const STATUS_RESOLVING: i64 = 1;
    pub const RESPONSE_NOT_MODIFIED: i64 = 304;
    pub const RESPONSE_REQUEST_ENTITY_TOO_LARGE: i64 = 413;
    pub const RESPONSE_INSUFFICIENT_STORAGE: i64 = 507;
    pub const RESPONSE_PERMANENT_REDIRECT: i64 = 308;
    pub const RESPONSE_FORBIDDEN: i64 = 403;
    pub const RESPONSE_REQUEST_TIMEOUT: i64 = 408;
    pub const METHOD_DELETE: i64 = 4;
    pub const RESPONSE_FOUND: i64 = 302;
    pub const RESPONSE_HTTP_VERSION_NOT_SUPPORTED: i64 = 505;
    pub const RESPONSE_PROCESSING: i64 = 102;
    pub const RESPONSE_BAD_REQUEST: i64 = 400;
    pub const METHOD_OPTIONS: i64 = 5;
    pub const RESPONSE_LOCKED: i64 = 423;
    pub const RESPONSE_MULTIPLE_CHOICES: i64 = 300;
    pub const RESPONSE_OK: i64 = 200;
    pub const RESPONSE_MISDIRECTED_REQUEST: i64 = 421;
    pub const RESPONSE_SERVICE_UNAVAILABLE: i64 = 503;
    pub const STATUS_REQUESTING: i64 = 6;
    pub const RESPONSE_EXPECTATION_FAILED: i64 = 417;
    pub const RESPONSE_CONFLICT: i64 = 409;
    pub const RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE: i64 = 431;
    pub const METHOD_MAX: i64 = 9;
    pub const METHOD_TRACE: i64 = 6;
    pub const METHOD_GET: i64 = 0;
    pub const RESPONSE_NON_AUTHORITATIVE_INFORMATION: i64 = 203;
    pub const RESPONSE_PRECONDITION_FAILED: i64 = 412;
    pub const RESPONSE_LENGTH_REQUIRED: i64 = 411;
    pub const RESPONSE_RESET_CONTENT: i64 = 205;
    pub const RESPONSE_TOO_MANY_REQUESTS: i64 = 429;
    pub const RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS: i64 = 451;
    pub const RESPONSE_UPGRADE_REQUIRED: i64 = 426;
    pub const STATUS_CONNECTED: i64 = 5;
    pub const STATUS_SSL_HANDSHAKE_ERROR: i64 = 9;
    pub const RESPONSE_LOOP_DETECTED: i64 = 508;
    pub const RESPONSE_PROXY_AUTHENTICATION_REQUIRED: i64 = 407;
    pub const RESPONSE_NOT_FOUND: i64 = 404;
    pub const RESPONSE_SEE_OTHER: i64 = 303;
    pub const METHOD_CONNECT: i64 = 7;
    pub const RESPONSE_NOT_IMPLEMENTED: i64 = 501;
    pub const RESPONSE_REQUEST_URI_TOO_LONG: i64 = 414;
    pub const METHOD_HEAD: i64 = 1;
    pub const RESPONSE_USE_PROXY: i64 = 305;
    pub const RESPONSE_BAD_GATEWAY: i64 = 502;
    pub const RESPONSE_METHOD_NOT_ALLOWED: i64 = 405;
    pub const RESPONSE_TEMPORARY_REDIRECT: i64 = 307;
    pub const STATUS_DISCONNECTED: i64 = 0;
    pub const STATUS_BODY: i64 = 7;
    pub const RESPONSE_CREATED: i64 = 201;
    pub const RESPONSE_SWITCH_PROXY: i64 = 306;
    pub const RESPONSE_GATEWAY_TIMEOUT: i64 = 504;
    pub const RESPONSE_NO_CONTENT: i64 = 204;
}
impl HTTPClient {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HTTPClientMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            HTTPClient {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { HTTPClient_close(self.this) }
    }

    #[inline]
    pub fn connect_to_host(&mut self, host: GodotString, port: i64, use_ssl: bool, verify_host: bool) -> GodotResult {
        unsafe { HTTPClient_connect_to_host(self.this, host, port, use_ssl, verify_host) }
    }

    #[inline]
    pub fn get_connection(&self) -> Option<StreamPeer> {
        unsafe { HTTPClient_get_connection(self.this) }
    }

    #[inline]
    pub fn get_read_chunk_size(&self) -> i64 {
        unsafe { HTTPClient_get_read_chunk_size(self.this) }
    }

    #[inline]
    pub fn get_response_body_length(&self) -> i64 {
        unsafe { HTTPClient_get_response_body_length(self.this) }
    }

    #[inline]
    pub fn get_response_code(&self) -> i64 {
        unsafe { HTTPClient_get_response_code(self.this) }
    }

    #[inline]
    pub fn get_response_headers(&mut self) -> StringArray {
        unsafe { HTTPClient_get_response_headers(self.this) }
    }

    #[inline]
    pub fn get_response_headers_as_dictionary(&mut self) -> Dictionary {
        unsafe { HTTPClient_get_response_headers_as_dictionary(self.this) }
    }

    #[inline]
    pub fn get_status(&self) -> HTTPClientStatus {
        unsafe { HTTPClient_get_status(self.this) }
    }

    #[inline]
    pub fn has_response(&self) -> bool {
        unsafe { HTTPClient_has_response(self.this) }
    }

    #[inline]
    pub fn is_blocking_mode_enabled(&self) -> bool {
        unsafe { HTTPClient_is_blocking_mode_enabled(self.this) }
    }

    #[inline]
    pub fn is_response_chunked(&self) -> bool {
        unsafe { HTTPClient_is_response_chunked(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> GodotResult {
        unsafe { HTTPClient_poll(self.this) }
    }

    #[inline]
    pub fn query_string_from_dict(&mut self, fields: Dictionary) -> GodotString {
        unsafe { HTTPClient_query_string_from_dict(self.this, fields) }
    }

    #[inline]
    pub fn read_response_body_chunk(&mut self) -> ByteArray {
        unsafe { HTTPClient_read_response_body_chunk(self.this) }
    }

    #[inline]
    pub fn request(&mut self, method: i64, url: GodotString, headers: StringArray, body: GodotString) -> GodotResult {
        unsafe { HTTPClient_request(self.this, method, url, headers, body) }
    }

    #[inline]
    pub fn request_raw(&mut self, method: i64, url: GodotString, headers: StringArray, body: ByteArray) -> GodotResult {
        unsafe { HTTPClient_request_raw(self.this, method, url, headers, body) }
    }

    #[inline]
    pub fn set_blocking_mode(&mut self, enabled: bool) -> () {
        unsafe { HTTPClient_set_blocking_mode(self.this, enabled) }
    }

    #[inline]
    pub fn set_connection(&mut self, connection: Option<StreamPeer>) -> () {
        unsafe { HTTPClient_set_connection(self.this, connection) }
    }

    #[inline]
    pub fn set_read_chunk_size(&mut self, bytes: i64) -> () {
        unsafe { HTTPClient_set_read_chunk_size(self.this, bytes) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HTTPRequest` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_httprequest.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HTTPRequest` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HTTPRequest::free`.
///
/// ## Class hierarchy
///
/// HTTPRequest inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HTTPRequest {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HTTPRequestResult {
    Success = 0,
    ChunkedBodySizeMismatch = 1,
    CantConnect = 2,
    CantResolve = 3,
    ConnectionError = 4,
    SslHandshakeError = 5,
    NoResponse = 6,
    BodySizeLimitExceeded = 7,
    RequestFailed = 8,
    DownloadFileCantOpen = 9,
    DownloadFileWriteError = 10,
    RedirectLimitReached = 11,
    Timeout = 12,
}
/// Constants
#[allow(non_upper_case_globals)]
impl HTTPRequest {
    pub const RESULT_REDIRECT_LIMIT_REACHED: i64 = 11;
    pub const RESULT_BODY_SIZE_LIMIT_EXCEEDED: i64 = 7;
    pub const RESULT_TIMEOUT: i64 = 12;
    pub const RESULT_CANT_CONNECT: i64 = 2;
    pub const RESULT_DOWNLOAD_FILE_CANT_OPEN: i64 = 9;
    pub const RESULT_NO_RESPONSE: i64 = 6;
    pub const RESULT_CONNECTION_ERROR: i64 = 4;
    pub const RESULT_CANT_RESOLVE: i64 = 3;
    pub const RESULT_REQUEST_FAILED: i64 = 8;
    pub const RESULT_SUCCESS: i64 = 0;
    pub const RESULT_SSL_HANDSHAKE_ERROR: i64 = 5;
    pub const RESULT_CHUNKED_BODY_SIZE_MISMATCH: i64 = 1;
    pub const RESULT_DOWNLOAD_FILE_WRITE_ERROR: i64 = 10;
}
impl HTTPRequest {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HTTPRequest::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HTTPRequestMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HTTPRequest {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _redirect_request(&mut self, arg0: GodotString) -> () {
        HTTPRequest__redirect_request(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _request_done(&mut self, arg0: i64, arg1: i64, arg2: StringArray, arg3: ByteArray) -> () {
        HTTPRequest__request_done(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _timeout(&mut self) -> () {
        HTTPRequest__timeout(self.this)
    }

    #[inline]
    pub unsafe fn cancel_request(&mut self) -> () {
        HTTPRequest_cancel_request(self.this)
    }

    #[inline]
    pub unsafe fn get_body_size(&self) -> i64 {
        HTTPRequest_get_body_size(self.this)
    }

    #[inline]
    pub unsafe fn get_body_size_limit(&self) -> i64 {
        HTTPRequest_get_body_size_limit(self.this)
    }

    #[inline]
    pub unsafe fn get_download_chunk_size(&self) -> i64 {
        HTTPRequest_get_download_chunk_size(self.this)
    }

    #[inline]
    pub unsafe fn get_download_file(&self) -> GodotString {
        HTTPRequest_get_download_file(self.this)
    }

    #[inline]
    pub unsafe fn get_downloaded_bytes(&self) -> i64 {
        HTTPRequest_get_downloaded_bytes(self.this)
    }

    #[inline]
    pub unsafe fn get_http_client_status(&self) -> HTTPClientStatus {
        HTTPRequest_get_http_client_status(self.this)
    }

    #[inline]
    pub unsafe fn get_max_redirects(&self) -> i64 {
        HTTPRequest_get_max_redirects(self.this)
    }

    #[inline]
    pub unsafe fn get_timeout(&mut self) -> i64 {
        HTTPRequest_get_timeout(self.this)
    }

    #[inline]
    pub unsafe fn is_using_threads(&self) -> bool {
        HTTPRequest_is_using_threads(self.this)
    }

    #[inline]
    pub unsafe fn request(&mut self, url: GodotString, custom_headers: StringArray, ssl_validate_domain: bool, method: i64, request_data: GodotString) -> GodotResult {
        HTTPRequest_request(self.this, url, custom_headers, ssl_validate_domain, method, request_data)
    }

    #[inline]
    pub unsafe fn set_body_size_limit(&mut self, bytes: i64) -> () {
        HTTPRequest_set_body_size_limit(self.this, bytes)
    }

    #[inline]
    pub unsafe fn set_download_chunk_size(&mut self, arg0: i64) -> () {
        HTTPRequest_set_download_chunk_size(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_download_file(&mut self, path: GodotString) -> () {
        HTTPRequest_set_download_file(self.this, path)
    }

    #[inline]
    pub unsafe fn set_max_redirects(&mut self, amount: i64) -> () {
        HTTPRequest_set_max_redirects(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_timeout(&mut self, timeout: i64) -> () {
        HTTPRequest_set_timeout(self.this, timeout)
    }

    #[inline]
    pub unsafe fn set_use_threads(&mut self, enable: bool) -> () {
        HTTPRequest_set_use_threads(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HashingContext` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hashingcontext.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// HashingContext inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HashingContext {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HashingContextHashType {
    HashMd5 = 0,
    HashSha1 = 1,
    HashSha256 = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl HashingContext {
    pub const HASH_SHA1: i64 = 1;
    pub const HASH_SHA256: i64 = 2;
    pub const HASH_MD5: i64 = 0;
}
impl HashingContext {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HashingContextMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            HashingContext {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn finish(&mut self) -> ByteArray {
        unsafe { HashingContext_finish(self.this) }
    }

    #[inline]
    pub fn start(&mut self, _type: i64) -> GodotResult {
        unsafe { HashingContext_start(self.this, _type) }
    }

    #[inline]
    pub fn update(&mut self, chunk: ByteArray) -> GodotResult {
        unsafe { HashingContext_update(self.this, chunk) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HeightMapShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_heightmapshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// HeightMapShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HeightMapShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl HeightMapShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HeightMapShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            HeightMapShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_map_data(&self) -> Float32Array {
        unsafe { HeightMapShape_get_map_data(self.this) }
    }

    #[inline]
    pub fn get_map_depth(&self) -> i64 {
        unsafe { HeightMapShape_get_map_depth(self.this) }
    }

    #[inline]
    pub fn get_map_width(&self) -> i64 {
        unsafe { HeightMapShape_get_map_width(self.this) }
    }

    #[inline]
    pub fn set_map_data(&mut self, data: Float32Array) -> () {
        unsafe { HeightMapShape_set_map_data(self.this, data) }
    }

    #[inline]
    pub fn set_map_depth(&mut self, height: i64) -> () {
        unsafe { HeightMapShape_set_map_depth(self.this, height) }
    }

    #[inline]
    pub fn set_map_width(&mut self, width: i64) -> () {
        unsafe { HeightMapShape_set_map_width(self.this, width) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class HingeJoint` inherits `Joint` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_hingejoint.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `HingeJoint` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `HingeJoint::free`.
///
/// ## Class hierarchy
///
/// HingeJoint inherits methods from:
/// - [Joint](struct.Joint.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct HingeJoint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HingeJointParam {
    Bias = 0,
    LimitUpper = 1,
    LimitLower = 2,
    LimitBias = 3,
    LimitSoftness = 4,
    LimitRelaxation = 5,
    MotorTargetVelocity = 6,
    MotorMaxImpulse = 7,
    Max = 8,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum HingeJointFlag {
    UseLimit = 0,
    EnableMotor = 1,
    Max = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl HingeJoint {
    pub const FLAG_MAX: i64 = 2;
    pub const PARAM_LIMIT_BIAS: i64 = 3;
    pub const PARAM_MAX: i64 = 8;
    pub const PARAM_LIMIT_RELAXATION: i64 = 5;
    pub const FLAG_USE_LIMIT: i64 = 0;
    pub const FLAG_ENABLE_MOTOR: i64 = 1;
    pub const PARAM_BIAS: i64 = 0;
    pub const PARAM_MOTOR_MAX_IMPULSE: i64 = 7;
    pub const PARAM_LIMIT_SOFTNESS: i64 = 4;
    pub const PARAM_MOTOR_TARGET_VELOCITY: i64 = 6;
    pub const PARAM_LIMIT_UPPER: i64 = 1;
    pub const PARAM_LIMIT_LOWER: i64 = 2;
}
impl HingeJoint {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `HingeJoint::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = HingeJointMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            HingeJoint {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_lower_limit(&self) -> f64 {
        HingeJoint__get_lower_limit(self.this)
    }

    #[inline]
    pub unsafe fn _get_upper_limit(&self) -> f64 {
        HingeJoint__get_upper_limit(self.this)
    }

    #[inline]
    pub unsafe fn _set_lower_limit(&mut self, lower_limit: f64) -> () {
        HingeJoint__set_lower_limit(self.this, lower_limit)
    }

    #[inline]
    pub unsafe fn _set_upper_limit(&mut self, upper_limit: f64) -> () {
        HingeJoint__set_upper_limit(self.this, upper_limit)
    }

    #[inline]
    pub unsafe fn get_flag(&self, flag: i64) -> bool {
        HingeJoint_get_flag(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        HingeJoint_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn set_flag(&mut self, flag: i64, enabled: bool) -> () {
        HingeJoint_set_flag(self.this, flag, enabled)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        HingeJoint_set_param(self.this, param, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint(&self) -> Joint {
        // Not reference-counted.
        Joint { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class IP` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_ip.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// IP inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct IP {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum IPResolverStatus {
    None = 0,
    Waiting = 1,
    Done = 2,
    Error = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum IPType {
    None = 0,
    Ipv4 = 1,
    Ipv6 = 2,
    Any = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl IP {
    pub const TYPE_IPV6: i64 = 2;
    pub const TYPE_ANY: i64 = 3;
    pub const RESOLVER_MAX_QUERIES: i64 = 32;
    pub const RESOLVER_STATUS_ERROR: i64 = 3;
    pub const TYPE_IPV4: i64 = 1;
    pub const RESOLVER_STATUS_DONE: i64 = 2;
    pub const RESOLVER_STATUS_WAITING: i64 = 1;
    pub const RESOLVER_STATUS_NONE: i64 = 0;
    pub const RESOLVER_INVALID_ID: i64 = -1;
    pub const TYPE_NONE: i64 = 0;
}
impl IP {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"IP\0".as_ptr() as *mut _);

            IP {
                this
            }
        }
    }
    #[inline]
    pub fn clear_cache(&mut self, hostname: GodotString) -> () {
        unsafe { IP_clear_cache(self.this, hostname) }
    }

    #[inline]
    pub fn erase_resolve_item(&mut self, id: i64) -> () {
        unsafe { IP_erase_resolve_item(self.this, id) }
    }

    #[inline]
    pub fn get_local_addresses(&self) -> VariantArray {
        unsafe { IP_get_local_addresses(self.this) }
    }

    #[inline]
    pub fn get_local_interfaces(&self) -> VariantArray {
        unsafe { IP_get_local_interfaces(self.this) }
    }

    #[inline]
    pub fn get_resolve_item_address(&self, id: i64) -> GodotString {
        unsafe { IP_get_resolve_item_address(self.this, id) }
    }

    #[inline]
    pub fn get_resolve_item_status(&self, id: i64) -> IPResolverStatus {
        unsafe { IP_get_resolve_item_status(self.this, id) }
    }

    #[inline]
    pub fn resolve_hostname(&mut self, host: GodotString, ip_type: i64) -> GodotString {
        unsafe { IP_resolve_hostname(self.this, host, ip_type) }
    }

    #[inline]
    pub fn resolve_hostname_queue_item(&mut self, host: GodotString, ip_type: i64) -> i64 {
        unsafe { IP_resolve_hostname_queue_item(self.this, host, ip_type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class IP_Unix` inherits `IP` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_ip_unix.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// IP_Unix inherits methods from:
/// - [IP](struct.IP.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct IP_Unix {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl IP_Unix {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_ip(&self) -> IP {
        // Not reference-counted.
        IP { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Image` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_image.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Image inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Image {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageAlphaMode {
    None = 0,
    Bit = 1,
    Blend = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageCompressSource {
    Generic = 0,
    Srgb = 1,
    Normal = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageInterpolation {
    InterpolateNearest = 0,
    InterpolateBilinear = 1,
    InterpolateCubic = 2,
    InterpolateTrilinear = 3,
    InterpolateLanczos = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageCompressMode {
    S3tc = 0,
    Pvrtc2 = 1,
    Pvrtc4 = 2,
    Etc = 3,
    Etc2 = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageFormat {
    L8 = 0,
    La8 = 1,
    R8 = 2,
    Rg8 = 3,
    Rgb8 = 4,
    Rgba8 = 5,
    Rgba4444 = 6,
    Rgba5551 = 7,
    Rf = 8,
    Rgf = 9,
    Rgbf = 10,
    Rgbaf = 11,
    Rh = 12,
    Rgh = 13,
    Rgbh = 14,
    Rgbah = 15,
    Rgbe9995 = 16,
    Dxt1 = 17,
    Dxt3 = 18,
    Dxt5 = 19,
    RgtcR = 20,
    RgtcRg = 21,
    BptcRgba = 22,
    BptcRgbf = 23,
    BptcRgbfu = 24,
    Pvrtc2 = 25,
    Pvrtc2a = 26,
    Pvrtc4 = 27,
    Pvrtc4a = 28,
    Etc = 29,
    Etc2R11 = 30,
    Etc2R11s = 31,
    Etc2Rg11 = 32,
    Etc2Rg11s = 33,
    Etc2Rgb8 = 34,
    Etc2Rgba8 = 35,
    Etc2Rgb8a1 = 36,
    Max = 37,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Image {
    pub const COMPRESS_ETC2: i64 = 4;
    pub const FORMAT_BPTC_RGBF: i64 = 23;
    pub const FORMAT_ETC2_RGB8: i64 = 34;
    pub const FORMAT_RGBF: i64 = 10;
    pub const INTERPOLATE_BILINEAR: i64 = 1;
    pub const FORMAT_RH: i64 = 12;
    pub const FORMAT_ETC2_RG11: i64 = 32;
    pub const COMPRESS_SOURCE_NORMAL: i64 = 2;
    pub const FORMAT_ETC2_RGBA8: i64 = 35;
    pub const FORMAT_DXT5: i64 = 19;
    pub const FORMAT_RGBA5551: i64 = 7;
    pub const FORMAT_RGBA8: i64 = 5;
    pub const FORMAT_RGBAH: i64 = 15;
    pub const ALPHA_BIT: i64 = 1;
    pub const COMPRESS_S3TC: i64 = 0;
    pub const FORMAT_ETC2_RG11S: i64 = 33;
    pub const FORMAT_RGBE9995: i64 = 16;
    pub const FORMAT_DXT3: i64 = 18;
    pub const FORMAT_ETC2_R11S: i64 = 31;
    pub const FORMAT_ETC2_RGB8A1: i64 = 36;
    pub const FORMAT_RGBH: i64 = 14;
    pub const FORMAT_DXT1: i64 = 17;
    pub const INTERPOLATE_CUBIC: i64 = 2;
    pub const FORMAT_RGTC_RG: i64 = 21;
    pub const INTERPOLATE_NEAREST: i64 = 0;
    pub const FORMAT_LA8: i64 = 1;
    pub const COMPRESS_PVRTC4: i64 = 2;
    pub const FORMAT_PVRTC4A: i64 = 28;
    pub const MAX_HEIGHT: i64 = 16384;
    pub const FORMAT_RG8: i64 = 3;
    pub const INTERPOLATE_TRILINEAR: i64 = 3;
    pub const INTERPOLATE_LANCZOS: i64 = 4;
    pub const COMPRESS_ETC: i64 = 3;
    pub const FORMAT_RGBAF: i64 = 11;
    pub const ALPHA_NONE: i64 = 0;
    pub const COMPRESS_SOURCE_SRGB: i64 = 1;
    pub const FORMAT_BPTC_RGBFU: i64 = 24;
    pub const COMPRESS_PVRTC2: i64 = 1;
    pub const FORMAT_MAX: i64 = 37;
    pub const FORMAT_R8: i64 = 2;
    pub const MAX_WIDTH: i64 = 16384;
    pub const FORMAT_ETC2_R11: i64 = 30;
    pub const FORMAT_RGTC_R: i64 = 20;
    pub const FORMAT_PVRTC4: i64 = 27;
    pub const FORMAT_PVRTC2A: i64 = 26;
    pub const ALPHA_BLEND: i64 = 2;
    pub const FORMAT_RF: i64 = 8;
    pub const FORMAT_RGBA4444: i64 = 6;
    pub const FORMAT_RGF: i64 = 9;
    pub const FORMAT_ETC: i64 = 29;
    pub const FORMAT_L8: i64 = 0;
    pub const FORMAT_RGH: i64 = 13;
    pub const COMPRESS_SOURCE_GENERIC: i64 = 0;
    pub const FORMAT_PVRTC2: i64 = 25;
    pub const FORMAT_BPTC_RGBA: i64 = 22;
    pub const FORMAT_RGB8: i64 = 4;
}
impl Image {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ImageMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Image {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { Image__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, data: Dictionary) -> () {
        unsafe { Image__set_data(self.this, data) }
    }

    #[inline]
    pub fn blend_rect(&mut self, src: Option<Image>, src_rect: Rect2, dst: Vector2) -> () {
        unsafe { Image_blend_rect(self.this, src, src_rect, dst) }
    }

    #[inline]
    pub fn blend_rect_mask(&mut self, src: Option<Image>, mask: Option<Image>, src_rect: Rect2, dst: Vector2) -> () {
        unsafe { Image_blend_rect_mask(self.this, src, mask, src_rect, dst) }
    }

    #[inline]
    pub fn blit_rect(&mut self, src: Option<Image>, src_rect: Rect2, dst: Vector2) -> () {
        unsafe { Image_blit_rect(self.this, src, src_rect, dst) }
    }

    #[inline]
    pub fn blit_rect_mask(&mut self, src: Option<Image>, mask: Option<Image>, src_rect: Rect2, dst: Vector2) -> () {
        unsafe { Image_blit_rect_mask(self.this, src, mask, src_rect, dst) }
    }

    #[inline]
    pub fn bumpmap_to_normalmap(&mut self, bump_scale: f64) -> () {
        unsafe { Image_bumpmap_to_normalmap(self.this, bump_scale) }
    }

    #[inline]
    pub fn clear_mipmaps(&mut self) -> () {
        unsafe { Image_clear_mipmaps(self.this) }
    }

    #[inline]
    pub fn compress(&mut self, mode: i64, source: i64, lossy_quality: f64) -> GodotResult {
        unsafe { Image_compress(self.this, mode, source, lossy_quality) }
    }

    #[inline]
    pub fn convert(&mut self, format: i64) -> () {
        unsafe { Image_convert(self.this, format) }
    }

    #[inline]
    pub fn copy_from(&mut self, src: Option<Image>) -> () {
        unsafe { Image_copy_from(self.this, src) }
    }

    #[inline]
    pub fn create(&mut self, width: i64, height: i64, use_mipmaps: bool, format: i64) -> () {
        unsafe { Image_create(self.this, width, height, use_mipmaps, format) }
    }

    #[inline]
    pub fn create_from_data(&mut self, width: i64, height: i64, use_mipmaps: bool, format: i64, data: ByteArray) -> () {
        unsafe { Image_create_from_data(self.this, width, height, use_mipmaps, format, data) }
    }

    #[inline]
    pub fn crop(&mut self, width: i64, height: i64) -> () {
        unsafe { Image_crop(self.this, width, height) }
    }

    #[inline]
    pub fn decompress(&mut self) -> GodotResult {
        unsafe { Image_decompress(self.this) }
    }

    #[inline]
    pub fn detect_alpha(&self) -> ImageAlphaMode {
        unsafe { Image_detect_alpha(self.this) }
    }

    #[inline]
    pub fn expand_x2_hq2x(&mut self) -> () {
        unsafe { Image_expand_x2_hq2x(self.this) }
    }

    #[inline]
    pub fn fill(&mut self, color: Color) -> () {
        unsafe { Image_fill(self.this, color) }
    }

    #[inline]
    pub fn fix_alpha_edges(&mut self) -> () {
        unsafe { Image_fix_alpha_edges(self.this) }
    }

    #[inline]
    pub fn flip_x(&mut self) -> () {
        unsafe { Image_flip_x(self.this) }
    }

    #[inline]
    pub fn flip_y(&mut self) -> () {
        unsafe { Image_flip_y(self.this) }
    }

    #[inline]
    pub fn generate_mipmaps(&mut self, renormalize: bool) -> GodotResult {
        unsafe { Image_generate_mipmaps(self.this, renormalize) }
    }

    #[inline]
    pub fn get_data(&self) -> ByteArray {
        unsafe { Image_get_data(self.this) }
    }

    #[inline]
    pub fn get_format(&self) -> ImageFormat {
        unsafe { Image_get_format(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> i64 {
        unsafe { Image_get_height(self.this) }
    }

    #[inline]
    pub fn get_mipmap_offset(&self, mipmap: i64) -> i64 {
        unsafe { Image_get_mipmap_offset(self.this, mipmap) }
    }

    #[inline]
    pub fn get_pixel(&self, x: i64, y: i64) -> Color {
        unsafe { Image_get_pixel(self.this, x, y) }
    }

    #[inline]
    pub fn get_pixelv(&self, src: Vector2) -> Color {
        unsafe { Image_get_pixelv(self.this, src) }
    }

    #[inline]
    pub fn get_rect(&self, rect: Rect2) -> Option<Image> {
        unsafe { Image_get_rect(self.this, rect) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { Image_get_size(self.this) }
    }

    #[inline]
    pub fn get_used_rect(&self) -> Rect2 {
        unsafe { Image_get_used_rect(self.this) }
    }

    #[inline]
    pub fn get_width(&self) -> i64 {
        unsafe { Image_get_width(self.this) }
    }

    #[inline]
    pub fn has_mipmaps(&self) -> bool {
        unsafe { Image_has_mipmaps(self.this) }
    }

    #[inline]
    pub fn is_compressed(&self) -> bool {
        unsafe { Image_is_compressed(self.this) }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        unsafe { Image_is_empty(self.this) }
    }

    #[inline]
    pub fn is_invisible(&self) -> bool {
        unsafe { Image_is_invisible(self.this) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { Image_load(self.this, path) }
    }

    #[inline]
    pub fn load_jpg_from_buffer(&mut self, buffer: ByteArray) -> GodotResult {
        unsafe { Image_load_jpg_from_buffer(self.this, buffer) }
    }

    #[inline]
    pub fn load_png_from_buffer(&mut self, buffer: ByteArray) -> GodotResult {
        unsafe { Image_load_png_from_buffer(self.this, buffer) }
    }

    #[inline]
    pub fn load_webp_from_buffer(&mut self, buffer: ByteArray) -> GodotResult {
        unsafe { Image_load_webp_from_buffer(self.this, buffer) }
    }

    #[inline]
    pub fn lock(&mut self) -> () {
        unsafe { Image_lock(self.this) }
    }

    #[inline]
    pub fn normalmap_to_xy(&mut self) -> () {
        unsafe { Image_normalmap_to_xy(self.this) }
    }

    #[inline]
    pub fn premultiply_alpha(&mut self) -> () {
        unsafe { Image_premultiply_alpha(self.this) }
    }

    #[inline]
    pub fn resize(&mut self, width: i64, height: i64, interpolation: i64) -> () {
        unsafe { Image_resize(self.this, width, height, interpolation) }
    }

    #[inline]
    pub fn resize_to_po2(&mut self, square: bool) -> () {
        unsafe { Image_resize_to_po2(self.this, square) }
    }

    #[inline]
    pub fn rgbe_to_srgb(&mut self) -> Option<Image> {
        unsafe { Image_rgbe_to_srgb(self.this) }
    }

    #[inline]
    pub fn save_exr(&self, path: GodotString, grayscale: bool) -> GodotResult {
        unsafe { Image_save_exr(self.this, path, grayscale) }
    }

    #[inline]
    pub fn save_png(&self, path: GodotString) -> GodotResult {
        unsafe { Image_save_png(self.this, path) }
    }

    #[inline]
    pub fn set_pixel(&mut self, x: i64, y: i64, color: Color) -> () {
        unsafe { Image_set_pixel(self.this, x, y, color) }
    }

    #[inline]
    pub fn set_pixelv(&mut self, dst: Vector2, color: Color) -> () {
        unsafe { Image_set_pixelv(self.this, dst, color) }
    }

    #[inline]
    pub fn shrink_x2(&mut self) -> () {
        unsafe { Image_shrink_x2(self.this) }
    }

    #[inline]
    pub fn srgb_to_linear(&mut self) -> () {
        unsafe { Image_srgb_to_linear(self.this) }
    }

    #[inline]
    pub fn unlock(&mut self) -> () {
        unsafe { Image_unlock(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ImageTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_imagetexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ImageTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ImageTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ImageTextureStorage {
    Raw = 0,
    CompressLossy = 1,
    CompressLossless = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ImageTexture {
    pub const STORAGE_RAW: i64 = 0;
    pub const STORAGE_COMPRESS_LOSSLESS: i64 = 2;
    pub const STORAGE_COMPRESS_LOSSY: i64 = 1;
}
impl ImageTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ImageTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ImageTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _reload_hook(&mut self, rid: Rid) -> () {
        unsafe { ImageTexture__reload_hook(self.this, rid) }
    }

    #[inline]
    pub fn create(&mut self, width: i64, height: i64, format: i64, flags: i64) -> () {
        unsafe { ImageTexture_create(self.this, width, height, format, flags) }
    }

    #[inline]
    pub fn create_from_image(&mut self, image: Option<Image>, flags: i64) -> () {
        unsafe { ImageTexture_create_from_image(self.this, image, flags) }
    }

    #[inline]
    pub fn get_format(&self) -> ImageFormat {
        unsafe { ImageTexture_get_format(self.this) }
    }

    #[inline]
    pub fn get_lossy_storage_quality(&self) -> f64 {
        unsafe { ImageTexture_get_lossy_storage_quality(self.this) }
    }

    #[inline]
    pub fn get_storage(&self) -> ImageTextureStorage {
        unsafe { ImageTexture_get_storage(self.this) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { ImageTexture_load(self.this, path) }
    }

    #[inline]
    pub fn set_data(&mut self, image: Option<Image>) -> () {
        unsafe { ImageTexture_set_data(self.this, image) }
    }

    #[inline]
    pub fn set_lossy_storage_quality(&mut self, quality: f64) -> () {
        unsafe { ImageTexture_set_lossy_storage_quality(self.this, quality) }
    }

    #[inline]
    pub fn set_size_override(&mut self, size: Vector2) -> () {
        unsafe { ImageTexture_set_size_override(self.this, size) }
    }

    #[inline]
    pub fn set_storage(&mut self, mode: i64) -> () {
        unsafe { ImageTexture_set_storage(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ImmediateGeometry` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_immediategeometry.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ImmediateGeometry` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ImmediateGeometry::free`.
///
/// ## Class hierarchy
///
/// ImmediateGeometry inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ImmediateGeometry {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ImmediateGeometry {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ImmediateGeometry::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ImmediateGeometryMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ImmediateGeometry {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_sphere(&mut self, lats: i64, lons: i64, radius: f64, add_uv: bool) -> () {
        ImmediateGeometry_add_sphere(self.this, lats, lons, radius, add_uv)
    }

    #[inline]
    pub unsafe fn add_vertex(&mut self, position: Vector3) -> () {
        ImmediateGeometry_add_vertex(self.this, position)
    }

    #[inline]
    pub unsafe fn begin(&mut self, primitive: i64, texture: Option<Texture>) -> () {
        ImmediateGeometry_begin(self.this, primitive, texture)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        ImmediateGeometry_clear(self.this)
    }

    #[inline]
    pub unsafe fn end(&mut self) -> () {
        ImmediateGeometry_end(self.this)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        ImmediateGeometry_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_normal(&mut self, normal: Vector3) -> () {
        ImmediateGeometry_set_normal(self.this, normal)
    }

    #[inline]
    pub unsafe fn set_tangent(&mut self, tangent: Plane) -> () {
        ImmediateGeometry_set_tangent(self.this, tangent)
    }

    #[inline]
    pub unsafe fn set_uv(&mut self, uv: Vector2) -> () {
        ImmediateGeometry_set_uv(self.this, uv)
    }

    #[inline]
    pub unsafe fn set_uv2(&mut self, uv: Vector2) -> () {
        ImmediateGeometry_set_uv2(self.this, uv)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Input` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_input.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Input inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Input {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum InputMouseMode {
    ModeVisible = 0,
    ModeHidden = 1,
    ModeCaptured = 2,
    ModeConfined = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum InputCursorShape {
    CursorArrow = 0,
    CursorIbeam = 1,
    CursorPointingHand = 2,
    CursorCross = 3,
    CursorWait = 4,
    CursorBusy = 5,
    CursorDrag = 6,
    CursorCanDrop = 7,
    CursorForbidden = 8,
    CursorVsize = 9,
    CursorHsize = 10,
    CursorBdiagsize = 11,
    CursorFdiagsize = 12,
    CursorMove = 13,
    CursorVsplit = 14,
    CursorHsplit = 15,
    CursorHelp = 16,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Input {
    pub const CURSOR_BDIAGSIZE: i64 = 11;
    pub const CURSOR_DRAG: i64 = 6;
    pub const CURSOR_MOVE: i64 = 13;
    pub const CURSOR_WAIT: i64 = 4;
    pub const CURSOR_VSIZE: i64 = 9;
    pub const MOUSE_MODE_CAPTURED: i64 = 2;
    pub const CURSOR_HSPLIT: i64 = 15;
    pub const CURSOR_POINTING_HAND: i64 = 2;
    pub const CURSOR_CROSS: i64 = 3;
    pub const CURSOR_HELP: i64 = 16;
    pub const CURSOR_VSPLIT: i64 = 14;
    pub const MOUSE_MODE_CONFINED: i64 = 3;
    pub const MOUSE_MODE_VISIBLE: i64 = 0;
    pub const CURSOR_FDIAGSIZE: i64 = 12;
    pub const CURSOR_FORBIDDEN: i64 = 8;
    pub const MOUSE_MODE_HIDDEN: i64 = 1;
    pub const CURSOR_HSIZE: i64 = 10;
    pub const CURSOR_ARROW: i64 = 0;
    pub const CURSOR_CAN_DROP: i64 = 7;
    pub const CURSOR_BUSY: i64 = 5;
    pub const CURSOR_IBEAM: i64 = 1;
}
impl Input {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Input\0".as_ptr() as *mut _);

            Input {
                this
            }
        }
    }
    #[inline]
    pub fn action_press(&mut self, action: GodotString, strength: f64) -> () {
        unsafe { Input_action_press(self.this, action, strength) }
    }

    #[inline]
    pub fn action_release(&mut self, action: GodotString) -> () {
        unsafe { Input_action_release(self.this, action) }
    }

    #[inline]
    pub fn add_joy_mapping(&mut self, mapping: GodotString, update_existing: bool) -> () {
        unsafe { Input_add_joy_mapping(self.this, mapping, update_existing) }
    }

    #[inline]
    pub fn get_accelerometer(&self) -> Vector3 {
        unsafe { Input_get_accelerometer(self.this) }
    }

    #[inline]
    pub fn get_action_strength(&self, action: GodotString) -> f64 {
        unsafe { Input_get_action_strength(self.this, action) }
    }

    #[inline]
    pub fn get_connected_joypads(&mut self) -> VariantArray {
        unsafe { Input_get_connected_joypads(self.this) }
    }

    #[inline]
    pub fn get_current_cursor_shape(&self) -> InputCursorShape {
        unsafe { Input_get_current_cursor_shape(self.this) }
    }

    #[inline]
    pub fn get_gravity(&self) -> Vector3 {
        unsafe { Input_get_gravity(self.this) }
    }

    #[inline]
    pub fn get_gyroscope(&self) -> Vector3 {
        unsafe { Input_get_gyroscope(self.this) }
    }

    #[inline]
    pub fn get_joy_axis(&self, device: i64, axis: i64) -> f64 {
        unsafe { Input_get_joy_axis(self.this, device, axis) }
    }

    #[inline]
    pub fn get_joy_axis_index_from_string(&mut self, axis: GodotString) -> i64 {
        unsafe { Input_get_joy_axis_index_from_string(self.this, axis) }
    }

    #[inline]
    pub fn get_joy_axis_string(&mut self, axis_index: i64) -> GodotString {
        unsafe { Input_get_joy_axis_string(self.this, axis_index) }
    }

    #[inline]
    pub fn get_joy_button_index_from_string(&mut self, button: GodotString) -> i64 {
        unsafe { Input_get_joy_button_index_from_string(self.this, button) }
    }

    #[inline]
    pub fn get_joy_button_string(&mut self, button_index: i64) -> GodotString {
        unsafe { Input_get_joy_button_string(self.this, button_index) }
    }

    #[inline]
    pub fn get_joy_guid(&self, device: i64) -> GodotString {
        unsafe { Input_get_joy_guid(self.this, device) }
    }

    #[inline]
    pub fn get_joy_name(&mut self, device: i64) -> GodotString {
        unsafe { Input_get_joy_name(self.this, device) }
    }

    #[inline]
    pub fn get_joy_vibration_duration(&mut self, device: i64) -> f64 {
        unsafe { Input_get_joy_vibration_duration(self.this, device) }
    }

    #[inline]
    pub fn get_joy_vibration_strength(&mut self, device: i64) -> Vector2 {
        unsafe { Input_get_joy_vibration_strength(self.this, device) }
    }

    #[inline]
    pub fn get_last_mouse_speed(&self) -> Vector2 {
        unsafe { Input_get_last_mouse_speed(self.this) }
    }

    #[inline]
    pub fn get_magnetometer(&self) -> Vector3 {
        unsafe { Input_get_magnetometer(self.this) }
    }

    #[inline]
    pub fn get_mouse_button_mask(&self) -> i64 {
        unsafe { Input_get_mouse_button_mask(self.this) }
    }

    #[inline]
    pub fn get_mouse_mode(&self) -> InputMouseMode {
        unsafe { Input_get_mouse_mode(self.this) }
    }

    #[inline]
    pub fn is_action_just_pressed(&self, action: GodotString) -> bool {
        unsafe { Input_is_action_just_pressed(self.this, action) }
    }

    #[inline]
    pub fn is_action_just_released(&self, action: GodotString) -> bool {
        unsafe { Input_is_action_just_released(self.this, action) }
    }

    #[inline]
    pub fn is_action_pressed(&self, action: GodotString) -> bool {
        unsafe { Input_is_action_pressed(self.this, action) }
    }

    #[inline]
    pub fn is_joy_button_pressed(&self, device: i64, button: i64) -> bool {
        unsafe { Input_is_joy_button_pressed(self.this, device, button) }
    }

    #[inline]
    pub fn is_joy_known(&mut self, device: i64) -> bool {
        unsafe { Input_is_joy_known(self.this, device) }
    }

    #[inline]
    pub fn is_key_pressed(&self, scancode: i64) -> bool {
        unsafe { Input_is_key_pressed(self.this, scancode) }
    }

    #[inline]
    pub fn is_mouse_button_pressed(&self, button: i64) -> bool {
        unsafe { Input_is_mouse_button_pressed(self.this, button) }
    }

    #[inline]
    pub fn joy_connection_changed(&mut self, device: i64, connected: bool, name: GodotString, guid: GodotString) -> () {
        unsafe { Input_joy_connection_changed(self.this, device, connected, name, guid) }
    }

    #[inline]
    pub fn parse_input_event(&mut self, event: Option<InputEvent>) -> () {
        unsafe { Input_parse_input_event(self.this, event) }
    }

    #[inline]
    pub fn remove_joy_mapping(&mut self, guid: GodotString) -> () {
        unsafe { Input_remove_joy_mapping(self.this, guid) }
    }

    #[inline]
    pub fn set_custom_mouse_cursor(&mut self, image: Option<Resource>, shape: i64, hotspot: Vector2) -> () {
        unsafe { Input_set_custom_mouse_cursor(self.this, image, shape, hotspot) }
    }

    #[inline]
    pub fn set_default_cursor_shape(&mut self, shape: i64) -> () {
        unsafe { Input_set_default_cursor_shape(self.this, shape) }
    }

    #[inline]
    pub fn set_mouse_mode(&mut self, mode: i64) -> () {
        unsafe { Input_set_mouse_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_use_accumulated_input(&mut self, enable: bool) -> () {
        unsafe { Input_set_use_accumulated_input(self.this, enable) }
    }

    #[inline]
    pub fn start_joy_vibration(&mut self, device: i64, weak_magnitude: f64, strong_magnitude: f64, duration: f64) -> () {
        unsafe { Input_start_joy_vibration(self.this, device, weak_magnitude, strong_magnitude, duration) }
    }

    #[inline]
    pub fn stop_joy_vibration(&mut self, device: i64) -> () {
        unsafe { Input_stop_joy_vibration(self.this, device) }
    }

    #[inline]
    pub fn vibrate_handheld(&mut self, duration_ms: i64) -> () {
        unsafe { Input_vibrate_handheld(self.this, duration_ms) }
    }

    #[inline]
    pub fn warp_mouse_position(&mut self, to: Vector2) -> () {
        unsafe { Input_warp_mouse_position(self.this, to) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputDefault` inherits `Input` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputdefault.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// InputDefault inherits methods from:
/// - [Input](struct.Input.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputDefault {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputDefault {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_input(&self) -> Input {
        // Not reference-counted.
        Input { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEvent` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputevent.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEvent inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEvent {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEvent {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn accumulate(&mut self, with_event: Option<InputEvent>) -> bool {
        unsafe { InputEvent_accumulate(self.this, with_event) }
    }

    #[inline]
    pub fn as_text(&self) -> GodotString {
        unsafe { InputEvent_as_text(self.this) }
    }

    #[inline]
    pub fn get_action_strength(&self, action: GodotString) -> f64 {
        unsafe { InputEvent_get_action_strength(self.this, action) }
    }

    #[inline]
    pub fn get_device(&self) -> i64 {
        unsafe { InputEvent_get_device(self.this) }
    }

    #[inline]
    pub fn is_action(&self, action: GodotString) -> bool {
        unsafe { InputEvent_is_action(self.this, action) }
    }

    #[inline]
    pub fn is_action_pressed(&self, action: GodotString, allow_echo: bool) -> bool {
        unsafe { InputEvent_is_action_pressed(self.this, action, allow_echo) }
    }

    #[inline]
    pub fn is_action_released(&self, action: GodotString) -> bool {
        unsafe { InputEvent_is_action_released(self.this, action) }
    }

    #[inline]
    pub fn is_action_type(&self) -> bool {
        unsafe { InputEvent_is_action_type(self.this) }
    }

    #[inline]
    pub fn is_echo(&self) -> bool {
        unsafe { InputEvent_is_echo(self.this) }
    }

    #[inline]
    pub fn is_pressed(&self) -> bool {
        unsafe { InputEvent_is_pressed(self.this) }
    }

    #[inline]
    pub fn set_device(&mut self, device: i64) -> () {
        unsafe { InputEvent_set_device(self.this, device) }
    }

    #[inline]
    pub fn shortcut_match(&self, event: Option<InputEvent>) -> bool {
        unsafe { InputEvent_shortcut_match(self.this, event) }
    }

    #[inline]
    pub fn xformed_by(&self, xform: Transform2D, local_ofs: Vector2) -> Option<InputEvent> {
        unsafe { InputEvent_xformed_by(self.this, xform, local_ofs) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventAction` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventaction.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventAction inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventAction {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventAction {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventActionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventAction {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_action(&self) -> GodotString {
        unsafe { InputEventAction_get_action(self.this) }
    }

    #[inline]
    pub fn get_strength(&self) -> f64 {
        unsafe { InputEventAction_get_strength(self.this) }
    }

    #[inline]
    pub fn set_action(&mut self, action: GodotString) -> () {
        unsafe { InputEventAction_set_action(self.this, action) }
    }

    #[inline]
    pub fn set_pressed(&mut self, pressed: bool) -> () {
        unsafe { InputEventAction_set_pressed(self.this, pressed) }
    }

    #[inline]
    pub fn set_strength(&mut self, strength: f64) -> () {
        unsafe { InputEventAction_set_strength(self.this, strength) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventGesture` inherits `InputEventWithModifiers` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventgesture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventGesture inherits methods from:
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventGesture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventGesture {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_position(&self) -> Vector2 {
        unsafe { InputEventGesture_get_position(self.this) }
    }

    #[inline]
    pub fn set_position(&mut self, position: Vector2) -> () {
        unsafe { InputEventGesture_set_position(self.this, position) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventJoypadButton` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventjoypadbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventJoypadButton inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventJoypadButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventJoypadButton {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventJoypadButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventJoypadButton {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_button_index(&self) -> i64 {
        unsafe { InputEventJoypadButton_get_button_index(self.this) }
    }

    #[inline]
    pub fn get_pressure(&self) -> f64 {
        unsafe { InputEventJoypadButton_get_pressure(self.this) }
    }

    #[inline]
    pub fn set_button_index(&mut self, button_index: i64) -> () {
        unsafe { InputEventJoypadButton_set_button_index(self.this, button_index) }
    }

    #[inline]
    pub fn set_pressed(&mut self, pressed: bool) -> () {
        unsafe { InputEventJoypadButton_set_pressed(self.this, pressed) }
    }

    #[inline]
    pub fn set_pressure(&mut self, pressure: f64) -> () {
        unsafe { InputEventJoypadButton_set_pressure(self.this, pressure) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventJoypadMotion` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventjoypadmotion.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventJoypadMotion inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventJoypadMotion {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventJoypadMotion {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventJoypadMotionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventJoypadMotion {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_axis(&self) -> i64 {
        unsafe { InputEventJoypadMotion_get_axis(self.this) }
    }

    #[inline]
    pub fn get_axis_value(&self) -> f64 {
        unsafe { InputEventJoypadMotion_get_axis_value(self.this) }
    }

    #[inline]
    pub fn set_axis(&mut self, axis: i64) -> () {
        unsafe { InputEventJoypadMotion_set_axis(self.this, axis) }
    }

    #[inline]
    pub fn set_axis_value(&mut self, axis_value: f64) -> () {
        unsafe { InputEventJoypadMotion_set_axis_value(self.this, axis_value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventKey` inherits `InputEventWithModifiers` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventkey.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventKey inherits methods from:
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventKey {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventKey {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventKeyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventKey {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_scancode(&self) -> i64 {
        unsafe { InputEventKey_get_scancode(self.this) }
    }

    #[inline]
    pub fn get_scancode_with_modifiers(&self) -> i64 {
        unsafe { InputEventKey_get_scancode_with_modifiers(self.this) }
    }

    #[inline]
    pub fn get_unicode(&self) -> i64 {
        unsafe { InputEventKey_get_unicode(self.this) }
    }

    #[inline]
    pub fn set_echo(&mut self, echo: bool) -> () {
        unsafe { InputEventKey_set_echo(self.this, echo) }
    }

    #[inline]
    pub fn set_pressed(&mut self, pressed: bool) -> () {
        unsafe { InputEventKey_set_pressed(self.this, pressed) }
    }

    #[inline]
    pub fn set_scancode(&mut self, scancode: i64) -> () {
        unsafe { InputEventKey_set_scancode(self.this, scancode) }
    }

    #[inline]
    pub fn set_unicode(&mut self, unicode: i64) -> () {
        unsafe { InputEventKey_set_unicode(self.this, unicode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventMIDI` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventmidi.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventMIDI inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventMIDI {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventMIDI {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventMIDIMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventMIDI {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_channel(&self) -> i64 {
        unsafe { InputEventMIDI_get_channel(self.this) }
    }

    #[inline]
    pub fn get_controller_number(&self) -> i64 {
        unsafe { InputEventMIDI_get_controller_number(self.this) }
    }

    #[inline]
    pub fn get_controller_value(&self) -> i64 {
        unsafe { InputEventMIDI_get_controller_value(self.this) }
    }

    #[inline]
    pub fn get_instrument(&self) -> i64 {
        unsafe { InputEventMIDI_get_instrument(self.this) }
    }

    #[inline]
    pub fn get_message(&self) -> i64 {
        unsafe { InputEventMIDI_get_message(self.this) }
    }

    #[inline]
    pub fn get_pitch(&self) -> i64 {
        unsafe { InputEventMIDI_get_pitch(self.this) }
    }

    #[inline]
    pub fn get_pressure(&self) -> i64 {
        unsafe { InputEventMIDI_get_pressure(self.this) }
    }

    #[inline]
    pub fn get_velocity(&self) -> i64 {
        unsafe { InputEventMIDI_get_velocity(self.this) }
    }

    #[inline]
    pub fn set_channel(&mut self, channel: i64) -> () {
        unsafe { InputEventMIDI_set_channel(self.this, channel) }
    }

    #[inline]
    pub fn set_controller_number(&mut self, controller_number: i64) -> () {
        unsafe { InputEventMIDI_set_controller_number(self.this, controller_number) }
    }

    #[inline]
    pub fn set_controller_value(&mut self, controller_value: i64) -> () {
        unsafe { InputEventMIDI_set_controller_value(self.this, controller_value) }
    }

    #[inline]
    pub fn set_instrument(&mut self, instrument: i64) -> () {
        unsafe { InputEventMIDI_set_instrument(self.this, instrument) }
    }

    #[inline]
    pub fn set_message(&mut self, message: i64) -> () {
        unsafe { InputEventMIDI_set_message(self.this, message) }
    }

    #[inline]
    pub fn set_pitch(&mut self, pitch: i64) -> () {
        unsafe { InputEventMIDI_set_pitch(self.this, pitch) }
    }

    #[inline]
    pub fn set_pressure(&mut self, pressure: i64) -> () {
        unsafe { InputEventMIDI_set_pressure(self.this, pressure) }
    }

    #[inline]
    pub fn set_velocity(&mut self, velocity: i64) -> () {
        unsafe { InputEventMIDI_set_velocity(self.this, velocity) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventMagnifyGesture` inherits `InputEventGesture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventmagnifygesture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventMagnifyGesture inherits methods from:
/// - [InputEventGesture](struct.InputEventGesture.html)
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventMagnifyGesture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventMagnifyGesture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventMagnifyGestureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventMagnifyGesture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_factor(&self) -> f64 {
        unsafe { InputEventMagnifyGesture_get_factor(self.this) }
    }

    #[inline]
    pub fn set_factor(&mut self, factor: f64) -> () {
        unsafe { InputEventMagnifyGesture_set_factor(self.this, factor) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_gesture(&self) -> InputEventGesture {
        unsafe {{ object::add_ref(self.this); }}
        InputEventGesture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventMouse` inherits `InputEventWithModifiers` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventmouse.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventMouse inherits methods from:
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventMouse {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventMouse {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_button_mask(&self) -> i64 {
        unsafe { InputEventMouse_get_button_mask(self.this) }
    }

    #[inline]
    pub fn get_global_position(&self) -> Vector2 {
        unsafe { InputEventMouse_get_global_position(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> Vector2 {
        unsafe { InputEventMouse_get_position(self.this) }
    }

    #[inline]
    pub fn set_button_mask(&mut self, button_mask: i64) -> () {
        unsafe { InputEventMouse_set_button_mask(self.this, button_mask) }
    }

    #[inline]
    pub fn set_global_position(&mut self, global_position: Vector2) -> () {
        unsafe { InputEventMouse_set_global_position(self.this, global_position) }
    }

    #[inline]
    pub fn set_position(&mut self, position: Vector2) -> () {
        unsafe { InputEventMouse_set_position(self.this, position) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventMouseButton` inherits `InputEventMouse` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventmousebutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventMouseButton inherits methods from:
/// - [InputEventMouse](struct.InputEventMouse.html)
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventMouseButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventMouseButton {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventMouseButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventMouseButton {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_button_index(&self) -> i64 {
        unsafe { InputEventMouseButton_get_button_index(self.this) }
    }

    #[inline]
    pub fn get_factor(&mut self) -> f64 {
        unsafe { InputEventMouseButton_get_factor(self.this) }
    }

    #[inline]
    pub fn is_doubleclick(&self) -> bool {
        unsafe { InputEventMouseButton_is_doubleclick(self.this) }
    }

    #[inline]
    pub fn set_button_index(&mut self, button_index: i64) -> () {
        unsafe { InputEventMouseButton_set_button_index(self.this, button_index) }
    }

    #[inline]
    pub fn set_doubleclick(&mut self, doubleclick: bool) -> () {
        unsafe { InputEventMouseButton_set_doubleclick(self.this, doubleclick) }
    }

    #[inline]
    pub fn set_factor(&mut self, factor: f64) -> () {
        unsafe { InputEventMouseButton_set_factor(self.this, factor) }
    }

    #[inline]
    pub fn set_pressed(&mut self, pressed: bool) -> () {
        unsafe { InputEventMouseButton_set_pressed(self.this, pressed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_mouse(&self) -> InputEventMouse {
        unsafe {{ object::add_ref(self.this); }}
        InputEventMouse { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventMouseMotion` inherits `InputEventMouse` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventmousemotion.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventMouseMotion inherits methods from:
/// - [InputEventMouse](struct.InputEventMouse.html)
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventMouseMotion {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventMouseMotion {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventMouseMotionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventMouseMotion {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_pressure(&self) -> f64 {
        unsafe { InputEventMouseMotion_get_pressure(self.this) }
    }

    #[inline]
    pub fn get_relative(&self) -> Vector2 {
        unsafe { InputEventMouseMotion_get_relative(self.this) }
    }

    #[inline]
    pub fn get_speed(&self) -> Vector2 {
        unsafe { InputEventMouseMotion_get_speed(self.this) }
    }

    #[inline]
    pub fn get_tilt(&self) -> Vector2 {
        unsafe { InputEventMouseMotion_get_tilt(self.this) }
    }

    #[inline]
    pub fn set_pressure(&mut self, pressure: f64) -> () {
        unsafe { InputEventMouseMotion_set_pressure(self.this, pressure) }
    }

    #[inline]
    pub fn set_relative(&mut self, relative: Vector2) -> () {
        unsafe { InputEventMouseMotion_set_relative(self.this, relative) }
    }

    #[inline]
    pub fn set_speed(&mut self, speed: Vector2) -> () {
        unsafe { InputEventMouseMotion_set_speed(self.this, speed) }
    }

    #[inline]
    pub fn set_tilt(&mut self, tilt: Vector2) -> () {
        unsafe { InputEventMouseMotion_set_tilt(self.this, tilt) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_mouse(&self) -> InputEventMouse {
        unsafe {{ object::add_ref(self.this); }}
        InputEventMouse { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventPanGesture` inherits `InputEventGesture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventpangesture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventPanGesture inherits methods from:
/// - [InputEventGesture](struct.InputEventGesture.html)
/// - [InputEventWithModifiers](struct.InputEventWithModifiers.html)
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventPanGesture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventPanGesture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventPanGestureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventPanGesture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_delta(&self) -> Vector2 {
        unsafe { InputEventPanGesture_get_delta(self.this) }
    }

    #[inline]
    pub fn set_delta(&mut self, delta: Vector2) -> () {
        unsafe { InputEventPanGesture_set_delta(self.this, delta) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event_gesture(&self) -> InputEventGesture {
        unsafe {{ object::add_ref(self.this); }}
        InputEventGesture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event_with_modifiers(&self) -> InputEventWithModifiers {
        unsafe {{ object::add_ref(self.this); }}
        InputEventWithModifiers { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventScreenDrag` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventscreendrag.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventScreenDrag inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventScreenDrag {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventScreenDrag {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventScreenDragMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventScreenDrag {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_index(&self) -> i64 {
        unsafe { InputEventScreenDrag_get_index(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> Vector2 {
        unsafe { InputEventScreenDrag_get_position(self.this) }
    }

    #[inline]
    pub fn get_relative(&self) -> Vector2 {
        unsafe { InputEventScreenDrag_get_relative(self.this) }
    }

    #[inline]
    pub fn get_speed(&self) -> Vector2 {
        unsafe { InputEventScreenDrag_get_speed(self.this) }
    }

    #[inline]
    pub fn set_index(&mut self, index: i64) -> () {
        unsafe { InputEventScreenDrag_set_index(self.this, index) }
    }

    #[inline]
    pub fn set_position(&mut self, position: Vector2) -> () {
        unsafe { InputEventScreenDrag_set_position(self.this, position) }
    }

    #[inline]
    pub fn set_relative(&mut self, relative: Vector2) -> () {
        unsafe { InputEventScreenDrag_set_relative(self.this, relative) }
    }

    #[inline]
    pub fn set_speed(&mut self, speed: Vector2) -> () {
        unsafe { InputEventScreenDrag_set_speed(self.this, speed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventScreenTouch` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventscreentouch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventScreenTouch inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventScreenTouch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventScreenTouch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InputEventScreenTouchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            InputEventScreenTouch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_index(&self) -> i64 {
        unsafe { InputEventScreenTouch_get_index(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> Vector2 {
        unsafe { InputEventScreenTouch_get_position(self.this) }
    }

    #[inline]
    pub fn set_index(&mut self, index: i64) -> () {
        unsafe { InputEventScreenTouch_set_index(self.this, index) }
    }

    #[inline]
    pub fn set_position(&mut self, position: Vector2) -> () {
        unsafe { InputEventScreenTouch_set_position(self.this, position) }
    }

    #[inline]
    pub fn set_pressed(&mut self, pressed: bool) -> () {
        unsafe { InputEventScreenTouch_set_pressed(self.this, pressed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InputEventWithModifiers` inherits `InputEvent` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputeventwithmodifiers.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// InputEventWithModifiers inherits methods from:
/// - [InputEvent](struct.InputEvent.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputEventWithModifiers {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputEventWithModifiers {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_alt(&self) -> bool {
        unsafe { InputEventWithModifiers_get_alt(self.this) }
    }

    #[inline]
    pub fn get_command(&self) -> bool {
        unsafe { InputEventWithModifiers_get_command(self.this) }
    }

    #[inline]
    pub fn get_control(&self) -> bool {
        unsafe { InputEventWithModifiers_get_control(self.this) }
    }

    #[inline]
    pub fn get_metakey(&self) -> bool {
        unsafe { InputEventWithModifiers_get_metakey(self.this) }
    }

    #[inline]
    pub fn get_shift(&self) -> bool {
        unsafe { InputEventWithModifiers_get_shift(self.this) }
    }

    #[inline]
    pub fn set_alt(&mut self, enable: bool) -> () {
        unsafe { InputEventWithModifiers_set_alt(self.this, enable) }
    }

    #[inline]
    pub fn set_command(&mut self, enable: bool) -> () {
        unsafe { InputEventWithModifiers_set_command(self.this, enable) }
    }

    #[inline]
    pub fn set_control(&mut self, enable: bool) -> () {
        unsafe { InputEventWithModifiers_set_control(self.this, enable) }
    }

    #[inline]
    pub fn set_metakey(&mut self, enable: bool) -> () {
        unsafe { InputEventWithModifiers_set_metakey(self.this, enable) }
    }

    #[inline]
    pub fn set_shift(&mut self, enable: bool) -> () {
        unsafe { InputEventWithModifiers_set_shift(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_input_event(&self) -> InputEvent {
        unsafe {{ object::add_ref(self.this); }}
        InputEvent { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class InputMap` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_inputmap.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// InputMap inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InputMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InputMap {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"InputMap\0".as_ptr() as *mut _);

            InputMap {
                this
            }
        }
    }
    #[inline]
    pub fn action_add_event(&mut self, action: GodotString, event: Option<InputEvent>) -> () {
        unsafe { InputMap_action_add_event(self.this, action, event) }
    }

    #[inline]
    pub fn action_erase_event(&mut self, action: GodotString, event: Option<InputEvent>) -> () {
        unsafe { InputMap_action_erase_event(self.this, action, event) }
    }

    #[inline]
    pub fn action_erase_events(&mut self, action: GodotString) -> () {
        unsafe { InputMap_action_erase_events(self.this, action) }
    }

    #[inline]
    pub fn action_has_event(&mut self, action: GodotString, event: Option<InputEvent>) -> bool {
        unsafe { InputMap_action_has_event(self.this, action, event) }
    }

    #[inline]
    pub fn action_set_deadzone(&mut self, action: GodotString, deadzone: f64) -> () {
        unsafe { InputMap_action_set_deadzone(self.this, action, deadzone) }
    }

    #[inline]
    pub fn add_action(&mut self, action: GodotString, deadzone: f64) -> () {
        unsafe { InputMap_add_action(self.this, action, deadzone) }
    }

    #[inline]
    pub fn erase_action(&mut self, action: GodotString) -> () {
        unsafe { InputMap_erase_action(self.this, action) }
    }

    #[inline]
    pub fn event_is_action(&self, event: Option<InputEvent>, action: GodotString) -> bool {
        unsafe { InputMap_event_is_action(self.this, event, action) }
    }

    #[inline]
    pub fn get_action_list(&mut self, action: GodotString) -> VariantArray {
        unsafe { InputMap_get_action_list(self.this, action) }
    }

    #[inline]
    pub fn get_actions(&mut self) -> VariantArray {
        unsafe { InputMap_get_actions(self.this) }
    }

    #[inline]
    pub fn has_action(&self, action: GodotString) -> bool {
        unsafe { InputMap_has_action(self.this, action) }
    }

    #[inline]
    pub fn load_from_globals(&mut self) -> () {
        unsafe { InputMap_load_from_globals(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InstancePlaceholder` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_instanceplaceholder.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// InstancePlaceholder inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InstancePlaceholder {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InstancePlaceholder {
    #[inline]
    pub unsafe fn create_instance(&mut self, replace: bool, custom_scene: Option<PackedScene>) -> Option<Node> {
        InstancePlaceholder_create_instance(self.this, replace, custom_scene)
    }

    #[inline]
    pub unsafe fn get_instance_path(&self) -> GodotString {
        InstancePlaceholder_get_instance_path(self.this)
    }

    #[inline]
    pub unsafe fn get_stored_values(&mut self, with_order: bool) -> Dictionary {
        InstancePlaceholder_get_stored_values(self.this, with_order)
    }

    #[inline]
    pub unsafe fn replace_by_instance(&mut self, custom_scene: Option<PackedScene>) -> () {
        InstancePlaceholder_replace_by_instance(self.this, custom_scene)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class InterpolatedCamera` inherits `Camera` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_interpolatedcamera.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `InterpolatedCamera` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `InterpolatedCamera::free`.
///
/// ## Class hierarchy
///
/// InterpolatedCamera inherits methods from:
/// - [Camera](struct.Camera.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct InterpolatedCamera {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl InterpolatedCamera {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `InterpolatedCamera::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = InterpolatedCameraMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            InterpolatedCamera {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_speed(&self) -> f64 {
        InterpolatedCamera_get_speed(self.this)
    }

    #[inline]
    pub unsafe fn get_target_path(&self) -> NodePath {
        InterpolatedCamera_get_target_path(self.this)
    }

    #[inline]
    pub unsafe fn is_interpolation_enabled(&self) -> bool {
        InterpolatedCamera_is_interpolation_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_interpolation_enabled(&mut self, target_path: bool) -> () {
        InterpolatedCamera_set_interpolation_enabled(self.this, target_path)
    }

    #[inline]
    pub unsafe fn set_speed(&mut self, speed: f64) -> () {
        InterpolatedCamera_set_speed(self.this, speed)
    }

    #[inline]
    pub unsafe fn set_target(&mut self, target: Option<Object>) -> () {
        InterpolatedCamera_set_target(self.this, target)
    }

    #[inline]
    pub unsafe fn set_target_path(&mut self, target_path: NodePath) -> () {
        InterpolatedCamera_set_target_path(self.this, target_path)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_camera(&self) -> Camera {
        // Not reference-counted.
        Camera { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ItemList` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_itemlist.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ItemList` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ItemList::free`.
///
/// ## Class hierarchy
///
/// ItemList inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ItemList {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ItemListSelectMode {
    Single = 0,
    Multi = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ItemListIconMode {
    ModeTop = 0,
    ModeLeft = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ItemList {
    pub const ICON_MODE_TOP: i64 = 0;
    pub const ICON_MODE_LEFT: i64 = 1;
    pub const SELECT_MULTI: i64 = 1;
    pub const SELECT_SINGLE: i64 = 0;
}
impl ItemList {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ItemList::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ItemListMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ItemList {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_items(&self) -> VariantArray {
        ItemList__get_items(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        ItemList__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _scroll_changed(&mut self, arg0: f64) -> () {
        ItemList__scroll_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _set_items(&mut self, arg0: VariantArray) -> () {
        ItemList__set_items(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_icon_item(&mut self, icon: Option<Texture>, selectable: bool) -> () {
        ItemList_add_icon_item(self.this, icon, selectable)
    }

    #[inline]
    pub unsafe fn add_item(&mut self, text: GodotString, icon: Option<Texture>, selectable: bool) -> () {
        ItemList_add_item(self.this, text, icon, selectable)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        ItemList_clear(self.this)
    }

    #[inline]
    pub unsafe fn ensure_current_is_visible(&mut self) -> () {
        ItemList_ensure_current_is_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_allow_reselect(&self) -> bool {
        ItemList_get_allow_reselect(self.this)
    }

    #[inline]
    pub unsafe fn get_allow_rmb_select(&self) -> bool {
        ItemList_get_allow_rmb_select(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_column_width(&self) -> i64 {
        ItemList_get_fixed_column_width(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_icon_size(&self) -> Vector2 {
        ItemList_get_fixed_icon_size(self.this)
    }

    #[inline]
    pub unsafe fn get_icon_mode(&self) -> ItemListIconMode {
        ItemList_get_icon_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_icon_scale(&self) -> f64 {
        ItemList_get_icon_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_item_at_position(&self, position: Vector2, exact: bool) -> i64 {
        ItemList_get_item_at_position(self.this, position, exact)
    }

    #[inline]
    pub unsafe fn get_item_count(&self) -> i64 {
        ItemList_get_item_count(self.this)
    }

    #[inline]
    pub unsafe fn get_item_custom_bg_color(&self, idx: i64) -> Color {
        ItemList_get_item_custom_bg_color(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_custom_fg_color(&self, idx: i64) -> Color {
        ItemList_get_item_custom_fg_color(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_icon(&self, idx: i64) -> Option<Texture> {
        ItemList_get_item_icon(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_icon_modulate(&self, idx: i64) -> Color {
        ItemList_get_item_icon_modulate(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_icon_region(&self, idx: i64) -> Rect2 {
        ItemList_get_item_icon_region(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_metadata(&self, idx: i64) -> Variant {
        ItemList_get_item_metadata(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_text(&self, idx: i64) -> GodotString {
        ItemList_get_item_text(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_tooltip(&self, idx: i64) -> GodotString {
        ItemList_get_item_tooltip(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_max_columns(&self) -> i64 {
        ItemList_get_max_columns(self.this)
    }

    #[inline]
    pub unsafe fn get_max_text_lines(&self) -> i64 {
        ItemList_get_max_text_lines(self.this)
    }

    #[inline]
    pub unsafe fn get_select_mode(&self) -> ItemListSelectMode {
        ItemList_get_select_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_items(&mut self) -> Int32Array {
        ItemList_get_selected_items(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scroll(&mut self) -> Option<VScrollBar> {
        ItemList_get_v_scroll(self.this)
    }

    #[inline]
    pub unsafe fn has_auto_height(&self) -> bool {
        ItemList_has_auto_height(self.this)
    }

    #[inline]
    pub unsafe fn is_anything_selected(&mut self) -> bool {
        ItemList_is_anything_selected(self.this)
    }

    #[inline]
    pub unsafe fn is_item_disabled(&self, idx: i64) -> bool {
        ItemList_is_item_disabled(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_icon_transposed(&self, idx: i64) -> bool {
        ItemList_is_item_icon_transposed(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_selectable(&self, idx: i64) -> bool {
        ItemList_is_item_selectable(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_tooltip_enabled(&self, idx: i64) -> bool {
        ItemList_is_item_tooltip_enabled(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_same_column_width(&self) -> bool {
        ItemList_is_same_column_width(self.this)
    }

    #[inline]
    pub unsafe fn is_selected(&self, idx: i64) -> bool {
        ItemList_is_selected(self.this, idx)
    }

    #[inline]
    pub unsafe fn move_item(&mut self, from_idx: i64, to_idx: i64) -> () {
        ItemList_move_item(self.this, from_idx, to_idx)
    }

    #[inline]
    pub unsafe fn remove_item(&mut self, idx: i64) -> () {
        ItemList_remove_item(self.this, idx)
    }

    #[inline]
    pub unsafe fn select(&mut self, idx: i64, single: bool) -> () {
        ItemList_select(self.this, idx, single)
    }

    #[inline]
    pub unsafe fn set_allow_reselect(&mut self, allow: bool) -> () {
        ItemList_set_allow_reselect(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_allow_rmb_select(&mut self, allow: bool) -> () {
        ItemList_set_allow_rmb_select(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_auto_height(&mut self, enable: bool) -> () {
        ItemList_set_auto_height(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_fixed_column_width(&mut self, width: i64) -> () {
        ItemList_set_fixed_column_width(self.this, width)
    }

    #[inline]
    pub unsafe fn set_fixed_icon_size(&mut self, size: Vector2) -> () {
        ItemList_set_fixed_icon_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_icon_mode(&mut self, mode: i64) -> () {
        ItemList_set_icon_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_icon_scale(&mut self, scale: f64) -> () {
        ItemList_set_icon_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_item_custom_bg_color(&mut self, idx: i64, custom_bg_color: Color) -> () {
        ItemList_set_item_custom_bg_color(self.this, idx, custom_bg_color)
    }

    #[inline]
    pub unsafe fn set_item_custom_fg_color(&mut self, idx: i64, custom_fg_color: Color) -> () {
        ItemList_set_item_custom_fg_color(self.this, idx, custom_fg_color)
    }

    #[inline]
    pub unsafe fn set_item_disabled(&mut self, idx: i64, disabled: bool) -> () {
        ItemList_set_item_disabled(self.this, idx, disabled)
    }

    #[inline]
    pub unsafe fn set_item_icon(&mut self, idx: i64, icon: Option<Texture>) -> () {
        ItemList_set_item_icon(self.this, idx, icon)
    }

    #[inline]
    pub unsafe fn set_item_icon_modulate(&mut self, idx: i64, modulate: Color) -> () {
        ItemList_set_item_icon_modulate(self.this, idx, modulate)
    }

    #[inline]
    pub unsafe fn set_item_icon_region(&mut self, idx: i64, rect: Rect2) -> () {
        ItemList_set_item_icon_region(self.this, idx, rect)
    }

    #[inline]
    pub unsafe fn set_item_icon_transposed(&mut self, idx: i64, transposed: bool) -> () {
        ItemList_set_item_icon_transposed(self.this, idx, transposed)
    }

    #[inline]
    pub unsafe fn set_item_metadata(&mut self, idx: i64, metadata: Variant) -> () {
        ItemList_set_item_metadata(self.this, idx, metadata)
    }

    #[inline]
    pub unsafe fn set_item_selectable(&mut self, idx: i64, selectable: bool) -> () {
        ItemList_set_item_selectable(self.this, idx, selectable)
    }

    #[inline]
    pub unsafe fn set_item_text(&mut self, idx: i64, text: GodotString) -> () {
        ItemList_set_item_text(self.this, idx, text)
    }

    #[inline]
    pub unsafe fn set_item_tooltip(&mut self, idx: i64, tooltip: GodotString) -> () {
        ItemList_set_item_tooltip(self.this, idx, tooltip)
    }

    #[inline]
    pub unsafe fn set_item_tooltip_enabled(&mut self, idx: i64, enable: bool) -> () {
        ItemList_set_item_tooltip_enabled(self.this, idx, enable)
    }

    #[inline]
    pub unsafe fn set_max_columns(&mut self, amount: i64) -> () {
        ItemList_set_max_columns(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_max_text_lines(&mut self, lines: i64) -> () {
        ItemList_set_max_text_lines(self.this, lines)
    }

    #[inline]
    pub unsafe fn set_same_column_width(&mut self, enable: bool) -> () {
        ItemList_set_same_column_width(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_select_mode(&mut self, mode: i64) -> () {
        ItemList_set_select_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn sort_items_by_text(&mut self) -> () {
        ItemList_sort_items_by_text(self.this)
    }

    #[inline]
    pub unsafe fn unselect(&mut self, idx: i64) -> () {
        ItemList_unselect(self.this, idx)
    }

    #[inline]
    pub unsafe fn unselect_all(&mut self) -> () {
        ItemList_unselect_all(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class JSONParseResult` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_jsonparseresult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// JSONParseResult inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JSONParseResult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl JSONParseResult {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = JSONParseResultMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            JSONParseResult {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_error(&self) -> GodotResult {
        unsafe { JSONParseResult_get_error(self.this) }
    }

    #[inline]
    pub fn get_error_line(&self) -> i64 {
        unsafe { JSONParseResult_get_error_line(self.this) }
    }

    #[inline]
    pub fn get_error_string(&self) -> GodotString {
        unsafe { JSONParseResult_get_error_string(self.this) }
    }

    #[inline]
    pub fn get_result(&self) -> Variant {
        unsafe { JSONParseResult_get_result(self.this) }
    }

    #[inline]
    pub fn set_error(&mut self, error: i64) -> () {
        unsafe { JSONParseResult_set_error(self.this, error) }
    }

    #[inline]
    pub fn set_error_line(&mut self, error_line: i64) -> () {
        unsafe { JSONParseResult_set_error_line(self.this, error_line) }
    }

    #[inline]
    pub fn set_error_string(&mut self, error_string: GodotString) -> () {
        unsafe { JSONParseResult_set_error_string(self.this, error_string) }
    }

    #[inline]
    pub fn set_result(&mut self, result: Variant) -> () {
        unsafe { JSONParseResult_set_result(self.this, result) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class JSONRPC` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_jsonrpc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `JSONRPC` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `JSONRPC::free`.
///
/// ## Class hierarchy
///
/// JSONRPC inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JSONRPC {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum JSONRPCErrorCode {
    ParseError = 4294934596,
    InternalError = 4294934693,
    InvalidParams = 4294934694,
    MethodNotFound = 4294934695,
    InvalidRequest = 4294934696,
}
/// Constants
#[allow(non_upper_case_globals)]
impl JSONRPC {
    pub const INVALID_REQUEST: i64 = -32600;
    pub const PARSE_ERROR: i64 = -32700;
    pub const INTERNAL_ERROR: i64 = -32603;
    pub const INVALID_PARAMS: i64 = -32602;
    pub const METHOD_NOT_FOUND: i64 = -32601;
}
impl JSONRPC {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `JSONRPC::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = JSONRPCMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            JSONRPC {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn make_notification(&mut self, method: GodotString, params: Variant) -> Dictionary {
        JSONRPC_make_notification(self.this, method, params)
    }

    #[inline]
    pub unsafe fn make_request(&mut self, method: GodotString, params: Variant, id: Variant) -> Dictionary {
        JSONRPC_make_request(self.this, method, params, id)
    }

    #[inline]
    pub unsafe fn make_response(&mut self, result: Variant, id: Variant) -> Dictionary {
        JSONRPC_make_response(self.this, result, id)
    }

    #[inline]
    pub unsafe fn make_response_error(&self, code: i64, message: GodotString, id: Variant) -> Dictionary {
        JSONRPC_make_response_error(self.this, code, message, id)
    }

    #[inline]
    pub unsafe fn process_action(&mut self, action: Variant, recurse: bool) -> Variant {
        JSONRPC_process_action(self.this, action, recurse)
    }

    #[inline]
    pub unsafe fn process_string(&mut self, action: GodotString) -> GodotString {
        JSONRPC_process_string(self.this, action)
    }

    #[inline]
    pub unsafe fn set_scope(&mut self, scope: GodotString, target: Option<Object>) -> () {
        JSONRPC_set_scope(self.this, scope, target)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class JavaClass` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_javaclass.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// JavaClass inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JavaClass {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl JavaClass {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = JavaClassMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            JavaClass {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class JavaClassWrapper` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_javaclasswrapper.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// JavaClassWrapper inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JavaClassWrapper {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl JavaClassWrapper {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"JavaClassWrapper\0".as_ptr() as *mut _);

            JavaClassWrapper {
                this
            }
        }
    }
    #[inline]
    pub fn wrap(&mut self, name: GodotString) -> Option<JavaClass> {
        unsafe { JavaClassWrapper_wrap(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class JavaScript` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_javascript.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// JavaScript inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JavaScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl JavaScript {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"JavaScript\0".as_ptr() as *mut _);

            JavaScript {
                this
            }
        }
    }
    #[inline]
    pub fn eval(&mut self, code: GodotString, use_global_execution_context: bool) -> Variant {
        unsafe { JavaScript_eval(self.this, code, use_global_execution_context) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Joint` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_joint.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Joint inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Joint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Joint {
    #[inline]
    pub unsafe fn get_exclude_nodes_from_collision(&self) -> bool {
        Joint_get_exclude_nodes_from_collision(self.this)
    }

    #[inline]
    pub unsafe fn get_node_a(&self) -> NodePath {
        Joint_get_node_a(self.this)
    }

    #[inline]
    pub unsafe fn get_node_b(&self) -> NodePath {
        Joint_get_node_b(self.this)
    }

    #[inline]
    pub unsafe fn get_solver_priority(&self) -> i64 {
        Joint_get_solver_priority(self.this)
    }

    #[inline]
    pub unsafe fn set_exclude_nodes_from_collision(&mut self, enable: bool) -> () {
        Joint_set_exclude_nodes_from_collision(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_node_a(&mut self, node: NodePath) -> () {
        Joint_set_node_a(self.this, node)
    }

    #[inline]
    pub unsafe fn set_node_b(&mut self, node: NodePath) -> () {
        Joint_set_node_b(self.this, node)
    }

    #[inline]
    pub unsafe fn set_solver_priority(&mut self, priority: i64) -> () {
        Joint_set_solver_priority(self.this, priority)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Joint2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_joint2d.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Joint2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Joint2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Joint2D {
    #[inline]
    pub unsafe fn get_bias(&self) -> f64 {
        Joint2D_get_bias(self.this)
    }

    #[inline]
    pub unsafe fn get_exclude_nodes_from_collision(&self) -> bool {
        Joint2D_get_exclude_nodes_from_collision(self.this)
    }

    #[inline]
    pub unsafe fn get_node_a(&self) -> NodePath {
        Joint2D_get_node_a(self.this)
    }

    #[inline]
    pub unsafe fn get_node_b(&self) -> NodePath {
        Joint2D_get_node_b(self.this)
    }

    #[inline]
    pub unsafe fn set_bias(&mut self, bias: f64) -> () {
        Joint2D_set_bias(self.this, bias)
    }

    #[inline]
    pub unsafe fn set_exclude_nodes_from_collision(&mut self, enable: bool) -> () {
        Joint2D_set_exclude_nodes_from_collision(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_node_a(&mut self, node: NodePath) -> () {
        Joint2D_set_node_a(self.this, node)
    }

    #[inline]
    pub unsafe fn set_node_b(&mut self, node: NodePath) -> () {
        Joint2D_set_node_b(self.this, node)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class KinematicBody` inherits `PhysicsBody` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_kinematicbody.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `KinematicBody` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `KinematicBody::free`.
///
/// ## Class hierarchy
///
/// KinematicBody inherits methods from:
/// - [PhysicsBody](struct.PhysicsBody.html)
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct KinematicBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl KinematicBody {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `KinematicBody::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = KinematicBodyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            KinematicBody {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_axis_lock(&self, axis: i64) -> bool {
        KinematicBody_get_axis_lock(self.this, axis)
    }

    #[inline]
    pub unsafe fn get_floor_normal(&self) -> Vector3 {
        KinematicBody_get_floor_normal(self.this)
    }

    #[inline]
    pub unsafe fn get_floor_velocity(&self) -> Vector3 {
        KinematicBody_get_floor_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_safe_margin(&self) -> f64 {
        KinematicBody_get_safe_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_slide_collision(&mut self, slide_idx: i64) -> Option<KinematicCollision> {
        KinematicBody_get_slide_collision(self.this, slide_idx)
    }

    #[inline]
    pub unsafe fn get_slide_count(&self) -> i64 {
        KinematicBody_get_slide_count(self.this)
    }

    #[inline]
    pub unsafe fn is_on_ceiling(&self) -> bool {
        KinematicBody_is_on_ceiling(self.this)
    }

    #[inline]
    pub unsafe fn is_on_floor(&self) -> bool {
        KinematicBody_is_on_floor(self.this)
    }

    #[inline]
    pub unsafe fn is_on_wall(&self) -> bool {
        KinematicBody_is_on_wall(self.this)
    }

    #[inline]
    pub unsafe fn move_and_collide(&mut self, rel_vec: Vector3, infinite_inertia: bool, exclude_raycast_shapes: bool, test_only: bool) -> Option<KinematicCollision> {
        KinematicBody_move_and_collide(self.this, rel_vec, infinite_inertia, exclude_raycast_shapes, test_only)
    }

    #[inline]
    pub unsafe fn move_and_slide(&mut self, linear_velocity: Vector3, up_direction: Vector3, stop_on_slope: bool, max_slides: i64, floor_max_angle: f64, infinite_inertia: bool) -> Vector3 {
        KinematicBody_move_and_slide(self.this, linear_velocity, up_direction, stop_on_slope, max_slides, floor_max_angle, infinite_inertia)
    }

    #[inline]
    pub unsafe fn move_and_slide_with_snap(&mut self, linear_velocity: Vector3, snap: Vector3, up_direction: Vector3, stop_on_slope: bool, max_slides: i64, floor_max_angle: f64, infinite_inertia: bool) -> Vector3 {
        KinematicBody_move_and_slide_with_snap(self.this, linear_velocity, snap, up_direction, stop_on_slope, max_slides, floor_max_angle, infinite_inertia)
    }

    #[inline]
    pub unsafe fn set_axis_lock(&mut self, axis: i64, lock: bool) -> () {
        KinematicBody_set_axis_lock(self.this, axis, lock)
    }

    #[inline]
    pub unsafe fn set_safe_margin(&mut self, pixels: f64) -> () {
        KinematicBody_set_safe_margin(self.this, pixels)
    }

    #[inline]
    pub unsafe fn test_move(&mut self, from: Transform, rel_vec: Vector3, infinite_inertia: bool) -> bool {
        KinematicBody_test_move(self.this, from, rel_vec, infinite_inertia)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body(&self) -> PhysicsBody {
        // Not reference-counted.
        PhysicsBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class KinematicBody2D` inherits `PhysicsBody2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_kinematicbody2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `KinematicBody2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `KinematicBody2D::free`.
///
/// ## Class hierarchy
///
/// KinematicBody2D inherits methods from:
/// - [PhysicsBody2D](struct.PhysicsBody2D.html)
/// - [CollisionObject2D](struct.CollisionObject2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct KinematicBody2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl KinematicBody2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `KinematicBody2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = KinematicBody2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            KinematicBody2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _direct_state_changed(&mut self, arg0: Option<Object>) -> () {
        KinematicBody2D__direct_state_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_floor_normal(&self) -> Vector2 {
        KinematicBody2D_get_floor_normal(self.this)
    }

    #[inline]
    pub unsafe fn get_floor_velocity(&self) -> Vector2 {
        KinematicBody2D_get_floor_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_safe_margin(&self) -> f64 {
        KinematicBody2D_get_safe_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_slide_collision(&mut self, slide_idx: i64) -> Option<KinematicCollision2D> {
        KinematicBody2D_get_slide_collision(self.this, slide_idx)
    }

    #[inline]
    pub unsafe fn get_slide_count(&self) -> i64 {
        KinematicBody2D_get_slide_count(self.this)
    }

    #[inline]
    pub unsafe fn is_on_ceiling(&self) -> bool {
        KinematicBody2D_is_on_ceiling(self.this)
    }

    #[inline]
    pub unsafe fn is_on_floor(&self) -> bool {
        KinematicBody2D_is_on_floor(self.this)
    }

    #[inline]
    pub unsafe fn is_on_wall(&self) -> bool {
        KinematicBody2D_is_on_wall(self.this)
    }

    #[inline]
    pub unsafe fn is_sync_to_physics_enabled(&self) -> bool {
        KinematicBody2D_is_sync_to_physics_enabled(self.this)
    }

    #[inline]
    pub unsafe fn move_and_collide(&mut self, rel_vec: Vector2, infinite_inertia: bool, exclude_raycast_shapes: bool, test_only: bool) -> Option<KinematicCollision2D> {
        KinematicBody2D_move_and_collide(self.this, rel_vec, infinite_inertia, exclude_raycast_shapes, test_only)
    }

    #[inline]
    pub unsafe fn move_and_slide(&mut self, linear_velocity: Vector2, up_direction: Vector2, stop_on_slope: bool, max_slides: i64, floor_max_angle: f64, infinite_inertia: bool) -> Vector2 {
        KinematicBody2D_move_and_slide(self.this, linear_velocity, up_direction, stop_on_slope, max_slides, floor_max_angle, infinite_inertia)
    }

    #[inline]
    pub unsafe fn move_and_slide_with_snap(&mut self, linear_velocity: Vector2, snap: Vector2, up_direction: Vector2, stop_on_slope: bool, max_slides: i64, floor_max_angle: f64, infinite_inertia: bool) -> Vector2 {
        KinematicBody2D_move_and_slide_with_snap(self.this, linear_velocity, snap, up_direction, stop_on_slope, max_slides, floor_max_angle, infinite_inertia)
    }

    #[inline]
    pub unsafe fn set_safe_margin(&mut self, pixels: f64) -> () {
        KinematicBody2D_set_safe_margin(self.this, pixels)
    }

    #[inline]
    pub unsafe fn set_sync_to_physics(&mut self, enable: bool) -> () {
        KinematicBody2D_set_sync_to_physics(self.this, enable)
    }

    #[inline]
    pub unsafe fn test_move(&mut self, from: Transform2D, rel_vec: Vector2, infinite_inertia: bool) -> bool {
        KinematicBody2D_test_move(self.this, from, rel_vec, infinite_inertia)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body_2d(&self) -> PhysicsBody2D {
        // Not reference-counted.
        PhysicsBody2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object_2d(&self) -> CollisionObject2D {
        // Not reference-counted.
        CollisionObject2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class KinematicCollision` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_kinematiccollision.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// KinematicCollision inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct KinematicCollision {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl KinematicCollision {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = KinematicCollisionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            KinematicCollision {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_collider(&self) -> Option<Object> {
        unsafe { KinematicCollision_get_collider(self.this) }
    }

    #[inline]
    pub fn get_collider_id(&self) -> i64 {
        unsafe { KinematicCollision_get_collider_id(self.this) }
    }

    #[inline]
    pub fn get_collider_metadata(&self) -> Variant {
        unsafe { KinematicCollision_get_collider_metadata(self.this) }
    }

    #[inline]
    pub fn get_collider_shape(&self) -> Option<Object> {
        unsafe { KinematicCollision_get_collider_shape(self.this) }
    }

    #[inline]
    pub fn get_collider_shape_index(&self) -> i64 {
        unsafe { KinematicCollision_get_collider_shape_index(self.this) }
    }

    #[inline]
    pub fn get_collider_velocity(&self) -> Vector3 {
        unsafe { KinematicCollision_get_collider_velocity(self.this) }
    }

    #[inline]
    pub fn get_local_shape(&self) -> Option<Object> {
        unsafe { KinematicCollision_get_local_shape(self.this) }
    }

    #[inline]
    pub fn get_normal(&self) -> Vector3 {
        unsafe { KinematicCollision_get_normal(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> Vector3 {
        unsafe { KinematicCollision_get_position(self.this) }
    }

    #[inline]
    pub fn get_remainder(&self) -> Vector3 {
        unsafe { KinematicCollision_get_remainder(self.this) }
    }

    #[inline]
    pub fn get_travel(&self) -> Vector3 {
        unsafe { KinematicCollision_get_travel(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class KinematicCollision2D` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_kinematiccollision2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// KinematicCollision2D inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct KinematicCollision2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl KinematicCollision2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = KinematicCollision2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            KinematicCollision2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_collider(&self) -> Option<Object> {
        unsafe { KinematicCollision2D_get_collider(self.this) }
    }

    #[inline]
    pub fn get_collider_id(&self) -> i64 {
        unsafe { KinematicCollision2D_get_collider_id(self.this) }
    }

    #[inline]
    pub fn get_collider_metadata(&self) -> Variant {
        unsafe { KinematicCollision2D_get_collider_metadata(self.this) }
    }

    #[inline]
    pub fn get_collider_shape(&self) -> Option<Object> {
        unsafe { KinematicCollision2D_get_collider_shape(self.this) }
    }

    #[inline]
    pub fn get_collider_shape_index(&self) -> i64 {
        unsafe { KinematicCollision2D_get_collider_shape_index(self.this) }
    }

    #[inline]
    pub fn get_collider_velocity(&self) -> Vector2 {
        unsafe { KinematicCollision2D_get_collider_velocity(self.this) }
    }

    #[inline]
    pub fn get_local_shape(&self) -> Option<Object> {
        unsafe { KinematicCollision2D_get_local_shape(self.this) }
    }

    #[inline]
    pub fn get_normal(&self) -> Vector2 {
        unsafe { KinematicCollision2D_get_normal(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> Vector2 {
        unsafe { KinematicCollision2D_get_position(self.this) }
    }

    #[inline]
    pub fn get_remainder(&self) -> Vector2 {
        unsafe { KinematicCollision2D_get_remainder(self.this) }
    }

    #[inline]
    pub fn get_travel(&self) -> Vector2 {
        unsafe { KinematicCollision2D_get_travel(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Label` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_label.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Label` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Label::free`.
///
/// ## Class hierarchy
///
/// Label inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Label {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LabelAlign {
    Left = 0,
    Center = 1,
    Right = 2,
    Fill = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LabelVAlign {
    Top = 0,
    Center = 1,
    Bottom = 2,
    Fill = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Label {
    pub const ALIGN_FILL: i64 = 3;
    pub const VALIGN_BOTTOM: i64 = 2;
    pub const VALIGN_FILL: i64 = 3;
    pub const ALIGN_LEFT: i64 = 0;
    pub const ALIGN_CENTER: i64 = 1;
    pub const ALIGN_RIGHT: i64 = 2;
    pub const VALIGN_TOP: i64 = 0;
    pub const VALIGN_CENTER: i64 = 1;
}
impl Label {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Label::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LabelMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Label {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_align(&self) -> LabelAlign {
        Label_get_align(self.this)
    }

    #[inline]
    pub unsafe fn get_line_count(&self) -> i64 {
        Label_get_line_count(self.this)
    }

    #[inline]
    pub unsafe fn get_line_height(&self) -> i64 {
        Label_get_line_height(self.this)
    }

    #[inline]
    pub unsafe fn get_lines_skipped(&self) -> i64 {
        Label_get_lines_skipped(self.this)
    }

    #[inline]
    pub unsafe fn get_max_lines_visible(&self) -> i64 {
        Label_get_max_lines_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_percent_visible(&self) -> f64 {
        Label_get_percent_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&self) -> GodotString {
        Label_get_text(self.this)
    }

    #[inline]
    pub unsafe fn get_total_character_count(&self) -> i64 {
        Label_get_total_character_count(self.this)
    }

    #[inline]
    pub unsafe fn get_valign(&self) -> LabelVAlign {
        Label_get_valign(self.this)
    }

    #[inline]
    pub unsafe fn get_visible_characters(&self) -> i64 {
        Label_get_visible_characters(self.this)
    }

    #[inline]
    pub unsafe fn get_visible_line_count(&self) -> i64 {
        Label_get_visible_line_count(self.this)
    }

    #[inline]
    pub unsafe fn has_autowrap(&self) -> bool {
        Label_has_autowrap(self.this)
    }

    #[inline]
    pub unsafe fn is_clipping_text(&self) -> bool {
        Label_is_clipping_text(self.this)
    }

    #[inline]
    pub unsafe fn is_uppercase(&self) -> bool {
        Label_is_uppercase(self.this)
    }

    #[inline]
    pub unsafe fn set_align(&mut self, align: i64) -> () {
        Label_set_align(self.this, align)
    }

    #[inline]
    pub unsafe fn set_autowrap(&mut self, enable: bool) -> () {
        Label_set_autowrap(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_clip_text(&mut self, enable: bool) -> () {
        Label_set_clip_text(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_lines_skipped(&mut self, lines_skipped: i64) -> () {
        Label_set_lines_skipped(self.this, lines_skipped)
    }

    #[inline]
    pub unsafe fn set_max_lines_visible(&mut self, lines_visible: i64) -> () {
        Label_set_max_lines_visible(self.this, lines_visible)
    }

    #[inline]
    pub unsafe fn set_percent_visible(&mut self, percent_visible: f64) -> () {
        Label_set_percent_visible(self.this, percent_visible)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        Label_set_text(self.this, text)
    }

    #[inline]
    pub unsafe fn set_uppercase(&mut self, enable: bool) -> () {
        Label_set_uppercase(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_valign(&mut self, valign: i64) -> () {
        Label_set_valign(self.this, valign)
    }

    #[inline]
    pub unsafe fn set_visible_characters(&mut self, amount: i64) -> () {
        Label_set_visible_characters(self.this, amount)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class LargeTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_largetexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// LargeTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct LargeTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl LargeTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LargeTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            LargeTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> VariantArray {
        unsafe { LargeTexture__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, data: VariantArray) -> () {
        unsafe { LargeTexture__set_data(self.this, data) }
    }

    #[inline]
    pub fn add_piece(&mut self, ofs: Vector2, texture: Option<Texture>) -> i64 {
        unsafe { LargeTexture_add_piece(self.this, ofs, texture) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { LargeTexture_clear(self.this) }
    }

    #[inline]
    pub fn get_piece_count(&self) -> i64 {
        unsafe { LargeTexture_get_piece_count(self.this) }
    }

    #[inline]
    pub fn get_piece_offset(&self, idx: i64) -> Vector2 {
        unsafe { LargeTexture_get_piece_offset(self.this, idx) }
    }

    #[inline]
    pub fn get_piece_texture(&self, idx: i64) -> Option<Texture> {
        unsafe { LargeTexture_get_piece_texture(self.this, idx) }
    }

    #[inline]
    pub fn set_piece_offset(&mut self, idx: i64, ofs: Vector2) -> () {
        unsafe { LargeTexture_set_piece_offset(self.this, idx, ofs) }
    }

    #[inline]
    pub fn set_piece_texture(&mut self, idx: i64, texture: Option<Texture>) -> () {
        unsafe { LargeTexture_set_piece_texture(self.this, idx, texture) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector2) -> () {
        unsafe { LargeTexture_set_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Light` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_light.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Light inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Light {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LightBakeMode {
    Disabled = 0,
    Indirect = 1,
    All = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LightParam {
    Energy = 0,
    IndirectEnergy = 1,
    Specular = 2,
    Range = 3,
    Attenuation = 4,
    SpotAngle = 5,
    SpotAttenuation = 6,
    ContactShadowSize = 7,
    ShadowMaxDistance = 8,
    ShadowSplit1Offset = 9,
    ShadowSplit2Offset = 10,
    ShadowSplit3Offset = 11,
    ShadowNormalBias = 12,
    ShadowBias = 13,
    ShadowBiasSplitScale = 14,
    Max = 15,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Light {
    pub const BAKE_INDIRECT: i64 = 1;
    pub const PARAM_RANGE: i64 = 3;
    pub const PARAM_CONTACT_SHADOW_SIZE: i64 = 7;
    pub const BAKE_ALL: i64 = 2;
    pub const PARAM_SHADOW_BIAS_SPLIT_SCALE: i64 = 14;
    pub const PARAM_SHADOW_MAX_DISTANCE: i64 = 8;
    pub const PARAM_SHADOW_BIAS: i64 = 13;
    pub const PARAM_SHADOW_SPLIT_1_OFFSET: i64 = 9;
    pub const PARAM_SPECULAR: i64 = 2;
    pub const PARAM_ENERGY: i64 = 0;
    pub const PARAM_MAX: i64 = 15;
    pub const PARAM_ATTENUATION: i64 = 4;
    pub const PARAM_INDIRECT_ENERGY: i64 = 1;
    pub const BAKE_DISABLED: i64 = 0;
    pub const PARAM_SHADOW_NORMAL_BIAS: i64 = 12;
    pub const PARAM_SHADOW_SPLIT_2_OFFSET: i64 = 10;
    pub const PARAM_SHADOW_SPLIT_3_OFFSET: i64 = 11;
    pub const PARAM_SPOT_ANGLE: i64 = 5;
    pub const PARAM_SPOT_ATTENUATION: i64 = 6;
}
impl Light {
    #[inline]
    pub unsafe fn get_bake_mode(&self) -> LightBakeMode {
        Light_get_bake_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        Light_get_color(self.this)
    }

    #[inline]
    pub unsafe fn get_cull_mask(&self) -> i64 {
        Light_get_cull_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        Light_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn get_shadow_color(&self) -> Color {
        Light_get_shadow_color(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_reverse_cull_face(&self) -> bool {
        Light_get_shadow_reverse_cull_face(self.this)
    }

    #[inline]
    pub unsafe fn has_shadow(&self) -> bool {
        Light_has_shadow(self.this)
    }

    #[inline]
    pub unsafe fn is_editor_only(&self) -> bool {
        Light_is_editor_only(self.this)
    }

    #[inline]
    pub unsafe fn is_negative(&self) -> bool {
        Light_is_negative(self.this)
    }

    #[inline]
    pub unsafe fn set_bake_mode(&mut self, bake_mode: i64) -> () {
        Light_set_bake_mode(self.this, bake_mode)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        Light_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_cull_mask(&mut self, cull_mask: i64) -> () {
        Light_set_cull_mask(self.this, cull_mask)
    }

    #[inline]
    pub unsafe fn set_editor_only(&mut self, editor_only: bool) -> () {
        Light_set_editor_only(self.this, editor_only)
    }

    #[inline]
    pub unsafe fn set_negative(&mut self, enabled: bool) -> () {
        Light_set_negative(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        Light_set_param(self.this, param, value)
    }

    #[inline]
    pub unsafe fn set_shadow(&mut self, enabled: bool) -> () {
        Light_set_shadow(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_shadow_color(&mut self, shadow_color: Color) -> () {
        Light_set_shadow_color(self.this, shadow_color)
    }

    #[inline]
    pub unsafe fn set_shadow_reverse_cull_face(&mut self, enable: bool) -> () {
        Light_set_shadow_reverse_cull_face(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Light2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_light2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Light2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Light2D::free`.
///
/// ## Class hierarchy
///
/// Light2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Light2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Light2DShadowFilter {
    None = 0,
    Pcf3 = 1,
    Pcf5 = 2,
    Pcf7 = 3,
    Pcf9 = 4,
    Pcf13 = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Light2DMode {
    ModeAdd = 0,
    ModeSub = 1,
    ModeMix = 2,
    ModeMask = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Light2D {
    pub const SHADOW_FILTER_PCF9: i64 = 4;
    pub const SHADOW_FILTER_NONE: i64 = 0;
    pub const SHADOW_FILTER_PCF5: i64 = 2;
    pub const MODE_SUB: i64 = 1;
    pub const MODE_MIX: i64 = 2;
    pub const SHADOW_FILTER_PCF3: i64 = 1;
    pub const SHADOW_FILTER_PCF13: i64 = 5;
    pub const SHADOW_FILTER_PCF7: i64 = 3;
    pub const MODE_MASK: i64 = 3;
    pub const MODE_ADD: i64 = 0;
}
impl Light2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Light2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Light2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Light2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        Light2D_get_color(self.this)
    }

    #[inline]
    pub unsafe fn get_energy(&self) -> f64 {
        Light2D_get_energy(self.this)
    }

    #[inline]
    pub unsafe fn get_height(&self) -> f64 {
        Light2D_get_height(self.this)
    }

    #[inline]
    pub unsafe fn get_item_cull_mask(&self) -> i64 {
        Light2D_get_item_cull_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_item_shadow_cull_mask(&self) -> i64 {
        Light2D_get_item_shadow_cull_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_layer_range_max(&self) -> i64 {
        Light2D_get_layer_range_max(self.this)
    }

    #[inline]
    pub unsafe fn get_layer_range_min(&self) -> i64 {
        Light2D_get_layer_range_min(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> Light2DMode {
        Light2D_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_buffer_size(&self) -> i64 {
        Light2D_get_shadow_buffer_size(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_color(&self) -> Color {
        Light2D_get_shadow_color(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_filter(&self) -> Light2DShadowFilter {
        Light2D_get_shadow_filter(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_gradient_length(&self) -> f64 {
        Light2D_get_shadow_gradient_length(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_smooth(&self) -> f64 {
        Light2D_get_shadow_smooth(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Light2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_offset(&self) -> Vector2 {
        Light2D_get_texture_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_scale(&self) -> f64 {
        Light2D_get_texture_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_z_range_max(&self) -> i64 {
        Light2D_get_z_range_max(self.this)
    }

    #[inline]
    pub unsafe fn get_z_range_min(&self) -> i64 {
        Light2D_get_z_range_min(self.this)
    }

    #[inline]
    pub unsafe fn is_editor_only(&self) -> bool {
        Light2D_is_editor_only(self.this)
    }

    #[inline]
    pub unsafe fn is_enabled(&self) -> bool {
        Light2D_is_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_shadow_enabled(&self) -> bool {
        Light2D_is_shadow_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        Light2D_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_editor_only(&mut self, editor_only: bool) -> () {
        Light2D_set_editor_only(self.this, editor_only)
    }

    #[inline]
    pub unsafe fn set_enabled(&mut self, enabled: bool) -> () {
        Light2D_set_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_energy(&mut self, energy: f64) -> () {
        Light2D_set_energy(self.this, energy)
    }

    #[inline]
    pub unsafe fn set_height(&mut self, height: f64) -> () {
        Light2D_set_height(self.this, height)
    }

    #[inline]
    pub unsafe fn set_item_cull_mask(&mut self, item_cull_mask: i64) -> () {
        Light2D_set_item_cull_mask(self.this, item_cull_mask)
    }

    #[inline]
    pub unsafe fn set_item_shadow_cull_mask(&mut self, item_shadow_cull_mask: i64) -> () {
        Light2D_set_item_shadow_cull_mask(self.this, item_shadow_cull_mask)
    }

    #[inline]
    pub unsafe fn set_layer_range_max(&mut self, layer: i64) -> () {
        Light2D_set_layer_range_max(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_layer_range_min(&mut self, layer: i64) -> () {
        Light2D_set_layer_range_min(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        Light2D_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_shadow_buffer_size(&mut self, size: i64) -> () {
        Light2D_set_shadow_buffer_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_shadow_color(&mut self, shadow_color: Color) -> () {
        Light2D_set_shadow_color(self.this, shadow_color)
    }

    #[inline]
    pub unsafe fn set_shadow_enabled(&mut self, enabled: bool) -> () {
        Light2D_set_shadow_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_shadow_filter(&mut self, filter: i64) -> () {
        Light2D_set_shadow_filter(self.this, filter)
    }

    #[inline]
    pub unsafe fn set_shadow_gradient_length(&mut self, multiplier: f64) -> () {
        Light2D_set_shadow_gradient_length(self.this, multiplier)
    }

    #[inline]
    pub unsafe fn set_shadow_smooth(&mut self, smooth: f64) -> () {
        Light2D_set_shadow_smooth(self.this, smooth)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Light2D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_texture_offset(&mut self, texture_offset: Vector2) -> () {
        Light2D_set_texture_offset(self.this, texture_offset)
    }

    #[inline]
    pub unsafe fn set_texture_scale(&mut self, texture_scale: f64) -> () {
        Light2D_set_texture_scale(self.this, texture_scale)
    }

    #[inline]
    pub unsafe fn set_z_range_max(&mut self, z: i64) -> () {
        Light2D_set_z_range_max(self.this, z)
    }

    #[inline]
    pub unsafe fn set_z_range_min(&mut self, z: i64) -> () {
        Light2D_set_z_range_min(self.this, z)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class LightOccluder2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_lightoccluder2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `LightOccluder2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `LightOccluder2D::free`.
///
/// ## Class hierarchy
///
/// LightOccluder2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct LightOccluder2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl LightOccluder2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `LightOccluder2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LightOccluder2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            LightOccluder2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _poly_changed(&mut self) -> () {
        LightOccluder2D__poly_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_occluder_light_mask(&self) -> i64 {
        LightOccluder2D_get_occluder_light_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_occluder_polygon(&self) -> Option<OccluderPolygon2D> {
        LightOccluder2D_get_occluder_polygon(self.this)
    }

    #[inline]
    pub unsafe fn set_occluder_light_mask(&mut self, mask: i64) -> () {
        LightOccluder2D_set_occluder_light_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_occluder_polygon(&mut self, polygon: Option<OccluderPolygon2D>) -> () {
        LightOccluder2D_set_occluder_polygon(self.this, polygon)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Line2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_line2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Line2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Line2D::free`.
///
/// ## Class hierarchy
///
/// Line2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Line2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Line2DLineTextureMode {
    None = 0,
    Tile = 1,
    Stretch = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Line2DLineCapMode {
    None = 0,
    Box = 1,
    Round = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Line2DLineJointMode {
    Sharp = 0,
    Bevel = 1,
    Round = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Line2D {
    pub const LINE_CAP_NONE: i64 = 0;
    pub const LINE_JOINT_BEVEL: i64 = 1;
    pub const LINE_TEXTURE_NONE: i64 = 0;
    pub const LINE_JOINT_ROUND: i64 = 2;
    pub const LINE_TEXTURE_STRETCH: i64 = 2;
    pub const LINE_JOINT_SHARP: i64 = 0;
    pub const LINE_CAP_ROUND: i64 = 2;
    pub const LINE_TEXTURE_TILE: i64 = 1;
    pub const LINE_CAP_BOX: i64 = 1;
}
impl Line2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Line2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Line2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Line2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _curve_changed(&mut self) -> () {
        Line2D__curve_changed(self.this)
    }

    #[inline]
    pub unsafe fn _gradient_changed(&mut self) -> () {
        Line2D__gradient_changed(self.this)
    }

    #[inline]
    pub unsafe fn add_point(&mut self, position: Vector2, at_position: i64) -> () {
        Line2D_add_point(self.this, position, at_position)
    }

    #[inline]
    pub unsafe fn clear_points(&mut self) -> () {
        Line2D_clear_points(self.this)
    }

    #[inline]
    pub unsafe fn get_antialiased(&self) -> bool {
        Line2D_get_antialiased(self.this)
    }

    #[inline]
    pub unsafe fn get_begin_cap_mode(&self) -> Line2DLineCapMode {
        Line2D_get_begin_cap_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_curve(&self) -> Option<Curve> {
        Line2D_get_curve(self.this)
    }

    #[inline]
    pub unsafe fn get_default_color(&self) -> Color {
        Line2D_get_default_color(self.this)
    }

    #[inline]
    pub unsafe fn get_end_cap_mode(&self) -> Line2DLineCapMode {
        Line2D_get_end_cap_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_gradient(&self) -> Option<Gradient> {
        Line2D_get_gradient(self.this)
    }

    #[inline]
    pub unsafe fn get_joint_mode(&self) -> Line2DLineJointMode {
        Line2D_get_joint_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_point_count(&self) -> i64 {
        Line2D_get_point_count(self.this)
    }

    #[inline]
    pub unsafe fn get_point_position(&self, i: i64) -> Vector2 {
        Line2D_get_point_position(self.this, i)
    }

    #[inline]
    pub unsafe fn get_points(&self) -> Vector2Array {
        Line2D_get_points(self.this)
    }

    #[inline]
    pub unsafe fn get_round_precision(&self) -> i64 {
        Line2D_get_round_precision(self.this)
    }

    #[inline]
    pub unsafe fn get_sharp_limit(&self) -> f64 {
        Line2D_get_sharp_limit(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Line2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_mode(&self) -> Line2DLineTextureMode {
        Line2D_get_texture_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_width(&self) -> f64 {
        Line2D_get_width(self.this)
    }

    #[inline]
    pub unsafe fn remove_point(&mut self, i: i64) -> () {
        Line2D_remove_point(self.this, i)
    }

    #[inline]
    pub unsafe fn set_antialiased(&mut self, antialiased: bool) -> () {
        Line2D_set_antialiased(self.this, antialiased)
    }

    #[inline]
    pub unsafe fn set_begin_cap_mode(&mut self, mode: i64) -> () {
        Line2D_set_begin_cap_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_curve(&mut self, curve: Option<Curve>) -> () {
        Line2D_set_curve(self.this, curve)
    }

    #[inline]
    pub unsafe fn set_default_color(&mut self, color: Color) -> () {
        Line2D_set_default_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_end_cap_mode(&mut self, mode: i64) -> () {
        Line2D_set_end_cap_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_gradient(&mut self, color: Option<Gradient>) -> () {
        Line2D_set_gradient(self.this, color)
    }

    #[inline]
    pub unsafe fn set_joint_mode(&mut self, mode: i64) -> () {
        Line2D_set_joint_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_point_position(&mut self, i: i64, position: Vector2) -> () {
        Line2D_set_point_position(self.this, i, position)
    }

    #[inline]
    pub unsafe fn set_points(&mut self, points: Vector2Array) -> () {
        Line2D_set_points(self.this, points)
    }

    #[inline]
    pub unsafe fn set_round_precision(&mut self, precision: i64) -> () {
        Line2D_set_round_precision(self.this, precision)
    }

    #[inline]
    pub unsafe fn set_sharp_limit(&mut self, limit: f64) -> () {
        Line2D_set_sharp_limit(self.this, limit)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Line2D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_texture_mode(&mut self, mode: i64) -> () {
        Line2D_set_texture_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_width(&mut self, width: f64) -> () {
        Line2D_set_width(self.this, width)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class LineEdit` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_lineedit.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `LineEdit` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `LineEdit::free`.
///
/// ## Class hierarchy
///
/// LineEdit inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct LineEdit {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LineEditAlign {
    Left = 0,
    Center = 1,
    Right = 2,
    Fill = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LineEditMenuItems {
    MenuCut = 0,
    MenuCopy = 1,
    MenuPaste = 2,
    MenuClear = 3,
    MenuSelectAll = 4,
    MenuUndo = 5,
    MenuRedo = 6,
    MenuMax = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl LineEdit {
    pub const MENU_MAX: i64 = 7;
    pub const MENU_UNDO: i64 = 5;
    pub const ALIGN_FILL: i64 = 3;
    pub const ALIGN_LEFT: i64 = 0;
    pub const MENU_REDO: i64 = 6;
    pub const MENU_CUT: i64 = 0;
    pub const MENU_COPY: i64 = 1;
    pub const ALIGN_CENTER: i64 = 1;
    pub const MENU_SELECT_ALL: i64 = 4;
    pub const MENU_PASTE: i64 = 2;
    pub const ALIGN_RIGHT: i64 = 2;
    pub const MENU_CLEAR: i64 = 3;
}
impl LineEdit {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `LineEdit::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LineEditMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            LineEdit {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _editor_settings_changed(&mut self) -> () {
        LineEdit__editor_settings_changed(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        LineEdit__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _text_changed(&mut self) -> () {
        LineEdit__text_changed(self.this)
    }

    #[inline]
    pub unsafe fn _toggle_draw_caret(&mut self) -> () {
        LineEdit__toggle_draw_caret(self.this)
    }

    #[inline]
    pub unsafe fn append_at_cursor(&mut self, text: GodotString) -> () {
        LineEdit_append_at_cursor(self.this, text)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        LineEdit_clear(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_blink_enabled(&self) -> bool {
        LineEdit_cursor_get_blink_enabled(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_blink_speed(&self) -> f64 {
        LineEdit_cursor_get_blink_speed(self.this)
    }

    #[inline]
    pub unsafe fn cursor_set_blink_enabled(&mut self, enabled: bool) -> () {
        LineEdit_cursor_set_blink_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn cursor_set_blink_speed(&mut self, blink_speed: f64) -> () {
        LineEdit_cursor_set_blink_speed(self.this, blink_speed)
    }

    #[inline]
    pub unsafe fn deselect(&mut self) -> () {
        LineEdit_deselect(self.this)
    }

    #[inline]
    pub unsafe fn get_align(&self) -> LineEditAlign {
        LineEdit_get_align(self.this)
    }

    #[inline]
    pub unsafe fn get_cursor_position(&self) -> i64 {
        LineEdit_get_cursor_position(self.this)
    }

    #[inline]
    pub unsafe fn get_expand_to_text_length(&self) -> bool {
        LineEdit_get_expand_to_text_length(self.this)
    }

    #[inline]
    pub unsafe fn get_max_length(&self) -> i64 {
        LineEdit_get_max_length(self.this)
    }

    #[inline]
    pub unsafe fn get_menu(&self) -> Option<PopupMenu> {
        LineEdit_get_menu(self.this)
    }

    #[inline]
    pub unsafe fn get_placeholder(&self) -> GodotString {
        LineEdit_get_placeholder(self.this)
    }

    #[inline]
    pub unsafe fn get_placeholder_alpha(&self) -> f64 {
        LineEdit_get_placeholder_alpha(self.this)
    }

    #[inline]
    pub unsafe fn get_right_icon(&mut self) -> Option<Texture> {
        LineEdit_get_right_icon(self.this)
    }

    #[inline]
    pub unsafe fn get_secret_character(&self) -> GodotString {
        LineEdit_get_secret_character(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&self) -> GodotString {
        LineEdit_get_text(self.this)
    }

    #[inline]
    pub unsafe fn is_clear_button_enabled(&self) -> bool {
        LineEdit_is_clear_button_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_context_menu_enabled(&mut self) -> bool {
        LineEdit_is_context_menu_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_editable(&self) -> bool {
        LineEdit_is_editable(self.this)
    }

    #[inline]
    pub unsafe fn is_secret(&self) -> bool {
        LineEdit_is_secret(self.this)
    }

    #[inline]
    pub unsafe fn is_selecting_enabled(&self) -> bool {
        LineEdit_is_selecting_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_shortcut_keys_enabled(&self) -> bool {
        LineEdit_is_shortcut_keys_enabled(self.this)
    }

    #[inline]
    pub unsafe fn menu_option(&mut self, option: i64) -> () {
        LineEdit_menu_option(self.this, option)
    }

    #[inline]
    pub unsafe fn select(&mut self, from: i64, to: i64) -> () {
        LineEdit_select(self.this, from, to)
    }

    #[inline]
    pub unsafe fn select_all(&mut self) -> () {
        LineEdit_select_all(self.this)
    }

    #[inline]
    pub unsafe fn set_align(&mut self, align: i64) -> () {
        LineEdit_set_align(self.this, align)
    }

    #[inline]
    pub unsafe fn set_clear_button_enabled(&mut self, enable: bool) -> () {
        LineEdit_set_clear_button_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_context_menu_enabled(&mut self, enable: bool) -> () {
        LineEdit_set_context_menu_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_cursor_position(&mut self, position: i64) -> () {
        LineEdit_set_cursor_position(self.this, position)
    }

    #[inline]
    pub unsafe fn set_editable(&mut self, enabled: bool) -> () {
        LineEdit_set_editable(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_expand_to_text_length(&mut self, enabled: bool) -> () {
        LineEdit_set_expand_to_text_length(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_max_length(&mut self, chars: i64) -> () {
        LineEdit_set_max_length(self.this, chars)
    }

    #[inline]
    pub unsafe fn set_placeholder(&mut self, text: GodotString) -> () {
        LineEdit_set_placeholder(self.this, text)
    }

    #[inline]
    pub unsafe fn set_placeholder_alpha(&mut self, alpha: f64) -> () {
        LineEdit_set_placeholder_alpha(self.this, alpha)
    }

    #[inline]
    pub unsafe fn set_right_icon(&mut self, icon: Option<Texture>) -> () {
        LineEdit_set_right_icon(self.this, icon)
    }

    #[inline]
    pub unsafe fn set_secret(&mut self, enabled: bool) -> () {
        LineEdit_set_secret(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_secret_character(&mut self, character: GodotString) -> () {
        LineEdit_set_secret_character(self.this, character)
    }

    #[inline]
    pub unsafe fn set_selecting_enabled(&mut self, enable: bool) -> () {
        LineEdit_set_selecting_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_shortcut_keys_enabled(&mut self, enable: bool) -> () {
        LineEdit_set_shortcut_keys_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        LineEdit_set_text(self.this, text)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class LineShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_lineshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// LineShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct LineShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl LineShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LineShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            LineShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_d(&self) -> f64 {
        unsafe { LineShape2D_get_d(self.this) }
    }

    #[inline]
    pub fn get_normal(&self) -> Vector2 {
        unsafe { LineShape2D_get_normal(self.this) }
    }

    #[inline]
    pub fn set_d(&mut self, d: f64) -> () {
        unsafe { LineShape2D_set_d(self.this, d) }
    }

    #[inline]
    pub fn set_normal(&mut self, normal: Vector2) -> () {
        unsafe { LineShape2D_set_normal(self.this, normal) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class LinkButton` inherits `BaseButton` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_linkbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `LinkButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `LinkButton::free`.
///
/// ## Class hierarchy
///
/// LinkButton inherits methods from:
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct LinkButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum LinkButtonUnderlineMode {
    ModeAlways = 0,
    ModeOnHover = 1,
    ModeNever = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl LinkButton {
    pub const UNDERLINE_MODE_ON_HOVER: i64 = 1;
    pub const UNDERLINE_MODE_ALWAYS: i64 = 0;
    pub const UNDERLINE_MODE_NEVER: i64 = 2;
}
impl LinkButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `LinkButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = LinkButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            LinkButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_text(&self) -> GodotString {
        LinkButton_get_text(self.this)
    }

    #[inline]
    pub unsafe fn get_underline_mode(&self) -> LinkButtonUnderlineMode {
        LinkButton_get_underline_mode(self.this)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        LinkButton_set_text(self.this, text)
    }

    #[inline]
    pub unsafe fn set_underline_mode(&mut self, underline_mode: i64) -> () {
        LinkButton_set_underline_mode(self.this, underline_mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Listener` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_listener.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Listener` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Listener::free`.
///
/// ## Class hierarchy
///
/// Listener inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Listener {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Listener {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Listener::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ListenerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Listener {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn clear_current(&mut self) -> () {
        Listener_clear_current(self.this)
    }

    #[inline]
    pub unsafe fn get_listener_transform(&self) -> Transform {
        Listener_get_listener_transform(self.this)
    }

    #[inline]
    pub unsafe fn is_current(&self) -> bool {
        Listener_is_current(self.this)
    }

    #[inline]
    pub unsafe fn make_current(&mut self) -> () {
        Listener_make_current(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MainLoop` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_mainloop.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MainLoop` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MainLoop::free`.
///
/// ## Class hierarchy
///
/// MainLoop inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MainLoop {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl MainLoop {
    pub const NOTIFICATION_TRANSLATION_CHANGED: i64 = 1010;
    pub const NOTIFICATION_WM_UNFOCUS_REQUEST: i64 = 1008;
    pub const NOTIFICATION_WM_MOUSE_ENTER: i64 = 1002;
    pub const NOTIFICATION_WM_FOCUS_OUT: i64 = 1005;
    pub const NOTIFICATION_WM_MOUSE_EXIT: i64 = 1003;
    pub const NOTIFICATION_OS_MEMORY_WARNING: i64 = 1009;
    pub const NOTIFICATION_OS_IME_UPDATE: i64 = 1013;
    pub const NOTIFICATION_WM_ABOUT: i64 = 1011;
    pub const NOTIFICATION_APP_PAUSED: i64 = 1015;
    pub const NOTIFICATION_WM_QUIT_REQUEST: i64 = 1006;
    pub const NOTIFICATION_WM_FOCUS_IN: i64 = 1004;
    pub const NOTIFICATION_CRASH: i64 = 1012;
    pub const NOTIFICATION_WM_GO_BACK_REQUEST: i64 = 1007;
    pub const NOTIFICATION_APP_RESUMED: i64 = 1014;
}
impl MainLoop {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MainLoop::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MainLoopMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MainLoop {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _drop_files(&mut self, files: StringArray, from_screen: i64) -> () {
        MainLoop__drop_files(self.this, files, from_screen)
    }

    #[inline]
    pub unsafe fn _finalize(&mut self) -> () {
        MainLoop__finalize(self.this)
    }

    #[inline]
    pub unsafe fn _global_menu_action(&mut self, id: Variant, meta: Variant) -> () {
        MainLoop__global_menu_action(self.this, id, meta)
    }

    #[inline]
    pub unsafe fn _idle(&mut self, delta: f64) -> bool {
        MainLoop__idle(self.this, delta)
    }

    #[inline]
    pub unsafe fn _initialize(&mut self) -> () {
        MainLoop__initialize(self.this)
    }

    #[inline]
    pub unsafe fn _input_event(&mut self, event: Option<InputEvent>) -> () {
        MainLoop__input_event(self.this, event)
    }

    #[inline]
    pub unsafe fn _input_text(&mut self, text: GodotString) -> () {
        MainLoop__input_text(self.this, text)
    }

    #[inline]
    pub unsafe fn _iteration(&mut self, delta: f64) -> bool {
        MainLoop__iteration(self.this, delta)
    }

    #[inline]
    pub unsafe fn finish(&mut self) -> () {
        MainLoop_finish(self.this)
    }

    #[inline]
    pub unsafe fn idle(&mut self, delta: f64) -> bool {
        MainLoop_idle(self.this, delta)
    }

    #[inline]
    pub unsafe fn init(&mut self) -> () {
        MainLoop_init(self.this)
    }

    #[inline]
    pub unsafe fn input_event(&mut self, event: Option<InputEvent>) -> () {
        MainLoop_input_event(self.this, event)
    }

    #[inline]
    pub unsafe fn input_text(&mut self, text: GodotString) -> () {
        MainLoop_input_text(self.this, text)
    }

    #[inline]
    pub unsafe fn iteration(&mut self, delta: f64) -> bool {
        MainLoop_iteration(self.this, delta)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MarginContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_margincontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MarginContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MarginContainer::free`.
///
/// ## Class hierarchy
///
/// MarginContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MarginContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MarginContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MarginContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MarginContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MarginContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Material` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_material.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Material inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Material {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl Material {
    pub const RENDER_PRIORITY_MAX: i64 = 127;
    pub const RENDER_PRIORITY_MIN: i64 = -128;
}
impl Material {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_next_pass(&self) -> Option<Material> {
        unsafe { Material_get_next_pass(self.this) }
    }

    #[inline]
    pub fn get_render_priority(&self) -> i64 {
        unsafe { Material_get_render_priority(self.this) }
    }

    #[inline]
    pub fn set_next_pass(&mut self, next_pass: Option<Material>) -> () {
        unsafe { Material_set_next_pass(self.this, next_pass) }
    }

    #[inline]
    pub fn set_render_priority(&mut self, priority: i64) -> () {
        unsafe { Material_set_render_priority(self.this, priority) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MenuButton` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_menubutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MenuButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MenuButton::free`.
///
/// ## Class hierarchy
///
/// MenuButton inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MenuButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MenuButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MenuButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MenuButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MenuButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_items(&self) -> VariantArray {
        MenuButton__get_items(self.this)
    }

    #[inline]
    pub unsafe fn _set_items(&mut self, arg0: VariantArray) -> () {
        MenuButton__set_items(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _unhandled_key_input(&mut self, arg0: Option<InputEvent>) -> () {
        MenuButton__unhandled_key_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_popup(&self) -> Option<PopupMenu> {
        MenuButton_get_popup(self.this)
    }

    #[inline]
    pub unsafe fn is_switch_on_hover(&mut self) -> bool {
        MenuButton_is_switch_on_hover(self.this)
    }

    #[inline]
    pub unsafe fn set_disable_shortcuts(&mut self, disabled: bool) -> () {
        MenuButton_set_disable_shortcuts(self.this, disabled)
    }

    #[inline]
    pub unsafe fn set_switch_on_hover(&mut self, enable: bool) -> () {
        MenuButton_set_switch_on_hover(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Mesh` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_mesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Mesh inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Mesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MeshBlendShapeMode {
    ModeNormalized = 0,
    ModeRelative = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MeshPrimitiveType {
    PrimitivePoints = 0,
    PrimitiveLines = 1,
    PrimitiveLineStrip = 2,
    PrimitiveLineLoop = 3,
    PrimitiveTriangles = 4,
    PrimitiveTriangleStrip = 5,
    PrimitiveTriangleFan = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MeshArrayFormat {
    Vertex = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    ArrayCompressBase = 9,
    TexUv = 16,
    TexUv2 = 32,
    Bones = 64,
    Weights = 128,
    Index = 256,
    ArrayCompressVertex = 512,
    ArrayCompressNormal = 1024,
    ArrayCompressTangent = 2048,
    ArrayCompressColor = 4096,
    ArrayCompressTexUv = 8192,
    ArrayCompressTexUv2 = 16384,
    ArrayCompressBones = 32768,
    ArrayCompressWeights = 65536,
    ArrayCompressDefault = 97280,
    ArrayCompressIndex = 131072,
    ArrayFlagUse2dVertices = 262144,
    ArrayFlagUse16BitBones = 524288,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MeshArrayType {
    ArrayVertex = 0,
    ArrayNormal = 1,
    ArrayTangent = 2,
    ArrayColor = 3,
    ArrayTexUv = 4,
    ArrayTexUv2 = 5,
    ArrayBones = 6,
    ArrayWeights = 7,
    ArrayIndex = 8,
    ArrayMax = 9,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Mesh {
    pub const ARRAY_COMPRESS_VERTEX: i64 = 512;
    pub const ARRAY_FORMAT_TANGENT: i64 = 4;
    pub const ARRAY_COMPRESS_BONES: i64 = 32768;
    pub const ARRAY_MAX: i64 = 9;
    pub const ARRAY_TANGENT: i64 = 2;
    pub const ARRAY_VERTEX: i64 = 0;
    pub const ARRAY_FORMAT_INDEX: i64 = 256;
    pub const ARRAY_FORMAT_TEX_UV: i64 = 16;
    pub const PRIMITIVE_TRIANGLE_FAN: i64 = 6;
    pub const ARRAY_COMPRESS_TANGENT: i64 = 2048;
    pub const ARRAY_COMPRESS_WEIGHTS: i64 = 65536;
    pub const ARRAY_FORMAT_WEIGHTS: i64 = 128;
    pub const PRIMITIVE_LINE_LOOP: i64 = 3;
    pub const PRIMITIVE_POINTS: i64 = 0;
    pub const ARRAY_FORMAT_TEX_UV2: i64 = 32;
    pub const ARRAY_TEX_UV: i64 = 4;
    pub const ARRAY_FLAG_USE_16_BIT_BONES: i64 = 524288;
    pub const PRIMITIVE_TRIANGLE_STRIP: i64 = 5;
    pub const ARRAY_WEIGHTS: i64 = 7;
    pub const ARRAY_COMPRESS_DEFAULT: i64 = 97280;
    pub const ARRAY_FORMAT_VERTEX: i64 = 1;
    pub const ARRAY_COMPRESS_TEX_UV2: i64 = 16384;
    pub const ARRAY_NORMAL: i64 = 1;
    pub const ARRAY_COMPRESS_INDEX: i64 = 131072;
    pub const ARRAY_FLAG_USE_2D_VERTICES: i64 = 262144;
    pub const PRIMITIVE_LINES: i64 = 1;
    pub const PRIMITIVE_LINE_STRIP: i64 = 2;
    pub const ARRAY_TEX_UV2: i64 = 5;
    pub const ARRAY_COMPRESS_TEX_UV: i64 = 8192;
    pub const ARRAY_COMPRESS_COLOR: i64 = 4096;
    pub const ARRAY_COLOR: i64 = 3;
    pub const ARRAY_COMPRESS_NORMAL: i64 = 1024;
    pub const ARRAY_FORMAT_NORMAL: i64 = 2;
    pub const ARRAY_INDEX: i64 = 8;
    pub const ARRAY_FORMAT_BONES: i64 = 64;
    pub const BLEND_SHAPE_MODE_NORMALIZED: i64 = 0;
    pub const ARRAY_BONES: i64 = 6;
    pub const BLEND_SHAPE_MODE_RELATIVE: i64 = 1;
    pub const ARRAY_FORMAT_COLOR: i64 = 8;
    pub const ARRAY_COMPRESS_BASE: i64 = 9;
    pub const PRIMITIVE_TRIANGLES: i64 = 4;
}
impl Mesh {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn create_convex_shape(&self) -> Option<Shape> {
        unsafe { Mesh_create_convex_shape(self.this) }
    }

    #[inline]
    pub fn create_outline(&self, margin: f64) -> Option<Mesh> {
        unsafe { Mesh_create_outline(self.this, margin) }
    }

    #[inline]
    pub fn create_trimesh_shape(&self) -> Option<Shape> {
        unsafe { Mesh_create_trimesh_shape(self.this) }
    }

    #[inline]
    pub fn generate_triangle_mesh(&self) -> Option<TriangleMesh> {
        unsafe { Mesh_generate_triangle_mesh(self.this) }
    }

    #[inline]
    pub fn get_aabb(&self) -> Aabb {
        unsafe { Mesh_get_aabb(self.this) }
    }

    #[inline]
    pub fn get_faces(&self) -> Vector3Array {
        unsafe { Mesh_get_faces(self.this) }
    }

    #[inline]
    pub fn get_lightmap_size_hint(&self) -> Vector2 {
        unsafe { Mesh_get_lightmap_size_hint(self.this) }
    }

    #[inline]
    pub fn get_surface_count(&self) -> i64 {
        unsafe { Mesh_get_surface_count(self.this) }
    }

    #[inline]
    pub fn set_lightmap_size_hint(&mut self, size: Vector2) -> () {
        unsafe { Mesh_set_lightmap_size_hint(self.this, size) }
    }

    #[inline]
    pub fn surface_get_arrays(&self, surf_idx: i64) -> VariantArray {
        unsafe { Mesh_surface_get_arrays(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_blend_shape_arrays(&self, surf_idx: i64) -> VariantArray {
        unsafe { Mesh_surface_get_blend_shape_arrays(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_get_material(&self, surf_idx: i64) -> Option<Material> {
        unsafe { Mesh_surface_get_material(self.this, surf_idx) }
    }

    #[inline]
    pub fn surface_set_material(&mut self, surf_idx: i64, material: Option<Material>) -> () {
        unsafe { Mesh_surface_set_material(self.this, surf_idx, material) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MeshDataTool` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_meshdatatool.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MeshDataTool inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MeshDataTool {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MeshDataTool {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MeshDataToolMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MeshDataTool {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { MeshDataTool_clear(self.this) }
    }

    #[inline]
    pub fn commit_to_surface(&mut self, mesh: Option<ArrayMesh>) -> GodotResult {
        unsafe { MeshDataTool_commit_to_surface(self.this, mesh) }
    }

    #[inline]
    pub fn create_from_surface(&mut self, mesh: Option<ArrayMesh>, surface: i64) -> GodotResult {
        unsafe { MeshDataTool_create_from_surface(self.this, mesh, surface) }
    }

    #[inline]
    pub fn get_edge_count(&self) -> i64 {
        unsafe { MeshDataTool_get_edge_count(self.this) }
    }

    #[inline]
    pub fn get_edge_faces(&self, idx: i64) -> Int32Array {
        unsafe { MeshDataTool_get_edge_faces(self.this, idx) }
    }

    #[inline]
    pub fn get_edge_meta(&self, idx: i64) -> Variant {
        unsafe { MeshDataTool_get_edge_meta(self.this, idx) }
    }

    #[inline]
    pub fn get_edge_vertex(&self, idx: i64, vertex: i64) -> i64 {
        unsafe { MeshDataTool_get_edge_vertex(self.this, idx, vertex) }
    }

    #[inline]
    pub fn get_face_count(&self) -> i64 {
        unsafe { MeshDataTool_get_face_count(self.this) }
    }

    #[inline]
    pub fn get_face_edge(&self, idx: i64, edge: i64) -> i64 {
        unsafe { MeshDataTool_get_face_edge(self.this, idx, edge) }
    }

    #[inline]
    pub fn get_face_meta(&self, idx: i64) -> Variant {
        unsafe { MeshDataTool_get_face_meta(self.this, idx) }
    }

    #[inline]
    pub fn get_face_normal(&self, idx: i64) -> Vector3 {
        unsafe { MeshDataTool_get_face_normal(self.this, idx) }
    }

    #[inline]
    pub fn get_face_vertex(&self, idx: i64, vertex: i64) -> i64 {
        unsafe { MeshDataTool_get_face_vertex(self.this, idx, vertex) }
    }

    #[inline]
    pub fn get_format(&self) -> i64 {
        unsafe { MeshDataTool_get_format(self.this) }
    }

    #[inline]
    pub fn get_material(&self) -> Option<Material> {
        unsafe { MeshDataTool_get_material(self.this) }
    }

    #[inline]
    pub fn get_vertex(&self, idx: i64) -> Vector3 {
        unsafe { MeshDataTool_get_vertex(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_bones(&self, idx: i64) -> Int32Array {
        unsafe { MeshDataTool_get_vertex_bones(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_color(&self, idx: i64) -> Color {
        unsafe { MeshDataTool_get_vertex_color(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_count(&self) -> i64 {
        unsafe { MeshDataTool_get_vertex_count(self.this) }
    }

    #[inline]
    pub fn get_vertex_edges(&self, idx: i64) -> Int32Array {
        unsafe { MeshDataTool_get_vertex_edges(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_faces(&self, idx: i64) -> Int32Array {
        unsafe { MeshDataTool_get_vertex_faces(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_meta(&self, idx: i64) -> Variant {
        unsafe { MeshDataTool_get_vertex_meta(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_normal(&self, idx: i64) -> Vector3 {
        unsafe { MeshDataTool_get_vertex_normal(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_tangent(&self, idx: i64) -> Plane {
        unsafe { MeshDataTool_get_vertex_tangent(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_uv(&self, idx: i64) -> Vector2 {
        unsafe { MeshDataTool_get_vertex_uv(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_uv2(&self, idx: i64) -> Vector2 {
        unsafe { MeshDataTool_get_vertex_uv2(self.this, idx) }
    }

    #[inline]
    pub fn get_vertex_weights(&self, idx: i64) -> Float32Array {
        unsafe { MeshDataTool_get_vertex_weights(self.this, idx) }
    }

    #[inline]
    pub fn set_edge_meta(&mut self, idx: i64, meta: Variant) -> () {
        unsafe { MeshDataTool_set_edge_meta(self.this, idx, meta) }
    }

    #[inline]
    pub fn set_face_meta(&mut self, idx: i64, meta: Variant) -> () {
        unsafe { MeshDataTool_set_face_meta(self.this, idx, meta) }
    }

    #[inline]
    pub fn set_material(&mut self, material: Option<Material>) -> () {
        unsafe { MeshDataTool_set_material(self.this, material) }
    }

    #[inline]
    pub fn set_vertex(&mut self, idx: i64, vertex: Vector3) -> () {
        unsafe { MeshDataTool_set_vertex(self.this, idx, vertex) }
    }

    #[inline]
    pub fn set_vertex_bones(&mut self, idx: i64, bones: Int32Array) -> () {
        unsafe { MeshDataTool_set_vertex_bones(self.this, idx, bones) }
    }

    #[inline]
    pub fn set_vertex_color(&mut self, idx: i64, color: Color) -> () {
        unsafe { MeshDataTool_set_vertex_color(self.this, idx, color) }
    }

    #[inline]
    pub fn set_vertex_meta(&mut self, idx: i64, meta: Variant) -> () {
        unsafe { MeshDataTool_set_vertex_meta(self.this, idx, meta) }
    }

    #[inline]
    pub fn set_vertex_normal(&mut self, idx: i64, normal: Vector3) -> () {
        unsafe { MeshDataTool_set_vertex_normal(self.this, idx, normal) }
    }

    #[inline]
    pub fn set_vertex_tangent(&mut self, idx: i64, tangent: Plane) -> () {
        unsafe { MeshDataTool_set_vertex_tangent(self.this, idx, tangent) }
    }

    #[inline]
    pub fn set_vertex_uv(&mut self, idx: i64, uv: Vector2) -> () {
        unsafe { MeshDataTool_set_vertex_uv(self.this, idx, uv) }
    }

    #[inline]
    pub fn set_vertex_uv2(&mut self, idx: i64, uv2: Vector2) -> () {
        unsafe { MeshDataTool_set_vertex_uv2(self.this, idx, uv2) }
    }

    #[inline]
    pub fn set_vertex_weights(&mut self, idx: i64, weights: Float32Array) -> () {
        unsafe { MeshDataTool_set_vertex_weights(self.this, idx, weights) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MeshInstance` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_meshinstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MeshInstance` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MeshInstance::free`.
///
/// ## Class hierarchy
///
/// MeshInstance inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MeshInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MeshInstance {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MeshInstance::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MeshInstanceMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MeshInstance {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _mesh_changed(&mut self) -> () {
        MeshInstance__mesh_changed(self.this)
    }

    #[inline]
    pub unsafe fn create_convex_collision(&mut self) -> () {
        MeshInstance_create_convex_collision(self.this)
    }

    #[inline]
    pub unsafe fn create_debug_tangents(&mut self) -> () {
        MeshInstance_create_debug_tangents(self.this)
    }

    #[inline]
    pub unsafe fn create_trimesh_collision(&mut self) -> () {
        MeshInstance_create_trimesh_collision(self.this)
    }

    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        MeshInstance_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_skeleton_path(&mut self) -> NodePath {
        MeshInstance_get_skeleton_path(self.this)
    }

    #[inline]
    pub unsafe fn get_skin(&self) -> Option<Skin> {
        MeshInstance_get_skin(self.this)
    }

    #[inline]
    pub unsafe fn get_surface_material(&self, surface: i64) -> Option<Material> {
        MeshInstance_get_surface_material(self.this, surface)
    }

    #[inline]
    pub unsafe fn get_surface_material_count(&self) -> i64 {
        MeshInstance_get_surface_material_count(self.this)
    }

    #[inline]
    pub unsafe fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        MeshInstance_set_mesh(self.this, mesh)
    }

    #[inline]
    pub unsafe fn set_skeleton_path(&mut self, skeleton_path: NodePath) -> () {
        MeshInstance_set_skeleton_path(self.this, skeleton_path)
    }

    #[inline]
    pub unsafe fn set_skin(&mut self, skin: Option<Skin>) -> () {
        MeshInstance_set_skin(self.this, skin)
    }

    #[inline]
    pub unsafe fn set_surface_material(&mut self, surface: i64, material: Option<Material>) -> () {
        MeshInstance_set_surface_material(self.this, surface, material)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MeshInstance2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_meshinstance2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MeshInstance2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MeshInstance2D::free`.
///
/// ## Class hierarchy
///
/// MeshInstance2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MeshInstance2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MeshInstance2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MeshInstance2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MeshInstance2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MeshInstance2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_mesh(&self) -> Option<Mesh> {
        MeshInstance2D_get_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_map(&self) -> Option<Texture> {
        MeshInstance2D_get_normal_map(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        MeshInstance2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        MeshInstance2D_set_mesh(self.this, mesh)
    }

    #[inline]
    pub unsafe fn set_normal_map(&mut self, normal_map: Option<Texture>) -> () {
        MeshInstance2D_set_normal_map(self.this, normal_map)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        MeshInstance2D_set_texture(self.this, texture)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MeshLibrary` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_meshlibrary.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MeshLibrary inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MeshLibrary {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MeshLibrary {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MeshLibraryMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MeshLibrary {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { MeshLibrary_clear(self.this) }
    }

    #[inline]
    pub fn create_item(&mut self, id: i64) -> () {
        unsafe { MeshLibrary_create_item(self.this, id) }
    }

    #[inline]
    pub fn find_item_by_name(&self, name: GodotString) -> i64 {
        unsafe { MeshLibrary_find_item_by_name(self.this, name) }
    }

    #[inline]
    pub fn get_item_list(&self) -> Int32Array {
        unsafe { MeshLibrary_get_item_list(self.this) }
    }

    #[inline]
    pub fn get_item_mesh(&self, id: i64) -> Option<Mesh> {
        unsafe { MeshLibrary_get_item_mesh(self.this, id) }
    }

    #[inline]
    pub fn get_item_name(&self, id: i64) -> GodotString {
        unsafe { MeshLibrary_get_item_name(self.this, id) }
    }

    #[inline]
    pub fn get_item_navmesh(&self, id: i64) -> Option<NavigationMesh> {
        unsafe { MeshLibrary_get_item_navmesh(self.this, id) }
    }

    #[inline]
    pub fn get_item_navmesh_transform(&self, id: i64) -> Transform {
        unsafe { MeshLibrary_get_item_navmesh_transform(self.this, id) }
    }

    #[inline]
    pub fn get_item_preview(&self, id: i64) -> Option<Texture> {
        unsafe { MeshLibrary_get_item_preview(self.this, id) }
    }

    #[inline]
    pub fn get_item_shapes(&self, id: i64) -> VariantArray {
        unsafe { MeshLibrary_get_item_shapes(self.this, id) }
    }

    #[inline]
    pub fn get_last_unused_item_id(&self) -> i64 {
        unsafe { MeshLibrary_get_last_unused_item_id(self.this) }
    }

    #[inline]
    pub fn remove_item(&mut self, id: i64) -> () {
        unsafe { MeshLibrary_remove_item(self.this, id) }
    }

    #[inline]
    pub fn set_item_mesh(&mut self, id: i64, mesh: Option<Mesh>) -> () {
        unsafe { MeshLibrary_set_item_mesh(self.this, id, mesh) }
    }

    #[inline]
    pub fn set_item_name(&mut self, id: i64, name: GodotString) -> () {
        unsafe { MeshLibrary_set_item_name(self.this, id, name) }
    }

    #[inline]
    pub fn set_item_navmesh(&mut self, id: i64, navmesh: Option<NavigationMesh>) -> () {
        unsafe { MeshLibrary_set_item_navmesh(self.this, id, navmesh) }
    }

    #[inline]
    pub fn set_item_navmesh_transform(&mut self, id: i64, navmesh: Transform) -> () {
        unsafe { MeshLibrary_set_item_navmesh_transform(self.this, id, navmesh) }
    }

    #[inline]
    pub fn set_item_preview(&mut self, id: i64, texture: Option<Texture>) -> () {
        unsafe { MeshLibrary_set_item_preview(self.this, id, texture) }
    }

    #[inline]
    pub fn set_item_shapes(&mut self, id: i64, shapes: VariantArray) -> () {
        unsafe { MeshLibrary_set_item_shapes(self.this, id, shapes) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MeshTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_meshtexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MeshTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MeshTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MeshTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MeshTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MeshTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_base_texture(&self) -> Option<Texture> {
        unsafe { MeshTexture_get_base_texture(self.this) }
    }

    #[inline]
    pub fn get_image_size(&self) -> Vector2 {
        unsafe { MeshTexture_get_image_size(self.this) }
    }

    #[inline]
    pub fn get_mesh(&self) -> Option<Mesh> {
        unsafe { MeshTexture_get_mesh(self.this) }
    }

    #[inline]
    pub fn set_base_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { MeshTexture_set_base_texture(self.this, texture) }
    }

    #[inline]
    pub fn set_image_size(&mut self, size: Vector2) -> () {
        unsafe { MeshTexture_set_image_size(self.this, size) }
    }

    #[inline]
    pub fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        unsafe { MeshTexture_set_mesh(self.this, mesh) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MobileVRInterface` inherits `ARVRInterface` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_mobilevrinterface.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MobileVRInterface inherits methods from:
/// - [ARVRInterface](struct.ARVRInterface.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MobileVRInterface {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MobileVRInterface {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MobileVRInterfaceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MobileVRInterface {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_display_to_lens(&self) -> f64 {
        unsafe { MobileVRInterface_get_display_to_lens(self.this) }
    }

    #[inline]
    pub fn get_display_width(&self) -> f64 {
        unsafe { MobileVRInterface_get_display_width(self.this) }
    }

    #[inline]
    pub fn get_eye_height(&self) -> f64 {
        unsafe { MobileVRInterface_get_eye_height(self.this) }
    }

    #[inline]
    pub fn get_iod(&self) -> f64 {
        unsafe { MobileVRInterface_get_iod(self.this) }
    }

    #[inline]
    pub fn get_k1(&self) -> f64 {
        unsafe { MobileVRInterface_get_k1(self.this) }
    }

    #[inline]
    pub fn get_k2(&self) -> f64 {
        unsafe { MobileVRInterface_get_k2(self.this) }
    }

    #[inline]
    pub fn get_oversample(&self) -> f64 {
        unsafe { MobileVRInterface_get_oversample(self.this) }
    }

    #[inline]
    pub fn set_display_to_lens(&mut self, display_to_lens: f64) -> () {
        unsafe { MobileVRInterface_set_display_to_lens(self.this, display_to_lens) }
    }

    #[inline]
    pub fn set_display_width(&mut self, display_width: f64) -> () {
        unsafe { MobileVRInterface_set_display_width(self.this, display_width) }
    }

    #[inline]
    pub fn set_eye_height(&mut self, eye_height: f64) -> () {
        unsafe { MobileVRInterface_set_eye_height(self.this, eye_height) }
    }

    #[inline]
    pub fn set_iod(&mut self, iod: f64) -> () {
        unsafe { MobileVRInterface_set_iod(self.this, iod) }
    }

    #[inline]
    pub fn set_k1(&mut self, k: f64) -> () {
        unsafe { MobileVRInterface_set_k1(self.this, k) }
    }

    #[inline]
    pub fn set_k2(&mut self, k: f64) -> () {
        unsafe { MobileVRInterface_set_k2(self.this, k) }
    }

    #[inline]
    pub fn set_oversample(&mut self, oversample: f64) -> () {
        unsafe { MobileVRInterface_set_oversample(self.this, oversample) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_arvr_interface(&self) -> ARVRInterface {
        unsafe {{ object::add_ref(self.this); }}
        ARVRInterface { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MultiMesh` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_multimesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MultiMesh inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MultiMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MultiMeshTransformFormat {
    Transform2d = 0,
    Transform3d = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MultiMeshCustomDataFormat {
    CustomDataNone = 0,
    CustomData8bit = 1,
    CustomDataFloat = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MultiMeshColorFormat {
    ColorNone = 0,
    Color8bit = 1,
    ColorFloat = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl MultiMesh {
    pub const CUSTOM_DATA_8BIT: i64 = 1;
    pub const CUSTOM_DATA_NONE: i64 = 0;
    pub const CUSTOM_DATA_FLOAT: i64 = 2;
    pub const COLOR_FLOAT: i64 = 2;
    pub const TRANSFORM_2D: i64 = 0;
    pub const COLOR_8BIT: i64 = 1;
    pub const COLOR_NONE: i64 = 0;
    pub const TRANSFORM_3D: i64 = 1;
}
impl MultiMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MultiMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MultiMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_color_array(&self) -> ColorArray {
        unsafe { MultiMesh__get_color_array(self.this) }
    }

    #[inline]
    pub fn _get_custom_data_array(&self) -> ColorArray {
        unsafe { MultiMesh__get_custom_data_array(self.this) }
    }

    #[inline]
    pub fn _get_transform_2d_array(&self) -> Vector2Array {
        unsafe { MultiMesh__get_transform_2d_array(self.this) }
    }

    #[inline]
    pub fn _get_transform_array(&self) -> Vector3Array {
        unsafe { MultiMesh__get_transform_array(self.this) }
    }

    #[inline]
    pub fn _set_color_array(&mut self, arg0: ColorArray) -> () {
        unsafe { MultiMesh__set_color_array(self.this, arg0) }
    }

    #[inline]
    pub fn _set_custom_data_array(&mut self, arg0: ColorArray) -> () {
        unsafe { MultiMesh__set_custom_data_array(self.this, arg0) }
    }

    #[inline]
    pub fn _set_transform_2d_array(&mut self, arg0: Vector2Array) -> () {
        unsafe { MultiMesh__set_transform_2d_array(self.this, arg0) }
    }

    #[inline]
    pub fn _set_transform_array(&mut self, arg0: Vector3Array) -> () {
        unsafe { MultiMesh__set_transform_array(self.this, arg0) }
    }

    #[inline]
    pub fn get_aabb(&self) -> Aabb {
        unsafe { MultiMesh_get_aabb(self.this) }
    }

    #[inline]
    pub fn get_color_format(&self) -> MultiMeshColorFormat {
        unsafe { MultiMesh_get_color_format(self.this) }
    }

    #[inline]
    pub fn get_custom_data_format(&self) -> MultiMeshCustomDataFormat {
        unsafe { MultiMesh_get_custom_data_format(self.this) }
    }

    #[inline]
    pub fn get_instance_color(&self, instance: i64) -> Color {
        unsafe { MultiMesh_get_instance_color(self.this, instance) }
    }

    #[inline]
    pub fn get_instance_count(&self) -> i64 {
        unsafe { MultiMesh_get_instance_count(self.this) }
    }

    #[inline]
    pub fn get_instance_custom_data(&self, instance: i64) -> Color {
        unsafe { MultiMesh_get_instance_custom_data(self.this, instance) }
    }

    #[inline]
    pub fn get_instance_transform(&self, instance: i64) -> Transform {
        unsafe { MultiMesh_get_instance_transform(self.this, instance) }
    }

    #[inline]
    pub fn get_instance_transform_2d(&self, instance: i64) -> Transform2D {
        unsafe { MultiMesh_get_instance_transform_2d(self.this, instance) }
    }

    #[inline]
    pub fn get_mesh(&self) -> Option<Mesh> {
        unsafe { MultiMesh_get_mesh(self.this) }
    }

    #[inline]
    pub fn get_transform_format(&self) -> MultiMeshTransformFormat {
        unsafe { MultiMesh_get_transform_format(self.this) }
    }

    #[inline]
    pub fn get_visible_instance_count(&self) -> i64 {
        unsafe { MultiMesh_get_visible_instance_count(self.this) }
    }

    #[inline]
    pub fn set_as_bulk_array(&mut self, array: Float32Array) -> () {
        unsafe { MultiMesh_set_as_bulk_array(self.this, array) }
    }

    #[inline]
    pub fn set_color_format(&mut self, format: i64) -> () {
        unsafe { MultiMesh_set_color_format(self.this, format) }
    }

    #[inline]
    pub fn set_custom_data_format(&mut self, format: i64) -> () {
        unsafe { MultiMesh_set_custom_data_format(self.this, format) }
    }

    #[inline]
    pub fn set_instance_color(&mut self, instance: i64, color: Color) -> () {
        unsafe { MultiMesh_set_instance_color(self.this, instance, color) }
    }

    #[inline]
    pub fn set_instance_count(&mut self, count: i64) -> () {
        unsafe { MultiMesh_set_instance_count(self.this, count) }
    }

    #[inline]
    pub fn set_instance_custom_data(&mut self, instance: i64, custom_data: Color) -> () {
        unsafe { MultiMesh_set_instance_custom_data(self.this, instance, custom_data) }
    }

    #[inline]
    pub fn set_instance_transform(&mut self, instance: i64, transform: Transform) -> () {
        unsafe { MultiMesh_set_instance_transform(self.this, instance, transform) }
    }

    #[inline]
    pub fn set_instance_transform_2d(&mut self, instance: i64, transform: Transform2D) -> () {
        unsafe { MultiMesh_set_instance_transform_2d(self.this, instance, transform) }
    }

    #[inline]
    pub fn set_mesh(&mut self, mesh: Option<Mesh>) -> () {
        unsafe { MultiMesh_set_mesh(self.this, mesh) }
    }

    #[inline]
    pub fn set_transform_format(&mut self, format: i64) -> () {
        unsafe { MultiMesh_set_transform_format(self.this, format) }
    }

    #[inline]
    pub fn set_visible_instance_count(&mut self, count: i64) -> () {
        unsafe { MultiMesh_set_visible_instance_count(self.this, count) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MultiMeshInstance` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_multimeshinstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MultiMeshInstance` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MultiMeshInstance::free`.
///
/// ## Class hierarchy
///
/// MultiMeshInstance inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MultiMeshInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MultiMeshInstance {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MultiMeshInstance::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MultiMeshInstanceMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MultiMeshInstance {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_multimesh(&self) -> Option<MultiMesh> {
        MultiMeshInstance_get_multimesh(self.this)
    }

    #[inline]
    pub unsafe fn set_multimesh(&mut self, multimesh: Option<MultiMesh>) -> () {
        MultiMeshInstance_set_multimesh(self.this, multimesh)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MultiMeshInstance2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_multimeshinstance2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `MultiMeshInstance2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `MultiMeshInstance2D::free`.
///
/// ## Class hierarchy
///
/// MultiMeshInstance2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MultiMeshInstance2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MultiMeshInstance2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `MultiMeshInstance2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MultiMeshInstance2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            MultiMeshInstance2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_multimesh(&self) -> Option<MultiMesh> {
        MultiMeshInstance2D_get_multimesh(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_map(&self) -> Option<Texture> {
        MultiMeshInstance2D_get_normal_map(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        MultiMeshInstance2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn set_multimesh(&mut self, multimesh: Option<MultiMesh>) -> () {
        MultiMeshInstance2D_set_multimesh(self.this, multimesh)
    }

    #[inline]
    pub unsafe fn set_normal_map(&mut self, normal_map: Option<Texture>) -> () {
        MultiMeshInstance2D_set_normal_map(self.this, normal_map)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        MultiMeshInstance2D_set_texture(self.this, texture)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MultiplayerAPI` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_multiplayerapi.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MultiplayerAPI inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MultiplayerAPI {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MultiplayerAPIRPCMode {
    ModeDisabled = 0,
    ModeRemote = 1,
    ModeMaster = 2,
    ModePuppet = 3,
    ModeRemotesync = 4,
    ModeMastersync = 5,
    ModePuppetsync = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl MultiplayerAPI {
    pub const RPC_MODE_MASTER: i64 = 2;
    pub const RPC_MODE_PUPPETSYNC: i64 = 6;
    pub const RPC_MODE_SYNC: i64 = 4;
    pub const RPC_MODE_DISABLED: i64 = 0;
    pub const RPC_MODE_REMOTESYNC: i64 = 4;
    pub const RPC_MODE_MASTERSYNC: i64 = 5;
    pub const RPC_MODE_PUPPET: i64 = 3;
    pub const RPC_MODE_REMOTE: i64 = 1;
    pub const RPC_MODE_SLAVE: i64 = 3;
}
impl MultiplayerAPI {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MultiplayerAPIMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MultiplayerAPI {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _add_peer(&mut self, id: i64) -> () {
        unsafe { MultiplayerAPI__add_peer(self.this, id) }
    }

    #[inline]
    pub fn _connected_to_server(&mut self) -> () {
        unsafe { MultiplayerAPI__connected_to_server(self.this) }
    }

    #[inline]
    pub fn _connection_failed(&mut self) -> () {
        unsafe { MultiplayerAPI__connection_failed(self.this) }
    }

    #[inline]
    pub fn _del_peer(&mut self, id: i64) -> () {
        unsafe { MultiplayerAPI__del_peer(self.this, id) }
    }

    #[inline]
    pub fn _server_disconnected(&mut self) -> () {
        unsafe { MultiplayerAPI__server_disconnected(self.this) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { MultiplayerAPI_clear(self.this) }
    }

    #[inline]
    pub fn get_network_connected_peers(&self) -> Int32Array {
        unsafe { MultiplayerAPI_get_network_connected_peers(self.this) }
    }

    #[inline]
    pub fn get_network_peer(&self) -> Option<NetworkedMultiplayerPeer> {
        unsafe { MultiplayerAPI_get_network_peer(self.this) }
    }

    #[inline]
    pub fn get_network_unique_id(&self) -> i64 {
        unsafe { MultiplayerAPI_get_network_unique_id(self.this) }
    }

    #[inline]
    pub fn get_rpc_sender_id(&self) -> i64 {
        unsafe { MultiplayerAPI_get_rpc_sender_id(self.this) }
    }

    #[inline]
    pub fn has_network_peer(&self) -> bool {
        unsafe { MultiplayerAPI_has_network_peer(self.this) }
    }

    #[inline]
    pub fn is_network_server(&self) -> bool {
        unsafe { MultiplayerAPI_is_network_server(self.this) }
    }

    #[inline]
    pub fn is_object_decoding_allowed(&self) -> bool {
        unsafe { MultiplayerAPI_is_object_decoding_allowed(self.this) }
    }

    #[inline]
    pub fn is_refusing_new_network_connections(&self) -> bool {
        unsafe { MultiplayerAPI_is_refusing_new_network_connections(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> () {
        unsafe { MultiplayerAPI_poll(self.this) }
    }

    #[inline]
    pub fn send_bytes(&mut self, bytes: ByteArray, id: i64, mode: i64) -> GodotResult {
        unsafe { MultiplayerAPI_send_bytes(self.this, bytes, id, mode) }
    }

    #[inline]
    pub fn set_allow_object_decoding(&mut self, enable: bool) -> () {
        unsafe { MultiplayerAPI_set_allow_object_decoding(self.this, enable) }
    }

    #[inline]
    pub fn set_network_peer(&mut self, peer: Option<NetworkedMultiplayerPeer>) -> () {
        unsafe { MultiplayerAPI_set_network_peer(self.this, peer) }
    }

    #[inline]
    pub fn set_refuse_new_network_connections(&mut self, refuse: bool) -> () {
        unsafe { MultiplayerAPI_set_refuse_new_network_connections(self.this, refuse) }
    }

    #[inline]
    pub fn set_root_node(&mut self, node: Option<Node>) -> () {
        unsafe { MultiplayerAPI_set_root_node(self.this, node) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class MultiplayerPeerGDNative` inherits `NetworkedMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_multiplayerpeergdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// MultiplayerPeerGDNative inherits methods from:
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct MultiplayerPeerGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl MultiplayerPeerGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MultiplayerPeerGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            MultiplayerPeerGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NativeScript` inherits `Script` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_nativescript.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NativeScript inherits methods from:
/// - [Script](struct.Script.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NativeScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl NativeScript {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NativeScriptMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            NativeScript {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_class_documentation(&self) -> GodotString {
        unsafe { NativeScript_get_class_documentation(self.this) }
    }

    #[inline]
    pub fn get_class_name(&self) -> GodotString {
        unsafe { NativeScript_get_class_name(self.this) }
    }

    #[inline]
    pub fn get_library(&self) -> Option<GDNativeLibrary> {
        unsafe { NativeScript_get_library(self.this) }
    }

    #[inline]
    pub fn get_method_documentation(&self, method: GodotString) -> GodotString {
        unsafe { NativeScript_get_method_documentation(self.this, method) }
    }

    #[inline]
    pub fn get_property_documentation(&self, path: GodotString) -> GodotString {
        unsafe { NativeScript_get_property_documentation(self.this, path) }
    }

    #[inline]
    pub fn get_script_class_icon_path(&self) -> GodotString {
        unsafe { NativeScript_get_script_class_icon_path(self.this) }
    }

    #[inline]
    pub fn get_script_class_name(&self) -> GodotString {
        unsafe { NativeScript_get_script_class_name(self.this) }
    }

    #[inline]
    pub fn get_signal_documentation(&self, signal_name: GodotString) -> GodotString {
        unsafe { NativeScript_get_signal_documentation(self.this, signal_name) }
    }

    #[inline]
    pub fn _new(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { NativeScript__new(self.this, varargs) }
    }

    #[inline]
    pub fn set_class_name(&mut self, class_name: GodotString) -> () {
        unsafe { NativeScript_set_class_name(self.this, class_name) }
    }

    #[inline]
    pub fn set_library(&mut self, library: Option<GDNativeLibrary>) -> () {
        unsafe { NativeScript_set_library(self.this, library) }
    }

    #[inline]
    pub fn set_script_class_icon_path(&mut self, icon_path: GodotString) -> () {
        unsafe { NativeScript_set_script_class_icon_path(self.this, icon_path) }
    }

    #[inline]
    pub fn set_script_class_name(&mut self, class_name: GodotString) -> () {
        unsafe { NativeScript_set_script_class_name(self.this, class_name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_script(&self) -> Script {
        unsafe {{ object::add_ref(self.this); }}
        Script { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Navigation` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigation.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Navigation` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Navigation::free`.
///
/// ## Class hierarchy
///
/// Navigation inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Navigation {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Navigation {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Navigation::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NavigationMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Navigation {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_closest_point(&mut self, to_point: Vector3) -> Vector3 {
        Navigation_get_closest_point(self.this, to_point)
    }

    #[inline]
    pub unsafe fn get_closest_point_normal(&mut self, to_point: Vector3) -> Vector3 {
        Navigation_get_closest_point_normal(self.this, to_point)
    }

    #[inline]
    pub unsafe fn get_closest_point_owner(&mut self, to_point: Vector3) -> Option<Object> {
        Navigation_get_closest_point_owner(self.this, to_point)
    }

    #[inline]
    pub unsafe fn get_closest_point_to_segment(&mut self, start: Vector3, end: Vector3, use_collision: bool) -> Vector3 {
        Navigation_get_closest_point_to_segment(self.this, start, end, use_collision)
    }

    #[inline]
    pub unsafe fn get_simple_path(&mut self, start: Vector3, end: Vector3, optimize: bool) -> Vector3Array {
        Navigation_get_simple_path(self.this, start, end, optimize)
    }

    #[inline]
    pub unsafe fn get_up_vector(&self) -> Vector3 {
        Navigation_get_up_vector(self.this)
    }

    #[inline]
    pub unsafe fn navmesh_add(&mut self, mesh: Option<NavigationMesh>, xform: Transform, owner: Option<Object>) -> i64 {
        Navigation_navmesh_add(self.this, mesh, xform, owner)
    }

    #[inline]
    pub unsafe fn navmesh_remove(&mut self, id: i64) -> () {
        Navigation_navmesh_remove(self.this, id)
    }

    #[inline]
    pub unsafe fn navmesh_set_transform(&mut self, id: i64, xform: Transform) -> () {
        Navigation_navmesh_set_transform(self.this, id, xform)
    }

    #[inline]
    pub unsafe fn set_up_vector(&mut self, up: Vector3) -> () {
        Navigation_set_up_vector(self.this, up)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Navigation2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigation2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Navigation2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Navigation2D::free`.
///
/// ## Class hierarchy
///
/// Navigation2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Navigation2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Navigation2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Navigation2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Navigation2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Navigation2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_closest_point(&mut self, to_point: Vector2) -> Vector2 {
        Navigation2D_get_closest_point(self.this, to_point)
    }

    #[inline]
    pub unsafe fn get_closest_point_owner(&mut self, to_point: Vector2) -> Option<Object> {
        Navigation2D_get_closest_point_owner(self.this, to_point)
    }

    #[inline]
    pub unsafe fn get_simple_path(&mut self, start: Vector2, end: Vector2, optimize: bool) -> Vector2Array {
        Navigation2D_get_simple_path(self.this, start, end, optimize)
    }

    #[inline]
    pub unsafe fn navpoly_add(&mut self, mesh: Option<NavigationPolygon>, xform: Transform2D, owner: Option<Object>) -> i64 {
        Navigation2D_navpoly_add(self.this, mesh, xform, owner)
    }

    #[inline]
    pub unsafe fn navpoly_remove(&mut self, id: i64) -> () {
        Navigation2D_navpoly_remove(self.this, id)
    }

    #[inline]
    pub unsafe fn navpoly_set_transform(&mut self, id: i64, xform: Transform2D) -> () {
        Navigation2D_navpoly_set_transform(self.this, id, xform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NavigationMesh` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigationmesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NavigationMesh inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NavigationMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl NavigationMesh {
    pub const PARSED_GEOMETRY_BOTH: i64 = 2;
    pub const PARSED_GEOMETRY_STATIC_COLLIDERS: i64 = 1;
    pub const SAMPLE_PARTITION_MONOTONE: i64 = 1;
    pub const SAMPLE_PARTITION_LAYERS: i64 = 2;
    pub const SAMPLE_PARTITION_WATERSHED: i64 = 0;
    pub const PARSED_GEOMETRY_MESH_INSTANCES: i64 = 0;
}
impl NavigationMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NavigationMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            NavigationMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_polygons(&self) -> VariantArray {
        unsafe { NavigationMesh__get_polygons(self.this) }
    }

    #[inline]
    pub fn _set_polygons(&mut self, polygons: VariantArray) -> () {
        unsafe { NavigationMesh__set_polygons(self.this, polygons) }
    }

    #[inline]
    pub fn add_polygon(&mut self, polygon: Int32Array) -> () {
        unsafe { NavigationMesh_add_polygon(self.this, polygon) }
    }

    #[inline]
    pub fn clear_polygons(&mut self) -> () {
        unsafe { NavigationMesh_clear_polygons(self.this) }
    }

    #[inline]
    pub fn create_from_mesh(&mut self, mesh: Option<Mesh>) -> () {
        unsafe { NavigationMesh_create_from_mesh(self.this, mesh) }
    }

    #[inline]
    pub fn get_agent_height(&self) -> f64 {
        unsafe { NavigationMesh_get_agent_height(self.this) }
    }

    #[inline]
    pub fn get_agent_max_climb(&self) -> f64 {
        unsafe { NavigationMesh_get_agent_max_climb(self.this) }
    }

    #[inline]
    pub fn get_agent_max_slope(&self) -> f64 {
        unsafe { NavigationMesh_get_agent_max_slope(self.this) }
    }

    #[inline]
    pub fn get_agent_radius(&mut self) -> f64 {
        unsafe { NavigationMesh_get_agent_radius(self.this) }
    }

    #[inline]
    pub fn get_cell_height(&self) -> f64 {
        unsafe { NavigationMesh_get_cell_height(self.this) }
    }

    #[inline]
    pub fn get_cell_size(&self) -> f64 {
        unsafe { NavigationMesh_get_cell_size(self.this) }
    }

    #[inline]
    pub fn get_collision_mask(&self) -> i64 {
        unsafe { NavigationMesh_get_collision_mask(self.this) }
    }

    #[inline]
    pub fn get_collision_mask_bit(&self, bit: i64) -> bool {
        unsafe { NavigationMesh_get_collision_mask_bit(self.this, bit) }
    }

    #[inline]
    pub fn get_detail_sample_distance(&self) -> f64 {
        unsafe { NavigationMesh_get_detail_sample_distance(self.this) }
    }

    #[inline]
    pub fn get_detail_sample_max_error(&self) -> f64 {
        unsafe { NavigationMesh_get_detail_sample_max_error(self.this) }
    }

    #[inline]
    pub fn get_edge_max_error(&self) -> f64 {
        unsafe { NavigationMesh_get_edge_max_error(self.this) }
    }

    #[inline]
    pub fn get_edge_max_length(&self) -> f64 {
        unsafe { NavigationMesh_get_edge_max_length(self.this) }
    }

    #[inline]
    pub fn get_filter_ledge_spans(&self) -> bool {
        unsafe { NavigationMesh_get_filter_ledge_spans(self.this) }
    }

    #[inline]
    pub fn get_filter_low_hanging_obstacles(&self) -> bool {
        unsafe { NavigationMesh_get_filter_low_hanging_obstacles(self.this) }
    }

    #[inline]
    pub fn get_filter_walkable_low_height_spans(&self) -> bool {
        unsafe { NavigationMesh_get_filter_walkable_low_height_spans(self.this) }
    }

    #[inline]
    pub fn get_parsed_geometry_type(&self) -> i64 {
        unsafe { NavigationMesh_get_parsed_geometry_type(self.this) }
    }

    #[inline]
    pub fn get_polygon(&mut self, idx: i64) -> Int32Array {
        unsafe { NavigationMesh_get_polygon(self.this, idx) }
    }

    #[inline]
    pub fn get_polygon_count(&self) -> i64 {
        unsafe { NavigationMesh_get_polygon_count(self.this) }
    }

    #[inline]
    pub fn get_region_merge_size(&self) -> f64 {
        unsafe { NavigationMesh_get_region_merge_size(self.this) }
    }

    #[inline]
    pub fn get_region_min_size(&self) -> f64 {
        unsafe { NavigationMesh_get_region_min_size(self.this) }
    }

    #[inline]
    pub fn get_sample_partition_type(&self) -> i64 {
        unsafe { NavigationMesh_get_sample_partition_type(self.this) }
    }

    #[inline]
    pub fn get_source_geometry_mode(&self) -> i64 {
        unsafe { NavigationMesh_get_source_geometry_mode(self.this) }
    }

    #[inline]
    pub fn get_source_group_name(&self) -> GodotString {
        unsafe { NavigationMesh_get_source_group_name(self.this) }
    }

    #[inline]
    pub fn get_vertices(&self) -> Vector3Array {
        unsafe { NavigationMesh_get_vertices(self.this) }
    }

    #[inline]
    pub fn get_verts_per_poly(&self) -> f64 {
        unsafe { NavigationMesh_get_verts_per_poly(self.this) }
    }

    #[inline]
    pub fn set_agent_height(&mut self, agent_height: f64) -> () {
        unsafe { NavigationMesh_set_agent_height(self.this, agent_height) }
    }

    #[inline]
    pub fn set_agent_max_climb(&mut self, agent_max_climb: f64) -> () {
        unsafe { NavigationMesh_set_agent_max_climb(self.this, agent_max_climb) }
    }

    #[inline]
    pub fn set_agent_max_slope(&mut self, agent_max_slope: f64) -> () {
        unsafe { NavigationMesh_set_agent_max_slope(self.this, agent_max_slope) }
    }

    #[inline]
    pub fn set_agent_radius(&mut self, agent_radius: f64) -> () {
        unsafe { NavigationMesh_set_agent_radius(self.this, agent_radius) }
    }

    #[inline]
    pub fn set_cell_height(&mut self, cell_height: f64) -> () {
        unsafe { NavigationMesh_set_cell_height(self.this, cell_height) }
    }

    #[inline]
    pub fn set_cell_size(&mut self, cell_size: f64) -> () {
        unsafe { NavigationMesh_set_cell_size(self.this, cell_size) }
    }

    #[inline]
    pub fn set_collision_mask(&mut self, mask: i64) -> () {
        unsafe { NavigationMesh_set_collision_mask(self.this, mask) }
    }

    #[inline]
    pub fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        unsafe { NavigationMesh_set_collision_mask_bit(self.this, bit, value) }
    }

    #[inline]
    pub fn set_detail_sample_distance(&mut self, detail_sample_dist: f64) -> () {
        unsafe { NavigationMesh_set_detail_sample_distance(self.this, detail_sample_dist) }
    }

    #[inline]
    pub fn set_detail_sample_max_error(&mut self, detail_sample_max_error: f64) -> () {
        unsafe { NavigationMesh_set_detail_sample_max_error(self.this, detail_sample_max_error) }
    }

    #[inline]
    pub fn set_edge_max_error(&mut self, edge_max_error: f64) -> () {
        unsafe { NavigationMesh_set_edge_max_error(self.this, edge_max_error) }
    }

    #[inline]
    pub fn set_edge_max_length(&mut self, edge_max_length: f64) -> () {
        unsafe { NavigationMesh_set_edge_max_length(self.this, edge_max_length) }
    }

    #[inline]
    pub fn set_filter_ledge_spans(&mut self, filter_ledge_spans: bool) -> () {
        unsafe { NavigationMesh_set_filter_ledge_spans(self.this, filter_ledge_spans) }
    }

    #[inline]
    pub fn set_filter_low_hanging_obstacles(&mut self, filter_low_hanging_obstacles: bool) -> () {
        unsafe { NavigationMesh_set_filter_low_hanging_obstacles(self.this, filter_low_hanging_obstacles) }
    }

    #[inline]
    pub fn set_filter_walkable_low_height_spans(&mut self, filter_walkable_low_height_spans: bool) -> () {
        unsafe { NavigationMesh_set_filter_walkable_low_height_spans(self.this, filter_walkable_low_height_spans) }
    }

    #[inline]
    pub fn set_parsed_geometry_type(&mut self, geometry_type: i64) -> () {
        unsafe { NavigationMesh_set_parsed_geometry_type(self.this, geometry_type) }
    }

    #[inline]
    pub fn set_region_merge_size(&mut self, region_merge_size: f64) -> () {
        unsafe { NavigationMesh_set_region_merge_size(self.this, region_merge_size) }
    }

    #[inline]
    pub fn set_region_min_size(&mut self, region_min_size: f64) -> () {
        unsafe { NavigationMesh_set_region_min_size(self.this, region_min_size) }
    }

    #[inline]
    pub fn set_sample_partition_type(&mut self, sample_partition_type: i64) -> () {
        unsafe { NavigationMesh_set_sample_partition_type(self.this, sample_partition_type) }
    }

    #[inline]
    pub fn set_source_geometry_mode(&mut self, mask: i64) -> () {
        unsafe { NavigationMesh_set_source_geometry_mode(self.this, mask) }
    }

    #[inline]
    pub fn set_source_group_name(&mut self, mask: GodotString) -> () {
        unsafe { NavigationMesh_set_source_group_name(self.this, mask) }
    }

    #[inline]
    pub fn set_vertices(&mut self, vertices: Vector3Array) -> () {
        unsafe { NavigationMesh_set_vertices(self.this, vertices) }
    }

    #[inline]
    pub fn set_verts_per_poly(&mut self, verts_per_poly: f64) -> () {
        unsafe { NavigationMesh_set_verts_per_poly(self.this, verts_per_poly) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NavigationMeshInstance` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigationmeshinstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `NavigationMeshInstance` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `NavigationMeshInstance::free`.
///
/// ## Class hierarchy
///
/// NavigationMeshInstance inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NavigationMeshInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl NavigationMeshInstance {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `NavigationMeshInstance::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NavigationMeshInstanceMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            NavigationMeshInstance {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_navigation_mesh(&self) -> Option<NavigationMesh> {
        NavigationMeshInstance_get_navigation_mesh(self.this)
    }

    #[inline]
    pub unsafe fn is_enabled(&self) -> bool {
        NavigationMeshInstance_is_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_enabled(&mut self, enabled: bool) -> () {
        NavigationMeshInstance_set_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_navigation_mesh(&mut self, navmesh: Option<NavigationMesh>) -> () {
        NavigationMeshInstance_set_navigation_mesh(self.this, navmesh)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NavigationPolygon` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigationpolygon.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NavigationPolygon inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NavigationPolygon {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl NavigationPolygon {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NavigationPolygonMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            NavigationPolygon {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_outlines(&self) -> VariantArray {
        unsafe { NavigationPolygon__get_outlines(self.this) }
    }

    #[inline]
    pub fn _get_polygons(&self) -> VariantArray {
        unsafe { NavigationPolygon__get_polygons(self.this) }
    }

    #[inline]
    pub fn _set_outlines(&mut self, outlines: VariantArray) -> () {
        unsafe { NavigationPolygon__set_outlines(self.this, outlines) }
    }

    #[inline]
    pub fn _set_polygons(&mut self, polygons: VariantArray) -> () {
        unsafe { NavigationPolygon__set_polygons(self.this, polygons) }
    }

    #[inline]
    pub fn add_outline(&mut self, outline: Vector2Array) -> () {
        unsafe { NavigationPolygon_add_outline(self.this, outline) }
    }

    #[inline]
    pub fn add_outline_at_index(&mut self, outline: Vector2Array, index: i64) -> () {
        unsafe { NavigationPolygon_add_outline_at_index(self.this, outline, index) }
    }

    #[inline]
    pub fn add_polygon(&mut self, polygon: Int32Array) -> () {
        unsafe { NavigationPolygon_add_polygon(self.this, polygon) }
    }

    #[inline]
    pub fn clear_outlines(&mut self) -> () {
        unsafe { NavigationPolygon_clear_outlines(self.this) }
    }

    #[inline]
    pub fn clear_polygons(&mut self) -> () {
        unsafe { NavigationPolygon_clear_polygons(self.this) }
    }

    #[inline]
    pub fn get_outline(&self, idx: i64) -> Vector2Array {
        unsafe { NavigationPolygon_get_outline(self.this, idx) }
    }

    #[inline]
    pub fn get_outline_count(&self) -> i64 {
        unsafe { NavigationPolygon_get_outline_count(self.this) }
    }

    #[inline]
    pub fn get_polygon(&mut self, idx: i64) -> Int32Array {
        unsafe { NavigationPolygon_get_polygon(self.this, idx) }
    }

    #[inline]
    pub fn get_polygon_count(&self) -> i64 {
        unsafe { NavigationPolygon_get_polygon_count(self.this) }
    }

    #[inline]
    pub fn get_vertices(&self) -> Vector2Array {
        unsafe { NavigationPolygon_get_vertices(self.this) }
    }

    #[inline]
    pub fn make_polygons_from_outlines(&mut self) -> () {
        unsafe { NavigationPolygon_make_polygons_from_outlines(self.this) }
    }

    #[inline]
    pub fn remove_outline(&mut self, idx: i64) -> () {
        unsafe { NavigationPolygon_remove_outline(self.this, idx) }
    }

    #[inline]
    pub fn set_outline(&mut self, idx: i64, outline: Vector2Array) -> () {
        unsafe { NavigationPolygon_set_outline(self.this, idx, outline) }
    }

    #[inline]
    pub fn set_vertices(&mut self, vertices: Vector2Array) -> () {
        unsafe { NavigationPolygon_set_vertices(self.this, vertices) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NavigationPolygonInstance` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_navigationpolygoninstance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `NavigationPolygonInstance` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `NavigationPolygonInstance::free`.
///
/// ## Class hierarchy
///
/// NavigationPolygonInstance inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NavigationPolygonInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl NavigationPolygonInstance {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `NavigationPolygonInstance::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NavigationPolygonInstanceMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            NavigationPolygonInstance {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _navpoly_changed(&mut self) -> () {
        NavigationPolygonInstance__navpoly_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_navigation_polygon(&self) -> Option<NavigationPolygon> {
        NavigationPolygonInstance_get_navigation_polygon(self.this)
    }

    #[inline]
    pub unsafe fn is_enabled(&self) -> bool {
        NavigationPolygonInstance_is_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_enabled(&mut self, enabled: bool) -> () {
        NavigationPolygonInstance_set_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_navigation_polygon(&mut self, navpoly: Option<NavigationPolygon>) -> () {
        NavigationPolygonInstance_set_navigation_polygon(self.this, navpoly)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NetworkedMultiplayerENet` inherits `NetworkedMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_networkedmultiplayerenet.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NetworkedMultiplayerENet inherits methods from:
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NetworkedMultiplayerENet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NetworkedMultiplayerENetCompressionMode {
    CompressNone = 0,
    CompressRangeCoder = 1,
    CompressFastlz = 2,
    CompressZlib = 3,
    CompressZstd = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl NetworkedMultiplayerENet {
    pub const COMPRESS_ZLIB: i64 = 3;
    pub const COMPRESS_RANGE_CODER: i64 = 1;
    pub const COMPRESS_NONE: i64 = 0;
    pub const COMPRESS_ZSTD: i64 = 4;
    pub const COMPRESS_FASTLZ: i64 = 2;
}
impl NetworkedMultiplayerENet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NetworkedMultiplayerENetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            NetworkedMultiplayerENet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close_connection(&mut self, wait_usec: i64) -> () {
        unsafe { NetworkedMultiplayerENet_close_connection(self.this, wait_usec) }
    }

    #[inline]
    pub fn create_client(&mut self, address: GodotString, port: i64, in_bandwidth: i64, out_bandwidth: i64, client_port: i64) -> GodotResult {
        unsafe { NetworkedMultiplayerENet_create_client(self.this, address, port, in_bandwidth, out_bandwidth, client_port) }
    }

    #[inline]
    pub fn create_server(&mut self, port: i64, max_clients: i64, in_bandwidth: i64, out_bandwidth: i64) -> GodotResult {
        unsafe { NetworkedMultiplayerENet_create_server(self.this, port, max_clients, in_bandwidth, out_bandwidth) }
    }

    #[inline]
    pub fn disconnect_peer(&mut self, id: i64, now: bool) -> () {
        unsafe { NetworkedMultiplayerENet_disconnect_peer(self.this, id, now) }
    }

    #[inline]
    pub fn get_channel_count(&self) -> i64 {
        unsafe { NetworkedMultiplayerENet_get_channel_count(self.this) }
    }

    #[inline]
    pub fn get_compression_mode(&self) -> NetworkedMultiplayerENetCompressionMode {
        unsafe { NetworkedMultiplayerENet_get_compression_mode(self.this) }
    }

    #[inline]
    pub fn get_last_packet_channel(&self) -> i64 {
        unsafe { NetworkedMultiplayerENet_get_last_packet_channel(self.this) }
    }

    #[inline]
    pub fn get_packet_channel(&self) -> i64 {
        unsafe { NetworkedMultiplayerENet_get_packet_channel(self.this) }
    }

    #[inline]
    pub fn get_peer_address(&self, id: i64) -> GodotString {
        unsafe { NetworkedMultiplayerENet_get_peer_address(self.this, id) }
    }

    #[inline]
    pub fn get_peer_port(&self, id: i64) -> i64 {
        unsafe { NetworkedMultiplayerENet_get_peer_port(self.this, id) }
    }

    #[inline]
    pub fn get_transfer_channel(&self) -> i64 {
        unsafe { NetworkedMultiplayerENet_get_transfer_channel(self.this) }
    }

    #[inline]
    pub fn is_always_ordered(&self) -> bool {
        unsafe { NetworkedMultiplayerENet_is_always_ordered(self.this) }
    }

    #[inline]
    pub fn is_server_relay_enabled(&self) -> bool {
        unsafe { NetworkedMultiplayerENet_is_server_relay_enabled(self.this) }
    }

    #[inline]
    pub fn set_always_ordered(&mut self, ordered: bool) -> () {
        unsafe { NetworkedMultiplayerENet_set_always_ordered(self.this, ordered) }
    }

    #[inline]
    pub fn set_bind_ip(&mut self, ip: GodotString) -> () {
        unsafe { NetworkedMultiplayerENet_set_bind_ip(self.this, ip) }
    }

    #[inline]
    pub fn set_channel_count(&mut self, channels: i64) -> () {
        unsafe { NetworkedMultiplayerENet_set_channel_count(self.this, channels) }
    }

    #[inline]
    pub fn set_compression_mode(&mut self, mode: i64) -> () {
        unsafe { NetworkedMultiplayerENet_set_compression_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_server_relay_enabled(&mut self, enabled: bool) -> () {
        unsafe { NetworkedMultiplayerENet_set_server_relay_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_transfer_channel(&mut self, channel: i64) -> () {
        unsafe { NetworkedMultiplayerENet_set_transfer_channel(self.this, channel) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NetworkedMultiplayerPeer` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_networkedmultiplayerpeer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NetworkedMultiplayerPeer inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NetworkedMultiplayerPeer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NetworkedMultiplayerPeerConnectionStatus {
    ConnectionDisconnected = 0,
    ConnectionConnecting = 1,
    ConnectionConnected = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NetworkedMultiplayerPeerTransferMode {
    ModeUnreliable = 0,
    ModeUnreliableOrdered = 1,
    ModeReliable = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl NetworkedMultiplayerPeer {
    pub const TRANSFER_MODE_UNRELIABLE_ORDERED: i64 = 1;
    pub const CONNECTION_CONNECTED: i64 = 2;
    pub const CONNECTION_DISCONNECTED: i64 = 0;
    pub const TARGET_PEER_BROADCAST: i64 = 0;
    pub const TARGET_PEER_SERVER: i64 = 1;
    pub const TRANSFER_MODE_UNRELIABLE: i64 = 0;
    pub const CONNECTION_CONNECTING: i64 = 1;
    pub const TRANSFER_MODE_RELIABLE: i64 = 2;
}
impl NetworkedMultiplayerPeer {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_connection_status(&self) -> NetworkedMultiplayerPeerConnectionStatus {
        unsafe { NetworkedMultiplayerPeer_get_connection_status(self.this) }
    }

    #[inline]
    pub fn get_packet_peer(&self) -> i64 {
        unsafe { NetworkedMultiplayerPeer_get_packet_peer(self.this) }
    }

    #[inline]
    pub fn get_transfer_mode(&self) -> NetworkedMultiplayerPeerTransferMode {
        unsafe { NetworkedMultiplayerPeer_get_transfer_mode(self.this) }
    }

    #[inline]
    pub fn get_unique_id(&self) -> i64 {
        unsafe { NetworkedMultiplayerPeer_get_unique_id(self.this) }
    }

    #[inline]
    pub fn is_refusing_new_connections(&self) -> bool {
        unsafe { NetworkedMultiplayerPeer_is_refusing_new_connections(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> () {
        unsafe { NetworkedMultiplayerPeer_poll(self.this) }
    }

    #[inline]
    pub fn set_refuse_new_connections(&mut self, enable: bool) -> () {
        unsafe { NetworkedMultiplayerPeer_set_refuse_new_connections(self.this, enable) }
    }

    #[inline]
    pub fn set_target_peer(&mut self, id: i64) -> () {
        unsafe { NetworkedMultiplayerPeer_set_target_peer(self.this, id) }
    }

    #[inline]
    pub fn set_transfer_mode(&mut self, mode: i64) -> () {
        unsafe { NetworkedMultiplayerPeer_set_transfer_mode(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NinePatchRect` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_ninepatchrect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `NinePatchRect` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `NinePatchRect::free`.
///
/// ## Class hierarchy
///
/// NinePatchRect inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NinePatchRect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NinePatchRectAxisStretchMode {
    ModeStretch = 0,
    ModeTile = 1,
    ModeTileFit = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl NinePatchRect {
    pub const AXIS_STRETCH_MODE_TILE: i64 = 1;
    pub const AXIS_STRETCH_MODE_STRETCH: i64 = 0;
    pub const AXIS_STRETCH_MODE_TILE_FIT: i64 = 2;
}
impl NinePatchRect {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `NinePatchRect::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NinePatchRectMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            NinePatchRect {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_h_axis_stretch_mode(&self) -> NinePatchRectAxisStretchMode {
        NinePatchRect_get_h_axis_stretch_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_patch_margin(&self, margin: i64) -> i64 {
        NinePatchRect_get_patch_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_region_rect(&self) -> Rect2 {
        NinePatchRect_get_region_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        NinePatchRect_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_v_axis_stretch_mode(&self) -> NinePatchRectAxisStretchMode {
        NinePatchRect_get_v_axis_stretch_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_draw_center_enabled(&self) -> bool {
        NinePatchRect_is_draw_center_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_draw_center(&mut self, draw_center: bool) -> () {
        NinePatchRect_set_draw_center(self.this, draw_center)
    }

    #[inline]
    pub unsafe fn set_h_axis_stretch_mode(&mut self, mode: i64) -> () {
        NinePatchRect_set_h_axis_stretch_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_patch_margin(&mut self, margin: i64, value: i64) -> () {
        NinePatchRect_set_patch_margin(self.this, margin, value)
    }

    #[inline]
    pub unsafe fn set_region_rect(&mut self, rect: Rect2) -> () {
        NinePatchRect_set_region_rect(self.this, rect)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        NinePatchRect_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_v_axis_stretch_mode(&mut self, mode: i64) -> () {
        NinePatchRect_set_v_axis_stretch_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Node` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_node.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Node` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Node::free`.
///
/// ## Class hierarchy
///
/// Node inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Node {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NodePauseMode {
    ModeInherit = 0,
    ModeStop = 1,
    ModeProcess = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum NodeDuplicateFlags {
    DuplicateSignals = 1,
    DuplicateGroups = 2,
    DuplicateScripts = 4,
    DuplicateUseInstancing = 8,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Node {
    pub const NOTIFICATION_CRASH: i64 = 1012;
    pub const NOTIFICATION_INSTANCED: i64 = 20;
    pub const NOTIFICATION_OS_MEMORY_WARNING: i64 = 1009;
    pub const NOTIFICATION_WM_QUIT_REQUEST: i64 = 1006;
    pub const NOTIFICATION_INTERNAL_PROCESS: i64 = 25;
    pub const NOTIFICATION_PATH_CHANGED: i64 = 23;
    pub const NOTIFICATION_PAUSED: i64 = 14;
    pub const DUPLICATE_SIGNALS: i64 = 1;
    pub const NOTIFICATION_WM_FOCUS_OUT: i64 = 1005;
    pub const PAUSE_MODE_STOP: i64 = 1;
    pub const NOTIFICATION_MOVED_IN_PARENT: i64 = 12;
    pub const NOTIFICATION_ENTER_TREE: i64 = 10;
    pub const NOTIFICATION_INTERNAL_PHYSICS_PROCESS: i64 = 26;
    pub const NOTIFICATION_PHYSICS_PROCESS: i64 = 16;
    pub const NOTIFICATION_WM_MOUSE_EXIT: i64 = 1003;
    pub const NOTIFICATION_WM_MOUSE_ENTER: i64 = 1002;
    pub const NOTIFICATION_DRAG_END: i64 = 22;
    pub const NOTIFICATION_UNPARENTED: i64 = 19;
    pub const NOTIFICATION_TRANSLATION_CHANGED: i64 = 1010;
    pub const DUPLICATE_USE_INSTANCING: i64 = 8;
    pub const NOTIFICATION_WM_GO_BACK_REQUEST: i64 = 1007;
    pub const NOTIFICATION_PROCESS: i64 = 17;
    pub const NOTIFICATION_APP_RESUMED: i64 = 1014;
    pub const NOTIFICATION_OS_IME_UPDATE: i64 = 1013;
    pub const NOTIFICATION_UNPAUSED: i64 = 15;
    pub const NOTIFICATION_WM_FOCUS_IN: i64 = 1004;
    pub const NOTIFICATION_WM_UNFOCUS_REQUEST: i64 = 1008;
    pub const PAUSE_MODE_PROCESS: i64 = 2;
    pub const DUPLICATE_SCRIPTS: i64 = 4;
    pub const NOTIFICATION_READY: i64 = 13;
    pub const NOTIFICATION_DRAG_BEGIN: i64 = 21;
    pub const DUPLICATE_GROUPS: i64 = 2;
    pub const NOTIFICATION_EXIT_TREE: i64 = 11;
    pub const NOTIFICATION_WM_ABOUT: i64 = 1011;
    pub const NOTIFICATION_APP_PAUSED: i64 = 1015;
    pub const NOTIFICATION_PARENTED: i64 = 18;
    pub const PAUSE_MODE_INHERIT: i64 = 0;
}
impl Node {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Node::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NodeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Node {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _enter_tree(&mut self) -> () {
        Node__enter_tree(self.this)
    }

    #[inline]
    pub unsafe fn _exit_tree(&mut self) -> () {
        Node__exit_tree(self.this)
    }

    #[inline]
    pub unsafe fn _get_configuration_warning(&mut self) -> GodotString {
        Node__get_configuration_warning(self.this)
    }

    #[inline]
    pub unsafe fn _get_editor_description(&self) -> GodotString {
        Node__get_editor_description(self.this)
    }

    #[inline]
    pub unsafe fn _get_import_path(&self) -> NodePath {
        Node__get_import_path(self.this)
    }

    #[inline]
    pub unsafe fn _input(&mut self, event: Option<InputEvent>) -> () {
        Node__input(self.this, event)
    }

    #[inline]
    pub unsafe fn _physics_process(&mut self, delta: f64) -> () {
        Node__physics_process(self.this, delta)
    }

    #[inline]
    pub unsafe fn _process(&mut self, delta: f64) -> () {
        Node__process(self.this, delta)
    }

    #[inline]
    pub unsafe fn _ready(&mut self) -> () {
        Node__ready(self.this)
    }

    #[inline]
    pub unsafe fn _set_editor_description(&mut self, editor_description: GodotString) -> () {
        Node__set_editor_description(self.this, editor_description)
    }

    #[inline]
    pub unsafe fn _set_import_path(&mut self, import_path: NodePath) -> () {
        Node__set_import_path(self.this, import_path)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, event: Option<InputEvent>) -> () {
        Node__unhandled_input(self.this, event)
    }

    #[inline]
    pub unsafe fn _unhandled_key_input(&mut self, event: Option<InputEventKey>) -> () {
        Node__unhandled_key_input(self.this, event)
    }

    #[inline]
    pub unsafe fn add_child(&mut self, node: Option<Node>, legible_unique_name: bool) -> () {
        Node_add_child(self.this, node, legible_unique_name)
    }

    #[inline]
    pub unsafe fn add_child_below_node(&mut self, node: Option<Node>, child_node: Option<Node>, legible_unique_name: bool) -> () {
        Node_add_child_below_node(self.this, node, child_node, legible_unique_name)
    }

    #[inline]
    pub unsafe fn add_to_group(&mut self, group: GodotString, persistent: bool) -> () {
        Node_add_to_group(self.this, group, persistent)
    }

    #[inline]
    pub unsafe fn can_process(&self) -> bool {
        Node_can_process(self.this)
    }

    #[inline]
    pub unsafe fn duplicate(&self, flags: i64) -> Option<Node> {
        Node_duplicate(self.this, flags)
    }

    #[inline]
    pub unsafe fn find_node(&self, mask: GodotString, recursive: bool, owned: bool) -> Option<Node> {
        Node_find_node(self.this, mask, recursive, owned)
    }

    #[inline]
    pub unsafe fn find_parent(&self, mask: GodotString) -> Option<Node> {
        Node_find_parent(self.this, mask)
    }

    #[inline]
    pub unsafe fn get_child(&self, idx: i64) -> Option<Node> {
        Node_get_child(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_child_count(&self) -> i64 {
        Node_get_child_count(self.this)
    }

    #[inline]
    pub unsafe fn get_children(&self) -> VariantArray {
        Node_get_children(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_multiplayer(&self) -> Option<MultiplayerAPI> {
        Node_get_custom_multiplayer(self.this)
    }

    #[inline]
    pub unsafe fn get_filename(&self) -> GodotString {
        Node_get_filename(self.this)
    }

    #[inline]
    pub unsafe fn get_groups(&self) -> VariantArray {
        Node_get_groups(self.this)
    }

    #[inline]
    pub unsafe fn get_index(&self) -> i64 {
        Node_get_index(self.this)
    }

    #[inline]
    pub unsafe fn get_multiplayer(&self) -> Option<MultiplayerAPI> {
        Node_get_multiplayer(self.this)
    }

    #[inline]
    pub unsafe fn get_name(&self) -> GodotString {
        Node_get_name(self.this)
    }

    #[inline]
    pub unsafe fn get_network_master(&self) -> i64 {
        Node_get_network_master(self.this)
    }

    #[inline]
    pub unsafe fn get_node(&self, path: NodePath) -> Option<Node> {
        Node_get_node(self.this, path)
    }

    #[inline]
    pub unsafe fn get_node_and_resource(&mut self, path: NodePath) -> VariantArray {
        Node_get_node_and_resource(self.this, path)
    }

    #[inline]
    pub unsafe fn get_node_or_null(&self, path: NodePath) -> Option<Node> {
        Node_get_node_or_null(self.this, path)
    }

    #[inline]
    pub unsafe fn get_owner(&self) -> Option<Node> {
        Node_get_owner(self.this)
    }

    #[inline]
    pub unsafe fn get_parent(&self) -> Option<Node> {
        Node_get_parent(self.this)
    }

    #[inline]
    pub unsafe fn get_path(&self) -> NodePath {
        Node_get_path(self.this)
    }

    #[inline]
    pub unsafe fn get_path_to(&self, node: Option<Node>) -> NodePath {
        Node_get_path_to(self.this, node)
    }

    #[inline]
    pub unsafe fn get_pause_mode(&self) -> NodePauseMode {
        Node_get_pause_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_process_delta_time(&self) -> f64 {
        Node_get_physics_process_delta_time(self.this)
    }

    #[inline]
    pub unsafe fn get_position_in_parent(&self) -> i64 {
        Node_get_position_in_parent(self.this)
    }

    #[inline]
    pub unsafe fn get_process_delta_time(&self) -> f64 {
        Node_get_process_delta_time(self.this)
    }

    #[inline]
    pub unsafe fn get_process_priority(&self) -> i64 {
        Node_get_process_priority(self.this)
    }

    #[inline]
    pub unsafe fn get_scene_instance_load_placeholder(&self) -> bool {
        Node_get_scene_instance_load_placeholder(self.this)
    }

    #[inline]
    pub unsafe fn get_tree(&self) -> Option<SceneTree> {
        Node_get_tree(self.this)
    }

    #[inline]
    pub unsafe fn get_viewport(&self) -> Option<Viewport> {
        Node_get_viewport(self.this)
    }

    #[inline]
    pub unsafe fn has_node(&self, path: NodePath) -> bool {
        Node_has_node(self.this, path)
    }

    #[inline]
    pub unsafe fn has_node_and_resource(&self, path: NodePath) -> bool {
        Node_has_node_and_resource(self.this, path)
    }

    #[inline]
    pub unsafe fn is_a_parent_of(&self, node: Option<Node>) -> bool {
        Node_is_a_parent_of(self.this, node)
    }

    #[inline]
    pub unsafe fn is_displayed_folded(&self) -> bool {
        Node_is_displayed_folded(self.this)
    }

    #[inline]
    pub unsafe fn is_greater_than(&self, node: Option<Node>) -> bool {
        Node_is_greater_than(self.this, node)
    }

    #[inline]
    pub unsafe fn is_in_group(&self, group: GodotString) -> bool {
        Node_is_in_group(self.this, group)
    }

    #[inline]
    pub unsafe fn is_inside_tree(&self) -> bool {
        Node_is_inside_tree(self.this)
    }

    #[inline]
    pub unsafe fn is_network_master(&self) -> bool {
        Node_is_network_master(self.this)
    }

    #[inline]
    pub unsafe fn is_physics_processing(&self) -> bool {
        Node_is_physics_processing(self.this)
    }

    #[inline]
    pub unsafe fn is_physics_processing_internal(&self) -> bool {
        Node_is_physics_processing_internal(self.this)
    }

    #[inline]
    pub unsafe fn is_processing(&self) -> bool {
        Node_is_processing(self.this)
    }

    #[inline]
    pub unsafe fn is_processing_input(&self) -> bool {
        Node_is_processing_input(self.this)
    }

    #[inline]
    pub unsafe fn is_processing_internal(&self) -> bool {
        Node_is_processing_internal(self.this)
    }

    #[inline]
    pub unsafe fn is_processing_unhandled_input(&self) -> bool {
        Node_is_processing_unhandled_input(self.this)
    }

    #[inline]
    pub unsafe fn is_processing_unhandled_key_input(&self) -> bool {
        Node_is_processing_unhandled_key_input(self.this)
    }

    #[inline]
    pub unsafe fn move_child(&mut self, child_node: Option<Node>, to_position: i64) -> () {
        Node_move_child(self.this, child_node, to_position)
    }

    #[inline]
    pub unsafe fn print_stray_nodes(&mut self) -> () {
        Node_print_stray_nodes(self.this)
    }

    #[inline]
    pub unsafe fn print_tree(&mut self) -> () {
        Node_print_tree(self.this)
    }

    #[inline]
    pub unsafe fn print_tree_pretty(&mut self) -> () {
        Node_print_tree_pretty(self.this)
    }

    #[inline]
    pub unsafe fn propagate_call(&mut self, method: GodotString, args: VariantArray, parent_first: bool) -> () {
        Node_propagate_call(self.this, method, args, parent_first)
    }

    #[inline]
    pub unsafe fn propagate_notification(&mut self, what: i64) -> () {
        Node_propagate_notification(self.this, what)
    }

    #[inline]
    pub unsafe fn queue_free(&mut self) -> () {
        Node_queue_free(self.this)
    }

    #[inline]
    pub unsafe fn raise(&mut self) -> () {
        Node_raise(self.this)
    }

    #[inline]
    pub unsafe fn remove_and_skip(&mut self) -> () {
        Node_remove_and_skip(self.this)
    }

    #[inline]
    pub unsafe fn remove_child(&mut self, node: Option<Node>) -> () {
        Node_remove_child(self.this, node)
    }

    #[inline]
    pub unsafe fn remove_from_group(&mut self, group: GodotString) -> () {
        Node_remove_from_group(self.this, group)
    }

    #[inline]
    pub unsafe fn replace_by(&mut self, node: Option<Node>, keep_data: bool) -> () {
        Node_replace_by(self.this, node, keep_data)
    }

    #[inline]
    pub unsafe fn request_ready(&mut self) -> () {
        Node_request_ready(self.this)
    }

    #[inline]
    pub unsafe fn rpc(&mut self, method: GodotString, varargs: &[Variant]) -> Variant {
        Node_rpc(self.this, method, varargs)
    }

    #[inline]
    pub unsafe fn rpc_config(&mut self, method: GodotString, mode: i64) -> () {
        Node_rpc_config(self.this, method, mode)
    }

    #[inline]
    pub unsafe fn rpc_id(&mut self, peer_id: i64, method: GodotString, varargs: &[Variant]) -> Variant {
        Node_rpc_id(self.this, peer_id, method, varargs)
    }

    #[inline]
    pub unsafe fn rpc_unreliable(&mut self, method: GodotString, varargs: &[Variant]) -> Variant {
        Node_rpc_unreliable(self.this, method, varargs)
    }

    #[inline]
    pub unsafe fn rpc_unreliable_id(&mut self, peer_id: i64, method: GodotString, varargs: &[Variant]) -> Variant {
        Node_rpc_unreliable_id(self.this, peer_id, method, varargs)
    }

    #[inline]
    pub unsafe fn rset(&mut self, property: GodotString, value: Variant) -> () {
        Node_rset(self.this, property, value)
    }

    #[inline]
    pub unsafe fn rset_config(&mut self, property: GodotString, mode: i64) -> () {
        Node_rset_config(self.this, property, mode)
    }

    #[inline]
    pub unsafe fn rset_id(&mut self, peer_id: i64, property: GodotString, value: Variant) -> () {
        Node_rset_id(self.this, peer_id, property, value)
    }

    #[inline]
    pub unsafe fn rset_unreliable(&mut self, property: GodotString, value: Variant) -> () {
        Node_rset_unreliable(self.this, property, value)
    }

    #[inline]
    pub unsafe fn rset_unreliable_id(&mut self, peer_id: i64, property: GodotString, value: Variant) -> () {
        Node_rset_unreliable_id(self.this, peer_id, property, value)
    }

    #[inline]
    pub unsafe fn set_custom_multiplayer(&mut self, api: Option<MultiplayerAPI>) -> () {
        Node_set_custom_multiplayer(self.this, api)
    }

    #[inline]
    pub unsafe fn set_display_folded(&mut self, fold: bool) -> () {
        Node_set_display_folded(self.this, fold)
    }

    #[inline]
    pub unsafe fn set_filename(&mut self, filename: GodotString) -> () {
        Node_set_filename(self.this, filename)
    }

    #[inline]
    pub unsafe fn set_name(&mut self, name: GodotString) -> () {
        Node_set_name(self.this, name)
    }

    #[inline]
    pub unsafe fn set_network_master(&mut self, id: i64, recursive: bool) -> () {
        Node_set_network_master(self.this, id, recursive)
    }

    #[inline]
    pub unsafe fn set_owner(&mut self, owner: Option<Node>) -> () {
        Node_set_owner(self.this, owner)
    }

    #[inline]
    pub unsafe fn set_pause_mode(&mut self, mode: i64) -> () {
        Node_set_pause_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_physics_process(&mut self, enable: bool) -> () {
        Node_set_physics_process(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_physics_process_internal(&mut self, enable: bool) -> () {
        Node_set_physics_process_internal(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_process(&mut self, enable: bool) -> () {
        Node_set_process(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_process_input(&mut self, enable: bool) -> () {
        Node_set_process_input(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_process_internal(&mut self, enable: bool) -> () {
        Node_set_process_internal(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_process_priority(&mut self, priority: i64) -> () {
        Node_set_process_priority(self.this, priority)
    }

    #[inline]
    pub unsafe fn set_process_unhandled_input(&mut self, enable: bool) -> () {
        Node_set_process_unhandled_input(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_process_unhandled_key_input(&mut self, enable: bool) -> () {
        Node_set_process_unhandled_key_input(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_scene_instance_load_placeholder(&mut self, load_placeholder: bool) -> () {
        Node_set_scene_instance_load_placeholder(self.this, load_placeholder)
    }

    #[inline]
    pub unsafe fn update_configuration_warning(&mut self) -> () {
        Node_update_configuration_warning(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Node2D` inherits `CanvasItem` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_node2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Node2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Node2D::free`.
///
/// ## Class hierarchy
///
/// Node2D inherits methods from:
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Node2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Node2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Node2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Node2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Node2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn apply_scale(&mut self, ratio: Vector2) -> () {
        Node2D_apply_scale(self.this, ratio)
    }

    #[inline]
    pub unsafe fn get_angle_to(&self, point: Vector2) -> f64 {
        Node2D_get_angle_to(self.this, point)
    }

    #[inline]
    pub unsafe fn get_global_position(&self) -> Vector2 {
        Node2D_get_global_position(self.this)
    }

    #[inline]
    pub unsafe fn get_global_rotation(&self) -> f64 {
        Node2D_get_global_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_global_rotation_degrees(&self) -> f64 {
        Node2D_get_global_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_global_scale(&self) -> Vector2 {
        Node2D_get_global_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_position(&self) -> Vector2 {
        Node2D_get_position(self.this)
    }

    #[inline]
    pub unsafe fn get_relative_transform_to_parent(&self, parent: Option<Node>) -> Transform2D {
        Node2D_get_relative_transform_to_parent(self.this, parent)
    }

    #[inline]
    pub unsafe fn get_rotation(&self) -> f64 {
        Node2D_get_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation_degrees(&self) -> f64 {
        Node2D_get_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_scale(&self) -> Vector2 {
        Node2D_get_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_z_index(&self) -> i64 {
        Node2D_get_z_index(self.this)
    }

    #[inline]
    pub unsafe fn global_translate(&mut self, offset: Vector2) -> () {
        Node2D_global_translate(self.this, offset)
    }

    #[inline]
    pub unsafe fn is_z_relative(&self) -> bool {
        Node2D_is_z_relative(self.this)
    }

    #[inline]
    pub unsafe fn look_at(&mut self, point: Vector2) -> () {
        Node2D_look_at(self.this, point)
    }

    #[inline]
    pub unsafe fn move_local_x(&mut self, delta: f64, scaled: bool) -> () {
        Node2D_move_local_x(self.this, delta, scaled)
    }

    #[inline]
    pub unsafe fn move_local_y(&mut self, delta: f64, scaled: bool) -> () {
        Node2D_move_local_y(self.this, delta, scaled)
    }

    #[inline]
    pub unsafe fn rotate(&mut self, radians: f64) -> () {
        Node2D_rotate(self.this, radians)
    }

    #[inline]
    pub unsafe fn set_global_position(&mut self, position: Vector2) -> () {
        Node2D_set_global_position(self.this, position)
    }

    #[inline]
    pub unsafe fn set_global_rotation(&mut self, radians: f64) -> () {
        Node2D_set_global_rotation(self.this, radians)
    }

    #[inline]
    pub unsafe fn set_global_rotation_degrees(&mut self, degrees: f64) -> () {
        Node2D_set_global_rotation_degrees(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_global_scale(&mut self, scale: Vector2) -> () {
        Node2D_set_global_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_global_transform(&mut self, xform: Transform2D) -> () {
        Node2D_set_global_transform(self.this, xform)
    }

    #[inline]
    pub unsafe fn set_position(&mut self, position: Vector2) -> () {
        Node2D_set_position(self.this, position)
    }

    #[inline]
    pub unsafe fn set_rotation(&mut self, radians: f64) -> () {
        Node2D_set_rotation(self.this, radians)
    }

    #[inline]
    pub unsafe fn set_rotation_degrees(&mut self, degrees: f64) -> () {
        Node2D_set_rotation_degrees(self.this, degrees)
    }

    #[inline]
    pub unsafe fn set_scale(&mut self, scale: Vector2) -> () {
        Node2D_set_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_transform(&mut self, xform: Transform2D) -> () {
        Node2D_set_transform(self.this, xform)
    }

    #[inline]
    pub unsafe fn set_z_as_relative(&mut self, enable: bool) -> () {
        Node2D_set_z_as_relative(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_z_index(&mut self, z_index: i64) -> () {
        Node2D_set_z_index(self.this, z_index)
    }

    #[inline]
    pub unsafe fn to_global(&self, local_point: Vector2) -> Vector2 {
        Node2D_to_global(self.this, local_point)
    }

    #[inline]
    pub unsafe fn to_local(&self, global_point: Vector2) -> Vector2 {
        Node2D_to_local(self.this, global_point)
    }

    #[inline]
    pub unsafe fn translate(&mut self, offset: Vector2) -> () {
        Node2D_translate(self.this, offset)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class NoiseTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_noisetexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// NoiseTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NoiseTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl NoiseTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = NoiseTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            NoiseTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _generate_texture(&mut self) -> Option<Image> {
        unsafe { NoiseTexture__generate_texture(self.this) }
    }

    #[inline]
    pub fn _queue_update(&mut self) -> () {
        unsafe { NoiseTexture__queue_update(self.this) }
    }

    #[inline]
    pub fn _thread_done(&mut self, image: Option<Image>) -> () {
        unsafe { NoiseTexture__thread_done(self.this, image) }
    }

    #[inline]
    pub fn _update_texture(&mut self) -> () {
        unsafe { NoiseTexture__update_texture(self.this) }
    }

    #[inline]
    pub fn get_bump_strength(&mut self) -> f64 {
        unsafe { NoiseTexture_get_bump_strength(self.this) }
    }

    #[inline]
    pub fn get_noise(&mut self) -> Option<OpenSimplexNoise> {
        unsafe { NoiseTexture_get_noise(self.this) }
    }

    #[inline]
    pub fn get_seamless(&mut self) -> bool {
        unsafe { NoiseTexture_get_seamless(self.this) }
    }

    #[inline]
    pub fn is_normalmap(&mut self) -> bool {
        unsafe { NoiseTexture_is_normalmap(self.this) }
    }

    #[inline]
    pub fn set_as_normalmap(&mut self, as_normalmap: bool) -> () {
        unsafe { NoiseTexture_set_as_normalmap(self.this, as_normalmap) }
    }

    #[inline]
    pub fn set_bump_strength(&mut self, bump_strength: f64) -> () {
        unsafe { NoiseTexture_set_bump_strength(self.this, bump_strength) }
    }

    #[inline]
    pub fn set_height(&mut self, height: i64) -> () {
        unsafe { NoiseTexture_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_noise(&mut self, noise: Option<OpenSimplexNoise>) -> () {
        unsafe { NoiseTexture_set_noise(self.this, noise) }
    }

    #[inline]
    pub fn set_seamless(&mut self, seamless: bool) -> () {
        unsafe { NoiseTexture_set_seamless(self.this, seamless) }
    }

    #[inline]
    pub fn set_width(&mut self, width: i64) -> () {
        unsafe { NoiseTexture_set_width(self.this, width) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class OccluderPolygon2D` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_occluderpolygon2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// OccluderPolygon2D inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct OccluderPolygon2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OccluderPolygon2DCullMode {
    Disabled = 0,
    Clockwise = 1,
    CounterClockwise = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl OccluderPolygon2D {
    pub const CULL_CLOCKWISE: i64 = 1;
    pub const CULL_COUNTER_CLOCKWISE: i64 = 2;
    pub const CULL_DISABLED: i64 = 0;
}
impl OccluderPolygon2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = OccluderPolygon2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            OccluderPolygon2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_cull_mode(&self) -> OccluderPolygon2DCullMode {
        unsafe { OccluderPolygon2D_get_cull_mode(self.this) }
    }

    #[inline]
    pub fn get_polygon(&self) -> Vector2Array {
        unsafe { OccluderPolygon2D_get_polygon(self.this) }
    }

    #[inline]
    pub fn is_closed(&self) -> bool {
        unsafe { OccluderPolygon2D_is_closed(self.this) }
    }

    #[inline]
    pub fn set_closed(&mut self, closed: bool) -> () {
        unsafe { OccluderPolygon2D_set_closed(self.this, closed) }
    }

    #[inline]
    pub fn set_cull_mode(&mut self, cull_mode: i64) -> () {
        unsafe { OccluderPolygon2D_set_cull_mode(self.this, cull_mode) }
    }

    #[inline]
    pub fn set_polygon(&mut self, polygon: Vector2Array) -> () {
        unsafe { OccluderPolygon2D_set_polygon(self.this, polygon) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class OmniLight` inherits `Light` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_omnilight.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `OmniLight` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `OmniLight::free`.
///
/// ## Class hierarchy
///
/// OmniLight inherits methods from:
/// - [Light](struct.Light.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct OmniLight {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OmniLightShadowMode {
    DualParaboloid = 0,
    Cube = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OmniLightShadowDetail {
    Vertical = 0,
    Horizontal = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl OmniLight {
    pub const SHADOW_CUBE: i64 = 1;
    pub const SHADOW_DUAL_PARABOLOID: i64 = 0;
    pub const SHADOW_DETAIL_HORIZONTAL: i64 = 1;
    pub const SHADOW_DETAIL_VERTICAL: i64 = 0;
}
impl OmniLight {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `OmniLight::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = OmniLightMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            OmniLight {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_shadow_detail(&self) -> OmniLightShadowDetail {
        OmniLight_get_shadow_detail(self.this)
    }

    #[inline]
    pub unsafe fn get_shadow_mode(&self) -> OmniLightShadowMode {
        OmniLight_get_shadow_mode(self.this)
    }

    #[inline]
    pub unsafe fn set_shadow_detail(&mut self, detail: i64) -> () {
        OmniLight_set_shadow_detail(self.this, detail)
    }

    #[inline]
    pub unsafe fn set_shadow_mode(&mut self, mode: i64) -> () {
        OmniLight_set_shadow_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_light(&self) -> Light {
        // Not reference-counted.
        Light { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class OpenSimplexNoise` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_opensimplexnoise.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// OpenSimplexNoise inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct OpenSimplexNoise {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl OpenSimplexNoise {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = OpenSimplexNoiseMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            OpenSimplexNoise {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_image(&mut self, width: i64, height: i64) -> Option<Image> {
        unsafe { OpenSimplexNoise_get_image(self.this, width, height) }
    }

    #[inline]
    pub fn get_lacunarity(&self) -> f64 {
        unsafe { OpenSimplexNoise_get_lacunarity(self.this) }
    }

    #[inline]
    pub fn get_noise_1d(&mut self, x: f64) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_1d(self.this, x) }
    }

    #[inline]
    pub fn get_noise_2d(&mut self, x: f64, y: f64) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_2d(self.this, x, y) }
    }

    #[inline]
    pub fn get_noise_2dv(&mut self, pos: Vector2) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_2dv(self.this, pos) }
    }

    #[inline]
    pub fn get_noise_3d(&mut self, x: f64, y: f64, z: f64) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_3d(self.this, x, y, z) }
    }

    #[inline]
    pub fn get_noise_3dv(&mut self, pos: Vector3) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_3dv(self.this, pos) }
    }

    #[inline]
    pub fn get_noise_4d(&mut self, x: f64, y: f64, z: f64, w: f64) -> f64 {
        unsafe { OpenSimplexNoise_get_noise_4d(self.this, x, y, z, w) }
    }

    #[inline]
    pub fn get_octaves(&self) -> i64 {
        unsafe { OpenSimplexNoise_get_octaves(self.this) }
    }

    #[inline]
    pub fn get_period(&self) -> f64 {
        unsafe { OpenSimplexNoise_get_period(self.this) }
    }

    #[inline]
    pub fn get_persistence(&self) -> f64 {
        unsafe { OpenSimplexNoise_get_persistence(self.this) }
    }

    #[inline]
    pub fn get_seamless_image(&mut self, size: i64) -> Option<Image> {
        unsafe { OpenSimplexNoise_get_seamless_image(self.this, size) }
    }

    #[inline]
    pub fn get_seed(&mut self) -> i64 {
        unsafe { OpenSimplexNoise_get_seed(self.this) }
    }

    #[inline]
    pub fn set_lacunarity(&mut self, lacunarity: f64) -> () {
        unsafe { OpenSimplexNoise_set_lacunarity(self.this, lacunarity) }
    }

    #[inline]
    pub fn set_octaves(&mut self, octave_count: i64) -> () {
        unsafe { OpenSimplexNoise_set_octaves(self.this, octave_count) }
    }

    #[inline]
    pub fn set_period(&mut self, period: f64) -> () {
        unsafe { OpenSimplexNoise_set_period(self.this, period) }
    }

    #[inline]
    pub fn set_persistence(&mut self, persistence: f64) -> () {
        unsafe { OpenSimplexNoise_set_persistence(self.this, persistence) }
    }

    #[inline]
    pub fn set_seed(&mut self, seed: i64) -> () {
        unsafe { OpenSimplexNoise_set_seed(self.this, seed) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class OptionButton` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_optionbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `OptionButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `OptionButton::free`.
///
/// ## Class hierarchy
///
/// OptionButton inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct OptionButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl OptionButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `OptionButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = OptionButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            OptionButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _focused(&mut self, arg0: i64) -> () {
        OptionButton__focused(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _get_items(&self) -> VariantArray {
        OptionButton__get_items(self.this)
    }

    #[inline]
    pub unsafe fn _select_int(&mut self, arg0: i64) -> () {
        OptionButton__select_int(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _selected(&mut self, arg0: i64) -> () {
        OptionButton__selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _set_items(&mut self, arg0: VariantArray) -> () {
        OptionButton__set_items(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_icon_item(&mut self, texture: Option<Texture>, label: GodotString, id: i64) -> () {
        OptionButton_add_icon_item(self.this, texture, label, id)
    }

    #[inline]
    pub unsafe fn add_item(&mut self, label: GodotString, id: i64) -> () {
        OptionButton_add_item(self.this, label, id)
    }

    #[inline]
    pub unsafe fn add_separator(&mut self) -> () {
        OptionButton_add_separator(self.this)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        OptionButton_clear(self.this)
    }

    #[inline]
    pub unsafe fn get_item_count(&self) -> i64 {
        OptionButton_get_item_count(self.this)
    }

    #[inline]
    pub unsafe fn get_item_icon(&self, idx: i64) -> Option<Texture> {
        OptionButton_get_item_icon(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_id(&self, idx: i64) -> i64 {
        OptionButton_get_item_id(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_index(&self, id: i64) -> i64 {
        OptionButton_get_item_index(self.this, id)
    }

    #[inline]
    pub unsafe fn get_item_metadata(&self, idx: i64) -> Variant {
        OptionButton_get_item_metadata(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_text(&self, idx: i64) -> GodotString {
        OptionButton_get_item_text(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_popup(&self) -> Option<PopupMenu> {
        OptionButton_get_popup(self.this)
    }

    #[inline]
    pub unsafe fn get_selected(&self) -> i64 {
        OptionButton_get_selected(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_id(&self) -> i64 {
        OptionButton_get_selected_id(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_metadata(&self) -> Variant {
        OptionButton_get_selected_metadata(self.this)
    }

    #[inline]
    pub unsafe fn is_item_disabled(&self, idx: i64) -> bool {
        OptionButton_is_item_disabled(self.this, idx)
    }

    #[inline]
    pub unsafe fn remove_item(&mut self, idx: i64) -> () {
        OptionButton_remove_item(self.this, idx)
    }

    #[inline]
    pub unsafe fn select(&mut self, idx: i64) -> () {
        OptionButton_select(self.this, idx)
    }

    #[inline]
    pub unsafe fn set_item_disabled(&mut self, idx: i64, disabled: bool) -> () {
        OptionButton_set_item_disabled(self.this, idx, disabled)
    }

    #[inline]
    pub unsafe fn set_item_icon(&mut self, idx: i64, texture: Option<Texture>) -> () {
        OptionButton_set_item_icon(self.this, idx, texture)
    }

    #[inline]
    pub unsafe fn set_item_id(&mut self, idx: i64, id: i64) -> () {
        OptionButton_set_item_id(self.this, idx, id)
    }

    #[inline]
    pub unsafe fn set_item_metadata(&mut self, idx: i64, metadata: Variant) -> () {
        OptionButton_set_item_metadata(self.this, idx, metadata)
    }

    #[inline]
    pub unsafe fn set_item_text(&mut self, idx: i64, text: GodotString) -> () {
        OptionButton_set_item_text(self.this, idx, text)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PCKPacker` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pckpacker.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PCKPacker inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PCKPacker {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PCKPacker {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PCKPackerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PCKPacker {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_file(&mut self, pck_path: GodotString, source_path: GodotString) -> GodotResult {
        unsafe { PCKPacker_add_file(self.this, pck_path, source_path) }
    }

    #[inline]
    pub fn flush(&mut self, verbose: bool) -> GodotResult {
        unsafe { PCKPacker_flush(self.this, verbose) }
    }

    #[inline]
    pub fn pck_start(&mut self, pck_name: GodotString, alignment: i64) -> GodotResult {
        unsafe { PCKPacker_pck_start(self.this, pck_name, alignment) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PHashTranslation` inherits `Translation` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_phashtranslation.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PHashTranslation inherits methods from:
/// - [Translation](struct.Translation.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PHashTranslation {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PHashTranslation {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PHashTranslationMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PHashTranslation {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn generate(&mut self, from: Option<Translation>) -> () {
        unsafe { PHashTranslation_generate(self.this, from) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_translation(&self) -> Translation {
        unsafe {{ object::add_ref(self.this); }}
        Translation { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PackedDataContainer` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packeddatacontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PackedDataContainer inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PackedDataContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PackedDataContainer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PackedDataContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PackedDataContainer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> ByteArray {
        unsafe { PackedDataContainer__get_data(self.this) }
    }

    #[inline]
    pub fn _iter_get(&mut self, arg0: Variant) -> Variant {
        unsafe { PackedDataContainer__iter_get(self.this, arg0) }
    }

    #[inline]
    pub fn _iter_init(&mut self, arg0: VariantArray) -> Variant {
        unsafe { PackedDataContainer__iter_init(self.this, arg0) }
    }

    #[inline]
    pub fn _iter_next(&mut self, arg0: VariantArray) -> Variant {
        unsafe { PackedDataContainer__iter_next(self.this, arg0) }
    }

    #[inline]
    pub fn _set_data(&mut self, arg0: ByteArray) -> () {
        unsafe { PackedDataContainer__set_data(self.this, arg0) }
    }

    #[inline]
    pub fn pack(&mut self, value: Variant) -> GodotResult {
        unsafe { PackedDataContainer_pack(self.this, value) }
    }

    #[inline]
    pub fn size(&self) -> i64 {
        unsafe { PackedDataContainer_size(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PackedDataContainerRef` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packeddatacontainerref.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PackedDataContainerRef inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PackedDataContainerRef {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PackedDataContainerRef {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _is_dictionary(&self) -> bool {
        unsafe { PackedDataContainerRef__is_dictionary(self.this) }
    }

    #[inline]
    pub fn _iter_get(&mut self, arg0: Variant) -> Variant {
        unsafe { PackedDataContainerRef__iter_get(self.this, arg0) }
    }

    #[inline]
    pub fn _iter_init(&mut self, arg0: VariantArray) -> Variant {
        unsafe { PackedDataContainerRef__iter_init(self.this, arg0) }
    }

    #[inline]
    pub fn _iter_next(&mut self, arg0: VariantArray) -> Variant {
        unsafe { PackedDataContainerRef__iter_next(self.this, arg0) }
    }

    #[inline]
    pub fn size(&self) -> i64 {
        unsafe { PackedDataContainerRef_size(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PackedScene` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packedscene.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PackedScene inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PackedScene {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PackedSceneGenEditState {
    Disabled = 0,
    Instance = 1,
    Main = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl PackedScene {
    pub const GEN_EDIT_STATE_MAIN: i64 = 2;
    pub const GEN_EDIT_STATE_DISABLED: i64 = 0;
    pub const GEN_EDIT_STATE_INSTANCE: i64 = 1;
}
impl PackedScene {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PackedSceneMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PackedScene {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_bundled_scene(&self) -> Dictionary {
        unsafe { PackedScene__get_bundled_scene(self.this) }
    }

    #[inline]
    pub fn _set_bundled_scene(&mut self, arg0: Dictionary) -> () {
        unsafe { PackedScene__set_bundled_scene(self.this, arg0) }
    }

    #[inline]
    pub fn can_instance(&self) -> bool {
        unsafe { PackedScene_can_instance(self.this) }
    }

    #[inline]
    pub fn get_state(&mut self) -> Option<SceneState> {
        unsafe { PackedScene_get_state(self.this) }
    }

    #[inline]
    pub fn instance(&self, edit_state: i64) -> Option<Node> {
        unsafe { PackedScene_instance(self.this, edit_state) }
    }

    #[inline]
    pub fn pack(&mut self, path: Option<Node>) -> GodotResult {
        unsafe { PackedScene_pack(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PacketPeer` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packetpeer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PacketPeer inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PacketPeer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PacketPeer {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_available_packet_count(&self) -> i64 {
        unsafe { PacketPeer_get_available_packet_count(self.this) }
    }

    #[inline]
    pub fn get_encode_buffer_max_size(&self) -> i64 {
        unsafe { PacketPeer_get_encode_buffer_max_size(self.this) }
    }

    #[inline]
    pub fn get_packet(&mut self) -> ByteArray {
        unsafe { PacketPeer_get_packet(self.this) }
    }

    #[inline]
    pub fn get_packet_error(&self) -> GodotResult {
        unsafe { PacketPeer_get_packet_error(self.this) }
    }

    #[inline]
    pub fn get_var(&mut self, allow_objects: bool) -> Variant {
        unsafe { PacketPeer_get_var(self.this, allow_objects) }
    }

    #[inline]
    pub fn is_object_decoding_allowed(&self) -> bool {
        unsafe { PacketPeer_is_object_decoding_allowed(self.this) }
    }

    #[inline]
    pub fn put_packet(&mut self, buffer: ByteArray) -> GodotResult {
        unsafe { PacketPeer_put_packet(self.this, buffer) }
    }

    #[inline]
    pub fn put_var(&mut self, var: Variant, full_objects: bool) -> GodotResult {
        unsafe { PacketPeer_put_var(self.this, var, full_objects) }
    }

    #[inline]
    pub fn set_allow_object_decoding(&mut self, enable: bool) -> () {
        unsafe { PacketPeer_set_allow_object_decoding(self.this, enable) }
    }

    #[inline]
    pub fn set_encode_buffer_max_size(&mut self, max_size: i64) -> () {
        unsafe { PacketPeer_set_encode_buffer_max_size(self.this, max_size) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PacketPeerGDNative` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packetpeergdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PacketPeerGDNative inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PacketPeerGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PacketPeerGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PacketPeerGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PacketPeerGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PacketPeerStream` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packetpeerstream.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PacketPeerStream inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PacketPeerStream {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PacketPeerStream {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PacketPeerStreamMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PacketPeerStream {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_input_buffer_max_size(&self) -> i64 {
        unsafe { PacketPeerStream_get_input_buffer_max_size(self.this) }
    }

    #[inline]
    pub fn get_output_buffer_max_size(&self) -> i64 {
        unsafe { PacketPeerStream_get_output_buffer_max_size(self.this) }
    }

    #[inline]
    pub fn get_stream_peer(&self) -> Option<StreamPeer> {
        unsafe { PacketPeerStream_get_stream_peer(self.this) }
    }

    #[inline]
    pub fn set_input_buffer_max_size(&mut self, max_size_bytes: i64) -> () {
        unsafe { PacketPeerStream_set_input_buffer_max_size(self.this, max_size_bytes) }
    }

    #[inline]
    pub fn set_output_buffer_max_size(&mut self, max_size_bytes: i64) -> () {
        unsafe { PacketPeerStream_set_output_buffer_max_size(self.this, max_size_bytes) }
    }

    #[inline]
    pub fn set_stream_peer(&mut self, peer: Option<StreamPeer>) -> () {
        unsafe { PacketPeerStream_set_stream_peer(self.this, peer) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PacketPeerUDP` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_packetpeerudp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PacketPeerUDP inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PacketPeerUDP {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PacketPeerUDP {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PacketPeerUDPMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PacketPeerUDP {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { PacketPeerUDP_close(self.this) }
    }

    #[inline]
    pub fn get_packet_ip(&self) -> GodotString {
        unsafe { PacketPeerUDP_get_packet_ip(self.this) }
    }

    #[inline]
    pub fn get_packet_port(&self) -> i64 {
        unsafe { PacketPeerUDP_get_packet_port(self.this) }
    }

    #[inline]
    pub fn is_listening(&self) -> bool {
        unsafe { PacketPeerUDP_is_listening(self.this) }
    }

    #[inline]
    pub fn join_multicast_group(&mut self, multicast_address: GodotString, interface_name: GodotString) -> GodotResult {
        unsafe { PacketPeerUDP_join_multicast_group(self.this, multicast_address, interface_name) }
    }

    #[inline]
    pub fn leave_multicast_group(&mut self, multicast_address: GodotString, interface_name: GodotString) -> GodotResult {
        unsafe { PacketPeerUDP_leave_multicast_group(self.this, multicast_address, interface_name) }
    }

    #[inline]
    pub fn listen(&mut self, port: i64, bind_address: GodotString, recv_buf_size: i64) -> GodotResult {
        unsafe { PacketPeerUDP_listen(self.this, port, bind_address, recv_buf_size) }
    }

    #[inline]
    pub fn set_broadcast_enabled(&mut self, enabled: bool) -> () {
        unsafe { PacketPeerUDP_set_broadcast_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_dest_address(&mut self, host: GodotString, port: i64) -> GodotResult {
        unsafe { PacketPeerUDP_set_dest_address(self.this, host, port) }
    }

    #[inline]
    pub fn wait(&mut self) -> GodotResult {
        unsafe { PacketPeerUDP_wait(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Panel` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_panel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Panel` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Panel::free`.
///
/// ## Class hierarchy
///
/// Panel inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Panel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Panel {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Panel::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PanelMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Panel {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PanelContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_panelcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PanelContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PanelContainer::free`.
///
/// ## Class hierarchy
///
/// PanelContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PanelContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PanelContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PanelContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PanelContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PanelContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PanoramaSky` inherits `Sky` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_panoramasky.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PanoramaSky inherits methods from:
/// - [Sky](struct.Sky.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PanoramaSky {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PanoramaSky {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PanoramaSkyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PanoramaSky {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_panorama(&self) -> Option<Texture> {
        unsafe { PanoramaSky_get_panorama(self.this) }
    }

    #[inline]
    pub fn set_panorama(&mut self, texture: Option<Texture>) -> () {
        unsafe { PanoramaSky_set_panorama(self.this, texture) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_sky(&self) -> Sky {
        unsafe {{ object::add_ref(self.this); }}
        Sky { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ParallaxBackground` inherits `CanvasLayer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_parallaxbackground.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ParallaxBackground` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ParallaxBackground::free`.
///
/// ## Class hierarchy
///
/// ParallaxBackground inherits methods from:
/// - [CanvasLayer](struct.CanvasLayer.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ParallaxBackground {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ParallaxBackground {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ParallaxBackground::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ParallaxBackgroundMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ParallaxBackground {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _camera_moved(&mut self, arg0: Transform2D, arg1: Vector2) -> () {
        ParallaxBackground__camera_moved(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn get_limit_begin(&self) -> Vector2 {
        ParallaxBackground_get_limit_begin(self.this)
    }

    #[inline]
    pub unsafe fn get_limit_end(&self) -> Vector2 {
        ParallaxBackground_get_limit_end(self.this)
    }

    #[inline]
    pub unsafe fn get_scroll_base_offset(&self) -> Vector2 {
        ParallaxBackground_get_scroll_base_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_scroll_base_scale(&self) -> Vector2 {
        ParallaxBackground_get_scroll_base_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_scroll_offset(&self) -> Vector2 {
        ParallaxBackground_get_scroll_offset(self.this)
    }

    #[inline]
    pub unsafe fn is_ignore_camera_zoom(&mut self) -> bool {
        ParallaxBackground_is_ignore_camera_zoom(self.this)
    }

    #[inline]
    pub unsafe fn set_ignore_camera_zoom(&mut self, ignore: bool) -> () {
        ParallaxBackground_set_ignore_camera_zoom(self.this, ignore)
    }

    #[inline]
    pub unsafe fn set_limit_begin(&mut self, ofs: Vector2) -> () {
        ParallaxBackground_set_limit_begin(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_limit_end(&mut self, ofs: Vector2) -> () {
        ParallaxBackground_set_limit_end(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_scroll_base_offset(&mut self, ofs: Vector2) -> () {
        ParallaxBackground_set_scroll_base_offset(self.this, ofs)
    }

    #[inline]
    pub unsafe fn set_scroll_base_scale(&mut self, scale: Vector2) -> () {
        ParallaxBackground_set_scroll_base_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_scroll_offset(&mut self, ofs: Vector2) -> () {
        ParallaxBackground_set_scroll_offset(self.this, ofs)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_layer(&self) -> CanvasLayer {
        // Not reference-counted.
        CanvasLayer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ParallaxLayer` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_parallaxlayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ParallaxLayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ParallaxLayer::free`.
///
/// ## Class hierarchy
///
/// ParallaxLayer inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ParallaxLayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ParallaxLayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ParallaxLayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ParallaxLayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ParallaxLayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_mirroring(&self) -> Vector2 {
        ParallaxLayer_get_mirroring(self.this)
    }

    #[inline]
    pub unsafe fn get_motion_offset(&self) -> Vector2 {
        ParallaxLayer_get_motion_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_motion_scale(&self) -> Vector2 {
        ParallaxLayer_get_motion_scale(self.this)
    }

    #[inline]
    pub unsafe fn set_mirroring(&mut self, mirror: Vector2) -> () {
        ParallaxLayer_set_mirroring(self.this, mirror)
    }

    #[inline]
    pub unsafe fn set_motion_offset(&mut self, offset: Vector2) -> () {
        ParallaxLayer_set_motion_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_motion_scale(&mut self, scale: Vector2) -> () {
        ParallaxLayer_set_motion_scale(self.this, scale)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Particles` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_particles.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Particles` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Particles::free`.
///
/// ## Class hierarchy
///
/// Particles inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Particles {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ParticlesDrawOrder {
    Index = 0,
    Lifetime = 1,
    ViewDepth = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Particles {
    pub const DRAW_ORDER_VIEW_DEPTH: i64 = 2;
    pub const DRAW_ORDER_LIFETIME: i64 = 1;
    pub const DRAW_ORDER_INDEX: i64 = 0;
    pub const MAX_DRAW_PASSES: i64 = 4;
}
impl Particles {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Particles::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ParticlesMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Particles {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn capture_aabb(&self) -> Aabb {
        Particles_capture_aabb(self.this)
    }

    #[inline]
    pub unsafe fn get_amount(&self) -> i64 {
        Particles_get_amount(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_order(&self) -> ParticlesDrawOrder {
        Particles_get_draw_order(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_pass_mesh(&self, pass: i64) -> Option<Mesh> {
        Particles_get_draw_pass_mesh(self.this, pass)
    }

    #[inline]
    pub unsafe fn get_draw_passes(&self) -> i64 {
        Particles_get_draw_passes(self.this)
    }

    #[inline]
    pub unsafe fn get_explosiveness_ratio(&self) -> f64 {
        Particles_get_explosiveness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_fps(&self) -> i64 {
        Particles_get_fixed_fps(self.this)
    }

    #[inline]
    pub unsafe fn get_fractional_delta(&self) -> bool {
        Particles_get_fractional_delta(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime(&self) -> f64 {
        Particles_get_lifetime(self.this)
    }

    #[inline]
    pub unsafe fn get_one_shot(&self) -> bool {
        Particles_get_one_shot(self.this)
    }

    #[inline]
    pub unsafe fn get_pre_process_time(&self) -> f64 {
        Particles_get_pre_process_time(self.this)
    }

    #[inline]
    pub unsafe fn get_process_material(&self) -> Option<Material> {
        Particles_get_process_material(self.this)
    }

    #[inline]
    pub unsafe fn get_randomness_ratio(&self) -> f64 {
        Particles_get_randomness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        Particles_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_use_local_coordinates(&self) -> bool {
        Particles_get_use_local_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn get_visibility_aabb(&self) -> Aabb {
        Particles_get_visibility_aabb(self.this)
    }

    #[inline]
    pub unsafe fn is_emitting(&self) -> bool {
        Particles_is_emitting(self.this)
    }

    #[inline]
    pub unsafe fn restart(&mut self) -> () {
        Particles_restart(self.this)
    }

    #[inline]
    pub unsafe fn set_amount(&mut self, amount: i64) -> () {
        Particles_set_amount(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_draw_order(&mut self, order: i64) -> () {
        Particles_set_draw_order(self.this, order)
    }

    #[inline]
    pub unsafe fn set_draw_pass_mesh(&mut self, pass: i64, mesh: Option<Mesh>) -> () {
        Particles_set_draw_pass_mesh(self.this, pass, mesh)
    }

    #[inline]
    pub unsafe fn set_draw_passes(&mut self, passes: i64) -> () {
        Particles_set_draw_passes(self.this, passes)
    }

    #[inline]
    pub unsafe fn set_emitting(&mut self, emitting: bool) -> () {
        Particles_set_emitting(self.this, emitting)
    }

    #[inline]
    pub unsafe fn set_explosiveness_ratio(&mut self, ratio: f64) -> () {
        Particles_set_explosiveness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_fixed_fps(&mut self, fps: i64) -> () {
        Particles_set_fixed_fps(self.this, fps)
    }

    #[inline]
    pub unsafe fn set_fractional_delta(&mut self, enable: bool) -> () {
        Particles_set_fractional_delta(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_lifetime(&mut self, secs: f64) -> () {
        Particles_set_lifetime(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_one_shot(&mut self, enable: bool) -> () {
        Particles_set_one_shot(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_pre_process_time(&mut self, secs: f64) -> () {
        Particles_set_pre_process_time(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_process_material(&mut self, material: Option<Material>) -> () {
        Particles_set_process_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_randomness_ratio(&mut self, ratio: f64) -> () {
        Particles_set_randomness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, scale: f64) -> () {
        Particles_set_speed_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_use_local_coordinates(&mut self, enable: bool) -> () {
        Particles_set_use_local_coordinates(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_visibility_aabb(&mut self, aabb: Aabb) -> () {
        Particles_set_visibility_aabb(self.this, aabb)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Particles2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_particles2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Particles2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Particles2D::free`.
///
/// ## Class hierarchy
///
/// Particles2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Particles2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Particles2DDrawOrder {
    Index = 0,
    Lifetime = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Particles2D {
    pub const DRAW_ORDER_LIFETIME: i64 = 1;
    pub const DRAW_ORDER_INDEX: i64 = 0;
}
impl Particles2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Particles2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Particles2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Particles2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn capture_rect(&self) -> Rect2 {
        Particles2D_capture_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_amount(&self) -> i64 {
        Particles2D_get_amount(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_order(&self) -> Particles2DDrawOrder {
        Particles2D_get_draw_order(self.this)
    }

    #[inline]
    pub unsafe fn get_explosiveness_ratio(&self) -> f64 {
        Particles2D_get_explosiveness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_fixed_fps(&self) -> i64 {
        Particles2D_get_fixed_fps(self.this)
    }

    #[inline]
    pub unsafe fn get_fractional_delta(&self) -> bool {
        Particles2D_get_fractional_delta(self.this)
    }

    #[inline]
    pub unsafe fn get_lifetime(&self) -> f64 {
        Particles2D_get_lifetime(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_map(&self) -> Option<Texture> {
        Particles2D_get_normal_map(self.this)
    }

    #[inline]
    pub unsafe fn get_one_shot(&self) -> bool {
        Particles2D_get_one_shot(self.this)
    }

    #[inline]
    pub unsafe fn get_pre_process_time(&self) -> f64 {
        Particles2D_get_pre_process_time(self.this)
    }

    #[inline]
    pub unsafe fn get_process_material(&self) -> Option<Material> {
        Particles2D_get_process_material(self.this)
    }

    #[inline]
    pub unsafe fn get_randomness_ratio(&self) -> f64 {
        Particles2D_get_randomness_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        Particles2D_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Particles2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_use_local_coordinates(&self) -> bool {
        Particles2D_get_use_local_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn get_visibility_rect(&self) -> Rect2 {
        Particles2D_get_visibility_rect(self.this)
    }

    #[inline]
    pub unsafe fn is_emitting(&self) -> bool {
        Particles2D_is_emitting(self.this)
    }

    #[inline]
    pub unsafe fn restart(&mut self) -> () {
        Particles2D_restart(self.this)
    }

    #[inline]
    pub unsafe fn set_amount(&mut self, amount: i64) -> () {
        Particles2D_set_amount(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_draw_order(&mut self, order: i64) -> () {
        Particles2D_set_draw_order(self.this, order)
    }

    #[inline]
    pub unsafe fn set_emitting(&mut self, emitting: bool) -> () {
        Particles2D_set_emitting(self.this, emitting)
    }

    #[inline]
    pub unsafe fn set_explosiveness_ratio(&mut self, ratio: f64) -> () {
        Particles2D_set_explosiveness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_fixed_fps(&mut self, fps: i64) -> () {
        Particles2D_set_fixed_fps(self.this, fps)
    }

    #[inline]
    pub unsafe fn set_fractional_delta(&mut self, enable: bool) -> () {
        Particles2D_set_fractional_delta(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_lifetime(&mut self, secs: f64) -> () {
        Particles2D_set_lifetime(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_normal_map(&mut self, texture: Option<Texture>) -> () {
        Particles2D_set_normal_map(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_one_shot(&mut self, secs: bool) -> () {
        Particles2D_set_one_shot(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_pre_process_time(&mut self, secs: f64) -> () {
        Particles2D_set_pre_process_time(self.this, secs)
    }

    #[inline]
    pub unsafe fn set_process_material(&mut self, material: Option<Material>) -> () {
        Particles2D_set_process_material(self.this, material)
    }

    #[inline]
    pub unsafe fn set_randomness_ratio(&mut self, ratio: f64) -> () {
        Particles2D_set_randomness_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, scale: f64) -> () {
        Particles2D_set_speed_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Particles2D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_use_local_coordinates(&mut self, enable: bool) -> () {
        Particles2D_set_use_local_coordinates(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_visibility_rect(&mut self, visibility_rect: Rect2) -> () {
        Particles2D_set_visibility_rect(self.this, visibility_rect)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ParticlesMaterial` inherits `Material` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_particlesmaterial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ParticlesMaterial inherits methods from:
/// - [Material](struct.Material.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ParticlesMaterial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ParticlesMaterialFlags {
    FlagAlignYToVelocity = 0,
    FlagRotateY = 1,
    FlagDisableZ = 2,
    FlagMax = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ParticlesMaterialEmissionShape {
    Point = 0,
    Sphere = 1,
    Box = 2,
    Points = 3,
    DirectedPoints = 4,
    Max = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ParticlesMaterialParameter {
    ParamInitialLinearVelocity = 0,
    ParamAngularVelocity = 1,
    ParamOrbitVelocity = 2,
    ParamLinearAccel = 3,
    ParamRadialAccel = 4,
    ParamTangentialAccel = 5,
    ParamDamping = 6,
    ParamAngle = 7,
    ParamScale = 8,
    ParamHueVariation = 9,
    ParamAnimSpeed = 10,
    ParamAnimOffset = 11,
    ParamMax = 12,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ParticlesMaterial {
    pub const PARAM_INITIAL_LINEAR_VELOCITY: i64 = 0;
    pub const PARAM_HUE_VARIATION: i64 = 9;
    pub const PARAM_ANIM_SPEED: i64 = 10;
    pub const PARAM_DAMPING: i64 = 6;
    pub const FLAG_ALIGN_Y_TO_VELOCITY: i64 = 0;
    pub const PARAM_ORBIT_VELOCITY: i64 = 2;
    pub const EMISSION_SHAPE_BOX: i64 = 2;
    pub const FLAG_DISABLE_Z: i64 = 2;
    pub const EMISSION_SHAPE_POINT: i64 = 0;
    pub const EMISSION_SHAPE_MAX: i64 = 5;
    pub const FLAG_MAX: i64 = 3;
    pub const PARAM_ANIM_OFFSET: i64 = 11;
    pub const PARAM_MAX: i64 = 12;
    pub const PARAM_RADIAL_ACCEL: i64 = 4;
    pub const FLAG_ROTATE_Y: i64 = 1;
    pub const PARAM_SCALE: i64 = 8;
    pub const PARAM_LINEAR_ACCEL: i64 = 3;
    pub const PARAM_TANGENTIAL_ACCEL: i64 = 5;
    pub const PARAM_ANGLE: i64 = 7;
    pub const PARAM_ANGULAR_VELOCITY: i64 = 1;
    pub const EMISSION_SHAPE_SPHERE: i64 = 1;
    pub const EMISSION_SHAPE_POINTS: i64 = 3;
    pub const EMISSION_SHAPE_DIRECTED_POINTS: i64 = 4;
}
impl ParticlesMaterial {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ParticlesMaterialMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ParticlesMaterial {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_color(&self) -> Color {
        unsafe { ParticlesMaterial_get_color(self.this) }
    }

    #[inline]
    pub fn get_color_ramp(&self) -> Option<Texture> {
        unsafe { ParticlesMaterial_get_color_ramp(self.this) }
    }

    #[inline]
    pub fn get_direction(&self) -> Vector3 {
        unsafe { ParticlesMaterial_get_direction(self.this) }
    }

    #[inline]
    pub fn get_emission_box_extents(&self) -> Vector3 {
        unsafe { ParticlesMaterial_get_emission_box_extents(self.this) }
    }

    #[inline]
    pub fn get_emission_color_texture(&self) -> Option<Texture> {
        unsafe { ParticlesMaterial_get_emission_color_texture(self.this) }
    }

    #[inline]
    pub fn get_emission_normal_texture(&self) -> Option<Texture> {
        unsafe { ParticlesMaterial_get_emission_normal_texture(self.this) }
    }

    #[inline]
    pub fn get_emission_point_count(&self) -> i64 {
        unsafe { ParticlesMaterial_get_emission_point_count(self.this) }
    }

    #[inline]
    pub fn get_emission_point_texture(&self) -> Option<Texture> {
        unsafe { ParticlesMaterial_get_emission_point_texture(self.this) }
    }

    #[inline]
    pub fn get_emission_shape(&self) -> ParticlesMaterialEmissionShape {
        unsafe { ParticlesMaterial_get_emission_shape(self.this) }
    }

    #[inline]
    pub fn get_emission_sphere_radius(&self) -> f64 {
        unsafe { ParticlesMaterial_get_emission_sphere_radius(self.this) }
    }

    #[inline]
    pub fn get_flag(&self, flag: i64) -> bool {
        unsafe { ParticlesMaterial_get_flag(self.this, flag) }
    }

    #[inline]
    pub fn get_flatness(&self) -> f64 {
        unsafe { ParticlesMaterial_get_flatness(self.this) }
    }

    #[inline]
    pub fn get_gravity(&self) -> Vector3 {
        unsafe { ParticlesMaterial_get_gravity(self.this) }
    }

    #[inline]
    pub fn get_lifetime_randomness(&self) -> f64 {
        unsafe { ParticlesMaterial_get_lifetime_randomness(self.this) }
    }

    #[inline]
    pub fn get_param(&self, param: i64) -> f64 {
        unsafe { ParticlesMaterial_get_param(self.this, param) }
    }

    #[inline]
    pub fn get_param_randomness(&self, param: i64) -> f64 {
        unsafe { ParticlesMaterial_get_param_randomness(self.this, param) }
    }

    #[inline]
    pub fn get_param_texture(&self, param: i64) -> Option<Texture> {
        unsafe { ParticlesMaterial_get_param_texture(self.this, param) }
    }

    #[inline]
    pub fn get_spread(&self) -> f64 {
        unsafe { ParticlesMaterial_get_spread(self.this) }
    }

    #[inline]
    pub fn get_trail_color_modifier(&self) -> Option<GradientTexture> {
        unsafe { ParticlesMaterial_get_trail_color_modifier(self.this) }
    }

    #[inline]
    pub fn get_trail_divisor(&self) -> i64 {
        unsafe { ParticlesMaterial_get_trail_divisor(self.this) }
    }

    #[inline]
    pub fn get_trail_size_modifier(&self) -> Option<CurveTexture> {
        unsafe { ParticlesMaterial_get_trail_size_modifier(self.this) }
    }

    #[inline]
    pub fn set_color(&mut self, color: Color) -> () {
        unsafe { ParticlesMaterial_set_color(self.this, color) }
    }

    #[inline]
    pub fn set_color_ramp(&mut self, ramp: Option<Texture>) -> () {
        unsafe { ParticlesMaterial_set_color_ramp(self.this, ramp) }
    }

    #[inline]
    pub fn set_direction(&mut self, degrees: Vector3) -> () {
        unsafe { ParticlesMaterial_set_direction(self.this, degrees) }
    }

    #[inline]
    pub fn set_emission_box_extents(&mut self, extents: Vector3) -> () {
        unsafe { ParticlesMaterial_set_emission_box_extents(self.this, extents) }
    }

    #[inline]
    pub fn set_emission_color_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { ParticlesMaterial_set_emission_color_texture(self.this, texture) }
    }

    #[inline]
    pub fn set_emission_normal_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { ParticlesMaterial_set_emission_normal_texture(self.this, texture) }
    }

    #[inline]
    pub fn set_emission_point_count(&mut self, point_count: i64) -> () {
        unsafe { ParticlesMaterial_set_emission_point_count(self.this, point_count) }
    }

    #[inline]
    pub fn set_emission_point_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { ParticlesMaterial_set_emission_point_texture(self.this, texture) }
    }

    #[inline]
    pub fn set_emission_shape(&mut self, shape: i64) -> () {
        unsafe { ParticlesMaterial_set_emission_shape(self.this, shape) }
    }

    #[inline]
    pub fn set_emission_sphere_radius(&mut self, radius: f64) -> () {
        unsafe { ParticlesMaterial_set_emission_sphere_radius(self.this, radius) }
    }

    #[inline]
    pub fn set_flag(&mut self, flag: i64, enable: bool) -> () {
        unsafe { ParticlesMaterial_set_flag(self.this, flag, enable) }
    }

    #[inline]
    pub fn set_flatness(&mut self, amount: f64) -> () {
        unsafe { ParticlesMaterial_set_flatness(self.this, amount) }
    }

    #[inline]
    pub fn set_gravity(&mut self, accel_vec: Vector3) -> () {
        unsafe { ParticlesMaterial_set_gravity(self.this, accel_vec) }
    }

    #[inline]
    pub fn set_lifetime_randomness(&mut self, randomness: f64) -> () {
        unsafe { ParticlesMaterial_set_lifetime_randomness(self.this, randomness) }
    }

    #[inline]
    pub fn set_param(&mut self, param: i64, value: f64) -> () {
        unsafe { ParticlesMaterial_set_param(self.this, param, value) }
    }

    #[inline]
    pub fn set_param_randomness(&mut self, param: i64, randomness: f64) -> () {
        unsafe { ParticlesMaterial_set_param_randomness(self.this, param, randomness) }
    }

    #[inline]
    pub fn set_param_texture(&mut self, param: i64, texture: Option<Texture>) -> () {
        unsafe { ParticlesMaterial_set_param_texture(self.this, param, texture) }
    }

    #[inline]
    pub fn set_spread(&mut self, degrees: f64) -> () {
        unsafe { ParticlesMaterial_set_spread(self.this, degrees) }
    }

    #[inline]
    pub fn set_trail_color_modifier(&mut self, texture: Option<GradientTexture>) -> () {
        unsafe { ParticlesMaterial_set_trail_color_modifier(self.this, texture) }
    }

    #[inline]
    pub fn set_trail_divisor(&mut self, divisor: i64) -> () {
        unsafe { ParticlesMaterial_set_trail_divisor(self.this, divisor) }
    }

    #[inline]
    pub fn set_trail_size_modifier(&mut self, texture: Option<CurveTexture>) -> () {
        unsafe { ParticlesMaterial_set_trail_size_modifier(self.this, texture) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_material(&self) -> Material {
        unsafe {{ object::add_ref(self.this); }}
        Material { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Path` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_path.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Path` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Path::free`.
///
/// ## Class hierarchy
///
/// Path inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Path {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Path {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Path::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PathMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Path {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _curve_changed(&mut self) -> () {
        Path__curve_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_curve(&self) -> Option<Curve3D> {
        Path_get_curve(self.this)
    }

    #[inline]
    pub unsafe fn set_curve(&mut self, curve: Option<Curve3D>) -> () {
        Path_set_curve(self.this, curve)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Path2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_path2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Path2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Path2D::free`.
///
/// ## Class hierarchy
///
/// Path2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Path2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Path2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Path2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Path2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Path2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _curve_changed(&mut self) -> () {
        Path2D__curve_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_curve(&self) -> Option<Curve2D> {
        Path2D_get_curve(self.this)
    }

    #[inline]
    pub unsafe fn set_curve(&mut self, curve: Option<Curve2D>) -> () {
        Path2D_set_curve(self.this, curve)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PathFollow` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pathfollow.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PathFollow` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PathFollow::free`.
///
/// ## Class hierarchy
///
/// PathFollow inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PathFollow {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PathFollowRotationMode {
    None = 0,
    Y = 1,
    Xy = 2,
    Xyz = 3,
    Oriented = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl PathFollow {
    pub const ROTATION_NONE: i64 = 0;
    pub const ROTATION_XYZ: i64 = 3;
    pub const ROTATION_XY: i64 = 2;
    pub const ROTATION_ORIENTED: i64 = 4;
    pub const ROTATION_Y: i64 = 1;
}
impl PathFollow {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PathFollow::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PathFollowMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PathFollow {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_cubic_interpolation(&self) -> bool {
        PathFollow_get_cubic_interpolation(self.this)
    }

    #[inline]
    pub unsafe fn get_h_offset(&self) -> f64 {
        PathFollow_get_h_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> f64 {
        PathFollow_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation_mode(&self) -> PathFollowRotationMode {
        PathFollow_get_rotation_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_unit_offset(&self) -> f64 {
        PathFollow_get_unit_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_v_offset(&self) -> f64 {
        PathFollow_get_v_offset(self.this)
    }

    #[inline]
    pub unsafe fn has_loop(&self) -> bool {
        PathFollow_has_loop(self.this)
    }

    #[inline]
    pub unsafe fn set_cubic_interpolation(&mut self, enable: bool) -> () {
        PathFollow_set_cubic_interpolation(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_h_offset(&mut self, h_offset: f64) -> () {
        PathFollow_set_h_offset(self.this, h_offset)
    }

    #[inline]
    pub unsafe fn set_loop(&mut self, _loop: bool) -> () {
        PathFollow_set_loop(self.this, _loop)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: f64) -> () {
        PathFollow_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_rotation_mode(&mut self, rotation_mode: i64) -> () {
        PathFollow_set_rotation_mode(self.this, rotation_mode)
    }

    #[inline]
    pub unsafe fn set_unit_offset(&mut self, unit_offset: f64) -> () {
        PathFollow_set_unit_offset(self.this, unit_offset)
    }

    #[inline]
    pub unsafe fn set_v_offset(&mut self, v_offset: f64) -> () {
        PathFollow_set_v_offset(self.this, v_offset)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PathFollow2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pathfollow2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PathFollow2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PathFollow2D::free`.
///
/// ## Class hierarchy
///
/// PathFollow2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PathFollow2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PathFollow2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PathFollow2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PathFollow2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PathFollow2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_cubic_interpolation(&self) -> bool {
        PathFollow2D_get_cubic_interpolation(self.this)
    }

    #[inline]
    pub unsafe fn get_h_offset(&self) -> f64 {
        PathFollow2D_get_h_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_lookahead(&self) -> f64 {
        PathFollow2D_get_lookahead(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> f64 {
        PathFollow2D_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_unit_offset(&self) -> f64 {
        PathFollow2D_get_unit_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_v_offset(&self) -> f64 {
        PathFollow2D_get_v_offset(self.this)
    }

    #[inline]
    pub unsafe fn has_loop(&self) -> bool {
        PathFollow2D_has_loop(self.this)
    }

    #[inline]
    pub unsafe fn is_rotating(&self) -> bool {
        PathFollow2D_is_rotating(self.this)
    }

    #[inline]
    pub unsafe fn set_cubic_interpolation(&mut self, enable: bool) -> () {
        PathFollow2D_set_cubic_interpolation(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_h_offset(&mut self, h_offset: f64) -> () {
        PathFollow2D_set_h_offset(self.this, h_offset)
    }

    #[inline]
    pub unsafe fn set_lookahead(&mut self, lookahead: f64) -> () {
        PathFollow2D_set_lookahead(self.this, lookahead)
    }

    #[inline]
    pub unsafe fn set_loop(&mut self, _loop: bool) -> () {
        PathFollow2D_set_loop(self.this, _loop)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: f64) -> () {
        PathFollow2D_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_rotate(&mut self, enable: bool) -> () {
        PathFollow2D_set_rotate(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_unit_offset(&mut self, unit_offset: f64) -> () {
        PathFollow2D_set_unit_offset(self.this, unit_offset)
    }

    #[inline]
    pub unsafe fn set_v_offset(&mut self, v_offset: f64) -> () {
        PathFollow2D_set_v_offset(self.this, v_offset)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Performance` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_performance.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Performance inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Performance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PerformanceMonitor {
    TimeFps = 0,
    TimeProcess = 1,
    TimePhysicsProcess = 2,
    MemoryStatic = 3,
    MemoryDynamic = 4,
    MemoryStaticMax = 5,
    MemoryDynamicMax = 6,
    MemoryMessageBufferMax = 7,
    ObjectCount = 8,
    ObjectResourceCount = 9,
    ObjectNodeCount = 10,
    ObjectOrphanNodeCount = 11,
    RenderObjectsInFrame = 12,
    RenderVerticesInFrame = 13,
    RenderMaterialChangesInFrame = 14,
    RenderShaderChangesInFrame = 15,
    RenderSurfaceChangesInFrame = 16,
    RenderDrawCallsInFrame = 17,
    RenderVideoMemUsed = 18,
    RenderTextureMemUsed = 19,
    RenderVertexMemUsed = 20,
    RenderUsageVideoMemTotal = 21,
    Physics2dActiveObjects = 22,
    Physics2dCollisionPairs = 23,
    Physics2dIslandCount = 24,
    Physics3dActiveObjects = 25,
    Physics3dCollisionPairs = 26,
    Physics3dIslandCount = 27,
    AudioOutputLatency = 28,
    Max = 29,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Performance {
    pub const MEMORY_STATIC_MAX: i64 = 5;
    pub const OBJECT_NODE_COUNT: i64 = 10;
    pub const PHYSICS_3D_ISLAND_COUNT: i64 = 27;
    pub const MEMORY_STATIC: i64 = 3;
    pub const MEMORY_DYNAMIC: i64 = 4;
    pub const PHYSICS_3D_COLLISION_PAIRS: i64 = 26;
    pub const OBJECT_COUNT: i64 = 8;
    pub const RENDER_OBJECTS_IN_FRAME: i64 = 12;
    pub const RENDER_MATERIAL_CHANGES_IN_FRAME: i64 = 14;
    pub const TIME_PHYSICS_PROCESS: i64 = 2;
    pub const PHYSICS_3D_ACTIVE_OBJECTS: i64 = 25;
    pub const MEMORY_MESSAGE_BUFFER_MAX: i64 = 7;
    pub const RENDER_DRAW_CALLS_IN_FRAME: i64 = 17;
    pub const RENDER_USAGE_VIDEO_MEM_TOTAL: i64 = 21;
    pub const AUDIO_OUTPUT_LATENCY: i64 = 28;
    pub const OBJECT_ORPHAN_NODE_COUNT: i64 = 11;
    pub const RENDER_SURFACE_CHANGES_IN_FRAME: i64 = 16;
    pub const PHYSICS_2D_ACTIVE_OBJECTS: i64 = 22;
    pub const PHYSICS_2D_ISLAND_COUNT: i64 = 24;
    pub const RENDER_VIDEO_MEM_USED: i64 = 18;
    pub const RENDER_SHADER_CHANGES_IN_FRAME: i64 = 15;
    pub const TIME_PROCESS: i64 = 1;
    pub const MONITOR_MAX: i64 = 29;
    pub const RENDER_VERTEX_MEM_USED: i64 = 20;
    pub const RENDER_TEXTURE_MEM_USED: i64 = 19;
    pub const OBJECT_RESOURCE_COUNT: i64 = 9;
    pub const RENDER_VERTICES_IN_FRAME: i64 = 13;
    pub const TIME_FPS: i64 = 0;
    pub const PHYSICS_2D_COLLISION_PAIRS: i64 = 23;
    pub const MEMORY_DYNAMIC_MAX: i64 = 6;
}
impl Performance {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Performance\0".as_ptr() as *mut _);

            Performance {
                this
            }
        }
    }
    #[inline]
    pub fn get_monitor(&self, monitor: i64) -> f64 {
        unsafe { Performance_get_monitor(self.this, monitor) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicalBone` inherits `PhysicsBody` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicalbone.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PhysicalBone` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PhysicalBone::free`.
///
/// ## Class hierarchy
///
/// PhysicalBone inherits methods from:
/// - [PhysicsBody](struct.PhysicsBody.html)
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicalBone {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicalBoneJointType {
    None = 0,
    Pin = 1,
    Cone = 2,
    Hinge = 3,
    Slider = 4,
    JointType6dof = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl PhysicalBone {
    pub const JOINT_TYPE_6DOF: i64 = 5;
    pub const JOINT_TYPE_NONE: i64 = 0;
    pub const JOINT_TYPE_CONE: i64 = 2;
    pub const JOINT_TYPE_HINGE: i64 = 3;
    pub const JOINT_TYPE_PIN: i64 = 1;
    pub const JOINT_TYPE_SLIDER: i64 = 4;
}
impl PhysicalBone {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PhysicalBone::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PhysicalBoneMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PhysicalBone {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _direct_state_changed(&mut self, arg0: Option<Object>) -> () {
        PhysicalBone__direct_state_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn apply_central_impulse(&mut self, impulse: Vector3) -> () {
        PhysicalBone_apply_central_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn apply_impulse(&mut self, position: Vector3, impulse: Vector3) -> () {
        PhysicalBone_apply_impulse(self.this, position, impulse)
    }

    #[inline]
    pub unsafe fn get_body_offset(&self) -> Transform {
        PhysicalBone_get_body_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_bone_id(&self) -> i64 {
        PhysicalBone_get_bone_id(self.this)
    }

    #[inline]
    pub unsafe fn get_bounce(&self) -> f64 {
        PhysicalBone_get_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_friction(&self) -> f64 {
        PhysicalBone_get_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_scale(&self) -> f64 {
        PhysicalBone_get_gravity_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_joint_offset(&self) -> Transform {
        PhysicalBone_get_joint_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_joint_type(&self) -> PhysicalBoneJointType {
        PhysicalBone_get_joint_type(self.this)
    }

    #[inline]
    pub unsafe fn get_mass(&self) -> f64 {
        PhysicalBone_get_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_simulate_physics(&mut self) -> bool {
        PhysicalBone_get_simulate_physics(self.this)
    }

    #[inline]
    pub unsafe fn get_weight(&self) -> f64 {
        PhysicalBone_get_weight(self.this)
    }

    #[inline]
    pub unsafe fn is_simulating_physics(&mut self) -> bool {
        PhysicalBone_is_simulating_physics(self.this)
    }

    #[inline]
    pub unsafe fn is_static_body(&mut self) -> bool {
        PhysicalBone_is_static_body(self.this)
    }

    #[inline]
    pub unsafe fn set_body_offset(&mut self, offset: Transform) -> () {
        PhysicalBone_set_body_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_bounce(&mut self, bounce: f64) -> () {
        PhysicalBone_set_bounce(self.this, bounce)
    }

    #[inline]
    pub unsafe fn set_friction(&mut self, friction: f64) -> () {
        PhysicalBone_set_friction(self.this, friction)
    }

    #[inline]
    pub unsafe fn set_gravity_scale(&mut self, gravity_scale: f64) -> () {
        PhysicalBone_set_gravity_scale(self.this, gravity_scale)
    }

    #[inline]
    pub unsafe fn set_joint_offset(&mut self, offset: Transform) -> () {
        PhysicalBone_set_joint_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_joint_type(&mut self, joint_type: i64) -> () {
        PhysicalBone_set_joint_type(self.this, joint_type)
    }

    #[inline]
    pub unsafe fn set_mass(&mut self, mass: f64) -> () {
        PhysicalBone_set_mass(self.this, mass)
    }

    #[inline]
    pub unsafe fn set_weight(&mut self, weight: f64) -> () {
        PhysicalBone_set_weight(self.this, weight)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body(&self) -> PhysicsBody {
        // Not reference-counted.
        PhysicsBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DDirectBodyState` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2ddirectbodystate.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Physics2DDirectBodyState inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DDirectBodyState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DDirectBodyState {
    #[inline]
    pub unsafe fn add_central_force(&mut self, force: Vector2) -> () {
        Physics2DDirectBodyState_add_central_force(self.this, force)
    }

    #[inline]
    pub unsafe fn add_force(&mut self, offset: Vector2, force: Vector2) -> () {
        Physics2DDirectBodyState_add_force(self.this, offset, force)
    }

    #[inline]
    pub unsafe fn add_torque(&mut self, torque: f64) -> () {
        Physics2DDirectBodyState_add_torque(self.this, torque)
    }

    #[inline]
    pub unsafe fn apply_central_impulse(&mut self, impulse: Vector2) -> () {
        Physics2DDirectBodyState_apply_central_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn apply_impulse(&mut self, offset: Vector2, impulse: Vector2) -> () {
        Physics2DDirectBodyState_apply_impulse(self.this, offset, impulse)
    }

    #[inline]
    pub unsafe fn apply_torque_impulse(&mut self, impulse: f64) -> () {
        Physics2DDirectBodyState_apply_torque_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn get_angular_velocity(&self) -> f64 {
        Physics2DDirectBodyState_get_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_contact_collider(&self, contact_idx: i64) -> Rid {
        Physics2DDirectBodyState_get_contact_collider(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_id(&self, contact_idx: i64) -> i64 {
        Physics2DDirectBodyState_get_contact_collider_id(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_object(&self, contact_idx: i64) -> Option<Object> {
        Physics2DDirectBodyState_get_contact_collider_object(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_position(&self, contact_idx: i64) -> Vector2 {
        Physics2DDirectBodyState_get_contact_collider_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_shape(&self, contact_idx: i64) -> i64 {
        Physics2DDirectBodyState_get_contact_collider_shape(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_shape_metadata(&self, contact_idx: i64) -> Variant {
        Physics2DDirectBodyState_get_contact_collider_shape_metadata(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_velocity_at_position(&self, contact_idx: i64) -> Vector2 {
        Physics2DDirectBodyState_get_contact_collider_velocity_at_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_count(&self) -> i64 {
        Physics2DDirectBodyState_get_contact_count(self.this)
    }

    #[inline]
    pub unsafe fn get_contact_local_normal(&self, contact_idx: i64) -> Vector2 {
        Physics2DDirectBodyState_get_contact_local_normal(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_local_position(&self, contact_idx: i64) -> Vector2 {
        Physics2DDirectBodyState_get_contact_local_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_local_shape(&self, contact_idx: i64) -> i64 {
        Physics2DDirectBodyState_get_contact_local_shape(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_inverse_inertia(&self) -> f64 {
        Physics2DDirectBodyState_get_inverse_inertia(self.this)
    }

    #[inline]
    pub unsafe fn get_inverse_mass(&self) -> f64 {
        Physics2DDirectBodyState_get_inverse_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_velocity(&self) -> Vector2 {
        Physics2DDirectBodyState_get_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_space_state(&mut self) -> Option<Physics2DDirectSpaceState> {
        Physics2DDirectBodyState_get_space_state(self.this)
    }

    #[inline]
    pub unsafe fn get_step(&self) -> f64 {
        Physics2DDirectBodyState_get_step(self.this)
    }

    #[inline]
    pub unsafe fn get_total_angular_damp(&self) -> f64 {
        Physics2DDirectBodyState_get_total_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_total_gravity(&self) -> Vector2 {
        Physics2DDirectBodyState_get_total_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_total_linear_damp(&self) -> f64 {
        Physics2DDirectBodyState_get_total_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self) -> Transform2D {
        Physics2DDirectBodyState_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn integrate_forces(&mut self) -> () {
        Physics2DDirectBodyState_integrate_forces(self.this)
    }

    #[inline]
    pub unsafe fn is_sleeping(&self) -> bool {
        Physics2DDirectBodyState_is_sleeping(self.this)
    }

    #[inline]
    pub unsafe fn set_angular_velocity(&mut self, velocity: f64) -> () {
        Physics2DDirectBodyState_set_angular_velocity(self.this, velocity)
    }

    #[inline]
    pub unsafe fn set_linear_velocity(&mut self, velocity: Vector2) -> () {
        Physics2DDirectBodyState_set_linear_velocity(self.this, velocity)
    }

    #[inline]
    pub unsafe fn set_sleep_state(&mut self, enabled: bool) -> () {
        Physics2DDirectBodyState_set_sleep_state(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_transform(&mut self, transform: Transform2D) -> () {
        Physics2DDirectBodyState_set_transform(self.this, transform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DDirectBodyStateSW` inherits `Physics2DDirectBodyState` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2ddirectbodystatesw.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Physics2DDirectBodyStateSW inherits methods from:
/// - [Physics2DDirectBodyState](struct.Physics2DDirectBodyState.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DDirectBodyStateSW {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DDirectBodyStateSW {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_2d_direct_body_state(&self) -> Physics2DDirectBodyState {
        // Not reference-counted.
        Physics2DDirectBodyState { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DDirectSpaceState` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2ddirectspacestate.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Physics2DDirectSpaceState inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DDirectSpaceState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DDirectSpaceState {
    #[inline]
    pub unsafe fn cast_motion(&mut self, shape: Option<Physics2DShapeQueryParameters>) -> VariantArray {
        Physics2DDirectSpaceState_cast_motion(self.this, shape)
    }

    #[inline]
    pub unsafe fn collide_shape(&mut self, shape: Option<Physics2DShapeQueryParameters>, max_results: i64) -> VariantArray {
        Physics2DDirectSpaceState_collide_shape(self.this, shape, max_results)
    }

    #[inline]
    pub unsafe fn get_rest_info(&mut self, shape: Option<Physics2DShapeQueryParameters>) -> Dictionary {
        Physics2DDirectSpaceState_get_rest_info(self.this, shape)
    }

    #[inline]
    pub unsafe fn intersect_point(&mut self, point: Vector2, max_results: i64, exclude: VariantArray, collision_layer: i64, collide_with_bodies: bool, collide_with_areas: bool) -> VariantArray {
        Physics2DDirectSpaceState_intersect_point(self.this, point, max_results, exclude, collision_layer, collide_with_bodies, collide_with_areas)
    }

    #[inline]
    pub unsafe fn intersect_point_on_canvas(&mut self, point: Vector2, canvas_instance_id: i64, max_results: i64, exclude: VariantArray, collision_layer: i64, collide_with_bodies: bool, collide_with_areas: bool) -> VariantArray {
        Physics2DDirectSpaceState_intersect_point_on_canvas(self.this, point, canvas_instance_id, max_results, exclude, collision_layer, collide_with_bodies, collide_with_areas)
    }

    #[inline]
    pub unsafe fn intersect_ray(&mut self, from: Vector2, to: Vector2, exclude: VariantArray, collision_layer: i64, collide_with_bodies: bool, collide_with_areas: bool) -> Dictionary {
        Physics2DDirectSpaceState_intersect_ray(self.this, from, to, exclude, collision_layer, collide_with_bodies, collide_with_areas)
    }

    #[inline]
    pub unsafe fn intersect_shape(&mut self, shape: Option<Physics2DShapeQueryParameters>, max_results: i64) -> VariantArray {
        Physics2DDirectSpaceState_intersect_shape(self.this, shape, max_results)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Physics2DServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2dserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Physics2DServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerProcessInfo {
    InfoActiveObjects = 0,
    InfoCollisionPairs = 1,
    InfoIslandCount = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerAreaBodyStatus {
    AreaBodyAdded = 0,
    AreaBodyRemoved = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerDampedStringParam {
    DampedStringRestLength = 0,
    DampedStringStiffness = 1,
    DampedStringDamping = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerBodyMode {
    ModeStatic = 0,
    ModeKinematic = 1,
    ModeRigid = 2,
    ModeCharacter = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerShapeType {
    ShapeLine = 0,
    ShapeRay = 1,
    ShapeSegment = 2,
    ShapeCircle = 3,
    ShapeRectangle = 4,
    ShapeCapsule = 5,
    ShapeConvexPolygon = 6,
    ShapeConcavePolygon = 7,
    ShapeCustom = 8,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerJointParam {
    Bias = 0,
    MaxBias = 1,
    MaxForce = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerSpaceParameter {
    SpaceParamContactRecycleRadius = 0,
    SpaceParamContactMaxSeparation = 1,
    SpaceParamBodyMaxAllowedPenetration = 2,
    SpaceParamBodyLinearVelocitySleepThreshold = 3,
    SpaceParamBodyAngularVelocitySleepThreshold = 4,
    SpaceParamBodyTimeToSleep = 5,
    SpaceParamConstraintDefaultBias = 6,
    SpaceParamTestMotionMinContactDepth = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerJointType {
    JointPin = 0,
    JointGroove = 1,
    JointDampedSpring = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerCCDMode {
    ModeDisabled = 0,
    ModeCastRay = 1,
    ModeCastShape = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerBodyState {
    Transform = 0,
    LinearVelocity = 1,
    AngularVelocity = 2,
    Sleeping = 3,
    CanSleep = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerBodyParameter {
    BodyParamBounce = 0,
    BodyParamFriction = 1,
    BodyParamMass = 2,
    BodyParamInertia = 3,
    BodyParamGravityScale = 4,
    BodyParamLinearDamp = 5,
    BodyParamAngularDamp = 6,
    BodyParamMax = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerAreaSpaceOverrideMode {
    Disabled = 0,
    Combine = 1,
    CombineReplace = 2,
    Replace = 3,
    ReplaceCombine = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Physics2DServerAreaParameter {
    AreaParamGravity = 0,
    AreaParamGravityVector = 1,
    AreaParamGravityIsPoint = 2,
    AreaParamGravityDistanceScale = 3,
    AreaParamGravityPointAttenuation = 4,
    AreaParamLinearDamp = 5,
    AreaParamAngularDamp = 6,
    AreaParamPriority = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Physics2DServer {
    pub const BODY_PARAM_MASS: i64 = 2;
    pub const BODY_PARAM_INERTIA: i64 = 3;
    pub const DAMPED_STRING_STIFFNESS: i64 = 1;
    pub const SHAPE_LINE: i64 = 0;
    pub const BODY_PARAM_MAX: i64 = 7;
    pub const AREA_PARAM_GRAVITY: i64 = 0;
    pub const BODY_PARAM_GRAVITY_SCALE: i64 = 4;
    pub const BODY_STATE_CAN_SLEEP: i64 = 4;
    pub const SHAPE_SEGMENT: i64 = 2;
    pub const AREA_SPACE_OVERRIDE_COMBINE_REPLACE: i64 = 2;
    pub const JOINT_PARAM_MAX_BIAS: i64 = 1;
    pub const SHAPE_CONVEX_POLYGON: i64 = 6;
    pub const BODY_PARAM_ANGULAR_DAMP: i64 = 6;
    pub const AREA_SPACE_OVERRIDE_REPLACE_COMBINE: i64 = 4;
    pub const AREA_PARAM_GRAVITY_IS_POINT: i64 = 2;
    pub const SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD: i64 = 3;
    pub const SHAPE_RAY: i64 = 1;
    pub const DAMPED_STRING_DAMPING: i64 = 2;
    pub const CCD_MODE_CAST_SHAPE: i64 = 2;
    pub const INFO_ISLAND_COUNT: i64 = 2;
    pub const SHAPE_CAPSULE: i64 = 5;
    pub const BODY_MODE_RIGID: i64 = 2;
    pub const BODY_STATE_LINEAR_VELOCITY: i64 = 1;
    pub const BODY_MODE_KINEMATIC: i64 = 1;
    pub const SPACE_PARAM_BODY_MAX_ALLOWED_PENETRATION: i64 = 2;
    pub const AREA_SPACE_OVERRIDE_REPLACE: i64 = 3;
    pub const AREA_BODY_REMOVED: i64 = 1;
    pub const JOINT_DAMPED_SPRING: i64 = 2;
    pub const BODY_STATE_TRANSFORM: i64 = 0;
    pub const SHAPE_CUSTOM: i64 = 8;
    pub const BODY_PARAM_BOUNCE: i64 = 0;
    pub const SPACE_PARAM_CONTACT_RECYCLE_RADIUS: i64 = 0;
    pub const SPACE_PARAM_TEST_MOTION_MIN_CONTACT_DEPTH: i64 = 7;
    pub const JOINT_PARAM_BIAS: i64 = 0;
    pub const SHAPE_RECTANGLE: i64 = 4;
    pub const SPACE_PARAM_CONTACT_MAX_SEPARATION: i64 = 1;
    pub const AREA_BODY_ADDED: i64 = 0;
    pub const AREA_PARAM_GRAVITY_POINT_ATTENUATION: i64 = 4;
    pub const SHAPE_CONCAVE_POLYGON: i64 = 7;
    pub const AREA_PARAM_ANGULAR_DAMP: i64 = 6;
    pub const SPACE_PARAM_BODY_TIME_TO_SLEEP: i64 = 5;
    pub const BODY_STATE_SLEEPING: i64 = 3;
    pub const CCD_MODE_CAST_RAY: i64 = 1;
    pub const AREA_SPACE_OVERRIDE_DISABLED: i64 = 0;
    pub const DAMPED_STRING_REST_LENGTH: i64 = 0;
    pub const SPACE_PARAM_CONSTRAINT_DEFAULT_BIAS: i64 = 6;
    pub const BODY_PARAM_LINEAR_DAMP: i64 = 5;
    pub const AREA_PARAM_GRAVITY_DISTANCE_SCALE: i64 = 3;
    pub const JOINT_GROOVE: i64 = 1;
    pub const INFO_COLLISION_PAIRS: i64 = 1;
    pub const BODY_MODE_STATIC: i64 = 0;
    pub const JOINT_PARAM_MAX_FORCE: i64 = 2;
    pub const AREA_PARAM_LINEAR_DAMP: i64 = 5;
    pub const CCD_MODE_DISABLED: i64 = 0;
    pub const AREA_PARAM_PRIORITY: i64 = 7;
    pub const JOINT_PIN: i64 = 0;
    pub const INFO_ACTIVE_OBJECTS: i64 = 0;
    pub const BODY_MODE_CHARACTER: i64 = 3;
    pub const SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD: i64 = 4;
    pub const AREA_SPACE_OVERRIDE_COMBINE: i64 = 1;
    pub const SHAPE_CIRCLE: i64 = 3;
    pub const BODY_STATE_ANGULAR_VELOCITY: i64 = 2;
    pub const AREA_PARAM_GRAVITY_VECTOR: i64 = 1;
    pub const BODY_PARAM_FRICTION: i64 = 1;
}
impl Physics2DServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Physics2DServer\0".as_ptr() as *mut _);

            Physics2DServer {
                this
            }
        }
    }
    #[inline]
    pub fn area_add_shape(&mut self, area: Rid, shape: Rid, transform: Transform2D, disabled: bool) -> () {
        unsafe { Physics2DServer_area_add_shape(self.this, area, shape, transform, disabled) }
    }

    #[inline]
    pub fn area_attach_canvas_instance_id(&mut self, area: Rid, id: i64) -> () {
        unsafe { Physics2DServer_area_attach_canvas_instance_id(self.this, area, id) }
    }

    #[inline]
    pub fn area_attach_object_instance_id(&mut self, area: Rid, id: i64) -> () {
        unsafe { Physics2DServer_area_attach_object_instance_id(self.this, area, id) }
    }

    #[inline]
    pub fn area_clear_shapes(&mut self, area: Rid) -> () {
        unsafe { Physics2DServer_area_clear_shapes(self.this, area) }
    }

    #[inline]
    pub fn area_create(&mut self) -> Rid {
        unsafe { Physics2DServer_area_create(self.this) }
    }

    #[inline]
    pub fn area_get_canvas_instance_id(&self, area: Rid) -> i64 {
        unsafe { Physics2DServer_area_get_canvas_instance_id(self.this, area) }
    }

    #[inline]
    pub fn area_get_object_instance_id(&self, area: Rid) -> i64 {
        unsafe { Physics2DServer_area_get_object_instance_id(self.this, area) }
    }

    #[inline]
    pub fn area_get_param(&self, area: Rid, param: i64) -> Variant {
        unsafe { Physics2DServer_area_get_param(self.this, area, param) }
    }

    #[inline]
    pub fn area_get_shape(&self, area: Rid, shape_idx: i64) -> Rid {
        unsafe { Physics2DServer_area_get_shape(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_get_shape_count(&self, area: Rid) -> i64 {
        unsafe { Physics2DServer_area_get_shape_count(self.this, area) }
    }

    #[inline]
    pub fn area_get_shape_transform(&self, area: Rid, shape_idx: i64) -> Transform2D {
        unsafe { Physics2DServer_area_get_shape_transform(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_get_space(&self, area: Rid) -> Rid {
        unsafe { Physics2DServer_area_get_space(self.this, area) }
    }

    #[inline]
    pub fn area_get_space_override_mode(&self, area: Rid) -> Physics2DServerAreaSpaceOverrideMode {
        unsafe { Physics2DServer_area_get_space_override_mode(self.this, area) }
    }

    #[inline]
    pub fn area_get_transform(&self, area: Rid) -> Transform2D {
        unsafe { Physics2DServer_area_get_transform(self.this, area) }
    }

    #[inline]
    pub fn area_remove_shape(&mut self, area: Rid, shape_idx: i64) -> () {
        unsafe { Physics2DServer_area_remove_shape(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_set_area_monitor_callback(&mut self, area: Rid, receiver: Option<Object>, method: GodotString) -> () {
        unsafe { Physics2DServer_area_set_area_monitor_callback(self.this, area, receiver, method) }
    }

    #[inline]
    pub fn area_set_collision_layer(&mut self, area: Rid, layer: i64) -> () {
        unsafe { Physics2DServer_area_set_collision_layer(self.this, area, layer) }
    }

    #[inline]
    pub fn area_set_collision_mask(&mut self, area: Rid, mask: i64) -> () {
        unsafe { Physics2DServer_area_set_collision_mask(self.this, area, mask) }
    }

    #[inline]
    pub fn area_set_monitor_callback(&mut self, area: Rid, receiver: Option<Object>, method: GodotString) -> () {
        unsafe { Physics2DServer_area_set_monitor_callback(self.this, area, receiver, method) }
    }

    #[inline]
    pub fn area_set_monitorable(&mut self, area: Rid, monitorable: bool) -> () {
        unsafe { Physics2DServer_area_set_monitorable(self.this, area, monitorable) }
    }

    #[inline]
    pub fn area_set_param(&mut self, area: Rid, param: i64, value: Variant) -> () {
        unsafe { Physics2DServer_area_set_param(self.this, area, param, value) }
    }

    #[inline]
    pub fn area_set_shape(&mut self, area: Rid, shape_idx: i64, shape: Rid) -> () {
        unsafe { Physics2DServer_area_set_shape(self.this, area, shape_idx, shape) }
    }

    #[inline]
    pub fn area_set_shape_disabled(&mut self, area: Rid, shape_idx: i64, disabled: bool) -> () {
        unsafe { Physics2DServer_area_set_shape_disabled(self.this, area, shape_idx, disabled) }
    }

    #[inline]
    pub fn area_set_shape_transform(&mut self, area: Rid, shape_idx: i64, transform: Transform2D) -> () {
        unsafe { Physics2DServer_area_set_shape_transform(self.this, area, shape_idx, transform) }
    }

    #[inline]
    pub fn area_set_space(&mut self, area: Rid, space: Rid) -> () {
        unsafe { Physics2DServer_area_set_space(self.this, area, space) }
    }

    #[inline]
    pub fn area_set_space_override_mode(&mut self, area: Rid, mode: i64) -> () {
        unsafe { Physics2DServer_area_set_space_override_mode(self.this, area, mode) }
    }

    #[inline]
    pub fn area_set_transform(&mut self, area: Rid, transform: Transform2D) -> () {
        unsafe { Physics2DServer_area_set_transform(self.this, area, transform) }
    }

    #[inline]
    pub fn body_add_central_force(&mut self, body: Rid, force: Vector2) -> () {
        unsafe { Physics2DServer_body_add_central_force(self.this, body, force) }
    }

    #[inline]
    pub fn body_add_collision_exception(&mut self, body: Rid, excepted_body: Rid) -> () {
        unsafe { Physics2DServer_body_add_collision_exception(self.this, body, excepted_body) }
    }

    #[inline]
    pub fn body_add_force(&mut self, body: Rid, offset: Vector2, force: Vector2) -> () {
        unsafe { Physics2DServer_body_add_force(self.this, body, offset, force) }
    }

    #[inline]
    pub fn body_add_shape(&mut self, body: Rid, shape: Rid, transform: Transform2D, disabled: bool) -> () {
        unsafe { Physics2DServer_body_add_shape(self.this, body, shape, transform, disabled) }
    }

    #[inline]
    pub fn body_add_torque(&mut self, body: Rid, torque: f64) -> () {
        unsafe { Physics2DServer_body_add_torque(self.this, body, torque) }
    }

    #[inline]
    pub fn body_apply_central_impulse(&mut self, body: Rid, impulse: Vector2) -> () {
        unsafe { Physics2DServer_body_apply_central_impulse(self.this, body, impulse) }
    }

    #[inline]
    pub fn body_apply_impulse(&mut self, body: Rid, position: Vector2, impulse: Vector2) -> () {
        unsafe { Physics2DServer_body_apply_impulse(self.this, body, position, impulse) }
    }

    #[inline]
    pub fn body_apply_torque_impulse(&mut self, body: Rid, impulse: f64) -> () {
        unsafe { Physics2DServer_body_apply_torque_impulse(self.this, body, impulse) }
    }

    #[inline]
    pub fn body_attach_canvas_instance_id(&mut self, body: Rid, id: i64) -> () {
        unsafe { Physics2DServer_body_attach_canvas_instance_id(self.this, body, id) }
    }

    #[inline]
    pub fn body_attach_object_instance_id(&mut self, body: Rid, id: i64) -> () {
        unsafe { Physics2DServer_body_attach_object_instance_id(self.this, body, id) }
    }

    #[inline]
    pub fn body_clear_shapes(&mut self, body: Rid) -> () {
        unsafe { Physics2DServer_body_clear_shapes(self.this, body) }
    }

    #[inline]
    pub fn body_create(&mut self) -> Rid {
        unsafe { Physics2DServer_body_create(self.this) }
    }

    #[inline]
    pub fn body_get_canvas_instance_id(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_canvas_instance_id(self.this, body) }
    }

    #[inline]
    pub fn body_get_collision_layer(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_collision_layer(self.this, body) }
    }

    #[inline]
    pub fn body_get_collision_mask(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_collision_mask(self.this, body) }
    }

    #[inline]
    pub fn body_get_continuous_collision_detection_mode(&self, body: Rid) -> Physics2DServerCCDMode {
        unsafe { Physics2DServer_body_get_continuous_collision_detection_mode(self.this, body) }
    }

    #[inline]
    pub fn body_get_direct_state(&mut self, body: Rid) -> Option<Physics2DDirectBodyState> {
        unsafe { Physics2DServer_body_get_direct_state(self.this, body) }
    }

    #[inline]
    pub fn body_get_max_contacts_reported(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_max_contacts_reported(self.this, body) }
    }

    #[inline]
    pub fn body_get_mode(&self, body: Rid) -> Physics2DServerBodyMode {
        unsafe { Physics2DServer_body_get_mode(self.this, body) }
    }

    #[inline]
    pub fn body_get_object_instance_id(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_object_instance_id(self.this, body) }
    }

    #[inline]
    pub fn body_get_param(&self, body: Rid, param: i64) -> f64 {
        unsafe { Physics2DServer_body_get_param(self.this, body, param) }
    }

    #[inline]
    pub fn body_get_shape(&self, body: Rid, shape_idx: i64) -> Rid {
        unsafe { Physics2DServer_body_get_shape(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_get_shape_count(&self, body: Rid) -> i64 {
        unsafe { Physics2DServer_body_get_shape_count(self.this, body) }
    }

    #[inline]
    pub fn body_get_shape_metadata(&self, body: Rid, shape_idx: i64) -> Variant {
        unsafe { Physics2DServer_body_get_shape_metadata(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_get_shape_transform(&self, body: Rid, shape_idx: i64) -> Transform2D {
        unsafe { Physics2DServer_body_get_shape_transform(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_get_space(&self, body: Rid) -> Rid {
        unsafe { Physics2DServer_body_get_space(self.this, body) }
    }

    #[inline]
    pub fn body_get_state(&self, body: Rid, state: i64) -> Variant {
        unsafe { Physics2DServer_body_get_state(self.this, body, state) }
    }

    #[inline]
    pub fn body_is_omitting_force_integration(&self, body: Rid) -> bool {
        unsafe { Physics2DServer_body_is_omitting_force_integration(self.this, body) }
    }

    #[inline]
    pub fn body_remove_collision_exception(&mut self, body: Rid, excepted_body: Rid) -> () {
        unsafe { Physics2DServer_body_remove_collision_exception(self.this, body, excepted_body) }
    }

    #[inline]
    pub fn body_remove_shape(&mut self, body: Rid, shape_idx: i64) -> () {
        unsafe { Physics2DServer_body_remove_shape(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_set_axis_velocity(&mut self, body: Rid, axis_velocity: Vector2) -> () {
        unsafe { Physics2DServer_body_set_axis_velocity(self.this, body, axis_velocity) }
    }

    #[inline]
    pub fn body_set_collision_layer(&mut self, body: Rid, layer: i64) -> () {
        unsafe { Physics2DServer_body_set_collision_layer(self.this, body, layer) }
    }

    #[inline]
    pub fn body_set_collision_mask(&mut self, body: Rid, mask: i64) -> () {
        unsafe { Physics2DServer_body_set_collision_mask(self.this, body, mask) }
    }

    #[inline]
    pub fn body_set_continuous_collision_detection_mode(&mut self, body: Rid, mode: i64) -> () {
        unsafe { Physics2DServer_body_set_continuous_collision_detection_mode(self.this, body, mode) }
    }

    #[inline]
    pub fn body_set_force_integration_callback(&mut self, body: Rid, receiver: Option<Object>, method: GodotString, userdata: Variant) -> () {
        unsafe { Physics2DServer_body_set_force_integration_callback(self.this, body, receiver, method, userdata) }
    }

    #[inline]
    pub fn body_set_max_contacts_reported(&mut self, body: Rid, amount: i64) -> () {
        unsafe { Physics2DServer_body_set_max_contacts_reported(self.this, body, amount) }
    }

    #[inline]
    pub fn body_set_mode(&mut self, body: Rid, mode: i64) -> () {
        unsafe { Physics2DServer_body_set_mode(self.this, body, mode) }
    }

    #[inline]
    pub fn body_set_omit_force_integration(&mut self, body: Rid, enable: bool) -> () {
        unsafe { Physics2DServer_body_set_omit_force_integration(self.this, body, enable) }
    }

    #[inline]
    pub fn body_set_param(&mut self, body: Rid, param: i64, value: f64) -> () {
        unsafe { Physics2DServer_body_set_param(self.this, body, param, value) }
    }

    #[inline]
    pub fn body_set_shape(&mut self, body: Rid, shape_idx: i64, shape: Rid) -> () {
        unsafe { Physics2DServer_body_set_shape(self.this, body, shape_idx, shape) }
    }

    #[inline]
    pub fn body_set_shape_as_one_way_collision(&mut self, body: Rid, shape_idx: i64, enable: bool, margin: f64) -> () {
        unsafe { Physics2DServer_body_set_shape_as_one_way_collision(self.this, body, shape_idx, enable, margin) }
    }

    #[inline]
    pub fn body_set_shape_disabled(&mut self, body: Rid, shape_idx: i64, disabled: bool) -> () {
        unsafe { Physics2DServer_body_set_shape_disabled(self.this, body, shape_idx, disabled) }
    }

    #[inline]
    pub fn body_set_shape_metadata(&mut self, body: Rid, shape_idx: i64, metadata: Variant) -> () {
        unsafe { Physics2DServer_body_set_shape_metadata(self.this, body, shape_idx, metadata) }
    }

    #[inline]
    pub fn body_set_shape_transform(&mut self, body: Rid, shape_idx: i64, transform: Transform2D) -> () {
        unsafe { Physics2DServer_body_set_shape_transform(self.this, body, shape_idx, transform) }
    }

    #[inline]
    pub fn body_set_space(&mut self, body: Rid, space: Rid) -> () {
        unsafe { Physics2DServer_body_set_space(self.this, body, space) }
    }

    #[inline]
    pub fn body_set_state(&mut self, body: Rid, state: i64, value: Variant) -> () {
        unsafe { Physics2DServer_body_set_state(self.this, body, state, value) }
    }

    #[inline]
    pub fn body_test_motion(&mut self, body: Rid, from: Transform2D, motion: Vector2, infinite_inertia: bool, margin: f64, result: Option<Physics2DTestMotionResult>) -> bool {
        unsafe { Physics2DServer_body_test_motion(self.this, body, from, motion, infinite_inertia, margin, result) }
    }

    #[inline]
    pub fn capsule_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_capsule_shape_create(self.this) }
    }

    #[inline]
    pub fn circle_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_circle_shape_create(self.this) }
    }

    #[inline]
    pub fn concave_polygon_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_concave_polygon_shape_create(self.this) }
    }

    #[inline]
    pub fn convex_polygon_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_convex_polygon_shape_create(self.this) }
    }

    #[inline]
    pub fn damped_spring_joint_create(&mut self, anchor_a: Vector2, anchor_b: Vector2, body_a: Rid, body_b: Rid) -> Rid {
        unsafe { Physics2DServer_damped_spring_joint_create(self.this, anchor_a, anchor_b, body_a, body_b) }
    }

    #[inline]
    pub fn damped_string_joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { Physics2DServer_damped_string_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn damped_string_joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { Physics2DServer_damped_string_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn free_rid(&mut self, rid: Rid) -> () {
        unsafe { Physics2DServer_free_rid(self.this, rid) }
    }

    #[inline]
    pub fn get_process_info(&mut self, process_info: i64) -> i64 {
        unsafe { Physics2DServer_get_process_info(self.this, process_info) }
    }

    #[inline]
    pub fn groove_joint_create(&mut self, groove1_a: Vector2, groove2_a: Vector2, anchor_b: Vector2, body_a: Rid, body_b: Rid) -> Rid {
        unsafe { Physics2DServer_groove_joint_create(self.this, groove1_a, groove2_a, anchor_b, body_a, body_b) }
    }

    #[inline]
    pub fn joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { Physics2DServer_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn joint_get_type(&self, joint: Rid) -> Physics2DServerJointType {
        unsafe { Physics2DServer_joint_get_type(self.this, joint) }
    }

    #[inline]
    pub fn joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { Physics2DServer_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn line_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_line_shape_create(self.this) }
    }

    #[inline]
    pub fn pin_joint_create(&mut self, anchor: Vector2, body_a: Rid, body_b: Rid) -> Rid {
        unsafe { Physics2DServer_pin_joint_create(self.this, anchor, body_a, body_b) }
    }

    #[inline]
    pub fn ray_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_ray_shape_create(self.this) }
    }

    #[inline]
    pub fn rectangle_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_rectangle_shape_create(self.this) }
    }

    #[inline]
    pub fn segment_shape_create(&mut self) -> Rid {
        unsafe { Physics2DServer_segment_shape_create(self.this) }
    }

    #[inline]
    pub fn set_active(&mut self, active: bool) -> () {
        unsafe { Physics2DServer_set_active(self.this, active) }
    }

    #[inline]
    pub fn shape_get_data(&self, shape: Rid) -> Variant {
        unsafe { Physics2DServer_shape_get_data(self.this, shape) }
    }

    #[inline]
    pub fn shape_get_type(&self, shape: Rid) -> Physics2DServerShapeType {
        unsafe { Physics2DServer_shape_get_type(self.this, shape) }
    }

    #[inline]
    pub fn shape_set_data(&mut self, shape: Rid, data: Variant) -> () {
        unsafe { Physics2DServer_shape_set_data(self.this, shape, data) }
    }

    #[inline]
    pub fn space_create(&mut self) -> Rid {
        unsafe { Physics2DServer_space_create(self.this) }
    }

    #[inline]
    pub fn space_get_direct_state(&mut self, space: Rid) -> Option<Physics2DDirectSpaceState> {
        unsafe { Physics2DServer_space_get_direct_state(self.this, space) }
    }

    #[inline]
    pub fn space_get_param(&self, space: Rid, param: i64) -> f64 {
        unsafe { Physics2DServer_space_get_param(self.this, space, param) }
    }

    #[inline]
    pub fn space_is_active(&self, space: Rid) -> bool {
        unsafe { Physics2DServer_space_is_active(self.this, space) }
    }

    #[inline]
    pub fn space_set_active(&mut self, space: Rid, active: bool) -> () {
        unsafe { Physics2DServer_space_set_active(self.this, space, active) }
    }

    #[inline]
    pub fn space_set_param(&mut self, space: Rid, param: i64, value: f64) -> () {
        unsafe { Physics2DServer_space_set_param(self.this, space, param, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DServerSW` inherits `Physics2DServer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2dserversw.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Physics2DServerSW inherits methods from:
/// - [Physics2DServer](struct.Physics2DServer.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DServerSW {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DServerSW {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_2d_server(&self) -> Physics2DServer {
        // Not reference-counted.
        Physics2DServer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DShapeQueryParameters` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2dshapequeryparameters.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Physics2DShapeQueryParameters inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DShapeQueryParameters {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DShapeQueryParameters {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Physics2DShapeQueryParametersMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Physics2DShapeQueryParameters {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_collision_layer(&self) -> i64 {
        unsafe { Physics2DShapeQueryParameters_get_collision_layer(self.this) }
    }

    #[inline]
    pub fn get_exclude(&self) -> VariantArray {
        unsafe { Physics2DShapeQueryParameters_get_exclude(self.this) }
    }

    #[inline]
    pub fn get_margin(&self) -> f64 {
        unsafe { Physics2DShapeQueryParameters_get_margin(self.this) }
    }

    #[inline]
    pub fn get_motion(&self) -> Vector2 {
        unsafe { Physics2DShapeQueryParameters_get_motion(self.this) }
    }

    #[inline]
    pub fn get_shape_rid(&self) -> Rid {
        unsafe { Physics2DShapeQueryParameters_get_shape_rid(self.this) }
    }

    #[inline]
    pub fn get_transform(&self) -> Transform2D {
        unsafe { Physics2DShapeQueryParameters_get_transform(self.this) }
    }

    #[inline]
    pub fn is_collide_with_areas_enabled(&self) -> bool {
        unsafe { Physics2DShapeQueryParameters_is_collide_with_areas_enabled(self.this) }
    }

    #[inline]
    pub fn is_collide_with_bodies_enabled(&self) -> bool {
        unsafe { Physics2DShapeQueryParameters_is_collide_with_bodies_enabled(self.this) }
    }

    #[inline]
    pub fn set_collide_with_areas(&mut self, enable: bool) -> () {
        unsafe { Physics2DShapeQueryParameters_set_collide_with_areas(self.this, enable) }
    }

    #[inline]
    pub fn set_collide_with_bodies(&mut self, enable: bool) -> () {
        unsafe { Physics2DShapeQueryParameters_set_collide_with_bodies(self.this, enable) }
    }

    #[inline]
    pub fn set_collision_layer(&mut self, collision_layer: i64) -> () {
        unsafe { Physics2DShapeQueryParameters_set_collision_layer(self.this, collision_layer) }
    }

    #[inline]
    pub fn set_exclude(&mut self, exclude: VariantArray) -> () {
        unsafe { Physics2DShapeQueryParameters_set_exclude(self.this, exclude) }
    }

    #[inline]
    pub fn set_margin(&mut self, margin: f64) -> () {
        unsafe { Physics2DShapeQueryParameters_set_margin(self.this, margin) }
    }

    #[inline]
    pub fn set_motion(&mut self, motion: Vector2) -> () {
        unsafe { Physics2DShapeQueryParameters_set_motion(self.this, motion) }
    }

    #[inline]
    pub fn set_shape(&mut self, shape: Option<Resource>) -> () {
        unsafe { Physics2DShapeQueryParameters_set_shape(self.this, shape) }
    }

    #[inline]
    pub fn set_shape_rid(&mut self, shape: Rid) -> () {
        unsafe { Physics2DShapeQueryParameters_set_shape_rid(self.this, shape) }
    }

    #[inline]
    pub fn set_transform(&mut self, transform: Transform2D) -> () {
        unsafe { Physics2DShapeQueryParameters_set_transform(self.this, transform) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DShapeQueryResult` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2dshapequeryresult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Physics2DShapeQueryResult inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DShapeQueryResult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DShapeQueryResult {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_result_count(&self) -> i64 {
        unsafe { Physics2DShapeQueryResult_get_result_count(self.this) }
    }

    #[inline]
    pub fn get_result_object(&self, idx: i64) -> Option<Object> {
        unsafe { Physics2DShapeQueryResult_get_result_object(self.this, idx) }
    }

    #[inline]
    pub fn get_result_object_id(&self, idx: i64) -> i64 {
        unsafe { Physics2DShapeQueryResult_get_result_object_id(self.this, idx) }
    }

    #[inline]
    pub fn get_result_object_shape(&self, idx: i64) -> i64 {
        unsafe { Physics2DShapeQueryResult_get_result_object_shape(self.this, idx) }
    }

    #[inline]
    pub fn get_result_rid(&self, idx: i64) -> Rid {
        unsafe { Physics2DShapeQueryResult_get_result_rid(self.this, idx) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Physics2DTestMotionResult` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physics2dtestmotionresult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Physics2DTestMotionResult inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Physics2DTestMotionResult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Physics2DTestMotionResult {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Physics2DTestMotionResultMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Physics2DTestMotionResult {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_collider(&self) -> Option<Object> {
        unsafe { Physics2DTestMotionResult_get_collider(self.this) }
    }

    #[inline]
    pub fn get_collider_id(&self) -> i64 {
        unsafe { Physics2DTestMotionResult_get_collider_id(self.this) }
    }

    #[inline]
    pub fn get_collider_rid(&self) -> Rid {
        unsafe { Physics2DTestMotionResult_get_collider_rid(self.this) }
    }

    #[inline]
    pub fn get_collider_shape(&self) -> i64 {
        unsafe { Physics2DTestMotionResult_get_collider_shape(self.this) }
    }

    #[inline]
    pub fn get_collider_velocity(&self) -> Vector2 {
        unsafe { Physics2DTestMotionResult_get_collider_velocity(self.this) }
    }

    #[inline]
    pub fn get_collision_normal(&self) -> Vector2 {
        unsafe { Physics2DTestMotionResult_get_collision_normal(self.this) }
    }

    #[inline]
    pub fn get_collision_point(&self) -> Vector2 {
        unsafe { Physics2DTestMotionResult_get_collision_point(self.this) }
    }

    #[inline]
    pub fn get_motion(&self) -> Vector2 {
        unsafe { Physics2DTestMotionResult_get_motion(self.this) }
    }

    #[inline]
    pub fn get_motion_remainder(&self) -> Vector2 {
        unsafe { Physics2DTestMotionResult_get_motion_remainder(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsBody` inherits `CollisionObject` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsbody.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// PhysicsBody inherits methods from:
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsBody {
    #[inline]
    pub unsafe fn _get_layers(&self) -> i64 {
        PhysicsBody__get_layers(self.this)
    }

    #[inline]
    pub unsafe fn _set_layers(&mut self, mask: i64) -> () {
        PhysicsBody__set_layers(self.this, mask)
    }

    #[inline]
    pub unsafe fn add_collision_exception_with(&mut self, body: Option<Node>) -> () {
        PhysicsBody_add_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn get_collision_exceptions(&mut self) -> VariantArray {
        PhysicsBody_get_collision_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        PhysicsBody_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        PhysicsBody_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        PhysicsBody_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        PhysicsBody_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn remove_collision_exception_with(&mut self, body: Option<Node>) -> () {
        PhysicsBody_remove_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, layer: i64) -> () {
        PhysicsBody_set_collision_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        PhysicsBody_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        PhysicsBody_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        PhysicsBody_set_collision_mask_bit(self.this, bit, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsBody2D` inherits `CollisionObject2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsbody2d.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// PhysicsBody2D inherits methods from:
/// - [CollisionObject2D](struct.CollisionObject2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsBody2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsBody2D {
    #[inline]
    pub unsafe fn _get_layers(&self) -> i64 {
        PhysicsBody2D__get_layers(self.this)
    }

    #[inline]
    pub unsafe fn _set_layers(&mut self, mask: i64) -> () {
        PhysicsBody2D__set_layers(self.this, mask)
    }

    #[inline]
    pub unsafe fn add_collision_exception_with(&mut self, body: Option<Node>) -> () {
        PhysicsBody2D_add_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn get_collision_exceptions(&mut self) -> VariantArray {
        PhysicsBody2D_get_collision_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        PhysicsBody2D_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        PhysicsBody2D_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        PhysicsBody2D_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        PhysicsBody2D_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn remove_collision_exception_with(&mut self, body: Option<Node>) -> () {
        PhysicsBody2D_remove_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, layer: i64) -> () {
        PhysicsBody2D_set_collision_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        PhysicsBody2D_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        PhysicsBody2D_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        PhysicsBody2D_set_collision_mask_bit(self.this, bit, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object_2d(&self) -> CollisionObject2D {
        // Not reference-counted.
        CollisionObject2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsDirectBodyState` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsdirectbodystate.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// PhysicsDirectBodyState inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsDirectBodyState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsDirectBodyState {
    #[inline]
    pub unsafe fn add_central_force(&mut self, force: Vector3) -> () {
        PhysicsDirectBodyState_add_central_force(self.this, force)
    }

    #[inline]
    pub unsafe fn add_force(&mut self, force: Vector3, position: Vector3) -> () {
        PhysicsDirectBodyState_add_force(self.this, force, position)
    }

    #[inline]
    pub unsafe fn add_torque(&mut self, torque: Vector3) -> () {
        PhysicsDirectBodyState_add_torque(self.this, torque)
    }

    #[inline]
    pub unsafe fn apply_central_impulse(&mut self, j: Vector3) -> () {
        PhysicsDirectBodyState_apply_central_impulse(self.this, j)
    }

    #[inline]
    pub unsafe fn apply_impulse(&mut self, position: Vector3, j: Vector3) -> () {
        PhysicsDirectBodyState_apply_impulse(self.this, position, j)
    }

    #[inline]
    pub unsafe fn apply_torque_impulse(&mut self, j: Vector3) -> () {
        PhysicsDirectBodyState_apply_torque_impulse(self.this, j)
    }

    #[inline]
    pub unsafe fn get_angular_velocity(&self) -> Vector3 {
        PhysicsDirectBodyState_get_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_center_of_mass(&self) -> Vector3 {
        PhysicsDirectBodyState_get_center_of_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_contact_collider(&self, contact_idx: i64) -> Rid {
        PhysicsDirectBodyState_get_contact_collider(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_id(&self, contact_idx: i64) -> i64 {
        PhysicsDirectBodyState_get_contact_collider_id(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_object(&self, contact_idx: i64) -> Option<Object> {
        PhysicsDirectBodyState_get_contact_collider_object(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_position(&self, contact_idx: i64) -> Vector3 {
        PhysicsDirectBodyState_get_contact_collider_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_shape(&self, contact_idx: i64) -> i64 {
        PhysicsDirectBodyState_get_contact_collider_shape(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_collider_velocity_at_position(&self, contact_idx: i64) -> Vector3 {
        PhysicsDirectBodyState_get_contact_collider_velocity_at_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_count(&self) -> i64 {
        PhysicsDirectBodyState_get_contact_count(self.this)
    }

    #[inline]
    pub unsafe fn get_contact_impulse(&self, contact_idx: i64) -> f64 {
        PhysicsDirectBodyState_get_contact_impulse(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_local_normal(&self, contact_idx: i64) -> Vector3 {
        PhysicsDirectBodyState_get_contact_local_normal(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_local_position(&self, contact_idx: i64) -> Vector3 {
        PhysicsDirectBodyState_get_contact_local_position(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_contact_local_shape(&self, contact_idx: i64) -> i64 {
        PhysicsDirectBodyState_get_contact_local_shape(self.this, contact_idx)
    }

    #[inline]
    pub unsafe fn get_inverse_inertia(&self) -> Vector3 {
        PhysicsDirectBodyState_get_inverse_inertia(self.this)
    }

    #[inline]
    pub unsafe fn get_inverse_mass(&self) -> f64 {
        PhysicsDirectBodyState_get_inverse_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_velocity(&self) -> Vector3 {
        PhysicsDirectBodyState_get_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_principal_inertia_axes(&self) -> Basis {
        PhysicsDirectBodyState_get_principal_inertia_axes(self.this)
    }

    #[inline]
    pub unsafe fn get_space_state(&mut self) -> Option<PhysicsDirectSpaceState> {
        PhysicsDirectBodyState_get_space_state(self.this)
    }

    #[inline]
    pub unsafe fn get_step(&self) -> f64 {
        PhysicsDirectBodyState_get_step(self.this)
    }

    #[inline]
    pub unsafe fn get_total_angular_damp(&self) -> f64 {
        PhysicsDirectBodyState_get_total_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_total_gravity(&self) -> Vector3 {
        PhysicsDirectBodyState_get_total_gravity(self.this)
    }

    #[inline]
    pub unsafe fn get_total_linear_damp(&self) -> f64 {
        PhysicsDirectBodyState_get_total_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self) -> Transform {
        PhysicsDirectBodyState_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn integrate_forces(&mut self) -> () {
        PhysicsDirectBodyState_integrate_forces(self.this)
    }

    #[inline]
    pub unsafe fn is_sleeping(&self) -> bool {
        PhysicsDirectBodyState_is_sleeping(self.this)
    }

    #[inline]
    pub unsafe fn set_angular_velocity(&mut self, velocity: Vector3) -> () {
        PhysicsDirectBodyState_set_angular_velocity(self.this, velocity)
    }

    #[inline]
    pub unsafe fn set_linear_velocity(&mut self, velocity: Vector3) -> () {
        PhysicsDirectBodyState_set_linear_velocity(self.this, velocity)
    }

    #[inline]
    pub unsafe fn set_sleep_state(&mut self, enabled: bool) -> () {
        PhysicsDirectBodyState_set_sleep_state(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_transform(&mut self, transform: Transform) -> () {
        PhysicsDirectBodyState_set_transform(self.this, transform)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsDirectSpaceState` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsdirectspacestate.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// PhysicsDirectSpaceState inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsDirectSpaceState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsDirectSpaceState {
    #[inline]
    pub unsafe fn cast_motion(&mut self, shape: Option<PhysicsShapeQueryParameters>, motion: Vector3) -> VariantArray {
        PhysicsDirectSpaceState_cast_motion(self.this, shape, motion)
    }

    #[inline]
    pub unsafe fn collide_shape(&mut self, shape: Option<PhysicsShapeQueryParameters>, max_results: i64) -> VariantArray {
        PhysicsDirectSpaceState_collide_shape(self.this, shape, max_results)
    }

    #[inline]
    pub unsafe fn get_rest_info(&mut self, shape: Option<PhysicsShapeQueryParameters>) -> Dictionary {
        PhysicsDirectSpaceState_get_rest_info(self.this, shape)
    }

    #[inline]
    pub unsafe fn intersect_ray(&mut self, from: Vector3, to: Vector3, exclude: VariantArray, collision_mask: i64, collide_with_bodies: bool, collide_with_areas: bool) -> Dictionary {
        PhysicsDirectSpaceState_intersect_ray(self.this, from, to, exclude, collision_mask, collide_with_bodies, collide_with_areas)
    }

    #[inline]
    pub unsafe fn intersect_shape(&mut self, shape: Option<PhysicsShapeQueryParameters>, max_results: i64) -> VariantArray {
        PhysicsDirectSpaceState_intersect_shape(self.this, shape, max_results)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsMaterial` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsmaterial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PhysicsMaterial inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsMaterial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsMaterial {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PhysicsMaterialMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PhysicsMaterial {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_bounce(&self) -> f64 {
        unsafe { PhysicsMaterial_get_bounce(self.this) }
    }

    #[inline]
    pub fn get_friction(&self) -> f64 {
        unsafe { PhysicsMaterial_get_friction(self.this) }
    }

    #[inline]
    pub fn is_absorbent(&self) -> bool {
        unsafe { PhysicsMaterial_is_absorbent(self.this) }
    }

    #[inline]
    pub fn is_rough(&self) -> bool {
        unsafe { PhysicsMaterial_is_rough(self.this) }
    }

    #[inline]
    pub fn set_absorbent(&mut self, absorbent: bool) -> () {
        unsafe { PhysicsMaterial_set_absorbent(self.this, absorbent) }
    }

    #[inline]
    pub fn set_bounce(&mut self, bounce: f64) -> () {
        unsafe { PhysicsMaterial_set_bounce(self.this, bounce) }
    }

    #[inline]
    pub fn set_friction(&mut self, friction: f64) -> () {
        unsafe { PhysicsMaterial_set_friction(self.this, friction) }
    }

    #[inline]
    pub fn set_rough(&mut self, rough: bool) -> () {
        unsafe { PhysicsMaterial_set_rough(self.this, rough) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class PhysicsServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// PhysicsServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerBodyAxis {
    LinearX = 1,
    LinearY = 2,
    LinearZ = 4,
    AngularX = 8,
    AngularY = 16,
    AngularZ = 32,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerProcessInfo {
    InfoActiveObjects = 0,
    InfoCollisionPairs = 1,
    InfoIslandCount = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerAreaBodyStatus {
    AreaBodyAdded = 0,
    AreaBodyRemoved = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerBodyMode {
    ModeStatic = 0,
    ModeKinematic = 1,
    ModeRigid = 2,
    ModeCharacter = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerShapeType {
    ShapePlane = 0,
    ShapeRay = 1,
    ShapeSphere = 2,
    ShapeBox = 3,
    ShapeCapsule = 4,
    ShapeCylinder = 5,
    ShapeConvexPolygon = 6,
    ShapeConcavePolygon = 7,
    ShapeHeightmap = 8,
    ShapeCustom = 9,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerPinJointParam {
    PinJointBias = 0,
    PinJointDamping = 1,
    PinJointImpulseClamp = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerSpaceParameter {
    SpaceParamContactRecycleRadius = 0,
    SpaceParamContactMaxSeparation = 1,
    SpaceParamBodyMaxAllowedPenetration = 2,
    SpaceParamBodyLinearVelocitySleepThreshold = 3,
    SpaceParamBodyAngularVelocitySleepThreshold = 4,
    SpaceParamBodyTimeToSleep = 5,
    SpaceParamBodyAngularVelocityDampRatio = 6,
    SpaceParamConstraintDefaultBias = 7,
    SpaceParamTestMotionMinContactDepth = 8,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerConeTwistJointParam {
    ConeTwistJointSwingSpan = 0,
    ConeTwistJointTwistSpan = 1,
    ConeTwistJointBias = 2,
    ConeTwistJointSoftness = 3,
    ConeTwistJointRelaxation = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerJointType {
    JointPin = 0,
    JointHinge = 1,
    JointSlider = 2,
    JointConeTwist = 3,
    Joint6dof = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerBodyState {
    Transform = 0,
    LinearVelocity = 1,
    AngularVelocity = 2,
    Sleeping = 3,
    CanSleep = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerBodyParameter {
    BodyParamBounce = 0,
    BodyParamFriction = 1,
    BodyParamMass = 2,
    BodyParamGravityScale = 3,
    BodyParamLinearDamp = 4,
    BodyParamAngularDamp = 5,
    BodyParamMax = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerG6DOFJointAxisParam {
    G6dofJointLinearLowerLimit = 0,
    G6dofJointLinearUpperLimit = 1,
    G6dofJointLinearLimitSoftness = 2,
    G6dofJointLinearRestitution = 3,
    G6dofJointLinearDamping = 4,
    G6dofJointLinearMotorTargetVelocity = 5,
    G6dofJointLinearMotorForceLimit = 6,
    G6dofJointAngularLowerLimit = 10,
    G6dofJointAngularUpperLimit = 11,
    G6dofJointAngularLimitSoftness = 12,
    G6dofJointAngularDamping = 13,
    G6dofJointAngularRestitution = 14,
    G6dofJointAngularForceLimit = 15,
    G6dofJointAngularErp = 16,
    G6dofJointAngularMotorTargetVelocity = 17,
    G6dofJointAngularMotorForceLimit = 18,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerSliderJointParam {
    SliderJointLinearLimitUpper = 0,
    SliderJointLinearLimitLower = 1,
    SliderJointLinearLimitSoftness = 2,
    SliderJointLinearLimitRestitution = 3,
    SliderJointLinearLimitDamping = 4,
    SliderJointLinearMotionSoftness = 5,
    SliderJointLinearMotionRestitution = 6,
    SliderJointLinearMotionDamping = 7,
    SliderJointLinearOrthogonalSoftness = 8,
    SliderJointLinearOrthogonalRestitution = 9,
    SliderJointLinearOrthogonalDamping = 10,
    SliderJointAngularLimitUpper = 11,
    SliderJointAngularLimitLower = 12,
    SliderJointAngularLimitSoftness = 13,
    SliderJointAngularLimitRestitution = 14,
    SliderJointAngularLimitDamping = 15,
    SliderJointAngularMotionSoftness = 16,
    SliderJointAngularMotionRestitution = 17,
    SliderJointAngularMotionDamping = 18,
    SliderJointAngularOrthogonalSoftness = 19,
    SliderJointAngularOrthogonalRestitution = 20,
    SliderJointAngularOrthogonalDamping = 21,
    SliderJointMax = 22,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerHingeJointParam {
    HingeJointBias = 0,
    HingeJointLimitUpper = 1,
    HingeJointLimitLower = 2,
    HingeJointLimitBias = 3,
    HingeJointLimitSoftness = 4,
    HingeJointLimitRelaxation = 5,
    HingeJointMotorTargetVelocity = 6,
    HingeJointMotorMaxImpulse = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerG6DOFJointAxisFlag {
    G6dofJointFlagEnableLinearLimit = 0,
    G6dofJointFlagEnableAngularLimit = 1,
    G6dofJointFlagEnableMotor = 4,
    G6dofJointFlagEnableLinearMotor = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerHingeJointFlag {
    UseLimit = 0,
    EnableMotor = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerAreaSpaceOverrideMode {
    Disabled = 0,
    Combine = 1,
    CombineReplace = 2,
    Replace = 3,
    ReplaceCombine = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PhysicsServerAreaParameter {
    AreaParamGravity = 0,
    AreaParamGravityVector = 1,
    AreaParamGravityIsPoint = 2,
    AreaParamGravityDistanceScale = 3,
    AreaParamGravityPointAttenuation = 4,
    AreaParamLinearDamp = 5,
    AreaParamAngularDamp = 6,
    AreaParamPriority = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl PhysicsServer {
    pub const G6DOF_JOINT_ANGULAR_FORCE_LIMIT: i64 = 15;
    pub const AREA_PARAM_LINEAR_DAMP: i64 = 5;
    pub const SHAPE_BOX: i64 = 3;
    pub const SLIDER_JOINT_LINEAR_ORTHOGONAL_RESTITUTION: i64 = 9;
    pub const AREA_SPACE_OVERRIDE_REPLACE: i64 = 3;
    pub const AREA_SPACE_OVERRIDE_COMBINE_REPLACE: i64 = 2;
    pub const HINGE_JOINT_MOTOR_MAX_IMPULSE: i64 = 7;
    pub const SPACE_PARAM_CONTACT_RECYCLE_RADIUS: i64 = 0;
    pub const AREA_PARAM_GRAVITY_DISTANCE_SCALE: i64 = 3;
    pub const G6DOF_JOINT_ANGULAR_RESTITUTION: i64 = 14;
    pub const AREA_SPACE_OVERRIDE_COMBINE: i64 = 1;
    pub const BODY_AXIS_LINEAR_X: i64 = 1;
    pub const SPACE_PARAM_CONSTRAINT_DEFAULT_BIAS: i64 = 7;
    pub const INFO_ISLAND_COUNT: i64 = 2;
    pub const SLIDER_JOINT_ANGULAR_LIMIT_RESTITUTION: i64 = 14;
    pub const AREA_PARAM_GRAVITY_POINT_ATTENUATION: i64 = 4;
    pub const SLIDER_JOINT_ANGULAR_MOTION_SOFTNESS: i64 = 16;
    pub const G6DOF_JOINT_LINEAR_LIMIT_SOFTNESS: i64 = 2;
    pub const INFO_COLLISION_PAIRS: i64 = 1;
    pub const SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD: i64 = 3;
    pub const BODY_MODE_STATIC: i64 = 0;
    pub const G6DOF_JOINT_LINEAR_UPPER_LIMIT: i64 = 1;
    pub const SLIDER_JOINT_ANGULAR_LIMIT_SOFTNESS: i64 = 13;
    pub const AREA_PARAM_GRAVITY_VECTOR: i64 = 1;
    pub const INFO_ACTIVE_OBJECTS: i64 = 0;
    pub const G6DOF_JOINT_ANGULAR_UPPER_LIMIT: i64 = 11;
    pub const SHAPE_HEIGHTMAP: i64 = 8;
    pub const AREA_SPACE_OVERRIDE_DISABLED: i64 = 0;
    pub const SLIDER_JOINT_LINEAR_MOTION_SOFTNESS: i64 = 5;
    pub const AREA_BODY_ADDED: i64 = 0;
    pub const BODY_PARAM_FRICTION: i64 = 1;
    pub const SHAPE_CONVEX_POLYGON: i64 = 6;
    pub const SLIDER_JOINT_LINEAR_ORTHOGONAL_SOFTNESS: i64 = 8;
    pub const JOINT_SLIDER: i64 = 2;
    pub const G6DOF_JOINT_ANGULAR_ERP: i64 = 16;
    pub const SLIDER_JOINT_MAX: i64 = 22;
    pub const G6DOF_JOINT_FLAG_ENABLE_LINEAR_MOTOR: i64 = 5;
    pub const G6DOF_JOINT_FLAG_ENABLE_MOTOR: i64 = 4;
    pub const SLIDER_JOINT_LINEAR_LIMIT_LOWER: i64 = 1;
    pub const SHAPE_PLANE: i64 = 0;
    pub const SPACE_PARAM_TEST_MOTION_MIN_CONTACT_DEPTH: i64 = 8;
    pub const BODY_PARAM_BOUNCE: i64 = 0;
    pub const SHAPE_CUSTOM: i64 = 9;
    pub const CONE_TWIST_JOINT_SOFTNESS: i64 = 3;
    pub const AREA_PARAM_GRAVITY: i64 = 0;
    pub const SLIDER_JOINT_ANGULAR_LIMIT_LOWER: i64 = 12;
    pub const AREA_BODY_REMOVED: i64 = 1;
    pub const HINGE_JOINT_BIAS: i64 = 0;
    pub const BODY_STATE_LINEAR_VELOCITY: i64 = 1;
    pub const SPACE_PARAM_BODY_MAX_ALLOWED_PENETRATION: i64 = 2;
    pub const AREA_SPACE_OVERRIDE_REPLACE_COMBINE: i64 = 4;
    pub const BODY_MODE_RIGID: i64 = 2;
    pub const SHAPE_CYLINDER: i64 = 5;
    pub const PIN_JOINT_BIAS: i64 = 0;
    pub const PIN_JOINT_IMPULSE_CLAMP: i64 = 2;
    pub const SLIDER_JOINT_ANGULAR_MOTION_DAMPING: i64 = 18;
    pub const SLIDER_JOINT_ANGULAR_LIMIT_UPPER: i64 = 11;
    pub const G6DOF_JOINT_ANGULAR_MOTOR_FORCE_LIMIT: i64 = 18;
    pub const HINGE_JOINT_LIMIT_UPPER: i64 = 1;
    pub const BODY_AXIS_LINEAR_Y: i64 = 2;
    pub const BODY_AXIS_ANGULAR_Y: i64 = 16;
    pub const SLIDER_JOINT_ANGULAR_LIMIT_DAMPING: i64 = 15;
    pub const SLIDER_JOINT_LINEAR_LIMIT_DAMPING: i64 = 4;
    pub const SLIDER_JOINT_LINEAR_ORTHOGONAL_DAMPING: i64 = 10;
    pub const SLIDER_JOINT_ANGULAR_MOTION_RESTITUTION: i64 = 17;
    pub const SPACE_PARAM_BODY_TIME_TO_SLEEP: i64 = 5;
    pub const G6DOF_JOINT_LINEAR_MOTOR_TARGET_VELOCITY: i64 = 5;
    pub const JOINT_PIN: i64 = 0;
    pub const G6DOF_JOINT_FLAG_ENABLE_ANGULAR_LIMIT: i64 = 1;
    pub const CONE_TWIST_JOINT_RELAXATION: i64 = 4;
    pub const BODY_PARAM_MAX: i64 = 6;
    pub const SHAPE_RAY: i64 = 1;
    pub const G6DOF_JOINT_ANGULAR_DAMPING: i64 = 13;
    pub const G6DOF_JOINT_LINEAR_DAMPING: i64 = 4;
    pub const JOINT_6DOF: i64 = 4;
    pub const BODY_PARAM_GRAVITY_SCALE: i64 = 3;
    pub const SHAPE_SPHERE: i64 = 2;
    pub const HINGE_JOINT_LIMIT_SOFTNESS: i64 = 4;
    pub const CONE_TWIST_JOINT_TWIST_SPAN: i64 = 1;
    pub const BODY_MODE_KINEMATIC: i64 = 1;
    pub const BODY_PARAM_ANGULAR_DAMP: i64 = 5;
    pub const BODY_STATE_TRANSFORM: i64 = 0;
    pub const BODY_PARAM_LINEAR_DAMP: i64 = 4;
    pub const BODY_AXIS_LINEAR_Z: i64 = 4;
    pub const G6DOF_JOINT_LINEAR_LOWER_LIMIT: i64 = 0;
    pub const HINGE_JOINT_FLAG_USE_LIMIT: i64 = 0;
    pub const SLIDER_JOINT_ANGULAR_ORTHOGONAL_DAMPING: i64 = 21;
    pub const BODY_AXIS_ANGULAR_Z: i64 = 32;
    pub const BODY_AXIS_ANGULAR_X: i64 = 8;
    pub const G6DOF_JOINT_FLAG_ENABLE_LINEAR_LIMIT: i64 = 0;
    pub const BODY_STATE_ANGULAR_VELOCITY: i64 = 2;
    pub const G6DOF_JOINT_LINEAR_RESTITUTION: i64 = 3;
    pub const JOINT_CONE_TWIST: i64 = 3;
    pub const SLIDER_JOINT_ANGULAR_ORTHOGONAL_SOFTNESS: i64 = 19;
    pub const PIN_JOINT_DAMPING: i64 = 1;
    pub const HINGE_JOINT_MOTOR_TARGET_VELOCITY: i64 = 6;
    pub const SLIDER_JOINT_LINEAR_LIMIT_RESTITUTION: i64 = 3;
    pub const SLIDER_JOINT_LINEAR_LIMIT_SOFTNESS: i64 = 2;
    pub const SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD: i64 = 4;
    pub const AREA_PARAM_ANGULAR_DAMP: i64 = 6;
    pub const HINGE_JOINT_LIMIT_LOWER: i64 = 2;
    pub const SPACE_PARAM_CONTACT_MAX_SEPARATION: i64 = 1;
    pub const BODY_PARAM_MASS: i64 = 2;
    pub const BODY_STATE_SLEEPING: i64 = 3;
    pub const G6DOF_JOINT_ANGULAR_MOTOR_TARGET_VELOCITY: i64 = 17;
    pub const G6DOF_JOINT_LINEAR_MOTOR_FORCE_LIMIT: i64 = 6;
    pub const SPACE_PARAM_BODY_ANGULAR_VELOCITY_DAMP_RATIO: i64 = 6;
    pub const HINGE_JOINT_FLAG_ENABLE_MOTOR: i64 = 1;
    pub const AREA_PARAM_PRIORITY: i64 = 7;
    pub const BODY_STATE_CAN_SLEEP: i64 = 4;
    pub const SLIDER_JOINT_LINEAR_LIMIT_UPPER: i64 = 0;
    pub const G6DOF_JOINT_ANGULAR_LOWER_LIMIT: i64 = 10;
    pub const SLIDER_JOINT_LINEAR_MOTION_RESTITUTION: i64 = 6;
    pub const HINGE_JOINT_LIMIT_BIAS: i64 = 3;
    pub const SHAPE_CAPSULE: i64 = 4;
    pub const BODY_MODE_CHARACTER: i64 = 3;
    pub const SHAPE_CONCAVE_POLYGON: i64 = 7;
    pub const CONE_TWIST_JOINT_SWING_SPAN: i64 = 0;
    pub const AREA_PARAM_GRAVITY_IS_POINT: i64 = 2;
    pub const CONE_TWIST_JOINT_BIAS: i64 = 2;
    pub const G6DOF_JOINT_ANGULAR_LIMIT_SOFTNESS: i64 = 12;
    pub const HINGE_JOINT_LIMIT_RELAXATION: i64 = 5;
    pub const JOINT_HINGE: i64 = 1;
    pub const SLIDER_JOINT_LINEAR_MOTION_DAMPING: i64 = 7;
    pub const SLIDER_JOINT_ANGULAR_ORTHOGONAL_RESTITUTION: i64 = 20;
}
impl PhysicsServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"PhysicsServer\0".as_ptr() as *mut _);

            PhysicsServer {
                this
            }
        }
    }
    #[inline]
    pub fn area_add_shape(&mut self, area: Rid, shape: Rid, transform: Transform, disabled: bool) -> () {
        unsafe { PhysicsServer_area_add_shape(self.this, area, shape, transform, disabled) }
    }

    #[inline]
    pub fn area_attach_object_instance_id(&mut self, area: Rid, id: i64) -> () {
        unsafe { PhysicsServer_area_attach_object_instance_id(self.this, area, id) }
    }

    #[inline]
    pub fn area_clear_shapes(&mut self, area: Rid) -> () {
        unsafe { PhysicsServer_area_clear_shapes(self.this, area) }
    }

    #[inline]
    pub fn area_create(&mut self) -> Rid {
        unsafe { PhysicsServer_area_create(self.this) }
    }

    #[inline]
    pub fn area_get_object_instance_id(&self, area: Rid) -> i64 {
        unsafe { PhysicsServer_area_get_object_instance_id(self.this, area) }
    }

    #[inline]
    pub fn area_get_param(&self, area: Rid, param: i64) -> Variant {
        unsafe { PhysicsServer_area_get_param(self.this, area, param) }
    }

    #[inline]
    pub fn area_get_shape(&self, area: Rid, shape_idx: i64) -> Rid {
        unsafe { PhysicsServer_area_get_shape(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_get_shape_count(&self, area: Rid) -> i64 {
        unsafe { PhysicsServer_area_get_shape_count(self.this, area) }
    }

    #[inline]
    pub fn area_get_shape_transform(&self, area: Rid, shape_idx: i64) -> Transform {
        unsafe { PhysicsServer_area_get_shape_transform(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_get_space(&self, area: Rid) -> Rid {
        unsafe { PhysicsServer_area_get_space(self.this, area) }
    }

    #[inline]
    pub fn area_get_space_override_mode(&self, area: Rid) -> PhysicsServerAreaSpaceOverrideMode {
        unsafe { PhysicsServer_area_get_space_override_mode(self.this, area) }
    }

    #[inline]
    pub fn area_get_transform(&self, area: Rid) -> Transform {
        unsafe { PhysicsServer_area_get_transform(self.this, area) }
    }

    #[inline]
    pub fn area_is_ray_pickable(&self, area: Rid) -> bool {
        unsafe { PhysicsServer_area_is_ray_pickable(self.this, area) }
    }

    #[inline]
    pub fn area_remove_shape(&mut self, area: Rid, shape_idx: i64) -> () {
        unsafe { PhysicsServer_area_remove_shape(self.this, area, shape_idx) }
    }

    #[inline]
    pub fn area_set_area_monitor_callback(&mut self, area: Rid, receiver: Option<Object>, method: GodotString) -> () {
        unsafe { PhysicsServer_area_set_area_monitor_callback(self.this, area, receiver, method) }
    }

    #[inline]
    pub fn area_set_collision_layer(&mut self, area: Rid, layer: i64) -> () {
        unsafe { PhysicsServer_area_set_collision_layer(self.this, area, layer) }
    }

    #[inline]
    pub fn area_set_collision_mask(&mut self, area: Rid, mask: i64) -> () {
        unsafe { PhysicsServer_area_set_collision_mask(self.this, area, mask) }
    }

    #[inline]
    pub fn area_set_monitor_callback(&mut self, area: Rid, receiver: Option<Object>, method: GodotString) -> () {
        unsafe { PhysicsServer_area_set_monitor_callback(self.this, area, receiver, method) }
    }

    #[inline]
    pub fn area_set_monitorable(&mut self, area: Rid, monitorable: bool) -> () {
        unsafe { PhysicsServer_area_set_monitorable(self.this, area, monitorable) }
    }

    #[inline]
    pub fn area_set_param(&mut self, area: Rid, param: i64, value: Variant) -> () {
        unsafe { PhysicsServer_area_set_param(self.this, area, param, value) }
    }

    #[inline]
    pub fn area_set_ray_pickable(&mut self, area: Rid, enable: bool) -> () {
        unsafe { PhysicsServer_area_set_ray_pickable(self.this, area, enable) }
    }

    #[inline]
    pub fn area_set_shape(&mut self, area: Rid, shape_idx: i64, shape: Rid) -> () {
        unsafe { PhysicsServer_area_set_shape(self.this, area, shape_idx, shape) }
    }

    #[inline]
    pub fn area_set_shape_disabled(&mut self, area: Rid, shape_idx: i64, disabled: bool) -> () {
        unsafe { PhysicsServer_area_set_shape_disabled(self.this, area, shape_idx, disabled) }
    }

    #[inline]
    pub fn area_set_shape_transform(&mut self, area: Rid, shape_idx: i64, transform: Transform) -> () {
        unsafe { PhysicsServer_area_set_shape_transform(self.this, area, shape_idx, transform) }
    }

    #[inline]
    pub fn area_set_space(&mut self, area: Rid, space: Rid) -> () {
        unsafe { PhysicsServer_area_set_space(self.this, area, space) }
    }

    #[inline]
    pub fn area_set_space_override_mode(&mut self, area: Rid, mode: i64) -> () {
        unsafe { PhysicsServer_area_set_space_override_mode(self.this, area, mode) }
    }

    #[inline]
    pub fn area_set_transform(&mut self, area: Rid, transform: Transform) -> () {
        unsafe { PhysicsServer_area_set_transform(self.this, area, transform) }
    }

    #[inline]
    pub fn body_add_central_force(&mut self, body: Rid, force: Vector3) -> () {
        unsafe { PhysicsServer_body_add_central_force(self.this, body, force) }
    }

    #[inline]
    pub fn body_add_collision_exception(&mut self, body: Rid, excepted_body: Rid) -> () {
        unsafe { PhysicsServer_body_add_collision_exception(self.this, body, excepted_body) }
    }

    #[inline]
    pub fn body_add_force(&mut self, body: Rid, force: Vector3, position: Vector3) -> () {
        unsafe { PhysicsServer_body_add_force(self.this, body, force, position) }
    }

    #[inline]
    pub fn body_add_shape(&mut self, body: Rid, shape: Rid, transform: Transform, disabled: bool) -> () {
        unsafe { PhysicsServer_body_add_shape(self.this, body, shape, transform, disabled) }
    }

    #[inline]
    pub fn body_add_torque(&mut self, body: Rid, torque: Vector3) -> () {
        unsafe { PhysicsServer_body_add_torque(self.this, body, torque) }
    }

    #[inline]
    pub fn body_apply_central_impulse(&mut self, body: Rid, impulse: Vector3) -> () {
        unsafe { PhysicsServer_body_apply_central_impulse(self.this, body, impulse) }
    }

    #[inline]
    pub fn body_apply_impulse(&mut self, body: Rid, position: Vector3, impulse: Vector3) -> () {
        unsafe { PhysicsServer_body_apply_impulse(self.this, body, position, impulse) }
    }

    #[inline]
    pub fn body_apply_torque_impulse(&mut self, body: Rid, impulse: Vector3) -> () {
        unsafe { PhysicsServer_body_apply_torque_impulse(self.this, body, impulse) }
    }

    #[inline]
    pub fn body_attach_object_instance_id(&mut self, body: Rid, id: i64) -> () {
        unsafe { PhysicsServer_body_attach_object_instance_id(self.this, body, id) }
    }

    #[inline]
    pub fn body_clear_shapes(&mut self, body: Rid) -> () {
        unsafe { PhysicsServer_body_clear_shapes(self.this, body) }
    }

    #[inline]
    pub fn body_create(&mut self, mode: i64, init_sleeping: bool) -> Rid {
        unsafe { PhysicsServer_body_create(self.this, mode, init_sleeping) }
    }

    #[inline]
    pub fn body_get_collision_layer(&self, body: Rid) -> i64 {
        unsafe { PhysicsServer_body_get_collision_layer(self.this, body) }
    }

    #[inline]
    pub fn body_get_collision_mask(&self, body: Rid) -> i64 {
        unsafe { PhysicsServer_body_get_collision_mask(self.this, body) }
    }

    #[inline]
    pub fn body_get_direct_state(&mut self, body: Rid) -> Option<PhysicsDirectBodyState> {
        unsafe { PhysicsServer_body_get_direct_state(self.this, body) }
    }

    #[inline]
    pub fn body_get_kinematic_safe_margin(&self, body: Rid) -> f64 {
        unsafe { PhysicsServer_body_get_kinematic_safe_margin(self.this, body) }
    }

    #[inline]
    pub fn body_get_max_contacts_reported(&self, body: Rid) -> i64 {
        unsafe { PhysicsServer_body_get_max_contacts_reported(self.this, body) }
    }

    #[inline]
    pub fn body_get_mode(&self, body: Rid) -> PhysicsServerBodyMode {
        unsafe { PhysicsServer_body_get_mode(self.this, body) }
    }

    #[inline]
    pub fn body_get_object_instance_id(&self, body: Rid) -> i64 {
        unsafe { PhysicsServer_body_get_object_instance_id(self.this, body) }
    }

    #[inline]
    pub fn body_get_param(&self, body: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_body_get_param(self.this, body, param) }
    }

    #[inline]
    pub fn body_get_shape(&self, body: Rid, shape_idx: i64) -> Rid {
        unsafe { PhysicsServer_body_get_shape(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_get_shape_count(&self, body: Rid) -> i64 {
        unsafe { PhysicsServer_body_get_shape_count(self.this, body) }
    }

    #[inline]
    pub fn body_get_shape_transform(&self, body: Rid, shape_idx: i64) -> Transform {
        unsafe { PhysicsServer_body_get_shape_transform(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_get_space(&self, body: Rid) -> Rid {
        unsafe { PhysicsServer_body_get_space(self.this, body) }
    }

    #[inline]
    pub fn body_get_state(&self, body: Rid, state: i64) -> Variant {
        unsafe { PhysicsServer_body_get_state(self.this, body, state) }
    }

    #[inline]
    pub fn body_is_axis_locked(&self, body: Rid, axis: i64) -> bool {
        unsafe { PhysicsServer_body_is_axis_locked(self.this, body, axis) }
    }

    #[inline]
    pub fn body_is_continuous_collision_detection_enabled(&self, body: Rid) -> bool {
        unsafe { PhysicsServer_body_is_continuous_collision_detection_enabled(self.this, body) }
    }

    #[inline]
    pub fn body_is_omitting_force_integration(&self, body: Rid) -> bool {
        unsafe { PhysicsServer_body_is_omitting_force_integration(self.this, body) }
    }

    #[inline]
    pub fn body_is_ray_pickable(&self, body: Rid) -> bool {
        unsafe { PhysicsServer_body_is_ray_pickable(self.this, body) }
    }

    #[inline]
    pub fn body_remove_collision_exception(&mut self, body: Rid, excepted_body: Rid) -> () {
        unsafe { PhysicsServer_body_remove_collision_exception(self.this, body, excepted_body) }
    }

    #[inline]
    pub fn body_remove_shape(&mut self, body: Rid, shape_idx: i64) -> () {
        unsafe { PhysicsServer_body_remove_shape(self.this, body, shape_idx) }
    }

    #[inline]
    pub fn body_set_axis_lock(&mut self, body: Rid, axis: i64, lock: bool) -> () {
        unsafe { PhysicsServer_body_set_axis_lock(self.this, body, axis, lock) }
    }

    #[inline]
    pub fn body_set_axis_velocity(&mut self, body: Rid, axis_velocity: Vector3) -> () {
        unsafe { PhysicsServer_body_set_axis_velocity(self.this, body, axis_velocity) }
    }

    #[inline]
    pub fn body_set_collision_layer(&mut self, body: Rid, layer: i64) -> () {
        unsafe { PhysicsServer_body_set_collision_layer(self.this, body, layer) }
    }

    #[inline]
    pub fn body_set_collision_mask(&mut self, body: Rid, mask: i64) -> () {
        unsafe { PhysicsServer_body_set_collision_mask(self.this, body, mask) }
    }

    #[inline]
    pub fn body_set_enable_continuous_collision_detection(&mut self, body: Rid, enable: bool) -> () {
        unsafe { PhysicsServer_body_set_enable_continuous_collision_detection(self.this, body, enable) }
    }

    #[inline]
    pub fn body_set_force_integration_callback(&mut self, body: Rid, receiver: Option<Object>, method: GodotString, userdata: Variant) -> () {
        unsafe { PhysicsServer_body_set_force_integration_callback(self.this, body, receiver, method, userdata) }
    }

    #[inline]
    pub fn body_set_kinematic_safe_margin(&mut self, body: Rid, margin: f64) -> () {
        unsafe { PhysicsServer_body_set_kinematic_safe_margin(self.this, body, margin) }
    }

    #[inline]
    pub fn body_set_max_contacts_reported(&mut self, body: Rid, amount: i64) -> () {
        unsafe { PhysicsServer_body_set_max_contacts_reported(self.this, body, amount) }
    }

    #[inline]
    pub fn body_set_mode(&mut self, body: Rid, mode: i64) -> () {
        unsafe { PhysicsServer_body_set_mode(self.this, body, mode) }
    }

    #[inline]
    pub fn body_set_omit_force_integration(&mut self, body: Rid, enable: bool) -> () {
        unsafe { PhysicsServer_body_set_omit_force_integration(self.this, body, enable) }
    }

    #[inline]
    pub fn body_set_param(&mut self, body: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_body_set_param(self.this, body, param, value) }
    }

    #[inline]
    pub fn body_set_ray_pickable(&mut self, body: Rid, enable: bool) -> () {
        unsafe { PhysicsServer_body_set_ray_pickable(self.this, body, enable) }
    }

    #[inline]
    pub fn body_set_shape(&mut self, body: Rid, shape_idx: i64, shape: Rid) -> () {
        unsafe { PhysicsServer_body_set_shape(self.this, body, shape_idx, shape) }
    }

    #[inline]
    pub fn body_set_shape_disabled(&mut self, body: Rid, shape_idx: i64, disabled: bool) -> () {
        unsafe { PhysicsServer_body_set_shape_disabled(self.this, body, shape_idx, disabled) }
    }

    #[inline]
    pub fn body_set_shape_transform(&mut self, body: Rid, shape_idx: i64, transform: Transform) -> () {
        unsafe { PhysicsServer_body_set_shape_transform(self.this, body, shape_idx, transform) }
    }

    #[inline]
    pub fn body_set_space(&mut self, body: Rid, space: Rid) -> () {
        unsafe { PhysicsServer_body_set_space(self.this, body, space) }
    }

    #[inline]
    pub fn body_set_state(&mut self, body: Rid, state: i64, value: Variant) -> () {
        unsafe { PhysicsServer_body_set_state(self.this, body, state, value) }
    }

    #[inline]
    pub fn cone_twist_joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_cone_twist_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn cone_twist_joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_cone_twist_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn free_rid(&mut self, rid: Rid) -> () {
        unsafe { PhysicsServer_free_rid(self.this, rid) }
    }

    #[inline]
    pub fn generic_6dof_joint_get_flag(&mut self, joint: Rid, axis: i64, flag: i64) -> bool {
        unsafe { PhysicsServer_generic_6dof_joint_get_flag(self.this, joint, axis, flag) }
    }

    #[inline]
    pub fn generic_6dof_joint_get_param(&mut self, joint: Rid, axis: i64, param: i64) -> f64 {
        unsafe { PhysicsServer_generic_6dof_joint_get_param(self.this, joint, axis, param) }
    }

    #[inline]
    pub fn generic_6dof_joint_set_flag(&mut self, joint: Rid, axis: i64, flag: i64, enable: bool) -> () {
        unsafe { PhysicsServer_generic_6dof_joint_set_flag(self.this, joint, axis, flag, enable) }
    }

    #[inline]
    pub fn generic_6dof_joint_set_param(&mut self, joint: Rid, axis: i64, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_generic_6dof_joint_set_param(self.this, joint, axis, param, value) }
    }

    #[inline]
    pub fn get_process_info(&mut self, process_info: i64) -> i64 {
        unsafe { PhysicsServer_get_process_info(self.this, process_info) }
    }

    #[inline]
    pub fn hinge_joint_get_flag(&self, joint: Rid, flag: i64) -> bool {
        unsafe { PhysicsServer_hinge_joint_get_flag(self.this, joint, flag) }
    }

    #[inline]
    pub fn hinge_joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_hinge_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn hinge_joint_set_flag(&mut self, joint: Rid, flag: i64, enabled: bool) -> () {
        unsafe { PhysicsServer_hinge_joint_set_flag(self.this, joint, flag, enabled) }
    }

    #[inline]
    pub fn hinge_joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_hinge_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn joint_create_cone_twist(&mut self, body_A: Rid, local_ref_A: Transform, body_B: Rid, local_ref_B: Transform) -> Rid {
        unsafe { PhysicsServer_joint_create_cone_twist(self.this, body_A, local_ref_A, body_B, local_ref_B) }
    }

    #[inline]
    pub fn joint_create_generic_6dof(&mut self, body_A: Rid, local_ref_A: Transform, body_B: Rid, local_ref_B: Transform) -> Rid {
        unsafe { PhysicsServer_joint_create_generic_6dof(self.this, body_A, local_ref_A, body_B, local_ref_B) }
    }

    #[inline]
    pub fn joint_create_hinge(&mut self, body_A: Rid, hinge_A: Transform, body_B: Rid, hinge_B: Transform) -> Rid {
        unsafe { PhysicsServer_joint_create_hinge(self.this, body_A, hinge_A, body_B, hinge_B) }
    }

    #[inline]
    pub fn joint_create_pin(&mut self, body_A: Rid, local_A: Vector3, body_B: Rid, local_B: Vector3) -> Rid {
        unsafe { PhysicsServer_joint_create_pin(self.this, body_A, local_A, body_B, local_B) }
    }

    #[inline]
    pub fn joint_create_slider(&mut self, body_A: Rid, local_ref_A: Transform, body_B: Rid, local_ref_B: Transform) -> Rid {
        unsafe { PhysicsServer_joint_create_slider(self.this, body_A, local_ref_A, body_B, local_ref_B) }
    }

    #[inline]
    pub fn joint_get_solver_priority(&self, joint: Rid) -> i64 {
        unsafe { PhysicsServer_joint_get_solver_priority(self.this, joint) }
    }

    #[inline]
    pub fn joint_get_type(&self, joint: Rid) -> PhysicsServerJointType {
        unsafe { PhysicsServer_joint_get_type(self.this, joint) }
    }

    #[inline]
    pub fn joint_set_solver_priority(&mut self, joint: Rid, priority: i64) -> () {
        unsafe { PhysicsServer_joint_set_solver_priority(self.this, joint, priority) }
    }

    #[inline]
    pub fn pin_joint_get_local_a(&self, joint: Rid) -> Vector3 {
        unsafe { PhysicsServer_pin_joint_get_local_a(self.this, joint) }
    }

    #[inline]
    pub fn pin_joint_get_local_b(&self, joint: Rid) -> Vector3 {
        unsafe { PhysicsServer_pin_joint_get_local_b(self.this, joint) }
    }

    #[inline]
    pub fn pin_joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_pin_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn pin_joint_set_local_a(&mut self, joint: Rid, local_A: Vector3) -> () {
        unsafe { PhysicsServer_pin_joint_set_local_a(self.this, joint, local_A) }
    }

    #[inline]
    pub fn pin_joint_set_local_b(&mut self, joint: Rid, local_B: Vector3) -> () {
        unsafe { PhysicsServer_pin_joint_set_local_b(self.this, joint, local_B) }
    }

    #[inline]
    pub fn pin_joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_pin_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn set_active(&mut self, active: bool) -> () {
        unsafe { PhysicsServer_set_active(self.this, active) }
    }

    #[inline]
    pub fn shape_create(&mut self, _type: i64) -> Rid {
        unsafe { PhysicsServer_shape_create(self.this, _type) }
    }

    #[inline]
    pub fn shape_get_data(&self, shape: Rid) -> Variant {
        unsafe { PhysicsServer_shape_get_data(self.this, shape) }
    }

    #[inline]
    pub fn shape_get_type(&self, shape: Rid) -> PhysicsServerShapeType {
        unsafe { PhysicsServer_shape_get_type(self.this, shape) }
    }

    #[inline]
    pub fn shape_set_data(&mut self, shape: Rid, data: Variant) -> () {
        unsafe { PhysicsServer_shape_set_data(self.this, shape, data) }
    }

    #[inline]
    pub fn slider_joint_get_param(&self, joint: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_slider_joint_get_param(self.this, joint, param) }
    }

    #[inline]
    pub fn slider_joint_set_param(&mut self, joint: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_slider_joint_set_param(self.this, joint, param, value) }
    }

    #[inline]
    pub fn space_create(&mut self) -> Rid {
        unsafe { PhysicsServer_space_create(self.this) }
    }

    #[inline]
    pub fn space_get_direct_state(&mut self, space: Rid) -> Option<PhysicsDirectSpaceState> {
        unsafe { PhysicsServer_space_get_direct_state(self.this, space) }
    }

    #[inline]
    pub fn space_get_param(&self, space: Rid, param: i64) -> f64 {
        unsafe { PhysicsServer_space_get_param(self.this, space, param) }
    }

    #[inline]
    pub fn space_is_active(&self, space: Rid) -> bool {
        unsafe { PhysicsServer_space_is_active(self.this, space) }
    }

    #[inline]
    pub fn space_set_active(&mut self, space: Rid, active: bool) -> () {
        unsafe { PhysicsServer_space_set_active(self.this, space, active) }
    }

    #[inline]
    pub fn space_set_param(&mut self, space: Rid, param: i64, value: f64) -> () {
        unsafe { PhysicsServer_space_set_param(self.this, space, param, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsShapeQueryParameters` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsshapequeryparameters.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PhysicsShapeQueryParameters inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsShapeQueryParameters {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsShapeQueryParameters {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PhysicsShapeQueryParametersMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PhysicsShapeQueryParameters {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_collision_mask(&self) -> i64 {
        unsafe { PhysicsShapeQueryParameters_get_collision_mask(self.this) }
    }

    #[inline]
    pub fn get_exclude(&self) -> VariantArray {
        unsafe { PhysicsShapeQueryParameters_get_exclude(self.this) }
    }

    #[inline]
    pub fn get_margin(&self) -> f64 {
        unsafe { PhysicsShapeQueryParameters_get_margin(self.this) }
    }

    #[inline]
    pub fn get_shape_rid(&self) -> Rid {
        unsafe { PhysicsShapeQueryParameters_get_shape_rid(self.this) }
    }

    #[inline]
    pub fn get_transform(&self) -> Transform {
        unsafe { PhysicsShapeQueryParameters_get_transform(self.this) }
    }

    #[inline]
    pub fn is_collide_with_areas_enabled(&self) -> bool {
        unsafe { PhysicsShapeQueryParameters_is_collide_with_areas_enabled(self.this) }
    }

    #[inline]
    pub fn is_collide_with_bodies_enabled(&self) -> bool {
        unsafe { PhysicsShapeQueryParameters_is_collide_with_bodies_enabled(self.this) }
    }

    #[inline]
    pub fn set_collide_with_areas(&mut self, enable: bool) -> () {
        unsafe { PhysicsShapeQueryParameters_set_collide_with_areas(self.this, enable) }
    }

    #[inline]
    pub fn set_collide_with_bodies(&mut self, enable: bool) -> () {
        unsafe { PhysicsShapeQueryParameters_set_collide_with_bodies(self.this, enable) }
    }

    #[inline]
    pub fn set_collision_mask(&mut self, collision_mask: i64) -> () {
        unsafe { PhysicsShapeQueryParameters_set_collision_mask(self.this, collision_mask) }
    }

    #[inline]
    pub fn set_exclude(&mut self, exclude: VariantArray) -> () {
        unsafe { PhysicsShapeQueryParameters_set_exclude(self.this, exclude) }
    }

    #[inline]
    pub fn set_margin(&mut self, margin: f64) -> () {
        unsafe { PhysicsShapeQueryParameters_set_margin(self.this, margin) }
    }

    #[inline]
    pub fn set_shape(&mut self, shape: Option<Resource>) -> () {
        unsafe { PhysicsShapeQueryParameters_set_shape(self.this, shape) }
    }

    #[inline]
    pub fn set_shape_rid(&mut self, shape: Rid) -> () {
        unsafe { PhysicsShapeQueryParameters_set_shape_rid(self.this, shape) }
    }

    #[inline]
    pub fn set_transform(&mut self, transform: Transform) -> () {
        unsafe { PhysicsShapeQueryParameters_set_transform(self.this, transform) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PhysicsShapeQueryResult` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_physicsshapequeryresult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PhysicsShapeQueryResult inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PhysicsShapeQueryResult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PhysicsShapeQueryResult {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_result_count(&self) -> i64 {
        unsafe { PhysicsShapeQueryResult_get_result_count(self.this) }
    }

    #[inline]
    pub fn get_result_object(&self, idx: i64) -> Option<Object> {
        unsafe { PhysicsShapeQueryResult_get_result_object(self.this, idx) }
    }

    #[inline]
    pub fn get_result_object_id(&self, idx: i64) -> i64 {
        unsafe { PhysicsShapeQueryResult_get_result_object_id(self.this, idx) }
    }

    #[inline]
    pub fn get_result_object_shape(&self, idx: i64) -> i64 {
        unsafe { PhysicsShapeQueryResult_get_result_object_shape(self.this, idx) }
    }

    #[inline]
    pub fn get_result_rid(&self, idx: i64) -> Rid {
        unsafe { PhysicsShapeQueryResult_get_result_rid(self.this, idx) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PinJoint` inherits `Joint` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pinjoint.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PinJoint` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PinJoint::free`.
///
/// ## Class hierarchy
///
/// PinJoint inherits methods from:
/// - [Joint](struct.Joint.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PinJoint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum PinJointParam {
    Bias = 0,
    Damping = 1,
    ImpulseClamp = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl PinJoint {
    pub const PARAM_DAMPING: i64 = 1;
    pub const PARAM_IMPULSE_CLAMP: i64 = 2;
    pub const PARAM_BIAS: i64 = 0;
}
impl PinJoint {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PinJoint::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PinJointMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PinJoint {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        PinJoint_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        PinJoint_set_param(self.this, param, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint(&self) -> Joint {
        // Not reference-counted.
        Joint { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PinJoint2D` inherits `Joint2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pinjoint2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PinJoint2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PinJoint2D::free`.
///
/// ## Class hierarchy
///
/// PinJoint2D inherits methods from:
/// - [Joint2D](struct.Joint2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PinJoint2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PinJoint2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PinJoint2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PinJoint2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PinJoint2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_softness(&self) -> f64 {
        PinJoint2D_get_softness(self.this)
    }

    #[inline]
    pub unsafe fn set_softness(&mut self, softness: f64) -> () {
        PinJoint2D_set_softness(self.this, softness)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint_2d(&self) -> Joint2D {
        // Not reference-counted.
        Joint2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PlaneMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_planemesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PlaneMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PlaneMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PlaneMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PlaneMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PlaneMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { PlaneMesh_get_size(self.this) }
    }

    #[inline]
    pub fn get_subdivide_depth(&self) -> i64 {
        unsafe { PlaneMesh_get_subdivide_depth(self.this) }
    }

    #[inline]
    pub fn get_subdivide_width(&self) -> i64 {
        unsafe { PlaneMesh_get_subdivide_width(self.this) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector2) -> () {
        unsafe { PlaneMesh_set_size(self.this, size) }
    }

    #[inline]
    pub fn set_subdivide_depth(&mut self, subdivide: i64) -> () {
        unsafe { PlaneMesh_set_subdivide_depth(self.this, subdivide) }
    }

    #[inline]
    pub fn set_subdivide_width(&mut self, subdivide: i64) -> () {
        unsafe { PlaneMesh_set_subdivide_width(self.this, subdivide) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PlaneShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_planeshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PlaneShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PlaneShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PlaneShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PlaneShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PlaneShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_plane(&self) -> Plane {
        unsafe { PlaneShape_get_plane(self.this) }
    }

    #[inline]
    pub fn set_plane(&mut self, plane: Plane) -> () {
        unsafe { PlaneShape_set_plane(self.this, plane) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PluginScript` inherits `Script` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pluginscript.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PluginScript inherits methods from:
/// - [Script](struct.Script.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PluginScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PluginScript {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PluginScriptMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PluginScript {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _new(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { PluginScript__new(self.this, varargs) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_script(&self) -> Script {
        unsafe {{ object::add_ref(self.this); }}
        Script { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PointMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_pointmesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PointMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PointMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PointMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PointMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PointMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Polygon2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_polygon2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Polygon2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Polygon2D::free`.
///
/// ## Class hierarchy
///
/// Polygon2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Polygon2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Polygon2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Polygon2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Polygon2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Polygon2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_bones(&self) -> VariantArray {
        Polygon2D__get_bones(self.this)
    }

    #[inline]
    pub unsafe fn _set_bones(&mut self, bones: VariantArray) -> () {
        Polygon2D__set_bones(self.this, bones)
    }

    #[inline]
    pub unsafe fn _skeleton_bone_setup_changed(&mut self) -> () {
        Polygon2D__skeleton_bone_setup_changed(self.this)
    }

    #[inline]
    pub unsafe fn add_bone(&mut self, path: NodePath, weights: Float32Array) -> () {
        Polygon2D_add_bone(self.this, path, weights)
    }

    #[inline]
    pub unsafe fn clear_bones(&mut self) -> () {
        Polygon2D_clear_bones(self.this)
    }

    #[inline]
    pub unsafe fn erase_bone(&mut self, index: i64) -> () {
        Polygon2D_erase_bone(self.this, index)
    }

    #[inline]
    pub unsafe fn get_antialiased(&self) -> bool {
        Polygon2D_get_antialiased(self.this)
    }

    #[inline]
    pub unsafe fn get_bone_count(&self) -> i64 {
        Polygon2D_get_bone_count(self.this)
    }

    #[inline]
    pub unsafe fn get_bone_path(&self, index: i64) -> NodePath {
        Polygon2D_get_bone_path(self.this, index)
    }

    #[inline]
    pub unsafe fn get_bone_weights(&self, index: i64) -> Float32Array {
        Polygon2D_get_bone_weights(self.this, index)
    }

    #[inline]
    pub unsafe fn get_color(&self) -> Color {
        Polygon2D_get_color(self.this)
    }

    #[inline]
    pub unsafe fn get_internal_vertex_count(&self) -> i64 {
        Polygon2D_get_internal_vertex_count(self.this)
    }

    #[inline]
    pub unsafe fn get_invert(&self) -> bool {
        Polygon2D_get_invert(self.this)
    }

    #[inline]
    pub unsafe fn get_invert_border(&self) -> f64 {
        Polygon2D_get_invert_border(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        Polygon2D_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_polygon(&self) -> Vector2Array {
        Polygon2D_get_polygon(self.this)
    }

    #[inline]
    pub unsafe fn get_polygons(&self) -> VariantArray {
        Polygon2D_get_polygons(self.this)
    }

    #[inline]
    pub unsafe fn get_skeleton(&self) -> NodePath {
        Polygon2D_get_skeleton(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Polygon2D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_offset(&self) -> Vector2 {
        Polygon2D_get_texture_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_rotation(&self) -> f64 {
        Polygon2D_get_texture_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_rotation_degrees(&self) -> f64 {
        Polygon2D_get_texture_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_scale(&self) -> Vector2 {
        Polygon2D_get_texture_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_uv(&self) -> Vector2Array {
        Polygon2D_get_uv(self.this)
    }

    #[inline]
    pub unsafe fn get_vertex_colors(&self) -> ColorArray {
        Polygon2D_get_vertex_colors(self.this)
    }

    #[inline]
    pub unsafe fn set_antialiased(&mut self, antialiased: bool) -> () {
        Polygon2D_set_antialiased(self.this, antialiased)
    }

    #[inline]
    pub unsafe fn set_bone_path(&mut self, index: i64, path: NodePath) -> () {
        Polygon2D_set_bone_path(self.this, index, path)
    }

    #[inline]
    pub unsafe fn set_bone_weights(&mut self, index: i64, weights: Float32Array) -> () {
        Polygon2D_set_bone_weights(self.this, index, weights)
    }

    #[inline]
    pub unsafe fn set_color(&mut self, color: Color) -> () {
        Polygon2D_set_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_internal_vertex_count(&mut self, internal_vertex_count: i64) -> () {
        Polygon2D_set_internal_vertex_count(self.this, internal_vertex_count)
    }

    #[inline]
    pub unsafe fn set_invert(&mut self, invert: bool) -> () {
        Polygon2D_set_invert(self.this, invert)
    }

    #[inline]
    pub unsafe fn set_invert_border(&mut self, invert_border: f64) -> () {
        Polygon2D_set_invert_border(self.this, invert_border)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        Polygon2D_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_polygon(&mut self, polygon: Vector2Array) -> () {
        Polygon2D_set_polygon(self.this, polygon)
    }

    #[inline]
    pub unsafe fn set_polygons(&mut self, polygons: VariantArray) -> () {
        Polygon2D_set_polygons(self.this, polygons)
    }

    #[inline]
    pub unsafe fn set_skeleton(&mut self, skeleton: NodePath) -> () {
        Polygon2D_set_skeleton(self.this, skeleton)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Polygon2D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_texture_offset(&mut self, texture_offset: Vector2) -> () {
        Polygon2D_set_texture_offset(self.this, texture_offset)
    }

    #[inline]
    pub unsafe fn set_texture_rotation(&mut self, texture_rotation: f64) -> () {
        Polygon2D_set_texture_rotation(self.this, texture_rotation)
    }

    #[inline]
    pub unsafe fn set_texture_rotation_degrees(&mut self, texture_rotation: f64) -> () {
        Polygon2D_set_texture_rotation_degrees(self.this, texture_rotation)
    }

    #[inline]
    pub unsafe fn set_texture_scale(&mut self, texture_scale: Vector2) -> () {
        Polygon2D_set_texture_scale(self.this, texture_scale)
    }

    #[inline]
    pub unsafe fn set_uv(&mut self, uv: Vector2Array) -> () {
        Polygon2D_set_uv(self.this, uv)
    }

    #[inline]
    pub unsafe fn set_vertex_colors(&mut self, vertex_colors: ColorArray) -> () {
        Polygon2D_set_vertex_colors(self.this, vertex_colors)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PolygonPathFinder` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_polygonpathfinder.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PolygonPathFinder inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PolygonPathFinder {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PolygonPathFinder {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PolygonPathFinderMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PolygonPathFinder {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { PolygonPathFinder__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, arg0: Dictionary) -> () {
        unsafe { PolygonPathFinder__set_data(self.this, arg0) }
    }

    #[inline]
    pub fn find_path(&mut self, from: Vector2, to: Vector2) -> Vector2Array {
        unsafe { PolygonPathFinder_find_path(self.this, from, to) }
    }

    #[inline]
    pub fn get_bounds(&self) -> Rect2 {
        unsafe { PolygonPathFinder_get_bounds(self.this) }
    }

    #[inline]
    pub fn get_closest_point(&self, point: Vector2) -> Vector2 {
        unsafe { PolygonPathFinder_get_closest_point(self.this, point) }
    }

    #[inline]
    pub fn get_intersections(&self, from: Vector2, to: Vector2) -> Vector2Array {
        unsafe { PolygonPathFinder_get_intersections(self.this, from, to) }
    }

    #[inline]
    pub fn get_point_penalty(&self, idx: i64) -> f64 {
        unsafe { PolygonPathFinder_get_point_penalty(self.this, idx) }
    }

    #[inline]
    pub fn is_point_inside(&self, point: Vector2) -> bool {
        unsafe { PolygonPathFinder_is_point_inside(self.this, point) }
    }

    #[inline]
    pub fn set_point_penalty(&mut self, idx: i64, penalty: f64) -> () {
        unsafe { PolygonPathFinder_set_point_penalty(self.this, idx, penalty) }
    }

    #[inline]
    pub fn setup(&mut self, points: Vector2Array, connections: Int32Array) -> () {
        unsafe { PolygonPathFinder_setup(self.this, points, connections) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Popup` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_popup.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Popup` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Popup::free`.
///
/// ## Class hierarchy
///
/// Popup inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Popup {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl Popup {
    pub const NOTIFICATION_POST_POPUP: i64 = 80;
    pub const NOTIFICATION_POPUP_HIDE: i64 = 81;
}
impl Popup {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Popup::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PopupMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Popup {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn is_exclusive(&self) -> bool {
        Popup_is_exclusive(self.this)
    }

    #[inline]
    pub unsafe fn popup(&mut self, bounds: Rect2) -> () {
        Popup_popup(self.this, bounds)
    }

    #[inline]
    pub unsafe fn popup_centered(&mut self, size: Vector2) -> () {
        Popup_popup_centered(self.this, size)
    }

    #[inline]
    pub unsafe fn popup_centered_clamped(&mut self, size: Vector2, fallback_ratio: f64) -> () {
        Popup_popup_centered_clamped(self.this, size, fallback_ratio)
    }

    #[inline]
    pub unsafe fn popup_centered_minsize(&mut self, minsize: Vector2) -> () {
        Popup_popup_centered_minsize(self.this, minsize)
    }

    #[inline]
    pub unsafe fn popup_centered_ratio(&mut self, ratio: f64) -> () {
        Popup_popup_centered_ratio(self.this, ratio)
    }

    #[inline]
    pub unsafe fn set_as_minsize(&mut self) -> () {
        Popup_set_as_minsize(self.this)
    }

    #[inline]
    pub unsafe fn set_exclusive(&mut self, enable: bool) -> () {
        Popup_set_exclusive(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PopupDialog` inherits `Popup` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_popupdialog.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PopupDialog` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PopupDialog::free`.
///
/// ## Class hierarchy
///
/// PopupDialog inherits methods from:
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PopupDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PopupDialog {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PopupDialog::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PopupDialogMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PopupDialog {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PopupMenu` inherits `Popup` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_popupmenu.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PopupMenu` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PopupMenu::free`.
///
/// ## Class hierarchy
///
/// PopupMenu inherits methods from:
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PopupMenu {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PopupMenu {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PopupMenu::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PopupMenuMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PopupMenu {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_items(&self) -> VariantArray {
        PopupMenu__get_items(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        PopupMenu__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _set_items(&mut self, arg0: VariantArray) -> () {
        PopupMenu__set_items(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _submenu_timeout(&mut self) -> () {
        PopupMenu__submenu_timeout(self.this)
    }

    #[inline]
    pub unsafe fn add_check_item(&mut self, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_check_item(self.this, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_check_shortcut(&mut self, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_check_shortcut(self.this, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_icon_check_item(&mut self, texture: Option<Texture>, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_icon_check_item(self.this, texture, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_icon_check_shortcut(&mut self, texture: Option<Texture>, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_icon_check_shortcut(self.this, texture, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_icon_item(&mut self, texture: Option<Texture>, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_icon_item(self.this, texture, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_icon_radio_check_item(&mut self, texture: Option<Texture>, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_icon_radio_check_item(self.this, texture, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_icon_radio_check_shortcut(&mut self, texture: Option<Texture>, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_icon_radio_check_shortcut(self.this, texture, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_icon_shortcut(&mut self, texture: Option<Texture>, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_icon_shortcut(self.this, texture, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_item(&mut self, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_item(self.this, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_multistate_item(&mut self, label: GodotString, max_states: i64, default_state: i64, id: i64, accel: i64) -> () {
        PopupMenu_add_multistate_item(self.this, label, max_states, default_state, id, accel)
    }

    #[inline]
    pub unsafe fn add_radio_check_item(&mut self, label: GodotString, id: i64, accel: i64) -> () {
        PopupMenu_add_radio_check_item(self.this, label, id, accel)
    }

    #[inline]
    pub unsafe fn add_radio_check_shortcut(&mut self, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_radio_check_shortcut(self.this, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_separator(&mut self, label: GodotString) -> () {
        PopupMenu_add_separator(self.this, label)
    }

    #[inline]
    pub unsafe fn add_shortcut(&mut self, shortcut: Option<ShortCut>, id: i64, global: bool) -> () {
        PopupMenu_add_shortcut(self.this, shortcut, id, global)
    }

    #[inline]
    pub unsafe fn add_submenu_item(&mut self, label: GodotString, submenu: GodotString, id: i64) -> () {
        PopupMenu_add_submenu_item(self.this, label, submenu, id)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        PopupMenu_clear(self.this)
    }

    #[inline]
    pub unsafe fn get_allow_search(&self) -> bool {
        PopupMenu_get_allow_search(self.this)
    }

    #[inline]
    pub unsafe fn get_item_accelerator(&self, idx: i64) -> i64 {
        PopupMenu_get_item_accelerator(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_count(&self) -> i64 {
        PopupMenu_get_item_count(self.this)
    }

    #[inline]
    pub unsafe fn get_item_icon(&self, idx: i64) -> Option<Texture> {
        PopupMenu_get_item_icon(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_id(&self, idx: i64) -> i64 {
        PopupMenu_get_item_id(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_index(&self, id: i64) -> i64 {
        PopupMenu_get_item_index(self.this, id)
    }

    #[inline]
    pub unsafe fn get_item_metadata(&self, idx: i64) -> Variant {
        PopupMenu_get_item_metadata(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_shortcut(&self, idx: i64) -> Option<ShortCut> {
        PopupMenu_get_item_shortcut(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_submenu(&self, idx: i64) -> GodotString {
        PopupMenu_get_item_submenu(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_text(&self, idx: i64) -> GodotString {
        PopupMenu_get_item_text(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_item_tooltip(&self, idx: i64) -> GodotString {
        PopupMenu_get_item_tooltip(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_submenu_popup_delay(&self) -> f64 {
        PopupMenu_get_submenu_popup_delay(self.this)
    }

    #[inline]
    pub unsafe fn is_hide_on_checkable_item_selection(&self) -> bool {
        PopupMenu_is_hide_on_checkable_item_selection(self.this)
    }

    #[inline]
    pub unsafe fn is_hide_on_item_selection(&self) -> bool {
        PopupMenu_is_hide_on_item_selection(self.this)
    }

    #[inline]
    pub unsafe fn is_hide_on_state_item_selection(&self) -> bool {
        PopupMenu_is_hide_on_state_item_selection(self.this)
    }

    #[inline]
    pub unsafe fn is_hide_on_window_lose_focus(&self) -> bool {
        PopupMenu_is_hide_on_window_lose_focus(self.this)
    }

    #[inline]
    pub unsafe fn is_item_checkable(&self, idx: i64) -> bool {
        PopupMenu_is_item_checkable(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_checked(&self, idx: i64) -> bool {
        PopupMenu_is_item_checked(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_disabled(&self, idx: i64) -> bool {
        PopupMenu_is_item_disabled(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_radio_checkable(&self, idx: i64) -> bool {
        PopupMenu_is_item_radio_checkable(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_separator(&self, idx: i64) -> bool {
        PopupMenu_is_item_separator(self.this, idx)
    }

    #[inline]
    pub unsafe fn is_item_shortcut_disabled(&self, idx: i64) -> bool {
        PopupMenu_is_item_shortcut_disabled(self.this, idx)
    }

    #[inline]
    pub unsafe fn remove_item(&mut self, idx: i64) -> () {
        PopupMenu_remove_item(self.this, idx)
    }

    #[inline]
    pub unsafe fn set_allow_search(&mut self, allow: bool) -> () {
        PopupMenu_set_allow_search(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_hide_on_checkable_item_selection(&mut self, enable: bool) -> () {
        PopupMenu_set_hide_on_checkable_item_selection(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_hide_on_item_selection(&mut self, enable: bool) -> () {
        PopupMenu_set_hide_on_item_selection(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_hide_on_state_item_selection(&mut self, enable: bool) -> () {
        PopupMenu_set_hide_on_state_item_selection(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_hide_on_window_lose_focus(&mut self, enable: bool) -> () {
        PopupMenu_set_hide_on_window_lose_focus(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_item_accelerator(&mut self, idx: i64, accel: i64) -> () {
        PopupMenu_set_item_accelerator(self.this, idx, accel)
    }

    #[inline]
    pub unsafe fn set_item_as_checkable(&mut self, idx: i64, enable: bool) -> () {
        PopupMenu_set_item_as_checkable(self.this, idx, enable)
    }

    #[inline]
    pub unsafe fn set_item_as_radio_checkable(&mut self, idx: i64, enable: bool) -> () {
        PopupMenu_set_item_as_radio_checkable(self.this, idx, enable)
    }

    #[inline]
    pub unsafe fn set_item_as_separator(&mut self, idx: i64, enable: bool) -> () {
        PopupMenu_set_item_as_separator(self.this, idx, enable)
    }

    #[inline]
    pub unsafe fn set_item_checked(&mut self, idx: i64, checked: bool) -> () {
        PopupMenu_set_item_checked(self.this, idx, checked)
    }

    #[inline]
    pub unsafe fn set_item_disabled(&mut self, idx: i64, disabled: bool) -> () {
        PopupMenu_set_item_disabled(self.this, idx, disabled)
    }

    #[inline]
    pub unsafe fn set_item_icon(&mut self, idx: i64, icon: Option<Texture>) -> () {
        PopupMenu_set_item_icon(self.this, idx, icon)
    }

    #[inline]
    pub unsafe fn set_item_id(&mut self, idx: i64, id: i64) -> () {
        PopupMenu_set_item_id(self.this, idx, id)
    }

    #[inline]
    pub unsafe fn set_item_metadata(&mut self, idx: i64, metadata: Variant) -> () {
        PopupMenu_set_item_metadata(self.this, idx, metadata)
    }

    #[inline]
    pub unsafe fn set_item_multistate(&mut self, idx: i64, state: i64) -> () {
        PopupMenu_set_item_multistate(self.this, idx, state)
    }

    #[inline]
    pub unsafe fn set_item_shortcut(&mut self, idx: i64, shortcut: Option<ShortCut>, global: bool) -> () {
        PopupMenu_set_item_shortcut(self.this, idx, shortcut, global)
    }

    #[inline]
    pub unsafe fn set_item_shortcut_disabled(&mut self, idx: i64, disabled: bool) -> () {
        PopupMenu_set_item_shortcut_disabled(self.this, idx, disabled)
    }

    #[inline]
    pub unsafe fn set_item_submenu(&mut self, idx: i64, submenu: GodotString) -> () {
        PopupMenu_set_item_submenu(self.this, idx, submenu)
    }

    #[inline]
    pub unsafe fn set_item_text(&mut self, idx: i64, text: GodotString) -> () {
        PopupMenu_set_item_text(self.this, idx, text)
    }

    #[inline]
    pub unsafe fn set_item_tooltip(&mut self, idx: i64, tooltip: GodotString) -> () {
        PopupMenu_set_item_tooltip(self.this, idx, tooltip)
    }

    #[inline]
    pub unsafe fn set_submenu_popup_delay(&mut self, seconds: f64) -> () {
        PopupMenu_set_submenu_popup_delay(self.this, seconds)
    }

    #[inline]
    pub unsafe fn toggle_item_checked(&mut self, idx: i64) -> () {
        PopupMenu_toggle_item_checked(self.this, idx)
    }

    #[inline]
    pub unsafe fn toggle_item_multistate(&mut self, idx: i64) -> () {
        PopupMenu_toggle_item_multistate(self.this, idx)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PopupPanel` inherits `Popup` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_popuppanel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `PopupPanel` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `PopupPanel::free`.
///
/// ## Class hierarchy
///
/// PopupPanel inherits methods from:
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PopupPanel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PopupPanel {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `PopupPanel::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PopupPanelMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            PopupPanel {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Position2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_position2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Position2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Position2D::free`.
///
/// ## Class hierarchy
///
/// Position2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Position2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Position2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Position2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Position2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Position2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_gizmo_extents(&self) -> f64 {
        Position2D__get_gizmo_extents(self.this)
    }

    #[inline]
    pub unsafe fn _set_gizmo_extents(&mut self, extents: f64) -> () {
        Position2D__set_gizmo_extents(self.this, extents)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Position3D` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_position3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Position3D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Position3D::free`.
///
/// ## Class hierarchy
///
/// Position3D inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Position3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Position3D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Position3D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Position3DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Position3D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PrimitiveMesh` inherits `Mesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_primitivemesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PrimitiveMesh inherits methods from:
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PrimitiveMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PrimitiveMesh {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _update(&self) -> () {
        unsafe { PrimitiveMesh__update(self.this) }
    }

    #[inline]
    pub fn get_custom_aabb(&self) -> Aabb {
        unsafe { PrimitiveMesh_get_custom_aabb(self.this) }
    }

    #[inline]
    pub fn get_flip_faces(&self) -> bool {
        unsafe { PrimitiveMesh_get_flip_faces(self.this) }
    }

    #[inline]
    pub fn get_material(&self) -> Option<Material> {
        unsafe { PrimitiveMesh_get_material(self.this) }
    }

    #[inline]
    pub fn get_mesh_arrays(&self) -> VariantArray {
        unsafe { PrimitiveMesh_get_mesh_arrays(self.this) }
    }

    #[inline]
    pub fn set_custom_aabb(&mut self, aabb: Aabb) -> () {
        unsafe { PrimitiveMesh_set_custom_aabb(self.this, aabb) }
    }

    #[inline]
    pub fn set_flip_faces(&mut self, flip_faces: bool) -> () {
        unsafe { PrimitiveMesh_set_flip_faces(self.this, flip_faces) }
    }

    #[inline]
    pub fn set_material(&mut self, material: Option<Material>) -> () {
        unsafe { PrimitiveMesh_set_material(self.this, material) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class PrismMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_prismmesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// PrismMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct PrismMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl PrismMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = PrismMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            PrismMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_left_to_right(&self) -> f64 {
        unsafe { PrismMesh_get_left_to_right(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector3 {
        unsafe { PrismMesh_get_size(self.this) }
    }

    #[inline]
    pub fn get_subdivide_depth(&self) -> i64 {
        unsafe { PrismMesh_get_subdivide_depth(self.this) }
    }

    #[inline]
    pub fn get_subdivide_height(&self) -> i64 {
        unsafe { PrismMesh_get_subdivide_height(self.this) }
    }

    #[inline]
    pub fn get_subdivide_width(&self) -> i64 {
        unsafe { PrismMesh_get_subdivide_width(self.this) }
    }

    #[inline]
    pub fn set_left_to_right(&mut self, left_to_right: f64) -> () {
        unsafe { PrismMesh_set_left_to_right(self.this, left_to_right) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector3) -> () {
        unsafe { PrismMesh_set_size(self.this, size) }
    }

    #[inline]
    pub fn set_subdivide_depth(&mut self, segments: i64) -> () {
        unsafe { PrismMesh_set_subdivide_depth(self.this, segments) }
    }

    #[inline]
    pub fn set_subdivide_height(&mut self, segments: i64) -> () {
        unsafe { PrismMesh_set_subdivide_height(self.this, segments) }
    }

    #[inline]
    pub fn set_subdivide_width(&mut self, segments: i64) -> () {
        unsafe { PrismMesh_set_subdivide_width(self.this, segments) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ProceduralSky` inherits `Sky` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_proceduralsky.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ProceduralSky inherits methods from:
/// - [Sky](struct.Sky.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ProceduralSky {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ProceduralSkyTextureSize {
    TextureSize256 = 0,
    TextureSize512 = 1,
    TextureSize1024 = 2,
    TextureSize2048 = 3,
    TextureSize4096 = 4,
    Max = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ProceduralSky {
    pub const TEXTURE_SIZE_512: i64 = 1;
    pub const TEXTURE_SIZE_1024: i64 = 2;
    pub const TEXTURE_SIZE_2048: i64 = 3;
    pub const TEXTURE_SIZE_4096: i64 = 4;
    pub const TEXTURE_SIZE_256: i64 = 0;
    pub const TEXTURE_SIZE_MAX: i64 = 5;
}
impl ProceduralSky {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ProceduralSkyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ProceduralSky {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _thread_done(&mut self, image: Option<Image>) -> () {
        unsafe { ProceduralSky__thread_done(self.this, image) }
    }

    #[inline]
    pub fn _update_sky(&mut self) -> () {
        unsafe { ProceduralSky__update_sky(self.this) }
    }

    #[inline]
    pub fn get_ground_bottom_color(&self) -> Color {
        unsafe { ProceduralSky_get_ground_bottom_color(self.this) }
    }

    #[inline]
    pub fn get_ground_curve(&self) -> f64 {
        unsafe { ProceduralSky_get_ground_curve(self.this) }
    }

    #[inline]
    pub fn get_ground_energy(&self) -> f64 {
        unsafe { ProceduralSky_get_ground_energy(self.this) }
    }

    #[inline]
    pub fn get_ground_horizon_color(&self) -> Color {
        unsafe { ProceduralSky_get_ground_horizon_color(self.this) }
    }

    #[inline]
    pub fn get_sky_curve(&self) -> f64 {
        unsafe { ProceduralSky_get_sky_curve(self.this) }
    }

    #[inline]
    pub fn get_sky_energy(&self) -> f64 {
        unsafe { ProceduralSky_get_sky_energy(self.this) }
    }

    #[inline]
    pub fn get_sky_horizon_color(&self) -> Color {
        unsafe { ProceduralSky_get_sky_horizon_color(self.this) }
    }

    #[inline]
    pub fn get_sky_top_color(&self) -> Color {
        unsafe { ProceduralSky_get_sky_top_color(self.this) }
    }

    #[inline]
    pub fn get_sun_angle_max(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_angle_max(self.this) }
    }

    #[inline]
    pub fn get_sun_angle_min(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_angle_min(self.this) }
    }

    #[inline]
    pub fn get_sun_color(&self) -> Color {
        unsafe { ProceduralSky_get_sun_color(self.this) }
    }

    #[inline]
    pub fn get_sun_curve(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_curve(self.this) }
    }

    #[inline]
    pub fn get_sun_energy(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_energy(self.this) }
    }

    #[inline]
    pub fn get_sun_latitude(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_latitude(self.this) }
    }

    #[inline]
    pub fn get_sun_longitude(&self) -> f64 {
        unsafe { ProceduralSky_get_sun_longitude(self.this) }
    }

    #[inline]
    pub fn get_texture_size(&self) -> ProceduralSkyTextureSize {
        unsafe { ProceduralSky_get_texture_size(self.this) }
    }

    #[inline]
    pub fn set_ground_bottom_color(&mut self, color: Color) -> () {
        unsafe { ProceduralSky_set_ground_bottom_color(self.this, color) }
    }

    #[inline]
    pub fn set_ground_curve(&mut self, curve: f64) -> () {
        unsafe { ProceduralSky_set_ground_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_ground_energy(&mut self, energy: f64) -> () {
        unsafe { ProceduralSky_set_ground_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_ground_horizon_color(&mut self, color: Color) -> () {
        unsafe { ProceduralSky_set_ground_horizon_color(self.this, color) }
    }

    #[inline]
    pub fn set_sky_curve(&mut self, curve: f64) -> () {
        unsafe { ProceduralSky_set_sky_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_sky_energy(&mut self, energy: f64) -> () {
        unsafe { ProceduralSky_set_sky_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_sky_horizon_color(&mut self, color: Color) -> () {
        unsafe { ProceduralSky_set_sky_horizon_color(self.this, color) }
    }

    #[inline]
    pub fn set_sky_top_color(&mut self, color: Color) -> () {
        unsafe { ProceduralSky_set_sky_top_color(self.this, color) }
    }

    #[inline]
    pub fn set_sun_angle_max(&mut self, degrees: f64) -> () {
        unsafe { ProceduralSky_set_sun_angle_max(self.this, degrees) }
    }

    #[inline]
    pub fn set_sun_angle_min(&mut self, degrees: f64) -> () {
        unsafe { ProceduralSky_set_sun_angle_min(self.this, degrees) }
    }

    #[inline]
    pub fn set_sun_color(&mut self, color: Color) -> () {
        unsafe { ProceduralSky_set_sun_color(self.this, color) }
    }

    #[inline]
    pub fn set_sun_curve(&mut self, curve: f64) -> () {
        unsafe { ProceduralSky_set_sun_curve(self.this, curve) }
    }

    #[inline]
    pub fn set_sun_energy(&mut self, energy: f64) -> () {
        unsafe { ProceduralSky_set_sun_energy(self.this, energy) }
    }

    #[inline]
    pub fn set_sun_latitude(&mut self, degrees: f64) -> () {
        unsafe { ProceduralSky_set_sun_latitude(self.this, degrees) }
    }

    #[inline]
    pub fn set_sun_longitude(&mut self, degrees: f64) -> () {
        unsafe { ProceduralSky_set_sun_longitude(self.this, degrees) }
    }

    #[inline]
    pub fn set_texture_size(&mut self, size: i64) -> () {
        unsafe { ProceduralSky_set_texture_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_sky(&self) -> Sky {
        unsafe {{ object::add_ref(self.this); }}
        Sky { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ProgressBar` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_progressbar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ProgressBar` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ProgressBar::free`.
///
/// ## Class hierarchy
///
/// ProgressBar inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ProgressBar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ProgressBar {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ProgressBar::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ProgressBarMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ProgressBar {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn is_percent_visible(&self) -> bool {
        ProgressBar_is_percent_visible(self.this)
    }

    #[inline]
    pub unsafe fn set_percent_visible(&mut self, visible: bool) -> () {
        ProgressBar_set_percent_visible(self.this, visible)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class ProjectSettings` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_projectsettings.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ProjectSettings inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ProjectSettings {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ProjectSettings {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"ProjectSettings\0".as_ptr() as *mut _);

            ProjectSettings {
                this
            }
        }
    }
    #[inline]
    pub fn add_property_info(&mut self, hint: Dictionary) -> () {
        unsafe { ProjectSettings_add_property_info(self.this, hint) }
    }

    #[inline]
    pub fn clear(&mut self, name: GodotString) -> () {
        unsafe { ProjectSettings_clear(self.this, name) }
    }

    #[inline]
    pub fn get_order(&self, name: GodotString) -> i64 {
        unsafe { ProjectSettings_get_order(self.this, name) }
    }

    #[inline]
    pub fn get_setting(&self, name: GodotString) -> Variant {
        unsafe { ProjectSettings_get_setting(self.this, name) }
    }

    #[inline]
    pub fn globalize_path(&self, path: GodotString) -> GodotString {
        unsafe { ProjectSettings_globalize_path(self.this, path) }
    }

    #[inline]
    pub fn has_setting(&self, name: GodotString) -> bool {
        unsafe { ProjectSettings_has_setting(self.this, name) }
    }

    #[inline]
    pub fn load_resource_pack(&mut self, pack: GodotString, replace_files: bool) -> bool {
        unsafe { ProjectSettings_load_resource_pack(self.this, pack, replace_files) }
    }

    #[inline]
    pub fn localize_path(&self, path: GodotString) -> GodotString {
        unsafe { ProjectSettings_localize_path(self.this, path) }
    }

    #[inline]
    pub fn property_can_revert(&mut self, name: GodotString) -> bool {
        unsafe { ProjectSettings_property_can_revert(self.this, name) }
    }

    #[inline]
    pub fn property_get_revert(&mut self, name: GodotString) -> Variant {
        unsafe { ProjectSettings_property_get_revert(self.this, name) }
    }

    #[inline]
    pub fn save(&mut self) -> GodotResult {
        unsafe { ProjectSettings_save(self.this) }
    }

    #[inline]
    pub fn save_custom(&mut self, file: GodotString) -> GodotResult {
        unsafe { ProjectSettings_save_custom(self.this, file) }
    }

    #[inline]
    pub fn set_initial_value(&mut self, name: GodotString, value: Variant) -> () {
        unsafe { ProjectSettings_set_initial_value(self.this, name, value) }
    }

    #[inline]
    pub fn set_order(&mut self, name: GodotString, position: i64) -> () {
        unsafe { ProjectSettings_set_order(self.this, name, position) }
    }

    #[inline]
    pub fn set_setting(&mut self, name: GodotString, value: Variant) -> () {
        unsafe { ProjectSettings_set_setting(self.this, name, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ProximityGroup` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_proximitygroup.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ProximityGroup` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ProximityGroup::free`.
///
/// ## Class hierarchy
///
/// ProximityGroup inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ProximityGroup {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ProximityGroupDispatchMode {
    ModeProxy = 0,
    ModeSignal = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ProximityGroup {
    pub const MODE_SIGNAL: i64 = 1;
    pub const MODE_PROXY: i64 = 0;
}
impl ProximityGroup {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ProximityGroup::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ProximityGroupMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ProximityGroup {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _proximity_group_broadcast(&mut self, name: GodotString, params: Variant) -> () {
        ProximityGroup__proximity_group_broadcast(self.this, name, params)
    }

    #[inline]
    pub unsafe fn broadcast(&mut self, name: GodotString, parameters: Variant) -> () {
        ProximityGroup_broadcast(self.this, name, parameters)
    }

    #[inline]
    pub unsafe fn get_dispatch_mode(&self) -> ProximityGroupDispatchMode {
        ProximityGroup_get_dispatch_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_grid_radius(&self) -> Vector3 {
        ProximityGroup_get_grid_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_group_name(&self) -> GodotString {
        ProximityGroup_get_group_name(self.this)
    }

    #[inline]
    pub unsafe fn set_dispatch_mode(&mut self, mode: i64) -> () {
        ProximityGroup_set_dispatch_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_grid_radius(&mut self, radius: Vector3) -> () {
        ProximityGroup_set_grid_radius(self.this, radius)
    }

    #[inline]
    pub unsafe fn set_group_name(&mut self, name: GodotString) -> () {
        ProximityGroup_set_group_name(self.this, name)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ProxyTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_proxytexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ProxyTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ProxyTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ProxyTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ProxyTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ProxyTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_base(&self) -> Option<Texture> {
        unsafe { ProxyTexture_get_base(self.this) }
    }

    #[inline]
    pub fn set_base(&mut self, base: Option<Texture>) -> () {
        unsafe { ProxyTexture_set_base(self.this, base) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class QuadMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_quadmesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// QuadMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct QuadMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl QuadMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = QuadMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            QuadMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { QuadMesh_get_size(self.this) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector2) -> () {
        unsafe { QuadMesh_set_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RandomNumberGenerator` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_randomnumbergenerator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RandomNumberGenerator inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RandomNumberGenerator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RandomNumberGenerator {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RandomNumberGeneratorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RandomNumberGenerator {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_seed(&mut self) -> i64 {
        unsafe { RandomNumberGenerator_get_seed(self.this) }
    }

    #[inline]
    pub fn randf(&mut self) -> f64 {
        unsafe { RandomNumberGenerator_randf(self.this) }
    }

    #[inline]
    pub fn randf_range(&mut self, from: f64, to: f64) -> f64 {
        unsafe { RandomNumberGenerator_randf_range(self.this, from, to) }
    }

    #[inline]
    pub fn randfn(&mut self, mean: f64, deviation: f64) -> f64 {
        unsafe { RandomNumberGenerator_randfn(self.this, mean, deviation) }
    }

    #[inline]
    pub fn randi(&mut self) -> i64 {
        unsafe { RandomNumberGenerator_randi(self.this) }
    }

    #[inline]
    pub fn randi_range(&mut self, from: i64, to: i64) -> i64 {
        unsafe { RandomNumberGenerator_randi_range(self.this, from, to) }
    }

    #[inline]
    pub fn randomize(&mut self) -> () {
        unsafe { RandomNumberGenerator_randomize(self.this) }
    }

    #[inline]
    pub fn set_seed(&mut self, seed: i64) -> () {
        unsafe { RandomNumberGenerator_set_seed(self.this, seed) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Range` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_range.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Range inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Range {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Range {
    #[inline]
    pub unsafe fn get_as_ratio(&self) -> f64 {
        Range_get_as_ratio(self.this)
    }

    #[inline]
    pub unsafe fn get_max(&self) -> f64 {
        Range_get_max(self.this)
    }

    #[inline]
    pub unsafe fn get_min(&self) -> f64 {
        Range_get_min(self.this)
    }

    #[inline]
    pub unsafe fn get_page(&self) -> f64 {
        Range_get_page(self.this)
    }

    #[inline]
    pub unsafe fn get_step(&self) -> f64 {
        Range_get_step(self.this)
    }

    #[inline]
    pub unsafe fn get_value(&self) -> f64 {
        Range_get_value(self.this)
    }

    #[inline]
    pub unsafe fn is_greater_allowed(&self) -> bool {
        Range_is_greater_allowed(self.this)
    }

    #[inline]
    pub unsafe fn is_lesser_allowed(&self) -> bool {
        Range_is_lesser_allowed(self.this)
    }

    #[inline]
    pub unsafe fn is_ratio_exp(&self) -> bool {
        Range_is_ratio_exp(self.this)
    }

    #[inline]
    pub unsafe fn is_using_rounded_values(&self) -> bool {
        Range_is_using_rounded_values(self.this)
    }

    #[inline]
    pub unsafe fn set_allow_greater(&mut self, allow: bool) -> () {
        Range_set_allow_greater(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_allow_lesser(&mut self, allow: bool) -> () {
        Range_set_allow_lesser(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_as_ratio(&mut self, value: f64) -> () {
        Range_set_as_ratio(self.this, value)
    }

    #[inline]
    pub unsafe fn set_exp_ratio(&mut self, enabled: bool) -> () {
        Range_set_exp_ratio(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_max(&mut self, maximum: f64) -> () {
        Range_set_max(self.this, maximum)
    }

    #[inline]
    pub unsafe fn set_min(&mut self, minimum: f64) -> () {
        Range_set_min(self.this, minimum)
    }

    #[inline]
    pub unsafe fn set_page(&mut self, pagesize: f64) -> () {
        Range_set_page(self.this, pagesize)
    }

    #[inline]
    pub unsafe fn set_step(&mut self, step: f64) -> () {
        Range_set_step(self.this, step)
    }

    #[inline]
    pub unsafe fn set_use_rounded_values(&mut self, enabled: bool) -> () {
        Range_set_use_rounded_values(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_value(&mut self, value: f64) -> () {
        Range_set_value(self.this, value)
    }

    #[inline]
    pub unsafe fn share(&mut self, with: Option<Node>) -> () {
        Range_share(self.this, with)
    }

    #[inline]
    pub unsafe fn unshare(&mut self) -> () {
        Range_unshare(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RayCast` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_raycast.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RayCast` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RayCast::free`.
///
/// ## Class hierarchy
///
/// RayCast inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RayCast {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RayCast {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RayCast::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RayCastMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RayCast {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_exception(&mut self, node: Option<Object>) -> () {
        RayCast_add_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn add_exception_rid(&mut self, rid: Rid) -> () {
        RayCast_add_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn clear_exceptions(&mut self) -> () {
        RayCast_clear_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn force_raycast_update(&mut self) -> () {
        RayCast_force_raycast_update(self.this)
    }

    #[inline]
    pub unsafe fn get_cast_to(&self) -> Vector3 {
        RayCast_get_cast_to(self.this)
    }

    #[inline]
    pub unsafe fn get_collider(&self) -> Option<Object> {
        RayCast_get_collider(self.this)
    }

    #[inline]
    pub unsafe fn get_collider_shape(&self) -> i64 {
        RayCast_get_collider_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        RayCast_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        RayCast_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_normal(&self) -> Vector3 {
        RayCast_get_collision_normal(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_point(&self) -> Vector3 {
        RayCast_get_collision_point(self.this)
    }

    #[inline]
    pub unsafe fn get_exclude_parent_body(&self) -> bool {
        RayCast_get_exclude_parent_body(self.this)
    }

    #[inline]
    pub unsafe fn is_collide_with_areas_enabled(&self) -> bool {
        RayCast_is_collide_with_areas_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_collide_with_bodies_enabled(&self) -> bool {
        RayCast_is_collide_with_bodies_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_colliding(&self) -> bool {
        RayCast_is_colliding(self.this)
    }

    #[inline]
    pub unsafe fn is_enabled(&self) -> bool {
        RayCast_is_enabled(self.this)
    }

    #[inline]
    pub unsafe fn remove_exception(&mut self, node: Option<Object>) -> () {
        RayCast_remove_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn remove_exception_rid(&mut self, rid: Rid) -> () {
        RayCast_remove_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn set_cast_to(&mut self, local_point: Vector3) -> () {
        RayCast_set_cast_to(self.this, local_point)
    }

    #[inline]
    pub unsafe fn set_collide_with_areas(&mut self, enable: bool) -> () {
        RayCast_set_collide_with_areas(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collide_with_bodies(&mut self, enable: bool) -> () {
        RayCast_set_collide_with_bodies(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        RayCast_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        RayCast_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_enabled(&mut self, enabled: bool) -> () {
        RayCast_set_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_exclude_parent_body(&mut self, mask: bool) -> () {
        RayCast_set_exclude_parent_body(self.this, mask)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RayCast2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_raycast2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RayCast2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RayCast2D::free`.
///
/// ## Class hierarchy
///
/// RayCast2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RayCast2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RayCast2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RayCast2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RayCast2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RayCast2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_exception(&mut self, node: Option<Object>) -> () {
        RayCast2D_add_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn add_exception_rid(&mut self, rid: Rid) -> () {
        RayCast2D_add_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn clear_exceptions(&mut self) -> () {
        RayCast2D_clear_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn force_raycast_update(&mut self) -> () {
        RayCast2D_force_raycast_update(self.this)
    }

    #[inline]
    pub unsafe fn get_cast_to(&self) -> Vector2 {
        RayCast2D_get_cast_to(self.this)
    }

    #[inline]
    pub unsafe fn get_collider(&self) -> Option<Object> {
        RayCast2D_get_collider(self.this)
    }

    #[inline]
    pub unsafe fn get_collider_shape(&self) -> i64 {
        RayCast2D_get_collider_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        RayCast2D_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        RayCast2D_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_normal(&self) -> Vector2 {
        RayCast2D_get_collision_normal(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_point(&self) -> Vector2 {
        RayCast2D_get_collision_point(self.this)
    }

    #[inline]
    pub unsafe fn get_exclude_parent_body(&self) -> bool {
        RayCast2D_get_exclude_parent_body(self.this)
    }

    #[inline]
    pub unsafe fn is_collide_with_areas_enabled(&self) -> bool {
        RayCast2D_is_collide_with_areas_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_collide_with_bodies_enabled(&self) -> bool {
        RayCast2D_is_collide_with_bodies_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_colliding(&self) -> bool {
        RayCast2D_is_colliding(self.this)
    }

    #[inline]
    pub unsafe fn is_enabled(&self) -> bool {
        RayCast2D_is_enabled(self.this)
    }

    #[inline]
    pub unsafe fn remove_exception(&mut self, node: Option<Object>) -> () {
        RayCast2D_remove_exception(self.this, node)
    }

    #[inline]
    pub unsafe fn remove_exception_rid(&mut self, rid: Rid) -> () {
        RayCast2D_remove_exception_rid(self.this, rid)
    }

    #[inline]
    pub unsafe fn set_cast_to(&mut self, local_point: Vector2) -> () {
        RayCast2D_set_cast_to(self.this, local_point)
    }

    #[inline]
    pub unsafe fn set_collide_with_areas(&mut self, enable: bool) -> () {
        RayCast2D_set_collide_with_areas(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collide_with_bodies(&mut self, enable: bool) -> () {
        RayCast2D_set_collide_with_bodies(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        RayCast2D_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        RayCast2D_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_enabled(&mut self, enabled: bool) -> () {
        RayCast2D_set_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_exclude_parent_body(&mut self, mask: bool) -> () {
        RayCast2D_set_exclude_parent_body(self.this, mask)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RayShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rayshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RayShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RayShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RayShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RayShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RayShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_length(&self) -> f64 {
        unsafe { RayShape_get_length(self.this) }
    }

    #[inline]
    pub fn get_slips_on_slope(&self) -> bool {
        unsafe { RayShape_get_slips_on_slope(self.this) }
    }

    #[inline]
    pub fn set_length(&mut self, length: f64) -> () {
        unsafe { RayShape_set_length(self.this, length) }
    }

    #[inline]
    pub fn set_slips_on_slope(&mut self, active: bool) -> () {
        unsafe { RayShape_set_slips_on_slope(self.this, active) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RayShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rayshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RayShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RayShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RayShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RayShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RayShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_length(&self) -> f64 {
        unsafe { RayShape2D_get_length(self.this) }
    }

    #[inline]
    pub fn get_slips_on_slope(&self) -> bool {
        unsafe { RayShape2D_get_slips_on_slope(self.this) }
    }

    #[inline]
    pub fn set_length(&mut self, length: f64) -> () {
        unsafe { RayShape2D_set_length(self.this, length) }
    }

    #[inline]
    pub fn set_slips_on_slope(&mut self, active: bool) -> () {
        unsafe { RayShape2D_set_slips_on_slope(self.this, active) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RectangleShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rectangleshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RectangleShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RectangleShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RectangleShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RectangleShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RectangleShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_extents(&self) -> Vector2 {
        unsafe { RectangleShape2D_get_extents(self.this) }
    }

    #[inline]
    pub fn set_extents(&mut self, extents: Vector2) -> () {
        unsafe { RectangleShape2D_set_extents(self.this, extents) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ReferenceRect` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_referencerect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ReferenceRect` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ReferenceRect::free`.
///
/// ## Class hierarchy
///
/// ReferenceRect inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ReferenceRect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ReferenceRect {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ReferenceRect::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ReferenceRectMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ReferenceRect {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_border_color(&self) -> Color {
        ReferenceRect_get_border_color(self.this)
    }

    #[inline]
    pub unsafe fn get_editor_only(&self) -> bool {
        ReferenceRect_get_editor_only(self.this)
    }

    #[inline]
    pub unsafe fn set_border_color(&mut self, color: Color) -> () {
        ReferenceRect_set_border_color(self.this, color)
    }

    #[inline]
    pub unsafe fn set_editor_only(&mut self, enabled: bool) -> () {
        ReferenceRect_set_editor_only(self.this, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ReflectionProbe` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_reflectionprobe.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ReflectionProbe` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ReflectionProbe::free`.
///
/// ## Class hierarchy
///
/// ReflectionProbe inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ReflectionProbe {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ReflectionProbeUpdateMode {
    Once = 0,
    Always = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ReflectionProbe {
    pub const UPDATE_ONCE: i64 = 0;
    pub const UPDATE_ALWAYS: i64 = 1;
}
impl ReflectionProbe {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ReflectionProbe::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ReflectionProbeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ReflectionProbe {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn are_shadows_enabled(&self) -> bool {
        ReflectionProbe_are_shadows_enabled(self.this)
    }

    #[inline]
    pub unsafe fn get_cull_mask(&self) -> i64 {
        ReflectionProbe_get_cull_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_extents(&self) -> Vector3 {
        ReflectionProbe_get_extents(self.this)
    }

    #[inline]
    pub unsafe fn get_intensity(&self) -> f64 {
        ReflectionProbe_get_intensity(self.this)
    }

    #[inline]
    pub unsafe fn get_interior_ambient(&self) -> Color {
        ReflectionProbe_get_interior_ambient(self.this)
    }

    #[inline]
    pub unsafe fn get_interior_ambient_energy(&self) -> f64 {
        ReflectionProbe_get_interior_ambient_energy(self.this)
    }

    #[inline]
    pub unsafe fn get_interior_ambient_probe_contribution(&self) -> f64 {
        ReflectionProbe_get_interior_ambient_probe_contribution(self.this)
    }

    #[inline]
    pub unsafe fn get_max_distance(&self) -> f64 {
        ReflectionProbe_get_max_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_origin_offset(&self) -> Vector3 {
        ReflectionProbe_get_origin_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_update_mode(&self) -> ReflectionProbeUpdateMode {
        ReflectionProbe_get_update_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_box_projection_enabled(&self) -> bool {
        ReflectionProbe_is_box_projection_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_set_as_interior(&self) -> bool {
        ReflectionProbe_is_set_as_interior(self.this)
    }

    #[inline]
    pub unsafe fn set_as_interior(&mut self, enable: bool) -> () {
        ReflectionProbe_set_as_interior(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_cull_mask(&mut self, layers: i64) -> () {
        ReflectionProbe_set_cull_mask(self.this, layers)
    }

    #[inline]
    pub unsafe fn set_enable_box_projection(&mut self, enable: bool) -> () {
        ReflectionProbe_set_enable_box_projection(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_enable_shadows(&mut self, enable: bool) -> () {
        ReflectionProbe_set_enable_shadows(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_extents(&mut self, extents: Vector3) -> () {
        ReflectionProbe_set_extents(self.this, extents)
    }

    #[inline]
    pub unsafe fn set_intensity(&mut self, intensity: f64) -> () {
        ReflectionProbe_set_intensity(self.this, intensity)
    }

    #[inline]
    pub unsafe fn set_interior_ambient(&mut self, ambient: Color) -> () {
        ReflectionProbe_set_interior_ambient(self.this, ambient)
    }

    #[inline]
    pub unsafe fn set_interior_ambient_energy(&mut self, ambient_energy: f64) -> () {
        ReflectionProbe_set_interior_ambient_energy(self.this, ambient_energy)
    }

    #[inline]
    pub unsafe fn set_interior_ambient_probe_contribution(&mut self, ambient_probe_contribution: f64) -> () {
        ReflectionProbe_set_interior_ambient_probe_contribution(self.this, ambient_probe_contribution)
    }

    #[inline]
    pub unsafe fn set_max_distance(&mut self, max_distance: f64) -> () {
        ReflectionProbe_set_max_distance(self.this, max_distance)
    }

    #[inline]
    pub unsafe fn set_origin_offset(&mut self, origin_offset: Vector3) -> () {
        ReflectionProbe_set_origin_offset(self.this, origin_offset)
    }

    #[inline]
    pub unsafe fn set_update_mode(&mut self, mode: i64) -> () {
        ReflectionProbe_set_update_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RegEx` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_regex.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RegEx inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RegEx {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RegEx {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RegExMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RegEx {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { RegEx_clear(self.this) }
    }

    #[inline]
    pub fn compile(&mut self, pattern: GodotString) -> GodotResult {
        unsafe { RegEx_compile(self.this, pattern) }
    }

    #[inline]
    pub fn get_group_count(&self) -> i64 {
        unsafe { RegEx_get_group_count(self.this) }
    }

    #[inline]
    pub fn get_names(&self) -> VariantArray {
        unsafe { RegEx_get_names(self.this) }
    }

    #[inline]
    pub fn get_pattern(&self) -> GodotString {
        unsafe { RegEx_get_pattern(self.this) }
    }

    #[inline]
    pub fn is_valid(&self) -> bool {
        unsafe { RegEx_is_valid(self.this) }
    }

    #[inline]
    pub fn search(&self, subject: GodotString, offset: i64, end: i64) -> Option<RegExMatch> {
        unsafe { RegEx_search(self.this, subject, offset, end) }
    }

    #[inline]
    pub fn search_all(&self, subject: GodotString, offset: i64, end: i64) -> VariantArray {
        unsafe { RegEx_search_all(self.this, subject, offset, end) }
    }

    #[inline]
    pub fn sub(&self, subject: GodotString, replacement: GodotString, all: bool, offset: i64, end: i64) -> GodotString {
        unsafe { RegEx_sub(self.this, subject, replacement, all, offset, end) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RegExMatch` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_regexmatch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RegExMatch inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RegExMatch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RegExMatch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RegExMatchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RegExMatch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_end(&self, name: Variant) -> i64 {
        unsafe { RegExMatch_get_end(self.this, name) }
    }

    #[inline]
    pub fn get_group_count(&self) -> i64 {
        unsafe { RegExMatch_get_group_count(self.this) }
    }

    #[inline]
    pub fn get_names(&self) -> Dictionary {
        unsafe { RegExMatch_get_names(self.this) }
    }

    #[inline]
    pub fn get_start(&self, name: Variant) -> i64 {
        unsafe { RegExMatch_get_start(self.this, name) }
    }

    #[inline]
    pub fn get_string(&self, name: Variant) -> GodotString {
        unsafe { RegExMatch_get_string(self.this, name) }
    }

    #[inline]
    pub fn get_strings(&self) -> VariantArray {
        unsafe { RegExMatch_get_strings(self.this) }
    }

    #[inline]
    pub fn get_subject(&self) -> GodotString {
        unsafe { RegExMatch_get_subject(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RemoteTransform` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_remotetransform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RemoteTransform` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RemoteTransform::free`.
///
/// ## Class hierarchy
///
/// RemoteTransform inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RemoteTransform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RemoteTransform {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RemoteTransform::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RemoteTransformMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RemoteTransform {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn force_update_cache(&mut self) -> () {
        RemoteTransform_force_update_cache(self.this)
    }

    #[inline]
    pub unsafe fn get_remote_node(&self) -> NodePath {
        RemoteTransform_get_remote_node(self.this)
    }

    #[inline]
    pub unsafe fn get_update_position(&self) -> bool {
        RemoteTransform_get_update_position(self.this)
    }

    #[inline]
    pub unsafe fn get_update_rotation(&self) -> bool {
        RemoteTransform_get_update_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_update_scale(&self) -> bool {
        RemoteTransform_get_update_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_use_global_coordinates(&self) -> bool {
        RemoteTransform_get_use_global_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn set_remote_node(&mut self, path: NodePath) -> () {
        RemoteTransform_set_remote_node(self.this, path)
    }

    #[inline]
    pub unsafe fn set_update_position(&mut self, update_remote_position: bool) -> () {
        RemoteTransform_set_update_position(self.this, update_remote_position)
    }

    #[inline]
    pub unsafe fn set_update_rotation(&mut self, update_remote_rotation: bool) -> () {
        RemoteTransform_set_update_rotation(self.this, update_remote_rotation)
    }

    #[inline]
    pub unsafe fn set_update_scale(&mut self, update_remote_scale: bool) -> () {
        RemoteTransform_set_update_scale(self.this, update_remote_scale)
    }

    #[inline]
    pub unsafe fn set_use_global_coordinates(&mut self, use_global_coordinates: bool) -> () {
        RemoteTransform_set_use_global_coordinates(self.this, use_global_coordinates)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RemoteTransform2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_remotetransform2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RemoteTransform2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RemoteTransform2D::free`.
///
/// ## Class hierarchy
///
/// RemoteTransform2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RemoteTransform2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RemoteTransform2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RemoteTransform2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RemoteTransform2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RemoteTransform2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn force_update_cache(&mut self) -> () {
        RemoteTransform2D_force_update_cache(self.this)
    }

    #[inline]
    pub unsafe fn get_remote_node(&self) -> NodePath {
        RemoteTransform2D_get_remote_node(self.this)
    }

    #[inline]
    pub unsafe fn get_update_position(&self) -> bool {
        RemoteTransform2D_get_update_position(self.this)
    }

    #[inline]
    pub unsafe fn get_update_rotation(&self) -> bool {
        RemoteTransform2D_get_update_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_update_scale(&self) -> bool {
        RemoteTransform2D_get_update_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_use_global_coordinates(&self) -> bool {
        RemoteTransform2D_get_use_global_coordinates(self.this)
    }

    #[inline]
    pub unsafe fn set_remote_node(&mut self, path: NodePath) -> () {
        RemoteTransform2D_set_remote_node(self.this, path)
    }

    #[inline]
    pub unsafe fn set_update_position(&mut self, update_remote_position: bool) -> () {
        RemoteTransform2D_set_update_position(self.this, update_remote_position)
    }

    #[inline]
    pub unsafe fn set_update_rotation(&mut self, update_remote_rotation: bool) -> () {
        RemoteTransform2D_set_update_rotation(self.this, update_remote_rotation)
    }

    #[inline]
    pub unsafe fn set_update_scale(&mut self, update_remote_scale: bool) -> () {
        RemoteTransform2D_set_update_scale(self.this, update_remote_scale)
    }

    #[inline]
    pub unsafe fn set_use_global_coordinates(&mut self, use_global_coordinates: bool) -> () {
        RemoteTransform2D_set_use_global_coordinates(self.this, use_global_coordinates)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Resource` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resource.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Resource inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Resource {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Resource {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ResourceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Resource {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _setup_local_to_scene(&mut self) -> () {
        unsafe { Resource__setup_local_to_scene(self.this) }
    }

    #[inline]
    pub fn duplicate(&self, subresources: bool) -> Option<Resource> {
        unsafe { Resource_duplicate(self.this, subresources) }
    }

    #[inline]
    pub fn get_local_scene(&self) -> Option<Node> {
        unsafe { Resource_get_local_scene(self.this) }
    }

    #[inline]
    pub fn get_name(&self) -> GodotString {
        unsafe { Resource_get_name(self.this) }
    }

    #[inline]
    pub fn get_path(&self) -> GodotString {
        unsafe { Resource_get_path(self.this) }
    }

    #[inline]
    pub fn get_rid(&self) -> Rid {
        unsafe { Resource_get_rid(self.this) }
    }

    #[inline]
    pub fn is_local_to_scene(&self) -> bool {
        unsafe { Resource_is_local_to_scene(self.this) }
    }

    #[inline]
    pub fn set_local_to_scene(&mut self, enable: bool) -> () {
        unsafe { Resource_set_local_to_scene(self.this, enable) }
    }

    #[inline]
    pub fn set_name(&mut self, name: GodotString) -> () {
        unsafe { Resource_set_name(self.this, name) }
    }

    #[inline]
    pub fn set_path(&mut self, path: GodotString) -> () {
        unsafe { Resource_set_path(self.this, path) }
    }

    #[inline]
    pub fn setup_local_to_scene(&mut self) -> () {
        unsafe { Resource_setup_local_to_scene(self.this) }
    }

    #[inline]
    pub fn take_over_path(&mut self, path: GodotString) -> () {
        unsafe { Resource_take_over_path(self.this, path) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceFormatLoader` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceformatloader.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceFormatLoader inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceFormatLoader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceFormatLoader {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ResourceFormatLoaderMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ResourceFormatLoader {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_dependencies(&mut self, path: GodotString, add_types: GodotString) -> () {
        unsafe { ResourceFormatLoader_get_dependencies(self.this, path, add_types) }
    }

    #[inline]
    pub fn get_recognized_extensions(&mut self) -> StringArray {
        unsafe { ResourceFormatLoader_get_recognized_extensions(self.this) }
    }

    #[inline]
    pub fn get_resource_type(&mut self, path: GodotString) -> GodotString {
        unsafe { ResourceFormatLoader_get_resource_type(self.this, path) }
    }

    #[inline]
    pub fn handles_type(&mut self, typename: GodotString) -> bool {
        unsafe { ResourceFormatLoader_handles_type(self.this, typename) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString, original_path: GodotString) -> Variant {
        unsafe { ResourceFormatLoader_load(self.this, path, original_path) }
    }

    #[inline]
    pub fn rename_dependencies(&mut self, path: GodotString, renames: GodotString) -> i64 {
        unsafe { ResourceFormatLoader_rename_dependencies(self.this, path, renames) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceFormatLoaderCrypto` inherits `ResourceFormatLoader` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceformatloadercrypto.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceFormatLoaderCrypto inherits methods from:
/// - [ResourceFormatLoader](struct.ResourceFormatLoader.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceFormatLoaderCrypto {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceFormatLoaderCrypto {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource_format_loader(&self) -> ResourceFormatLoader {
        unsafe {{ object::add_ref(self.this); }}
        ResourceFormatLoader { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceFormatSaver` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceformatsaver.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceFormatSaver inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceFormatSaver {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceFormatSaver {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ResourceFormatSaverMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ResourceFormatSaver {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_recognized_extensions(&mut self, resource: Option<Resource>) -> StringArray {
        unsafe { ResourceFormatSaver_get_recognized_extensions(self.this, resource) }
    }

    #[inline]
    pub fn recognize(&mut self, resource: Option<Resource>) -> bool {
        unsafe { ResourceFormatSaver_recognize(self.this, resource) }
    }

    #[inline]
    pub fn save(&mut self, path: GodotString, resource: Option<Resource>, flags: i64) -> i64 {
        unsafe { ResourceFormatSaver_save(self.this, path, resource, flags) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceFormatSaverCrypto` inherits `ResourceFormatSaver` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceformatsavercrypto.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceFormatSaverCrypto inherits methods from:
/// - [ResourceFormatSaver](struct.ResourceFormatSaver.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceFormatSaverCrypto {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceFormatSaverCrypto {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource_format_saver(&self) -> ResourceFormatSaver {
        unsafe {{ object::add_ref(self.this); }}
        ResourceFormatSaver { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceImporter` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceimporter.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceImporter inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceImporter {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceImporter {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourceInteractiveLoader` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceinteractiveloader.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ResourceInteractiveLoader inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceInteractiveLoader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceInteractiveLoader {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_resource(&mut self) -> Option<Resource> {
        unsafe { ResourceInteractiveLoader_get_resource(self.this) }
    }

    #[inline]
    pub fn get_stage(&self) -> i64 {
        unsafe { ResourceInteractiveLoader_get_stage(self.this) }
    }

    #[inline]
    pub fn get_stage_count(&self) -> i64 {
        unsafe { ResourceInteractiveLoader_get_stage_count(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> GodotResult {
        unsafe { ResourceInteractiveLoader_poll(self.this) }
    }

    #[inline]
    pub fn wait(&mut self) -> GodotResult {
        unsafe { ResourceInteractiveLoader_wait(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ResourcePreloader` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourcepreloader.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ResourcePreloader` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ResourcePreloader::free`.
///
/// ## Class hierarchy
///
/// ResourcePreloader inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourcePreloader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourcePreloader {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ResourcePreloader::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ResourcePreloaderMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ResourcePreloader {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_resources(&self) -> VariantArray {
        ResourcePreloader__get_resources(self.this)
    }

    #[inline]
    pub unsafe fn _set_resources(&mut self, arg0: VariantArray) -> () {
        ResourcePreloader__set_resources(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_resource(&mut self, name: GodotString, resource: Option<Resource>) -> () {
        ResourcePreloader_add_resource(self.this, name, resource)
    }

    #[inline]
    pub unsafe fn get_resource(&self, name: GodotString) -> Option<Resource> {
        ResourcePreloader_get_resource(self.this, name)
    }

    #[inline]
    pub unsafe fn get_resource_list(&self) -> StringArray {
        ResourcePreloader_get_resource_list(self.this)
    }

    #[inline]
    pub unsafe fn has_resource(&self, name: GodotString) -> bool {
        ResourcePreloader_has_resource(self.this, name)
    }

    #[inline]
    pub unsafe fn remove_resource(&mut self, name: GodotString) -> () {
        ResourcePreloader_remove_resource(self.this, name)
    }

    #[inline]
    pub unsafe fn rename_resource(&mut self, name: GodotString, newname: GodotString) -> () {
        ResourcePreloader_rename_resource(self.this, name, newname)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RichTextEffect` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_richtexteffect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// RichTextEffect inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RichTextEffect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RichTextEffect {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RichTextEffectMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            RichTextEffect {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _process_custom_fx(&mut self, char_fx: Option<CharFXTransform>) -> bool {
        unsafe { RichTextEffect__process_custom_fx(self.this, char_fx) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RichTextLabel` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_richtextlabel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RichTextLabel` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RichTextLabel::free`.
///
/// ## Class hierarchy
///
/// RichTextLabel inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RichTextLabel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RichTextLabelAlign {
    Left = 0,
    Center = 1,
    Right = 2,
    Fill = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RichTextLabelListType {
    ListNumbers = 0,
    ListLetters = 1,
    ListDots = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RichTextLabelItemType {
    ItemFrame = 0,
    ItemText = 1,
    ItemImage = 2,
    ItemNewline = 3,
    ItemFont = 4,
    ItemColor = 5,
    ItemUnderline = 6,
    ItemStrikethrough = 7,
    ItemAlign = 8,
    ItemIndent = 9,
    ItemList = 10,
    ItemTable = 11,
    ItemFade = 12,
    ItemShake = 13,
    ItemWave = 14,
    ItemTornado = 15,
    ItemRainbow = 16,
    ItemMeta = 17,
    ItemCustomfx = 18,
}
/// Constants
#[allow(non_upper_case_globals)]
impl RichTextLabel {
    pub const ITEM_WAVE: i64 = 14;
    pub const ITEM_NEWLINE: i64 = 3;
    pub const ITEM_STRIKETHROUGH: i64 = 7;
    pub const LIST_NUMBERS: i64 = 0;
    pub const ALIGN_LEFT: i64 = 0;
    pub const ITEM_LIST: i64 = 10;
    pub const LIST_DOTS: i64 = 2;
    pub const ITEM_TORNADO: i64 = 15;
    pub const ITEM_FRAME: i64 = 0;
    pub const ITEM_ALIGN: i64 = 8;
    pub const ALIGN_FILL: i64 = 3;
    pub const ITEM_CUSTOMFX: i64 = 18;
    pub const ITEM_IMAGE: i64 = 2;
    pub const ITEM_TEXT: i64 = 1;
    pub const ITEM_UNDERLINE: i64 = 6;
    pub const ITEM_FADE: i64 = 12;
    pub const ITEM_TABLE: i64 = 11;
    pub const LIST_LETTERS: i64 = 1;
    pub const ITEM_RAINBOW: i64 = 16;
    pub const ITEM_FONT: i64 = 4;
    pub const ITEM_META: i64 = 17;
    pub const ITEM_COLOR: i64 = 5;
    pub const ALIGN_RIGHT: i64 = 2;
    pub const ITEM_SHAKE: i64 = 13;
    pub const ITEM_INDENT: i64 = 9;
    pub const ALIGN_CENTER: i64 = 1;
}
impl RichTextLabel {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RichTextLabel::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RichTextLabelMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RichTextLabel {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        RichTextLabel__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _scroll_changed(&mut self, arg0: f64) -> () {
        RichTextLabel__scroll_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn add_image(&mut self, image: Option<Texture>, width: i64, height: i64) -> () {
        RichTextLabel_add_image(self.this, image, width, height)
    }

    #[inline]
    pub unsafe fn add_text(&mut self, text: GodotString) -> () {
        RichTextLabel_add_text(self.this, text)
    }

    #[inline]
    pub unsafe fn append_bbcode(&mut self, bbcode: GodotString) -> GodotResult {
        RichTextLabel_append_bbcode(self.this, bbcode)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        RichTextLabel_clear(self.this)
    }

    #[inline]
    pub unsafe fn get_bbcode(&self) -> GodotString {
        RichTextLabel_get_bbcode(self.this)
    }

    #[inline]
    pub unsafe fn get_content_height(&mut self) -> i64 {
        RichTextLabel_get_content_height(self.this)
    }

    #[inline]
    pub unsafe fn get_effects(&mut self) -> VariantArray {
        RichTextLabel_get_effects(self.this)
    }

    #[inline]
    pub unsafe fn get_line_count(&self) -> i64 {
        RichTextLabel_get_line_count(self.this)
    }

    #[inline]
    pub unsafe fn get_percent_visible(&self) -> f64 {
        RichTextLabel_get_percent_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_size(&self) -> i64 {
        RichTextLabel_get_tab_size(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&mut self) -> GodotString {
        RichTextLabel_get_text(self.this)
    }

    #[inline]
    pub unsafe fn get_total_character_count(&self) -> i64 {
        RichTextLabel_get_total_character_count(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scroll(&mut self) -> Option<VScrollBar> {
        RichTextLabel_get_v_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_visible_characters(&self) -> i64 {
        RichTextLabel_get_visible_characters(self.this)
    }

    #[inline]
    pub unsafe fn get_visible_line_count(&self) -> i64 {
        RichTextLabel_get_visible_line_count(self.this)
    }

    #[inline]
    pub unsafe fn install_effect(&mut self, effect: Variant) -> () {
        RichTextLabel_install_effect(self.this, effect)
    }

    #[inline]
    pub unsafe fn is_meta_underlined(&self) -> bool {
        RichTextLabel_is_meta_underlined(self.this)
    }

    #[inline]
    pub unsafe fn is_overriding_selected_font_color(&self) -> bool {
        RichTextLabel_is_overriding_selected_font_color(self.this)
    }

    #[inline]
    pub unsafe fn is_scroll_active(&self) -> bool {
        RichTextLabel_is_scroll_active(self.this)
    }

    #[inline]
    pub unsafe fn is_scroll_following(&self) -> bool {
        RichTextLabel_is_scroll_following(self.this)
    }

    #[inline]
    pub unsafe fn is_selection_enabled(&self) -> bool {
        RichTextLabel_is_selection_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_using_bbcode(&self) -> bool {
        RichTextLabel_is_using_bbcode(self.this)
    }

    #[inline]
    pub unsafe fn newline(&mut self) -> () {
        RichTextLabel_newline(self.this)
    }

    #[inline]
    pub unsafe fn parse_bbcode(&mut self, bbcode: GodotString) -> GodotResult {
        RichTextLabel_parse_bbcode(self.this, bbcode)
    }

    #[inline]
    pub unsafe fn parse_expressions_for_values(&mut self, expressions: StringArray) -> Dictionary {
        RichTextLabel_parse_expressions_for_values(self.this, expressions)
    }

    #[inline]
    pub unsafe fn pop(&mut self) -> () {
        RichTextLabel_pop(self.this)
    }

    #[inline]
    pub unsafe fn push_align(&mut self, align: i64) -> () {
        RichTextLabel_push_align(self.this, align)
    }

    #[inline]
    pub unsafe fn push_bold(&mut self) -> () {
        RichTextLabel_push_bold(self.this)
    }

    #[inline]
    pub unsafe fn push_bold_italics(&mut self) -> () {
        RichTextLabel_push_bold_italics(self.this)
    }

    #[inline]
    pub unsafe fn push_cell(&mut self) -> () {
        RichTextLabel_push_cell(self.this)
    }

    #[inline]
    pub unsafe fn push_color(&mut self, color: Color) -> () {
        RichTextLabel_push_color(self.this, color)
    }

    #[inline]
    pub unsafe fn push_font(&mut self, font: Option<Font>) -> () {
        RichTextLabel_push_font(self.this, font)
    }

    #[inline]
    pub unsafe fn push_indent(&mut self, level: i64) -> () {
        RichTextLabel_push_indent(self.this, level)
    }

    #[inline]
    pub unsafe fn push_italics(&mut self) -> () {
        RichTextLabel_push_italics(self.this)
    }

    #[inline]
    pub unsafe fn push_list(&mut self, _type: i64) -> () {
        RichTextLabel_push_list(self.this, _type)
    }

    #[inline]
    pub unsafe fn push_meta(&mut self, data: Variant) -> () {
        RichTextLabel_push_meta(self.this, data)
    }

    #[inline]
    pub unsafe fn push_mono(&mut self) -> () {
        RichTextLabel_push_mono(self.this)
    }

    #[inline]
    pub unsafe fn push_normal(&mut self) -> () {
        RichTextLabel_push_normal(self.this)
    }

    #[inline]
    pub unsafe fn push_strikethrough(&mut self) -> () {
        RichTextLabel_push_strikethrough(self.this)
    }

    #[inline]
    pub unsafe fn push_table(&mut self, columns: i64) -> () {
        RichTextLabel_push_table(self.this, columns)
    }

    #[inline]
    pub unsafe fn push_underline(&mut self) -> () {
        RichTextLabel_push_underline(self.this)
    }

    #[inline]
    pub unsafe fn remove_line(&mut self, line: i64) -> bool {
        RichTextLabel_remove_line(self.this, line)
    }

    #[inline]
    pub unsafe fn scroll_to_line(&mut self, line: i64) -> () {
        RichTextLabel_scroll_to_line(self.this, line)
    }

    #[inline]
    pub unsafe fn set_bbcode(&mut self, text: GodotString) -> () {
        RichTextLabel_set_bbcode(self.this, text)
    }

    #[inline]
    pub unsafe fn set_effects(&mut self, effects: VariantArray) -> () {
        RichTextLabel_set_effects(self.this, effects)
    }

    #[inline]
    pub unsafe fn set_meta_underline(&mut self, enable: bool) -> () {
        RichTextLabel_set_meta_underline(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_override_selected_font_color(&mut self, _override: bool) -> () {
        RichTextLabel_set_override_selected_font_color(self.this, _override)
    }

    #[inline]
    pub unsafe fn set_percent_visible(&mut self, percent_visible: f64) -> () {
        RichTextLabel_set_percent_visible(self.this, percent_visible)
    }

    #[inline]
    pub unsafe fn set_scroll_active(&mut self, active: bool) -> () {
        RichTextLabel_set_scroll_active(self.this, active)
    }

    #[inline]
    pub unsafe fn set_scroll_follow(&mut self, follow: bool) -> () {
        RichTextLabel_set_scroll_follow(self.this, follow)
    }

    #[inline]
    pub unsafe fn set_selection_enabled(&mut self, enabled: bool) -> () {
        RichTextLabel_set_selection_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_tab_size(&mut self, spaces: i64) -> () {
        RichTextLabel_set_tab_size(self.this, spaces)
    }

    #[inline]
    pub unsafe fn set_table_column_expand(&mut self, column: i64, expand: bool, ratio: i64) -> () {
        RichTextLabel_set_table_column_expand(self.this, column, expand, ratio)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        RichTextLabel_set_text(self.this, text)
    }

    #[inline]
    pub unsafe fn set_use_bbcode(&mut self, enable: bool) -> () {
        RichTextLabel_set_use_bbcode(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_visible_characters(&mut self, amount: i64) -> () {
        RichTextLabel_set_visible_characters(self.this, amount)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RigidBody` inherits `PhysicsBody` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rigidbody.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RigidBody` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RigidBody::free`.
///
/// ## Class hierarchy
///
/// RigidBody inherits methods from:
/// - [PhysicsBody](struct.PhysicsBody.html)
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RigidBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RigidBodyMode {
    ModeRigid = 0,
    ModeStatic = 1,
    ModeCharacter = 2,
    ModeKinematic = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl RigidBody {
    pub const MODE_CHARACTER: i64 = 2;
    pub const MODE_STATIC: i64 = 1;
    pub const MODE_KINEMATIC: i64 = 3;
    pub const MODE_RIGID: i64 = 0;
}
impl RigidBody {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RigidBody::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RigidBodyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RigidBody {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _body_enter_tree(&mut self, arg0: i64) -> () {
        RigidBody__body_enter_tree(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _body_exit_tree(&mut self, arg0: i64) -> () {
        RigidBody__body_exit_tree(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _direct_state_changed(&mut self, arg0: Option<Object>) -> () {
        RigidBody__direct_state_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _integrate_forces(&mut self, state: Option<PhysicsDirectBodyState>) -> () {
        RigidBody__integrate_forces(self.this, state)
    }

    #[inline]
    pub unsafe fn _reload_physics_characteristics(&mut self) -> () {
        RigidBody__reload_physics_characteristics(self.this)
    }

    #[inline]
    pub unsafe fn add_central_force(&mut self, force: Vector3) -> () {
        RigidBody_add_central_force(self.this, force)
    }

    #[inline]
    pub unsafe fn add_force(&mut self, force: Vector3, position: Vector3) -> () {
        RigidBody_add_force(self.this, force, position)
    }

    #[inline]
    pub unsafe fn add_torque(&mut self, torque: Vector3) -> () {
        RigidBody_add_torque(self.this, torque)
    }

    #[inline]
    pub unsafe fn apply_central_impulse(&mut self, impulse: Vector3) -> () {
        RigidBody_apply_central_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn apply_impulse(&mut self, position: Vector3, impulse: Vector3) -> () {
        RigidBody_apply_impulse(self.this, position, impulse)
    }

    #[inline]
    pub unsafe fn apply_torque_impulse(&mut self, impulse: Vector3) -> () {
        RigidBody_apply_torque_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn get_angular_damp(&self) -> f64 {
        RigidBody_get_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_angular_velocity(&self) -> Vector3 {
        RigidBody_get_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_axis_lock(&self, axis: i64) -> bool {
        RigidBody_get_axis_lock(self.this, axis)
    }

    #[inline]
    pub unsafe fn get_bounce(&self) -> f64 {
        RigidBody_get_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_colliding_bodies(&self) -> VariantArray {
        RigidBody_get_colliding_bodies(self.this)
    }

    #[inline]
    pub unsafe fn get_friction(&self) -> f64 {
        RigidBody_get_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_scale(&self) -> f64 {
        RigidBody_get_gravity_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_damp(&self) -> f64 {
        RigidBody_get_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_velocity(&self) -> Vector3 {
        RigidBody_get_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_mass(&self) -> f64 {
        RigidBody_get_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_max_contacts_reported(&self) -> i64 {
        RigidBody_get_max_contacts_reported(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> RigidBodyMode {
        RigidBody_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_material_override(&self) -> Option<PhysicsMaterial> {
        RigidBody_get_physics_material_override(self.this)
    }

    #[inline]
    pub unsafe fn get_weight(&self) -> f64 {
        RigidBody_get_weight(self.this)
    }

    #[inline]
    pub unsafe fn is_able_to_sleep(&self) -> bool {
        RigidBody_is_able_to_sleep(self.this)
    }

    #[inline]
    pub unsafe fn is_contact_monitor_enabled(&self) -> bool {
        RigidBody_is_contact_monitor_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_sleeping(&self) -> bool {
        RigidBody_is_sleeping(self.this)
    }

    #[inline]
    pub unsafe fn is_using_continuous_collision_detection(&self) -> bool {
        RigidBody_is_using_continuous_collision_detection(self.this)
    }

    #[inline]
    pub unsafe fn is_using_custom_integrator(&mut self) -> bool {
        RigidBody_is_using_custom_integrator(self.this)
    }

    #[inline]
    pub unsafe fn set_angular_damp(&mut self, angular_damp: f64) -> () {
        RigidBody_set_angular_damp(self.this, angular_damp)
    }

    #[inline]
    pub unsafe fn set_angular_velocity(&mut self, angular_velocity: Vector3) -> () {
        RigidBody_set_angular_velocity(self.this, angular_velocity)
    }

    #[inline]
    pub unsafe fn set_axis_lock(&mut self, axis: i64, lock: bool) -> () {
        RigidBody_set_axis_lock(self.this, axis, lock)
    }

    #[inline]
    pub unsafe fn set_axis_velocity(&mut self, axis_velocity: Vector3) -> () {
        RigidBody_set_axis_velocity(self.this, axis_velocity)
    }

    #[inline]
    pub unsafe fn set_bounce(&mut self, bounce: f64) -> () {
        RigidBody_set_bounce(self.this, bounce)
    }

    #[inline]
    pub unsafe fn set_can_sleep(&mut self, able_to_sleep: bool) -> () {
        RigidBody_set_can_sleep(self.this, able_to_sleep)
    }

    #[inline]
    pub unsafe fn set_contact_monitor(&mut self, enabled: bool) -> () {
        RigidBody_set_contact_monitor(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_friction(&mut self, friction: f64) -> () {
        RigidBody_set_friction(self.this, friction)
    }

    #[inline]
    pub unsafe fn set_gravity_scale(&mut self, gravity_scale: f64) -> () {
        RigidBody_set_gravity_scale(self.this, gravity_scale)
    }

    #[inline]
    pub unsafe fn set_linear_damp(&mut self, linear_damp: f64) -> () {
        RigidBody_set_linear_damp(self.this, linear_damp)
    }

    #[inline]
    pub unsafe fn set_linear_velocity(&mut self, linear_velocity: Vector3) -> () {
        RigidBody_set_linear_velocity(self.this, linear_velocity)
    }

    #[inline]
    pub unsafe fn set_mass(&mut self, mass: f64) -> () {
        RigidBody_set_mass(self.this, mass)
    }

    #[inline]
    pub unsafe fn set_max_contacts_reported(&mut self, amount: i64) -> () {
        RigidBody_set_max_contacts_reported(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        RigidBody_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_physics_material_override(&mut self, physics_material_override: Option<PhysicsMaterial>) -> () {
        RigidBody_set_physics_material_override(self.this, physics_material_override)
    }

    #[inline]
    pub unsafe fn set_sleeping(&mut self, sleeping: bool) -> () {
        RigidBody_set_sleeping(self.this, sleeping)
    }

    #[inline]
    pub unsafe fn set_use_continuous_collision_detection(&mut self, enable: bool) -> () {
        RigidBody_set_use_continuous_collision_detection(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_use_custom_integrator(&mut self, enable: bool) -> () {
        RigidBody_set_use_custom_integrator(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_weight(&mut self, weight: f64) -> () {
        RigidBody_set_weight(self.this, weight)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body(&self) -> PhysicsBody {
        // Not reference-counted.
        PhysicsBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RigidBody2D` inherits `PhysicsBody2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rigidbody2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `RigidBody2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `RigidBody2D::free`.
///
/// ## Class hierarchy
///
/// RigidBody2D inherits methods from:
/// - [PhysicsBody2D](struct.PhysicsBody2D.html)
/// - [CollisionObject2D](struct.CollisionObject2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RigidBody2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RigidBody2DMode {
    ModeRigid = 0,
    ModeStatic = 1,
    ModeCharacter = 2,
    ModeKinematic = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum RigidBody2DCCDMode {
    ModeDisabled = 0,
    ModeCastRay = 1,
    ModeCastShape = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl RigidBody2D {
    pub const MODE_KINEMATIC: i64 = 3;
    pub const MODE_CHARACTER: i64 = 2;
    pub const MODE_STATIC: i64 = 1;
    pub const CCD_MODE_CAST_RAY: i64 = 1;
    pub const CCD_MODE_CAST_SHAPE: i64 = 2;
    pub const CCD_MODE_DISABLED: i64 = 0;
    pub const MODE_RIGID: i64 = 0;
}
impl RigidBody2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `RigidBody2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = RigidBody2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            RigidBody2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _body_enter_tree(&mut self, arg0: i64) -> () {
        RigidBody2D__body_enter_tree(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _body_exit_tree(&mut self, arg0: i64) -> () {
        RigidBody2D__body_exit_tree(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _direct_state_changed(&mut self, arg0: Option<Object>) -> () {
        RigidBody2D__direct_state_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _integrate_forces(&mut self, state: Option<Physics2DDirectBodyState>) -> () {
        RigidBody2D__integrate_forces(self.this, state)
    }

    #[inline]
    pub unsafe fn _reload_physics_characteristics(&mut self) -> () {
        RigidBody2D__reload_physics_characteristics(self.this)
    }

    #[inline]
    pub unsafe fn add_central_force(&mut self, force: Vector2) -> () {
        RigidBody2D_add_central_force(self.this, force)
    }

    #[inline]
    pub unsafe fn add_force(&mut self, offset: Vector2, force: Vector2) -> () {
        RigidBody2D_add_force(self.this, offset, force)
    }

    #[inline]
    pub unsafe fn add_torque(&mut self, torque: f64) -> () {
        RigidBody2D_add_torque(self.this, torque)
    }

    #[inline]
    pub unsafe fn apply_central_impulse(&mut self, impulse: Vector2) -> () {
        RigidBody2D_apply_central_impulse(self.this, impulse)
    }

    #[inline]
    pub unsafe fn apply_impulse(&mut self, offset: Vector2, impulse: Vector2) -> () {
        RigidBody2D_apply_impulse(self.this, offset, impulse)
    }

    #[inline]
    pub unsafe fn apply_torque_impulse(&mut self, torque: f64) -> () {
        RigidBody2D_apply_torque_impulse(self.this, torque)
    }

    #[inline]
    pub unsafe fn get_angular_damp(&self) -> f64 {
        RigidBody2D_get_angular_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_angular_velocity(&self) -> f64 {
        RigidBody2D_get_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_applied_force(&self) -> Vector2 {
        RigidBody2D_get_applied_force(self.this)
    }

    #[inline]
    pub unsafe fn get_applied_torque(&self) -> f64 {
        RigidBody2D_get_applied_torque(self.this)
    }

    #[inline]
    pub unsafe fn get_bounce(&self) -> f64 {
        RigidBody2D_get_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_colliding_bodies(&self) -> VariantArray {
        RigidBody2D_get_colliding_bodies(self.this)
    }

    #[inline]
    pub unsafe fn get_continuous_collision_detection_mode(&self) -> RigidBody2DCCDMode {
        RigidBody2D_get_continuous_collision_detection_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_friction(&self) -> f64 {
        RigidBody2D_get_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_gravity_scale(&self) -> f64 {
        RigidBody2D_get_gravity_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_inertia(&self) -> f64 {
        RigidBody2D_get_inertia(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_damp(&self) -> f64 {
        RigidBody2D_get_linear_damp(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_velocity(&self) -> Vector2 {
        RigidBody2D_get_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_mass(&self) -> f64 {
        RigidBody2D_get_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_max_contacts_reported(&self) -> i64 {
        RigidBody2D_get_max_contacts_reported(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> RigidBody2DMode {
        RigidBody2D_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_material_override(&self) -> Option<PhysicsMaterial> {
        RigidBody2D_get_physics_material_override(self.this)
    }

    #[inline]
    pub unsafe fn get_weight(&self) -> f64 {
        RigidBody2D_get_weight(self.this)
    }

    #[inline]
    pub unsafe fn is_able_to_sleep(&self) -> bool {
        RigidBody2D_is_able_to_sleep(self.this)
    }

    #[inline]
    pub unsafe fn is_contact_monitor_enabled(&self) -> bool {
        RigidBody2D_is_contact_monitor_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_sleeping(&self) -> bool {
        RigidBody2D_is_sleeping(self.this)
    }

    #[inline]
    pub unsafe fn is_using_custom_integrator(&mut self) -> bool {
        RigidBody2D_is_using_custom_integrator(self.this)
    }

    #[inline]
    pub unsafe fn set_angular_damp(&mut self, angular_damp: f64) -> () {
        RigidBody2D_set_angular_damp(self.this, angular_damp)
    }

    #[inline]
    pub unsafe fn set_angular_velocity(&mut self, angular_velocity: f64) -> () {
        RigidBody2D_set_angular_velocity(self.this, angular_velocity)
    }

    #[inline]
    pub unsafe fn set_applied_force(&mut self, force: Vector2) -> () {
        RigidBody2D_set_applied_force(self.this, force)
    }

    #[inline]
    pub unsafe fn set_applied_torque(&mut self, torque: f64) -> () {
        RigidBody2D_set_applied_torque(self.this, torque)
    }

    #[inline]
    pub unsafe fn set_axis_velocity(&mut self, axis_velocity: Vector2) -> () {
        RigidBody2D_set_axis_velocity(self.this, axis_velocity)
    }

    #[inline]
    pub unsafe fn set_bounce(&mut self, bounce: f64) -> () {
        RigidBody2D_set_bounce(self.this, bounce)
    }

    #[inline]
    pub unsafe fn set_can_sleep(&mut self, able_to_sleep: bool) -> () {
        RigidBody2D_set_can_sleep(self.this, able_to_sleep)
    }

    #[inline]
    pub unsafe fn set_contact_monitor(&mut self, enabled: bool) -> () {
        RigidBody2D_set_contact_monitor(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_continuous_collision_detection_mode(&mut self, mode: i64) -> () {
        RigidBody2D_set_continuous_collision_detection_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_friction(&mut self, friction: f64) -> () {
        RigidBody2D_set_friction(self.this, friction)
    }

    #[inline]
    pub unsafe fn set_gravity_scale(&mut self, gravity_scale: f64) -> () {
        RigidBody2D_set_gravity_scale(self.this, gravity_scale)
    }

    #[inline]
    pub unsafe fn set_inertia(&mut self, inertia: f64) -> () {
        RigidBody2D_set_inertia(self.this, inertia)
    }

    #[inline]
    pub unsafe fn set_linear_damp(&mut self, linear_damp: f64) -> () {
        RigidBody2D_set_linear_damp(self.this, linear_damp)
    }

    #[inline]
    pub unsafe fn set_linear_velocity(&mut self, linear_velocity: Vector2) -> () {
        RigidBody2D_set_linear_velocity(self.this, linear_velocity)
    }

    #[inline]
    pub unsafe fn set_mass(&mut self, mass: f64) -> () {
        RigidBody2D_set_mass(self.this, mass)
    }

    #[inline]
    pub unsafe fn set_max_contacts_reported(&mut self, amount: i64) -> () {
        RigidBody2D_set_max_contacts_reported(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        RigidBody2D_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_physics_material_override(&mut self, physics_material_override: Option<PhysicsMaterial>) -> () {
        RigidBody2D_set_physics_material_override(self.this, physics_material_override)
    }

    #[inline]
    pub unsafe fn set_sleeping(&mut self, sleeping: bool) -> () {
        RigidBody2D_set_sleeping(self.this, sleeping)
    }

    #[inline]
    pub unsafe fn set_use_custom_integrator(&mut self, enable: bool) -> () {
        RigidBody2D_set_use_custom_integrator(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_weight(&mut self, weight: f64) -> () {
        RigidBody2D_set_weight(self.this, weight)
    }

    #[inline]
    pub unsafe fn test_motion(&mut self, motion: Vector2, infinite_inertia: bool, margin: f64, result: Option<Physics2DTestMotionResult>) -> bool {
        RigidBody2D_test_motion(self.this, motion, infinite_inertia, margin, result)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body_2d(&self) -> PhysicsBody2D {
        // Not reference-counted.
        PhysicsBody2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object_2d(&self) -> CollisionObject2D {
        // Not reference-counted.
        CollisionObject2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class RootMotionView` inherits `VisualInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_rootmotionview.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// RootMotionView inherits methods from:
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct RootMotionView {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl RootMotionView {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SceneState` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scenestate.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SceneState inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SceneState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SceneStateGenEditState {
    Disabled = 0,
    Instance = 1,
    Main = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SceneState {
    pub const GEN_EDIT_STATE_INSTANCE: i64 = 1;
    pub const GEN_EDIT_STATE_DISABLED: i64 = 0;
    pub const GEN_EDIT_STATE_MAIN: i64 = 2;
}
impl SceneState {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_connection_binds(&self, idx: i64) -> VariantArray {
        unsafe { SceneState_get_connection_binds(self.this, idx) }
    }

    #[inline]
    pub fn get_connection_count(&self) -> i64 {
        unsafe { SceneState_get_connection_count(self.this) }
    }

    #[inline]
    pub fn get_connection_flags(&self, idx: i64) -> i64 {
        unsafe { SceneState_get_connection_flags(self.this, idx) }
    }

    #[inline]
    pub fn get_connection_method(&self, idx: i64) -> GodotString {
        unsafe { SceneState_get_connection_method(self.this, idx) }
    }

    #[inline]
    pub fn get_connection_signal(&self, idx: i64) -> GodotString {
        unsafe { SceneState_get_connection_signal(self.this, idx) }
    }

    #[inline]
    pub fn get_connection_source(&self, idx: i64) -> NodePath {
        unsafe { SceneState_get_connection_source(self.this, idx) }
    }

    #[inline]
    pub fn get_connection_target(&self, idx: i64) -> NodePath {
        unsafe { SceneState_get_connection_target(self.this, idx) }
    }

    #[inline]
    pub fn get_node_count(&self) -> i64 {
        unsafe { SceneState_get_node_count(self.this) }
    }

    #[inline]
    pub fn get_node_groups(&self, idx: i64) -> StringArray {
        unsafe { SceneState_get_node_groups(self.this, idx) }
    }

    #[inline]
    pub fn get_node_index(&self, idx: i64) -> i64 {
        unsafe { SceneState_get_node_index(self.this, idx) }
    }

    #[inline]
    pub fn get_node_instance(&self, idx: i64) -> Option<PackedScene> {
        unsafe { SceneState_get_node_instance(self.this, idx) }
    }

    #[inline]
    pub fn get_node_instance_placeholder(&self, idx: i64) -> GodotString {
        unsafe { SceneState_get_node_instance_placeholder(self.this, idx) }
    }

    #[inline]
    pub fn get_node_name(&self, idx: i64) -> GodotString {
        unsafe { SceneState_get_node_name(self.this, idx) }
    }

    #[inline]
    pub fn get_node_owner_path(&self, idx: i64) -> NodePath {
        unsafe { SceneState_get_node_owner_path(self.this, idx) }
    }

    #[inline]
    pub fn get_node_path(&self, idx: i64, for_parent: bool) -> NodePath {
        unsafe { SceneState_get_node_path(self.this, idx, for_parent) }
    }

    #[inline]
    pub fn get_node_property_count(&self, idx: i64) -> i64 {
        unsafe { SceneState_get_node_property_count(self.this, idx) }
    }

    #[inline]
    pub fn get_node_property_name(&self, idx: i64, prop_idx: i64) -> GodotString {
        unsafe { SceneState_get_node_property_name(self.this, idx, prop_idx) }
    }

    #[inline]
    pub fn get_node_property_value(&self, idx: i64, prop_idx: i64) -> Variant {
        unsafe { SceneState_get_node_property_value(self.this, idx, prop_idx) }
    }

    #[inline]
    pub fn get_node_type(&self, idx: i64) -> GodotString {
        unsafe { SceneState_get_node_type(self.this, idx) }
    }

    #[inline]
    pub fn is_node_instance_placeholder(&self, idx: i64) -> bool {
        unsafe { SceneState_is_node_instance_placeholder(self.this, idx) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SceneTree` inherits `MainLoop` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scenetree.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SceneTree` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SceneTree::free`.
///
/// ## Class hierarchy
///
/// SceneTree inherits methods from:
/// - [MainLoop](struct.MainLoop.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SceneTree {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SceneTreeStretchAspect {
    Ignore = 0,
    Keep = 1,
    KeepWidth = 2,
    KeepHeight = 3,
    Expand = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SceneTreeGroupCallFlags {
    GroupCallDefault = 0,
    GroupCallReverse = 1,
    GroupCallRealtime = 2,
    GroupCallUnique = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SceneTreeStretchMode {
    ModeDisabled = 0,
    Mode2d = 1,
    ModeViewport = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SceneTree {
    pub const GROUP_CALL_DEFAULT: i64 = 0;
    pub const STRETCH_MODE_2D: i64 = 1;
    pub const GROUP_CALL_UNIQUE: i64 = 4;
    pub const STRETCH_ASPECT_EXPAND: i64 = 4;
    pub const STRETCH_MODE_DISABLED: i64 = 0;
    pub const GROUP_CALL_REVERSE: i64 = 1;
    pub const GROUP_CALL_REALTIME: i64 = 2;
    pub const STRETCH_ASPECT_KEEP: i64 = 1;
    pub const STRETCH_ASPECT_KEEP_HEIGHT: i64 = 3;
    pub const STRETCH_ASPECT_IGNORE: i64 = 0;
    pub const STRETCH_ASPECT_KEEP_WIDTH: i64 = 2;
    pub const STRETCH_MODE_VIEWPORT: i64 = 2;
}
impl SceneTree {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SceneTree::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SceneTreeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SceneTree {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _change_scene(&mut self, arg0: Option<Node>) -> () {
        SceneTree__change_scene(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _connected_to_server(&mut self) -> () {
        SceneTree__connected_to_server(self.this)
    }

    #[inline]
    pub unsafe fn _connection_failed(&mut self) -> () {
        SceneTree__connection_failed(self.this)
    }

    #[inline]
    pub unsafe fn _network_peer_connected(&mut self, arg0: i64) -> () {
        SceneTree__network_peer_connected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _network_peer_disconnected(&mut self, arg0: i64) -> () {
        SceneTree__network_peer_disconnected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _server_disconnected(&mut self) -> () {
        SceneTree__server_disconnected(self.this)
    }

    #[inline]
    pub unsafe fn call_group(&mut self, group: GodotString, method: GodotString, varargs: &[Variant]) -> Variant {
        SceneTree_call_group(self.this, group, method, varargs)
    }

    #[inline]
    pub unsafe fn call_group_flags(&mut self, flags: i64, group: GodotString, method: GodotString, varargs: &[Variant]) -> Variant {
        SceneTree_call_group_flags(self.this, flags, group, method, varargs)
    }

    #[inline]
    pub unsafe fn change_scene(&mut self, path: GodotString) -> GodotResult {
        SceneTree_change_scene(self.this, path)
    }

    #[inline]
    pub unsafe fn change_scene_to(&mut self, packed_scene: Option<PackedScene>) -> GodotResult {
        SceneTree_change_scene_to(self.this, packed_scene)
    }

    #[inline]
    pub unsafe fn create_timer(&mut self, time_sec: f64, pause_mode_process: bool) -> Option<SceneTreeTimer> {
        SceneTree_create_timer(self.this, time_sec, pause_mode_process)
    }

    #[inline]
    pub unsafe fn get_current_scene(&self) -> Option<Node> {
        SceneTree_get_current_scene(self.this)
    }

    #[inline]
    pub unsafe fn get_edited_scene_root(&self) -> Option<Node> {
        SceneTree_get_edited_scene_root(self.this)
    }

    #[inline]
    pub unsafe fn get_frame(&self) -> i64 {
        SceneTree_get_frame(self.this)
    }

    #[inline]
    pub unsafe fn get_multiplayer(&self) -> Option<MultiplayerAPI> {
        SceneTree_get_multiplayer(self.this)
    }

    #[inline]
    pub unsafe fn get_network_connected_peers(&self) -> Int32Array {
        SceneTree_get_network_connected_peers(self.this)
    }

    #[inline]
    pub unsafe fn get_network_peer(&self) -> Option<NetworkedMultiplayerPeer> {
        SceneTree_get_network_peer(self.this)
    }

    #[inline]
    pub unsafe fn get_network_unique_id(&self) -> i64 {
        SceneTree_get_network_unique_id(self.this)
    }

    #[inline]
    pub unsafe fn get_node_count(&self) -> i64 {
        SceneTree_get_node_count(self.this)
    }

    #[inline]
    pub unsafe fn get_nodes_in_group(&mut self, group: GodotString) -> VariantArray {
        SceneTree_get_nodes_in_group(self.this, group)
    }

    #[inline]
    pub unsafe fn get_root(&self) -> Option<Viewport> {
        SceneTree_get_root(self.this)
    }

    #[inline]
    pub unsafe fn get_rpc_sender_id(&self) -> i64 {
        SceneTree_get_rpc_sender_id(self.this)
    }

    #[inline]
    pub unsafe fn has_group(&self, name: GodotString) -> bool {
        SceneTree_has_group(self.this, name)
    }

    #[inline]
    pub unsafe fn has_network_peer(&self) -> bool {
        SceneTree_has_network_peer(self.this)
    }

    #[inline]
    pub unsafe fn is_debugging_collisions_hint(&self) -> bool {
        SceneTree_is_debugging_collisions_hint(self.this)
    }

    #[inline]
    pub unsafe fn is_debugging_navigation_hint(&self) -> bool {
        SceneTree_is_debugging_navigation_hint(self.this)
    }

    #[inline]
    pub unsafe fn is_input_handled(&mut self) -> bool {
        SceneTree_is_input_handled(self.this)
    }

    #[inline]
    pub unsafe fn is_multiplayer_poll_enabled(&self) -> bool {
        SceneTree_is_multiplayer_poll_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_network_server(&self) -> bool {
        SceneTree_is_network_server(self.this)
    }

    #[inline]
    pub unsafe fn is_paused(&self) -> bool {
        SceneTree_is_paused(self.this)
    }

    #[inline]
    pub unsafe fn is_refusing_new_network_connections(&self) -> bool {
        SceneTree_is_refusing_new_network_connections(self.this)
    }

    #[inline]
    pub unsafe fn is_using_font_oversampling(&self) -> bool {
        SceneTree_is_using_font_oversampling(self.this)
    }

    #[inline]
    pub unsafe fn notify_group(&mut self, group: GodotString, notification: i64) -> () {
        SceneTree_notify_group(self.this, group, notification)
    }

    #[inline]
    pub unsafe fn notify_group_flags(&mut self, call_flags: i64, group: GodotString, notification: i64) -> () {
        SceneTree_notify_group_flags(self.this, call_flags, group, notification)
    }

    #[inline]
    pub unsafe fn queue_delete(&mut self, obj: Option<Object>) -> () {
        SceneTree_queue_delete(self.this, obj)
    }

    #[inline]
    pub unsafe fn quit(&mut self, exit_code: i64) -> () {
        SceneTree_quit(self.this, exit_code)
    }

    #[inline]
    pub unsafe fn reload_current_scene(&mut self) -> GodotResult {
        SceneTree_reload_current_scene(self.this)
    }

    #[inline]
    pub unsafe fn set_auto_accept_quit(&mut self, enabled: bool) -> () {
        SceneTree_set_auto_accept_quit(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_current_scene(&mut self, child_node: Option<Node>) -> () {
        SceneTree_set_current_scene(self.this, child_node)
    }

    #[inline]
    pub unsafe fn set_debug_collisions_hint(&mut self, enable: bool) -> () {
        SceneTree_set_debug_collisions_hint(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_debug_navigation_hint(&mut self, enable: bool) -> () {
        SceneTree_set_debug_navigation_hint(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_edited_scene_root(&mut self, scene: Option<Node>) -> () {
        SceneTree_set_edited_scene_root(self.this, scene)
    }

    #[inline]
    pub unsafe fn set_group(&mut self, group: GodotString, property: GodotString, value: Variant) -> () {
        SceneTree_set_group(self.this, group, property, value)
    }

    #[inline]
    pub unsafe fn set_group_flags(&mut self, call_flags: i64, group: GodotString, property: GodotString, value: Variant) -> () {
        SceneTree_set_group_flags(self.this, call_flags, group, property, value)
    }

    #[inline]
    pub unsafe fn set_input_as_handled(&mut self) -> () {
        SceneTree_set_input_as_handled(self.this)
    }

    #[inline]
    pub unsafe fn set_multiplayer(&mut self, multiplayer: Option<MultiplayerAPI>) -> () {
        SceneTree_set_multiplayer(self.this, multiplayer)
    }

    #[inline]
    pub unsafe fn set_multiplayer_poll_enabled(&mut self, enabled: bool) -> () {
        SceneTree_set_multiplayer_poll_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_network_peer(&mut self, peer: Option<NetworkedMultiplayerPeer>) -> () {
        SceneTree_set_network_peer(self.this, peer)
    }

    #[inline]
    pub unsafe fn set_pause(&mut self, enable: bool) -> () {
        SceneTree_set_pause(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_quit_on_go_back(&mut self, enabled: bool) -> () {
        SceneTree_set_quit_on_go_back(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_refuse_new_network_connections(&mut self, refuse: bool) -> () {
        SceneTree_set_refuse_new_network_connections(self.this, refuse)
    }

    #[inline]
    pub unsafe fn set_screen_stretch(&mut self, mode: i64, aspect: i64, minsize: Vector2, shrink: f64) -> () {
        SceneTree_set_screen_stretch(self.this, mode, aspect, minsize, shrink)
    }

    #[inline]
    pub unsafe fn set_use_font_oversampling(&mut self, enable: bool) -> () {
        SceneTree_set_use_font_oversampling(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_main_loop(&self) -> MainLoop {
        // Not reference-counted.
        MainLoop { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SceneTreeTimer` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scenetreetimer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SceneTreeTimer inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SceneTreeTimer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SceneTreeTimer {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_time_left(&self) -> f64 {
        unsafe { SceneTreeTimer_get_time_left(self.this) }
    }

    #[inline]
    pub fn set_time_left(&mut self, time: f64) -> () {
        unsafe { SceneTreeTimer_set_time_left(self.this, time) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Script` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_script.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Script inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Script {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Script {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn can_instance(&self) -> bool {
        unsafe { Script_can_instance(self.this) }
    }

    #[inline]
    pub fn get_base_script(&self) -> Option<Script> {
        unsafe { Script_get_base_script(self.this) }
    }

    #[inline]
    pub fn get_instance_base_type(&self) -> GodotString {
        unsafe { Script_get_instance_base_type(self.this) }
    }

    #[inline]
    pub fn get_property_default_value(&mut self, property: GodotString) -> Variant {
        unsafe { Script_get_property_default_value(self.this, property) }
    }

    #[inline]
    pub fn get_script_constant_map(&mut self) -> Dictionary {
        unsafe { Script_get_script_constant_map(self.this) }
    }

    #[inline]
    pub fn get_script_method_list(&mut self) -> VariantArray {
        unsafe { Script_get_script_method_list(self.this) }
    }

    #[inline]
    pub fn get_script_property_list(&mut self) -> VariantArray {
        unsafe { Script_get_script_property_list(self.this) }
    }

    #[inline]
    pub fn get_script_signal_list(&mut self) -> VariantArray {
        unsafe { Script_get_script_signal_list(self.this) }
    }

    #[inline]
    pub fn get_source_code(&self) -> GodotString {
        unsafe { Script_get_source_code(self.this) }
    }

    #[inline]
    pub fn has_script_signal(&self, signal_name: GodotString) -> bool {
        unsafe { Script_has_script_signal(self.this, signal_name) }
    }

    #[inline]
    pub fn has_source_code(&self) -> bool {
        unsafe { Script_has_source_code(self.this) }
    }

    #[inline]
    pub fn instance_has(&self, base_object: Option<Object>) -> bool {
        unsafe { Script_instance_has(self.this, base_object) }
    }

    #[inline]
    pub fn is_tool(&self) -> bool {
        unsafe { Script_is_tool(self.this) }
    }

    #[inline]
    pub fn reload(&mut self, keep_state: bool) -> GodotResult {
        unsafe { Script_reload(self.this, keep_state) }
    }

    #[inline]
    pub fn set_source_code(&mut self, source: GodotString) -> () {
        unsafe { Script_set_source_code(self.this, source) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class ScriptCreateDialog` inherits `ConfirmationDialog` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scriptcreatedialog.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ScriptCreateDialog inherits methods from:
/// - [ConfirmationDialog](struct.ConfirmationDialog.html)
/// - [AcceptDialog](struct.AcceptDialog.html)
/// - [WindowDialog](struct.WindowDialog.html)
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ScriptCreateDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ScriptCreateDialog {
    #[inline]
    pub unsafe fn _browse_class_in_tree(&mut self) -> () {
        ScriptCreateDialog__browse_class_in_tree(self.this)
    }

    #[inline]
    pub unsafe fn _browse_path(&mut self, arg0: bool, arg1: bool) -> () {
        ScriptCreateDialog__browse_path(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _built_in_pressed(&mut self) -> () {
        ScriptCreateDialog__built_in_pressed(self.this)
    }

    #[inline]
    pub unsafe fn _class_name_changed(&mut self, arg0: GodotString) -> () {
        ScriptCreateDialog__class_name_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _create(&mut self) -> () {
        ScriptCreateDialog__create(self.this)
    }

    #[inline]
    pub unsafe fn _file_selected(&mut self, arg0: GodotString) -> () {
        ScriptCreateDialog__file_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _lang_changed(&mut self, arg0: i64) -> () {
        ScriptCreateDialog__lang_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _parent_name_changed(&mut self, arg0: GodotString) -> () {
        ScriptCreateDialog__parent_name_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _path_changed(&mut self, arg0: GodotString) -> () {
        ScriptCreateDialog__path_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _path_entered(&mut self, arg0: GodotString) -> () {
        ScriptCreateDialog__path_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _path_hbox_sorted(&mut self) -> () {
        ScriptCreateDialog__path_hbox_sorted(self.this)
    }

    #[inline]
    pub unsafe fn _template_changed(&mut self, arg0: i64) -> () {
        ScriptCreateDialog__template_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn config(&mut self, inherits: GodotString, path: GodotString, built_in_enabled: bool, load_enabled: bool) -> () {
        ScriptCreateDialog_config(self.this, inherits, path, built_in_enabled, load_enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_confirmation_dialog(&self) -> ConfirmationDialog {
        // Not reference-counted.
        ConfirmationDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_accept_dialog(&self) -> AcceptDialog {
        // Not reference-counted.
        AcceptDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_window_dialog(&self) -> WindowDialog {
        // Not reference-counted.
        WindowDialog { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools class ScriptEditor` inherits `PanelContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scripteditor.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ScriptEditor inherits methods from:
/// - [PanelContainer](struct.PanelContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ScriptEditor {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ScriptEditor {
    #[inline]
    pub unsafe fn _add_callback(&mut self, arg0: Option<Object>, arg1: GodotString, arg2: StringArray) -> () {
        ScriptEditor__add_callback(self.this, arg0, arg1, arg2)
    }

    #[inline]
    pub unsafe fn _autosave_scripts(&mut self) -> () {
        ScriptEditor__autosave_scripts(self.this)
    }

    #[inline]
    pub unsafe fn _breaked(&mut self, arg0: bool, arg1: bool) -> () {
        ScriptEditor__breaked(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _clear_execution(&mut self, arg0: Option<Reference>) -> () {
        ScriptEditor__clear_execution(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _close_all_tabs(&mut self) -> () {
        ScriptEditor__close_all_tabs(self.this)
    }

    #[inline]
    pub unsafe fn _close_current_tab(&mut self) -> () {
        ScriptEditor__close_current_tab(self.this)
    }

    #[inline]
    pub unsafe fn _close_discard_current_tab(&mut self, arg0: GodotString) -> () {
        ScriptEditor__close_discard_current_tab(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _close_docs_tab(&mut self) -> () {
        ScriptEditor__close_docs_tab(self.this)
    }

    #[inline]
    pub unsafe fn _close_other_tabs(&mut self) -> () {
        ScriptEditor__close_other_tabs(self.this)
    }

    #[inline]
    pub unsafe fn _copy_script_path(&mut self) -> () {
        ScriptEditor__copy_script_path(self.this)
    }

    #[inline]
    pub unsafe fn _editor_pause(&mut self) -> () {
        ScriptEditor__editor_pause(self.this)
    }

    #[inline]
    pub unsafe fn _editor_play(&mut self) -> () {
        ScriptEditor__editor_play(self.this)
    }

    #[inline]
    pub unsafe fn _editor_settings_changed(&mut self) -> () {
        ScriptEditor__editor_settings_changed(self.this)
    }

    #[inline]
    pub unsafe fn _editor_stop(&mut self) -> () {
        ScriptEditor__editor_stop(self.this)
    }

    #[inline]
    pub unsafe fn _file_dialog_action(&mut self, arg0: GodotString) -> () {
        ScriptEditor__file_dialog_action(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _filter_methods_text_changed(&mut self, arg0: GodotString) -> () {
        ScriptEditor__filter_methods_text_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _filter_scripts_text_changed(&mut self, arg0: GodotString) -> () {
        ScriptEditor__filter_scripts_text_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _get_debug_tooltip(&mut self, arg0: GodotString, arg1: Option<Node>) -> GodotString {
        ScriptEditor__get_debug_tooltip(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _goto_script_line(&mut self, arg0: Option<Reference>, arg1: i64) -> () {
        ScriptEditor__goto_script_line(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _goto_script_line2(&mut self, arg0: i64) -> () {
        ScriptEditor__goto_script_line2(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _help_class_goto(&mut self, arg0: GodotString) -> () {
        ScriptEditor__help_class_goto(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _help_class_open(&mut self, arg0: GodotString) -> () {
        ScriptEditor__help_class_open(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _help_overview_selected(&mut self, arg0: i64) -> () {
        ScriptEditor__help_overview_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _help_search(&mut self, arg0: GodotString) -> () {
        ScriptEditor__help_search(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _history_back(&mut self) -> () {
        ScriptEditor__history_back(self.this)
    }

    #[inline]
    pub unsafe fn _history_forward(&mut self) -> () {
        ScriptEditor__history_forward(self.this)
    }

    #[inline]
    pub unsafe fn _live_auto_reload_running_scripts(&mut self) -> () {
        ScriptEditor__live_auto_reload_running_scripts(self.this)
    }

    #[inline]
    pub unsafe fn _members_overview_selected(&mut self, arg0: i64) -> () {
        ScriptEditor__members_overview_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _menu_option(&mut self, arg0: i64) -> () {
        ScriptEditor__menu_option(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _on_find_in_files_modified_files(&mut self, arg0: StringArray) -> () {
        ScriptEditor__on_find_in_files_modified_files(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _on_find_in_files_requested(&mut self, arg0: GodotString) -> () {
        ScriptEditor__on_find_in_files_requested(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _on_find_in_files_result_selected(&mut self, arg0: GodotString, arg1: i64, arg2: i64, arg3: i64) -> () {
        ScriptEditor__on_find_in_files_result_selected(self.this, arg0, arg1, arg2, arg3)
    }

    #[inline]
    pub unsafe fn _open_recent_script(&mut self, arg0: i64) -> () {
        ScriptEditor__open_recent_script(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _reload_scripts(&mut self) -> () {
        ScriptEditor__reload_scripts(self.this)
    }

    #[inline]
    pub unsafe fn _request_help(&mut self, arg0: GodotString) -> () {
        ScriptEditor__request_help(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _res_saved_callback(&mut self, arg0: Option<Resource>) -> () {
        ScriptEditor__res_saved_callback(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _resave_scripts(&mut self, arg0: GodotString) -> () {
        ScriptEditor__resave_scripts(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _save_history(&mut self) -> () {
        ScriptEditor__save_history(self.this)
    }

    #[inline]
    pub unsafe fn _script_changed(&mut self) -> () {
        ScriptEditor__script_changed(self.this)
    }

    #[inline]
    pub unsafe fn _script_created(&mut self, arg0: Option<Script>) -> () {
        ScriptEditor__script_created(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _script_list_gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        ScriptEditor__script_list_gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _script_selected(&mut self, arg0: i64) -> () {
        ScriptEditor__script_selected(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _script_split_dragged(&mut self, arg0: f64) -> () {
        ScriptEditor__script_split_dragged(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _set_execution(&mut self, arg0: Option<Reference>, arg1: i64) -> () {
        ScriptEditor__set_execution(self.this, arg0, arg1)
    }

    #[inline]
    pub unsafe fn _show_debugger(&mut self, arg0: bool) -> () {
        ScriptEditor__show_debugger(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _start_find_in_files(&mut self, arg0: bool) -> () {
        ScriptEditor__start_find_in_files(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _tab_changed(&mut self, arg0: i64) -> () {
        ScriptEditor__tab_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _theme_option(&mut self, arg0: i64) -> () {
        ScriptEditor__theme_option(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _toggle_members_overview_alpha_sort(&mut self, arg0: bool) -> () {
        ScriptEditor__toggle_members_overview_alpha_sort(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _tree_changed(&mut self) -> () {
        ScriptEditor__tree_changed(self.this)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, arg0: Option<InputEvent>) -> () {
        ScriptEditor__unhandled_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _update_autosave_timer(&mut self) -> () {
        ScriptEditor__update_autosave_timer(self.this)
    }

    #[inline]
    pub unsafe fn _update_members_overview(&mut self) -> () {
        ScriptEditor__update_members_overview(self.this)
    }

    #[inline]
    pub unsafe fn _update_recent_scripts(&mut self) -> () {
        ScriptEditor__update_recent_scripts(self.this)
    }

    #[inline]
    pub unsafe fn _update_script_connections(&mut self) -> () {
        ScriptEditor__update_script_connections(self.this)
    }

    #[inline]
    pub unsafe fn _update_script_names(&mut self) -> () {
        ScriptEditor__update_script_names(self.this)
    }

    #[inline]
    pub unsafe fn can_drop_data_fw(&self, point: Vector2, data: Variant, from: Option<Control>) -> bool {
        ScriptEditor_can_drop_data_fw(self.this, point, data, from)
    }

    #[inline]
    pub unsafe fn drop_data_fw(&mut self, point: Vector2, data: Variant, from: Option<Control>) -> () {
        ScriptEditor_drop_data_fw(self.this, point, data, from)
    }

    #[inline]
    pub unsafe fn get_current_script(&mut self) -> Option<Script> {
        ScriptEditor_get_current_script(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_data_fw(&mut self, point: Vector2, from: Option<Control>) -> Variant {
        ScriptEditor_get_drag_data_fw(self.this, point, from)
    }

    #[inline]
    pub unsafe fn get_open_scripts(&self) -> VariantArray {
        ScriptEditor_get_open_scripts(self.this)
    }

    #[inline]
    pub unsafe fn goto_line(&mut self, line_number: i64) -> () {
        ScriptEditor_goto_line(self.this, line_number)
    }

    #[inline]
    pub unsafe fn open_script_create_dialog(&mut self, base_name: GodotString, base_path: GodotString) -> () {
        ScriptEditor_open_script_create_dialog(self.this, base_name, base_path)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_panel_container(&self) -> PanelContainer {
        // Not reference-counted.
        PanelContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ScrollBar` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scrollbar.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ScrollBar inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ScrollBar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ScrollBar {
    #[inline]
    pub unsafe fn _drag_node_exit(&mut self) -> () {
        ScrollBar__drag_node_exit(self.this)
    }

    #[inline]
    pub unsafe fn _drag_node_input(&mut self, arg0: Option<InputEvent>) -> () {
        ScrollBar__drag_node_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        ScrollBar__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_custom_step(&self) -> f64 {
        ScrollBar_get_custom_step(self.this)
    }

    #[inline]
    pub unsafe fn set_custom_step(&mut self, step: f64) -> () {
        ScrollBar_set_custom_step(self.this, step)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ScrollContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_scrollcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ScrollContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ScrollContainer::free`.
///
/// ## Class hierarchy
///
/// ScrollContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ScrollContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ScrollContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ScrollContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ScrollContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ScrollContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _ensure_focused_visible(&mut self, arg0: Option<Control>) -> () {
        ScrollContainer__ensure_focused_visible(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        ScrollContainer__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _scroll_moved(&mut self, arg0: f64) -> () {
        ScrollContainer__scroll_moved(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _update_scrollbar_position(&mut self) -> () {
        ScrollContainer__update_scrollbar_position(self.this)
    }

    #[inline]
    pub unsafe fn get_deadzone(&self) -> i64 {
        ScrollContainer_get_deadzone(self.this)
    }

    #[inline]
    pub unsafe fn get_h_scroll(&self) -> i64 {
        ScrollContainer_get_h_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_h_scrollbar(&mut self) -> Option<HScrollBar> {
        ScrollContainer_get_h_scrollbar(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scroll(&self) -> i64 {
        ScrollContainer_get_v_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scrollbar(&mut self) -> Option<VScrollBar> {
        ScrollContainer_get_v_scrollbar(self.this)
    }

    #[inline]
    pub unsafe fn is_following_focus(&self) -> bool {
        ScrollContainer_is_following_focus(self.this)
    }

    #[inline]
    pub unsafe fn is_h_scroll_enabled(&self) -> bool {
        ScrollContainer_is_h_scroll_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_v_scroll_enabled(&self) -> bool {
        ScrollContainer_is_v_scroll_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_deadzone(&mut self, deadzone: i64) -> () {
        ScrollContainer_set_deadzone(self.this, deadzone)
    }

    #[inline]
    pub unsafe fn set_enable_h_scroll(&mut self, enable: bool) -> () {
        ScrollContainer_set_enable_h_scroll(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_enable_v_scroll(&mut self, enable: bool) -> () {
        ScrollContainer_set_enable_v_scroll(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_follow_focus(&mut self, enabled: bool) -> () {
        ScrollContainer_set_follow_focus(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_h_scroll(&mut self, value: i64) -> () {
        ScrollContainer_set_h_scroll(self.this, value)
    }

    #[inline]
    pub unsafe fn set_v_scroll(&mut self, value: i64) -> () {
        ScrollContainer_set_v_scroll(self.this, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SegmentShape2D` inherits `Shape2D` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_segmentshape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SegmentShape2D inherits methods from:
/// - [Shape2D](struct.Shape2D.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SegmentShape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SegmentShape2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SegmentShape2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SegmentShape2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_a(&self) -> Vector2 {
        unsafe { SegmentShape2D_get_a(self.this) }
    }

    #[inline]
    pub fn get_b(&self) -> Vector2 {
        unsafe { SegmentShape2D_get_b(self.this) }
    }

    #[inline]
    pub fn set_a(&mut self, a: Vector2) -> () {
        unsafe { SegmentShape2D_set_a(self.this, a) }
    }

    #[inline]
    pub fn set_b(&mut self, b: Vector2) -> () {
        unsafe { SegmentShape2D_set_b(self.this, b) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape_2d(&self) -> Shape2D {
        unsafe {{ object::add_ref(self.this); }}
        Shape2D { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Separator` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_separator.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Separator inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Separator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Separator {

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Shader` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_shader.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Shader inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Shader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ShaderMode {
    ModeSpatial = 0,
    ModeCanvasItem = 1,
    ModeParticles = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Shader {
    pub const MODE_PARTICLES: i64 = 2;
    pub const MODE_SPATIAL: i64 = 0;
    pub const MODE_CANVAS_ITEM: i64 = 1;
}
impl Shader {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ShaderMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Shader {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_code(&self) -> GodotString {
        unsafe { Shader_get_code(self.this) }
    }

    #[inline]
    pub fn get_default_texture_param(&self, param: GodotString) -> Option<Texture> {
        unsafe { Shader_get_default_texture_param(self.this, param) }
    }

    #[inline]
    pub fn get_mode(&self) -> ShaderMode {
        unsafe { Shader_get_mode(self.this) }
    }

    #[inline]
    pub fn has_param(&self, name: GodotString) -> bool {
        unsafe { Shader_has_param(self.this, name) }
    }

    #[inline]
    pub fn set_code(&mut self, code: GodotString) -> () {
        unsafe { Shader_set_code(self.this, code) }
    }

    #[inline]
    pub fn set_default_texture_param(&mut self, param: GodotString, texture: Option<Texture>) -> () {
        unsafe { Shader_set_default_texture_param(self.this, param, texture) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ShaderMaterial` inherits `Material` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_shadermaterial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ShaderMaterial inherits methods from:
/// - [Material](struct.Material.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ShaderMaterial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ShaderMaterial {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ShaderMaterialMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ShaderMaterial {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _shader_changed(&mut self) -> () {
        unsafe { ShaderMaterial__shader_changed(self.this) }
    }

    #[inline]
    pub fn get_shader(&self) -> Option<Shader> {
        unsafe { ShaderMaterial_get_shader(self.this) }
    }

    #[inline]
    pub fn get_shader_param(&self, param: GodotString) -> Variant {
        unsafe { ShaderMaterial_get_shader_param(self.this, param) }
    }

    #[inline]
    pub fn property_can_revert(&mut self, name: GodotString) -> bool {
        unsafe { ShaderMaterial_property_can_revert(self.this, name) }
    }

    #[inline]
    pub fn property_get_revert(&mut self, name: GodotString) -> Variant {
        unsafe { ShaderMaterial_property_get_revert(self.this, name) }
    }

    #[inline]
    pub fn set_shader(&mut self, shader: Option<Shader>) -> () {
        unsafe { ShaderMaterial_set_shader(self.this, shader) }
    }

    #[inline]
    pub fn set_shader_param(&mut self, param: GodotString, value: Variant) -> () {
        unsafe { ShaderMaterial_set_shader_param(self.this, param, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_material(&self) -> Material {
        unsafe {{ object::add_ref(self.this); }}
        Material { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Shape` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_shape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Shape inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Shape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Shape {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_margin(&self) -> f64 {
        unsafe { Shape_get_margin(self.this) }
    }

    #[inline]
    pub fn set_margin(&mut self, margin: f64) -> () {
        unsafe { Shape_set_margin(self.this, margin) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Shape2D` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_shape2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Shape2D inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Shape2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Shape2D {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn collide(&mut self, local_xform: Transform2D, with_shape: Option<Shape2D>, shape_xform: Transform2D) -> bool {
        unsafe { Shape2D_collide(self.this, local_xform, with_shape, shape_xform) }
    }

    #[inline]
    pub fn collide_and_get_contacts(&mut self, local_xform: Transform2D, with_shape: Option<Shape2D>, shape_xform: Transform2D) -> VariantArray {
        unsafe { Shape2D_collide_and_get_contacts(self.this, local_xform, with_shape, shape_xform) }
    }

    #[inline]
    pub fn collide_with_motion(&mut self, local_xform: Transform2D, local_motion: Vector2, with_shape: Option<Shape2D>, shape_xform: Transform2D, shape_motion: Vector2) -> bool {
        unsafe { Shape2D_collide_with_motion(self.this, local_xform, local_motion, with_shape, shape_xform, shape_motion) }
    }

    #[inline]
    pub fn collide_with_motion_and_get_contacts(&mut self, local_xform: Transform2D, local_motion: Vector2, with_shape: Option<Shape2D>, shape_xform: Transform2D, shape_motion: Vector2) -> VariantArray {
        unsafe { Shape2D_collide_with_motion_and_get_contacts(self.this, local_xform, local_motion, with_shape, shape_xform, shape_motion) }
    }

    #[inline]
    pub fn get_custom_solver_bias(&self) -> f64 {
        unsafe { Shape2D_get_custom_solver_bias(self.this) }
    }

    #[inline]
    pub fn set_custom_solver_bias(&mut self, bias: f64) -> () {
        unsafe { Shape2D_set_custom_solver_bias(self.this, bias) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ShortCut` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_shortcut.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ShortCut inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ShortCut {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ShortCut {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ShortCutMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ShortCut {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_as_text(&self) -> GodotString {
        unsafe { ShortCut_get_as_text(self.this) }
    }

    #[inline]
    pub fn get_shortcut(&self) -> Option<InputEvent> {
        unsafe { ShortCut_get_shortcut(self.this) }
    }

    #[inline]
    pub fn is_shortcut(&self, event: Option<InputEvent>) -> bool {
        unsafe { ShortCut_is_shortcut(self.this, event) }
    }

    #[inline]
    pub fn is_valid(&self) -> bool {
        unsafe { ShortCut_is_valid(self.this) }
    }

    #[inline]
    pub fn set_shortcut(&mut self, event: Option<InputEvent>) -> () {
        unsafe { ShortCut_set_shortcut(self.this, event) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Skeleton` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_skeleton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Skeleton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Skeleton::free`.
///
/// ## Class hierarchy
///
/// Skeleton inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Skeleton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl Skeleton {
    pub const NOTIFICATION_UPDATE_SKELETON: i64 = 50;
}
impl Skeleton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Skeleton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SkeletonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Skeleton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_bone(&mut self, name: GodotString) -> () {
        Skeleton_add_bone(self.this, name)
    }

    #[inline]
    pub unsafe fn bind_child_node_to_bone(&mut self, bone_idx: i64, node: Option<Node>) -> () {
        Skeleton_bind_child_node_to_bone(self.this, bone_idx, node)
    }

    #[inline]
    pub unsafe fn clear_bones(&mut self) -> () {
        Skeleton_clear_bones(self.this)
    }

    #[inline]
    pub unsafe fn find_bone(&self, name: GodotString) -> i64 {
        Skeleton_find_bone(self.this, name)
    }

    #[inline]
    pub unsafe fn get_bone_count(&self) -> i64 {
        Skeleton_get_bone_count(self.this)
    }

    #[inline]
    pub unsafe fn get_bone_custom_pose(&self, bone_idx: i64) -> Transform {
        Skeleton_get_bone_custom_pose(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bone_global_pose(&self, bone_idx: i64) -> Transform {
        Skeleton_get_bone_global_pose(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bone_name(&self, bone_idx: i64) -> GodotString {
        Skeleton_get_bone_name(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bone_parent(&self, bone_idx: i64) -> i64 {
        Skeleton_get_bone_parent(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bone_pose(&self, bone_idx: i64) -> Transform {
        Skeleton_get_bone_pose(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bone_rest(&self, bone_idx: i64) -> Transform {
        Skeleton_get_bone_rest(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn get_bound_child_nodes_to_bone(&self, bone_idx: i64) -> VariantArray {
        Skeleton_get_bound_child_nodes_to_bone(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn is_bone_rest_disabled(&self, bone_idx: i64) -> bool {
        Skeleton_is_bone_rest_disabled(self.this, bone_idx)
    }

    #[inline]
    pub unsafe fn localize_rests(&mut self) -> () {
        Skeleton_localize_rests(self.this)
    }

    #[inline]
    pub unsafe fn physical_bones_add_collision_exception(&mut self, exception: Rid) -> () {
        Skeleton_physical_bones_add_collision_exception(self.this, exception)
    }

    #[inline]
    pub unsafe fn physical_bones_remove_collision_exception(&mut self, exception: Rid) -> () {
        Skeleton_physical_bones_remove_collision_exception(self.this, exception)
    }

    #[inline]
    pub unsafe fn physical_bones_start_simulation(&mut self, bones: VariantArray) -> () {
        Skeleton_physical_bones_start_simulation(self.this, bones)
    }

    #[inline]
    pub unsafe fn physical_bones_stop_simulation(&mut self) -> () {
        Skeleton_physical_bones_stop_simulation(self.this)
    }

    #[inline]
    pub unsafe fn register_skin(&mut self, skin: Option<Skin>) -> Option<SkinReference> {
        Skeleton_register_skin(self.this, skin)
    }

    #[inline]
    pub unsafe fn set_bone_custom_pose(&mut self, bone_idx: i64, custom_pose: Transform) -> () {
        Skeleton_set_bone_custom_pose(self.this, bone_idx, custom_pose)
    }

    #[inline]
    pub unsafe fn set_bone_disable_rest(&mut self, bone_idx: i64, disable: bool) -> () {
        Skeleton_set_bone_disable_rest(self.this, bone_idx, disable)
    }

    #[inline]
    pub unsafe fn set_bone_global_pose_override(&mut self, bone_idx: i64, pose: Transform, amount: f64, persistent: bool) -> () {
        Skeleton_set_bone_global_pose_override(self.this, bone_idx, pose, amount, persistent)
    }

    #[inline]
    pub unsafe fn set_bone_parent(&mut self, bone_idx: i64, parent_idx: i64) -> () {
        Skeleton_set_bone_parent(self.this, bone_idx, parent_idx)
    }

    #[inline]
    pub unsafe fn set_bone_pose(&mut self, bone_idx: i64, pose: Transform) -> () {
        Skeleton_set_bone_pose(self.this, bone_idx, pose)
    }

    #[inline]
    pub unsafe fn set_bone_rest(&mut self, bone_idx: i64, rest: Transform) -> () {
        Skeleton_set_bone_rest(self.this, bone_idx, rest)
    }

    #[inline]
    pub unsafe fn unbind_child_node_from_bone(&mut self, bone_idx: i64, node: Option<Node>) -> () {
        Skeleton_unbind_child_node_from_bone(self.this, bone_idx, node)
    }

    #[inline]
    pub unsafe fn unparent_bone_and_rest(&mut self, bone_idx: i64) -> () {
        Skeleton_unparent_bone_and_rest(self.this, bone_idx)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Skeleton2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_skeleton2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Skeleton2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Skeleton2D::free`.
///
/// ## Class hierarchy
///
/// Skeleton2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Skeleton2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Skeleton2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Skeleton2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Skeleton2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Skeleton2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _update_bone_setup(&mut self) -> () {
        Skeleton2D__update_bone_setup(self.this)
    }

    #[inline]
    pub unsafe fn _update_transform(&mut self) -> () {
        Skeleton2D__update_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_bone(&mut self, idx: i64) -> Option<Bone2D> {
        Skeleton2D_get_bone(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_bone_count(&self) -> i64 {
        Skeleton2D_get_bone_count(self.this)
    }

    #[inline]
    pub unsafe fn get_skeleton(&self) -> Rid {
        Skeleton2D_get_skeleton(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SkeletonIK` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_skeletonik.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SkeletonIK` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SkeletonIK::free`.
///
/// ## Class hierarchy
///
/// SkeletonIK inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SkeletonIK {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SkeletonIK {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SkeletonIK::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SkeletonIKMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SkeletonIK {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_interpolation(&self) -> f64 {
        SkeletonIK_get_interpolation(self.this)
    }

    #[inline]
    pub unsafe fn get_magnet_position(&self) -> Vector3 {
        SkeletonIK_get_magnet_position(self.this)
    }

    #[inline]
    pub unsafe fn get_max_iterations(&self) -> i64 {
        SkeletonIK_get_max_iterations(self.this)
    }

    #[inline]
    pub unsafe fn get_min_distance(&self) -> f64 {
        SkeletonIK_get_min_distance(self.this)
    }

    #[inline]
    pub unsafe fn get_parent_skeleton(&self) -> Option<Skeleton> {
        SkeletonIK_get_parent_skeleton(self.this)
    }

    #[inline]
    pub unsafe fn get_root_bone(&self) -> GodotString {
        SkeletonIK_get_root_bone(self.this)
    }

    #[inline]
    pub unsafe fn get_target_node(&mut self) -> NodePath {
        SkeletonIK_get_target_node(self.this)
    }

    #[inline]
    pub unsafe fn get_target_transform(&self) -> Transform {
        SkeletonIK_get_target_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_tip_bone(&self) -> GodotString {
        SkeletonIK_get_tip_bone(self.this)
    }

    #[inline]
    pub unsafe fn is_override_tip_basis(&self) -> bool {
        SkeletonIK_is_override_tip_basis(self.this)
    }

    #[inline]
    pub unsafe fn is_running(&mut self) -> bool {
        SkeletonIK_is_running(self.this)
    }

    #[inline]
    pub unsafe fn is_using_magnet(&self) -> bool {
        SkeletonIK_is_using_magnet(self.this)
    }

    #[inline]
    pub unsafe fn set_interpolation(&mut self, interpolation: f64) -> () {
        SkeletonIK_set_interpolation(self.this, interpolation)
    }

    #[inline]
    pub unsafe fn set_magnet_position(&mut self, local_position: Vector3) -> () {
        SkeletonIK_set_magnet_position(self.this, local_position)
    }

    #[inline]
    pub unsafe fn set_max_iterations(&mut self, iterations: i64) -> () {
        SkeletonIK_set_max_iterations(self.this, iterations)
    }

    #[inline]
    pub unsafe fn set_min_distance(&mut self, min_distance: f64) -> () {
        SkeletonIK_set_min_distance(self.this, min_distance)
    }

    #[inline]
    pub unsafe fn set_override_tip_basis(&mut self, _override: bool) -> () {
        SkeletonIK_set_override_tip_basis(self.this, _override)
    }

    #[inline]
    pub unsafe fn set_root_bone(&mut self, root_bone: GodotString) -> () {
        SkeletonIK_set_root_bone(self.this, root_bone)
    }

    #[inline]
    pub unsafe fn set_target_node(&mut self, node: NodePath) -> () {
        SkeletonIK_set_target_node(self.this, node)
    }

    #[inline]
    pub unsafe fn set_target_transform(&mut self, target: Transform) -> () {
        SkeletonIK_set_target_transform(self.this, target)
    }

    #[inline]
    pub unsafe fn set_tip_bone(&mut self, tip_bone: GodotString) -> () {
        SkeletonIK_set_tip_bone(self.this, tip_bone)
    }

    #[inline]
    pub unsafe fn set_use_magnet(&mut self, _use: bool) -> () {
        SkeletonIK_set_use_magnet(self.this, _use)
    }

    #[inline]
    pub unsafe fn start(&mut self, one_time: bool) -> () {
        SkeletonIK_start(self.this, one_time)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        SkeletonIK_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Skin` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_skin.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Skin inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Skin {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Skin {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SkinMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Skin {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_bind(&mut self, bone: i64, pose: Transform) -> () {
        unsafe { Skin_add_bind(self.this, bone, pose) }
    }

    #[inline]
    pub fn clear_binds(&mut self) -> () {
        unsafe { Skin_clear_binds(self.this) }
    }

    #[inline]
    pub fn get_bind_bone(&self, bind_index: i64) -> i64 {
        unsafe { Skin_get_bind_bone(self.this, bind_index) }
    }

    #[inline]
    pub fn get_bind_count(&self) -> i64 {
        unsafe { Skin_get_bind_count(self.this) }
    }

    #[inline]
    pub fn get_bind_pose(&self, bind_index: i64) -> Transform {
        unsafe { Skin_get_bind_pose(self.this, bind_index) }
    }

    #[inline]
    pub fn set_bind_bone(&mut self, bind_index: i64, bone: i64) -> () {
        unsafe { Skin_set_bind_bone(self.this, bind_index, bone) }
    }

    #[inline]
    pub fn set_bind_count(&mut self, bind_count: i64) -> () {
        unsafe { Skin_set_bind_count(self.this, bind_count) }
    }

    #[inline]
    pub fn set_bind_pose(&mut self, bind_index: i64, pose: Transform) -> () {
        unsafe { Skin_set_bind_pose(self.this, bind_index, pose) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SkinReference` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_skinreference.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SkinReference inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SkinReference {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SkinReference {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _skin_changed(&mut self) -> () {
        unsafe { SkinReference__skin_changed(self.this) }
    }

    #[inline]
    pub fn get_skeleton(&self) -> Rid {
        unsafe { SkinReference_get_skeleton(self.this) }
    }

    #[inline]
    pub fn get_skin(&self) -> Option<Skin> {
        unsafe { SkinReference_get_skin(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Sky` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_sky.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Sky inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Sky {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SkyRadianceSize {
    RadianceSize32 = 0,
    RadianceSize64 = 1,
    RadianceSize128 = 2,
    RadianceSize256 = 3,
    RadianceSize512 = 4,
    RadianceSize1024 = 5,
    RadianceSize2048 = 6,
    Max = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Sky {
    pub const RADIANCE_SIZE_32: i64 = 0;
    pub const RADIANCE_SIZE_128: i64 = 2;
    pub const RADIANCE_SIZE_256: i64 = 3;
    pub const RADIANCE_SIZE_MAX: i64 = 7;
    pub const RADIANCE_SIZE_1024: i64 = 5;
    pub const RADIANCE_SIZE_64: i64 = 1;
    pub const RADIANCE_SIZE_512: i64 = 4;
    pub const RADIANCE_SIZE_2048: i64 = 6;
}
impl Sky {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_radiance_size(&self) -> SkyRadianceSize {
        unsafe { Sky_get_radiance_size(self.this) }
    }

    #[inline]
    pub fn set_radiance_size(&mut self, size: i64) -> () {
        unsafe { Sky_set_radiance_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Slider` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_slider.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Slider inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Slider {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Slider {
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        Slider__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_ticks(&self) -> i64 {
        Slider_get_ticks(self.this)
    }

    #[inline]
    pub unsafe fn get_ticks_on_borders(&self) -> bool {
        Slider_get_ticks_on_borders(self.this)
    }

    #[inline]
    pub unsafe fn is_editable(&self) -> bool {
        Slider_is_editable(self.this)
    }

    #[inline]
    pub unsafe fn is_scrollable(&self) -> bool {
        Slider_is_scrollable(self.this)
    }

    #[inline]
    pub unsafe fn set_editable(&mut self, editable: bool) -> () {
        Slider_set_editable(self.this, editable)
    }

    #[inline]
    pub unsafe fn set_scrollable(&mut self, scrollable: bool) -> () {
        Slider_set_scrollable(self.this, scrollable)
    }

    #[inline]
    pub unsafe fn set_ticks(&mut self, count: i64) -> () {
        Slider_set_ticks(self.this, count)
    }

    #[inline]
    pub unsafe fn set_ticks_on_borders(&mut self, ticks_on_border: bool) -> () {
        Slider_set_ticks_on_borders(self.this, ticks_on_border)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SliderJoint` inherits `Joint` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_sliderjoint.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SliderJoint` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SliderJoint::free`.
///
/// ## Class hierarchy
///
/// SliderJoint inherits methods from:
/// - [Joint](struct.Joint.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SliderJoint {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SliderJointParam {
    LinearLimitUpper = 0,
    LinearLimitLower = 1,
    LinearLimitSoftness = 2,
    LinearLimitRestitution = 3,
    LinearLimitDamping = 4,
    LinearMotionSoftness = 5,
    LinearMotionRestitution = 6,
    LinearMotionDamping = 7,
    LinearOrthogonalSoftness = 8,
    LinearOrthogonalRestitution = 9,
    LinearOrthogonalDamping = 10,
    AngularLimitUpper = 11,
    AngularLimitLower = 12,
    AngularLimitSoftness = 13,
    AngularLimitRestitution = 14,
    AngularLimitDamping = 15,
    AngularMotionSoftness = 16,
    AngularMotionRestitution = 17,
    AngularMotionDamping = 18,
    AngularOrthogonalSoftness = 19,
    AngularOrthogonalRestitution = 20,
    AngularOrthogonalDamping = 21,
    Max = 22,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SliderJoint {
    pub const PARAM_ANGULAR_ORTHOGONAL_RESTITUTION: i64 = 20;
    pub const PARAM_ANGULAR_MOTION_RESTITUTION: i64 = 17;
    pub const PARAM_ANGULAR_LIMIT_LOWER: i64 = 12;
    pub const PARAM_LINEAR_MOTION_DAMPING: i64 = 7;
    pub const PARAM_LINEAR_ORTHOGONAL_DAMPING: i64 = 10;
    pub const PARAM_ANGULAR_ORTHOGONAL_SOFTNESS: i64 = 19;
    pub const PARAM_LINEAR_MOTION_RESTITUTION: i64 = 6;
    pub const PARAM_ANGULAR_LIMIT_UPPER: i64 = 11;
    pub const PARAM_LINEAR_LIMIT_SOFTNESS: i64 = 2;
    pub const PARAM_LINEAR_LIMIT_UPPER: i64 = 0;
    pub const PARAM_ANGULAR_MOTION_DAMPING: i64 = 18;
    pub const PARAM_ANGULAR_MOTION_SOFTNESS: i64 = 16;
    pub const PARAM_LINEAR_LIMIT_DAMPING: i64 = 4;
    pub const PARAM_LINEAR_LIMIT_RESTITUTION: i64 = 3;
    pub const PARAM_LINEAR_MOTION_SOFTNESS: i64 = 5;
    pub const PARAM_ANGULAR_LIMIT_RESTITUTION: i64 = 14;
    pub const PARAM_LINEAR_ORTHOGONAL_SOFTNESS: i64 = 8;
    pub const PARAM_MAX: i64 = 22;
    pub const PARAM_ANGULAR_ORTHOGONAL_DAMPING: i64 = 21;
    pub const PARAM_LINEAR_LIMIT_LOWER: i64 = 1;
    pub const PARAM_ANGULAR_LIMIT_DAMPING: i64 = 15;
    pub const PARAM_LINEAR_ORTHOGONAL_RESTITUTION: i64 = 9;
    pub const PARAM_ANGULAR_LIMIT_SOFTNESS: i64 = 13;
}
impl SliderJoint {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SliderJoint::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SliderJointMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SliderJoint {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _get_lower_limit_angular(&self) -> f64 {
        SliderJoint__get_lower_limit_angular(self.this)
    }

    #[inline]
    pub unsafe fn _get_upper_limit_angular(&self) -> f64 {
        SliderJoint__get_upper_limit_angular(self.this)
    }

    #[inline]
    pub unsafe fn _set_lower_limit_angular(&mut self, lower_limit_angular: f64) -> () {
        SliderJoint__set_lower_limit_angular(self.this, lower_limit_angular)
    }

    #[inline]
    pub unsafe fn _set_upper_limit_angular(&mut self, upper_limit_angular: f64) -> () {
        SliderJoint__set_upper_limit_angular(self.this, upper_limit_angular)
    }

    #[inline]
    pub unsafe fn get_param(&self, param: i64) -> f64 {
        SliderJoint_get_param(self.this, param)
    }

    #[inline]
    pub unsafe fn set_param(&mut self, param: i64, value: f64) -> () {
        SliderJoint_set_param(self.this, param, value)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_joint(&self) -> Joint {
        // Not reference-counted.
        Joint { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SoftBody` inherits `MeshInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_softbody.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SoftBody` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SoftBody::free`.
///
/// ## Class hierarchy
///
/// SoftBody inherits methods from:
/// - [MeshInstance](struct.MeshInstance.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SoftBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SoftBody {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SoftBody::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SoftBodyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SoftBody {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _draw_soft_mesh(&mut self) -> () {
        SoftBody__draw_soft_mesh(self.this)
    }

    #[inline]
    pub unsafe fn add_collision_exception_with(&mut self, body: Option<Node>) -> () {
        SoftBody_add_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn get_areaAngular_stiffness(&mut self) -> f64 {
        SoftBody_get_areaAngular_stiffness(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_exceptions(&mut self) -> VariantArray {
        SoftBody_get_collision_exceptions(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        SoftBody_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        SoftBody_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        SoftBody_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        SoftBody_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_damping_coefficient(&mut self) -> f64 {
        SoftBody_get_damping_coefficient(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_coefficient(&mut self) -> f64 {
        SoftBody_get_drag_coefficient(self.this)
    }

    #[inline]
    pub unsafe fn get_linear_stiffness(&mut self) -> f64 {
        SoftBody_get_linear_stiffness(self.this)
    }

    #[inline]
    pub unsafe fn get_parent_collision_ignore(&self) -> NodePath {
        SoftBody_get_parent_collision_ignore(self.this)
    }

    #[inline]
    pub unsafe fn get_pose_matching_coefficient(&mut self) -> f64 {
        SoftBody_get_pose_matching_coefficient(self.this)
    }

    #[inline]
    pub unsafe fn get_pressure_coefficient(&mut self) -> f64 {
        SoftBody_get_pressure_coefficient(self.this)
    }

    #[inline]
    pub unsafe fn get_simulation_precision(&mut self) -> i64 {
        SoftBody_get_simulation_precision(self.this)
    }

    #[inline]
    pub unsafe fn get_total_mass(&mut self) -> f64 {
        SoftBody_get_total_mass(self.this)
    }

    #[inline]
    pub unsafe fn get_volume_stiffness(&mut self) -> f64 {
        SoftBody_get_volume_stiffness(self.this)
    }

    #[inline]
    pub unsafe fn is_ray_pickable(&self) -> bool {
        SoftBody_is_ray_pickable(self.this)
    }

    #[inline]
    pub unsafe fn remove_collision_exception_with(&mut self, body: Option<Node>) -> () {
        SoftBody_remove_collision_exception_with(self.this, body)
    }

    #[inline]
    pub unsafe fn set_areaAngular_stiffness(&mut self, areaAngular_stiffness: f64) -> () {
        SoftBody_set_areaAngular_stiffness(self.this, areaAngular_stiffness)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, collision_layer: i64) -> () {
        SoftBody_set_collision_layer(self.this, collision_layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        SoftBody_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, collision_mask: i64) -> () {
        SoftBody_set_collision_mask(self.this, collision_mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        SoftBody_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_damping_coefficient(&mut self, damping_coefficient: f64) -> () {
        SoftBody_set_damping_coefficient(self.this, damping_coefficient)
    }

    #[inline]
    pub unsafe fn set_drag_coefficient(&mut self, drag_coefficient: f64) -> () {
        SoftBody_set_drag_coefficient(self.this, drag_coefficient)
    }

    #[inline]
    pub unsafe fn set_linear_stiffness(&mut self, linear_stiffness: f64) -> () {
        SoftBody_set_linear_stiffness(self.this, linear_stiffness)
    }

    #[inline]
    pub unsafe fn set_parent_collision_ignore(&mut self, parent_collision_ignore: NodePath) -> () {
        SoftBody_set_parent_collision_ignore(self.this, parent_collision_ignore)
    }

    #[inline]
    pub unsafe fn set_pose_matching_coefficient(&mut self, pose_matching_coefficient: f64) -> () {
        SoftBody_set_pose_matching_coefficient(self.this, pose_matching_coefficient)
    }

    #[inline]
    pub unsafe fn set_pressure_coefficient(&mut self, pressure_coefficient: f64) -> () {
        SoftBody_set_pressure_coefficient(self.this, pressure_coefficient)
    }

    #[inline]
    pub unsafe fn set_ray_pickable(&mut self, ray_pickable: bool) -> () {
        SoftBody_set_ray_pickable(self.this, ray_pickable)
    }

    #[inline]
    pub unsafe fn set_simulation_precision(&mut self, simulation_precision: i64) -> () {
        SoftBody_set_simulation_precision(self.this, simulation_precision)
    }

    #[inline]
    pub unsafe fn set_total_mass(&mut self, mass: f64) -> () {
        SoftBody_set_total_mass(self.this, mass)
    }

    #[inline]
    pub unsafe fn set_volume_stiffness(&mut self, volume_stiffness: f64) -> () {
        SoftBody_set_volume_stiffness(self.this, volume_stiffness)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_mesh_instance(&self) -> MeshInstance {
        // Not reference-counted.
        MeshInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Spatial` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spatial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Spatial` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Spatial::free`.
///
/// ## Class hierarchy
///
/// Spatial inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Spatial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

/// Constants
#[allow(non_upper_case_globals)]
impl Spatial {
    pub const NOTIFICATION_ENTER_WORLD: i64 = 41;
    pub const NOTIFICATION_EXIT_WORLD: i64 = 42;
    pub const NOTIFICATION_VISIBILITY_CHANGED: i64 = 43;
    pub const NOTIFICATION_TRANSFORM_CHANGED: i64 = 2000;
}
impl Spatial {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Spatial::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpatialMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Spatial {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _update_gizmo(&mut self) -> () {
        Spatial__update_gizmo(self.this)
    }

    #[inline]
    pub unsafe fn force_update_transform(&mut self) -> () {
        Spatial_force_update_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_gizmo(&self) -> Option<SpatialGizmo> {
        Spatial_get_gizmo(self.this)
    }

    #[inline]
    pub unsafe fn get_global_transform(&self) -> Transform {
        Spatial_get_global_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_parent_spatial(&self) -> Option<Spatial> {
        Spatial_get_parent_spatial(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation(&self) -> Vector3 {
        Spatial_get_rotation(self.this)
    }

    #[inline]
    pub unsafe fn get_rotation_degrees(&self) -> Vector3 {
        Spatial_get_rotation_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_scale(&self) -> Vector3 {
        Spatial_get_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_transform(&self) -> Transform {
        Spatial_get_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_translation(&self) -> Vector3 {
        Spatial_get_translation(self.this)
    }

    #[inline]
    pub unsafe fn get_world(&self) -> Option<World> {
        Spatial_get_world(self.this)
    }

    #[inline]
    pub unsafe fn global_rotate(&mut self, axis: Vector3, angle: f64) -> () {
        Spatial_global_rotate(self.this, axis, angle)
    }

    #[inline]
    pub unsafe fn global_scale(&mut self, scale: Vector3) -> () {
        Spatial_global_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn global_translate(&mut self, offset: Vector3) -> () {
        Spatial_global_translate(self.this, offset)
    }

    #[inline]
    pub unsafe fn hide(&mut self) -> () {
        Spatial_hide(self.this)
    }

    #[inline]
    pub unsafe fn is_local_transform_notification_enabled(&self) -> bool {
        Spatial_is_local_transform_notification_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_scale_disabled(&self) -> bool {
        Spatial_is_scale_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_set_as_toplevel(&self) -> bool {
        Spatial_is_set_as_toplevel(self.this)
    }

    #[inline]
    pub unsafe fn is_transform_notification_enabled(&self) -> bool {
        Spatial_is_transform_notification_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_visible(&self) -> bool {
        Spatial_is_visible(self.this)
    }

    #[inline]
    pub unsafe fn is_visible_in_tree(&self) -> bool {
        Spatial_is_visible_in_tree(self.this)
    }

    #[inline]
    pub unsafe fn look_at(&mut self, target: Vector3, up: Vector3) -> () {
        Spatial_look_at(self.this, target, up)
    }

    #[inline]
    pub unsafe fn look_at_from_position(&mut self, position: Vector3, target: Vector3, up: Vector3) -> () {
        Spatial_look_at_from_position(self.this, position, target, up)
    }

    #[inline]
    pub unsafe fn orthonormalize(&mut self) -> () {
        Spatial_orthonormalize(self.this)
    }

    #[inline]
    pub unsafe fn rotate(&mut self, axis: Vector3, angle: f64) -> () {
        Spatial_rotate(self.this, axis, angle)
    }

    #[inline]
    pub unsafe fn rotate_object_local(&mut self, axis: Vector3, angle: f64) -> () {
        Spatial_rotate_object_local(self.this, axis, angle)
    }

    #[inline]
    pub unsafe fn rotate_x(&mut self, angle: f64) -> () {
        Spatial_rotate_x(self.this, angle)
    }

    #[inline]
    pub unsafe fn rotate_y(&mut self, angle: f64) -> () {
        Spatial_rotate_y(self.this, angle)
    }

    #[inline]
    pub unsafe fn rotate_z(&mut self, angle: f64) -> () {
        Spatial_rotate_z(self.this, angle)
    }

    #[inline]
    pub unsafe fn scale_object_local(&mut self, scale: Vector3) -> () {
        Spatial_scale_object_local(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_as_toplevel(&mut self, enable: bool) -> () {
        Spatial_set_as_toplevel(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_disable_scale(&mut self, disable: bool) -> () {
        Spatial_set_disable_scale(self.this, disable)
    }

    #[inline]
    pub unsafe fn set_gizmo(&mut self, gizmo: Option<SpatialGizmo>) -> () {
        Spatial_set_gizmo(self.this, gizmo)
    }

    #[inline]
    pub unsafe fn set_global_transform(&mut self, global: Transform) -> () {
        Spatial_set_global_transform(self.this, global)
    }

    #[inline]
    pub unsafe fn set_identity(&mut self) -> () {
        Spatial_set_identity(self.this)
    }

    #[inline]
    pub unsafe fn set_ignore_transform_notification(&mut self, enabled: bool) -> () {
        Spatial_set_ignore_transform_notification(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_notify_local_transform(&mut self, enable: bool) -> () {
        Spatial_set_notify_local_transform(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_notify_transform(&mut self, enable: bool) -> () {
        Spatial_set_notify_transform(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_rotation(&mut self, euler: Vector3) -> () {
        Spatial_set_rotation(self.this, euler)
    }

    #[inline]
    pub unsafe fn set_rotation_degrees(&mut self, euler_degrees: Vector3) -> () {
        Spatial_set_rotation_degrees(self.this, euler_degrees)
    }

    #[inline]
    pub unsafe fn set_scale(&mut self, scale: Vector3) -> () {
        Spatial_set_scale(self.this, scale)
    }

    #[inline]
    pub unsafe fn set_transform(&mut self, local: Transform) -> () {
        Spatial_set_transform(self.this, local)
    }

    #[inline]
    pub unsafe fn set_translation(&mut self, translation: Vector3) -> () {
        Spatial_set_translation(self.this, translation)
    }

    #[inline]
    pub unsafe fn set_visible(&mut self, visible: bool) -> () {
        Spatial_set_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn show(&mut self) -> () {
        Spatial_show(self.this)
    }

    #[inline]
    pub unsafe fn to_global(&self, local_point: Vector3) -> Vector3 {
        Spatial_to_global(self.this, local_point)
    }

    #[inline]
    pub unsafe fn to_local(&self, global_point: Vector3) -> Vector3 {
        Spatial_to_local(self.this, global_point)
    }

    #[inline]
    pub unsafe fn translate(&mut self, offset: Vector3) -> () {
        Spatial_translate(self.this, offset)
    }

    #[inline]
    pub unsafe fn translate_object_local(&mut self, offset: Vector3) -> () {
        Spatial_translate_object_local(self.this, offset)
    }

    #[inline]
    pub unsafe fn update_gizmo(&mut self) -> () {
        Spatial_update_gizmo(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpatialGizmo` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spatialgizmo.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SpatialGizmo inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpatialGizmo {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpatialGizmo {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpatialMaterial` inherits `Material` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spatialmaterial.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SpatialMaterial inherits methods from:
/// - [Material](struct.Material.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpatialMaterial {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialEmissionOperator {
    EmissionOpAdd = 0,
    EmissionOpMultiply = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialDiffuseMode {
    Burley = 0,
    Lambert = 1,
    LambertWrap = 2,
    OrenNayar = 3,
    Toon = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialSpecularMode {
    SchlickGgx = 0,
    Blinn = 1,
    Phong = 2,
    Toon = 3,
    Disabled = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialFeature {
    Transparent = 0,
    Emission = 1,
    NormalMapping = 2,
    Rim = 3,
    Clearcoat = 4,
    Anisotropy = 5,
    AmbientOcclusion = 6,
    DepthMapping = 7,
    SubsuraceScattering = 8,
    Transmission = 9,
    Refraction = 10,
    Detail = 11,
    Max = 12,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialFlags {
    FlagUnshaded = 0,
    FlagUseVertexLighting = 1,
    FlagDisableDepthTest = 2,
    FlagAlbedoFromVertexColor = 3,
    rgbVertexColor = 4,
    FlagUsePointSize = 5,
    FlagFixedSize = 6,
    FlagBillboardKeepScale = 7,
    FlagUv1UseTriplanar = 8,
    FlagUv2UseTriplanar = 9,
    FlagTriplanarUseWorld = 10,
    FlagAoOnUv2 = 11,
    FlagEmissionOnUv2 = 12,
    FlagUseAlphaScissor = 13,
    FlagAlbedoTextureForceSrgb = 14,
    FlagDontReceiveShadows = 15,
    FlagEnsureCorrectNormals = 16,
    FlagDisableAmbientLight = 17,
    FlagUseShadowToOpacity = 18,
    FlagMax = 19,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialCullMode {
    Back = 0,
    Front = 1,
    Disabled = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialDetailUV {
    DetailUv1 = 0,
    DetailUv2 = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialDistanceFadeMode {
    Disabled = 0,
    PixelAlpha = 1,
    PixelDither = 2,
    ObjectDither = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialBillboardMode {
    Disabled = 0,
    Enabled = 1,
    FixedY = 2,
    Particles = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialDepthDrawMode {
    OpaqueOnly = 0,
    Always = 1,
    Disabled = 2,
    AlphaOpaquePrepass = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialTextureChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
    Grayscale = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialBlendMode {
    ModeMix = 0,
    ModeAdd = 1,
    ModeSub = 2,
    ModeMul = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpatialMaterialTextureParam {
    TextureAlbedo = 0,
    TextureMetallic = 1,
    TextureRoughness = 2,
    TextureEmission = 3,
    TextureNormal = 4,
    TextureRim = 5,
    TextureClearcoat = 6,
    TextureFlowmap = 7,
    TextureAmbientOcclusion = 8,
    TextureDepth = 9,
    TextureSubsurfaceScattering = 10,
    TextureTransmission = 11,
    TextureRefraction = 12,
    TextureDetailMask = 13,
    TextureDetailAlbedo = 14,
    TextureDetailNormal = 15,
    TextureMax = 16,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SpatialMaterial {
    pub const FLAG_TRIPLANAR_USE_WORLD: i64 = 10;
    pub const TEXTURE_METALLIC: i64 = 1;
    pub const DISTANCE_FADE_OBJECT_DITHER: i64 = 3;
    pub const FEATURE_TRANSPARENT: i64 = 0;
    pub const FLAG_FIXED_SIZE: i64 = 6;
    pub const TEXTURE_REFRACTION: i64 = 12;
    pub const FEATURE_TRANSMISSION: i64 = 9;
    pub const FLAG_MAX: i64 = 19;
    pub const DIFFUSE_TOON: i64 = 4;
    pub const TEXTURE_RIM: i64 = 5;
    pub const FEATURE_DETAIL: i64 = 11;
    pub const BILLBOARD_PARTICLES: i64 = 3;
    pub const BLEND_MODE_MUL: i64 = 3;
    pub const FLAG_USE_POINT_SIZE: i64 = 5;
    pub const FLAG_ALBEDO_FROM_VERTEX_COLOR: i64 = 3;
    pub const TEXTURE_CHANNEL_RED: i64 = 0;
    pub const FEATURE_NORMAL_MAPPING: i64 = 2;
    pub const TEXTURE_NORMAL: i64 = 4;
    pub const TEXTURE_TRANSMISSION: i64 = 11;
    pub const FEATURE_RIM: i64 = 3;
    pub const FLAG_DISABLE_DEPTH_TEST: i64 = 2;
    pub const FEATURE_CLEARCOAT: i64 = 4;
    pub const FLAG_USE_VERTEX_LIGHTING: i64 = 1;
    pub const BILLBOARD_DISABLED: i64 = 0;
    pub const EMISSION_OP_ADD: i64 = 0;
    pub const SPECULAR_TOON: i64 = 3;
    pub const FLAG_EMISSION_ON_UV2: i64 = 12;
    pub const SPECULAR_SCHLICK_GGX: i64 = 0;
    pub const TEXTURE_DETAIL_MASK: i64 = 13;
    pub const DISTANCE_FADE_PIXEL_DITHER: i64 = 2;
    pub const FLAG_USE_SHADOW_TO_OPACITY: i64 = 18;
    pub const BLEND_MODE_MIX: i64 = 0;
    pub const FLAG_SRGB_VERTEX_COLOR: i64 = 4;
    pub const FLAG_AO_ON_UV2: i64 = 11;
    pub const TEXTURE_FLOWMAP: i64 = 7;
    pub const CULL_BACK: i64 = 0;
    pub const TEXTURE_SUBSURFACE_SCATTERING: i64 = 10;
    pub const DEPTH_DRAW_ALPHA_OPAQUE_PREPASS: i64 = 3;
    pub const DEPTH_DRAW_OPAQUE_ONLY: i64 = 0;
    pub const DEPTH_DRAW_DISABLED: i64 = 2;
    pub const FLAG_UV1_USE_TRIPLANAR: i64 = 8;
    pub const SPECULAR_DISABLED: i64 = 4;
    pub const TEXTURE_CHANNEL_GREEN: i64 = 1;
    pub const BLEND_MODE_SUB: i64 = 2;
    pub const FEATURE_SUBSURACE_SCATTERING: i64 = 8;
    pub const DISTANCE_FADE_DISABLED: i64 = 0;
    pub const DISTANCE_FADE_PIXEL_ALPHA: i64 = 1;
    pub const SPECULAR_BLINN: i64 = 1;
    pub const TEXTURE_CLEARCOAT: i64 = 6;
    pub const FLAG_DISABLE_AMBIENT_LIGHT: i64 = 17;
    pub const TEXTURE_DEPTH: i64 = 9;
    pub const TEXTURE_DETAIL_NORMAL: i64 = 15;
    pub const FLAG_UNSHADED: i64 = 0;
    pub const FLAG_USE_ALPHA_SCISSOR: i64 = 13;
    pub const BLEND_MODE_ADD: i64 = 1;
    pub const DIFFUSE_BURLEY: i64 = 0;
    pub const FEATURE_DEPTH_MAPPING: i64 = 7;
    pub const FLAG_DONT_RECEIVE_SHADOWS: i64 = 15;
    pub const TEXTURE_ALBEDO: i64 = 0;
    pub const TEXTURE_EMISSION: i64 = 3;
    pub const DIFFUSE_LAMBERT_WRAP: i64 = 2;
    pub const FLAG_ALBEDO_TEXTURE_FORCE_SRGB: i64 = 14;
    pub const TEXTURE_DETAIL_ALBEDO: i64 = 14;
    pub const BILLBOARD_FIXED_Y: i64 = 2;
    pub const DIFFUSE_LAMBERT: i64 = 1;
    pub const FLAG_BILLBOARD_KEEP_SCALE: i64 = 7;
    pub const FEATURE_EMISSION: i64 = 1;
    pub const FLAG_ENSURE_CORRECT_NORMALS: i64 = 16;
    pub const TEXTURE_AMBIENT_OCCLUSION: i64 = 8;
    pub const FEATURE_MAX: i64 = 12;
    pub const FEATURE_REFRACTION: i64 = 10;
    pub const DETAIL_UV_1: i64 = 0;
    pub const CULL_DISABLED: i64 = 2;
    pub const FLAG_UV2_USE_TRIPLANAR: i64 = 9;
    pub const SPECULAR_PHONG: i64 = 2;
    pub const FEATURE_ANISOTROPY: i64 = 5;
    pub const CULL_FRONT: i64 = 1;
    pub const TEXTURE_CHANNEL_ALPHA: i64 = 3;
    pub const TEXTURE_CHANNEL_BLUE: i64 = 2;
    pub const FEATURE_AMBIENT_OCCLUSION: i64 = 6;
    pub const BILLBOARD_ENABLED: i64 = 1;
    pub const EMISSION_OP_MULTIPLY: i64 = 1;
    pub const DIFFUSE_OREN_NAYAR: i64 = 3;
    pub const TEXTURE_CHANNEL_GRAYSCALE: i64 = 4;
    pub const TEXTURE_MAX: i64 = 16;
    pub const DETAIL_UV_2: i64 = 1;
    pub const TEXTURE_ROUGHNESS: i64 = 2;
    pub const DEPTH_DRAW_ALWAYS: i64 = 1;
}
impl SpatialMaterial {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpatialMaterialMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SpatialMaterial {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_albedo(&self) -> Color {
        unsafe { SpatialMaterial_get_albedo(self.this) }
    }

    #[inline]
    pub fn get_alpha_scissor_threshold(&self) -> f64 {
        unsafe { SpatialMaterial_get_alpha_scissor_threshold(self.this) }
    }

    #[inline]
    pub fn get_anisotropy(&self) -> f64 {
        unsafe { SpatialMaterial_get_anisotropy(self.this) }
    }

    #[inline]
    pub fn get_ao_light_affect(&self) -> f64 {
        unsafe { SpatialMaterial_get_ao_light_affect(self.this) }
    }

    #[inline]
    pub fn get_ao_texture_channel(&self) -> SpatialMaterialTextureChannel {
        unsafe { SpatialMaterial_get_ao_texture_channel(self.this) }
    }

    #[inline]
    pub fn get_billboard_mode(&self) -> SpatialMaterialBillboardMode {
        unsafe { SpatialMaterial_get_billboard_mode(self.this) }
    }

    #[inline]
    pub fn get_blend_mode(&self) -> SpatialMaterialBlendMode {
        unsafe { SpatialMaterial_get_blend_mode(self.this) }
    }

    #[inline]
    pub fn get_clearcoat(&self) -> f64 {
        unsafe { SpatialMaterial_get_clearcoat(self.this) }
    }

    #[inline]
    pub fn get_clearcoat_gloss(&self) -> f64 {
        unsafe { SpatialMaterial_get_clearcoat_gloss(self.this) }
    }

    #[inline]
    pub fn get_cull_mode(&self) -> SpatialMaterialCullMode {
        unsafe { SpatialMaterial_get_cull_mode(self.this) }
    }

    #[inline]
    pub fn get_depth_deep_parallax_flip_binormal(&self) -> bool {
        unsafe { SpatialMaterial_get_depth_deep_parallax_flip_binormal(self.this) }
    }

    #[inline]
    pub fn get_depth_deep_parallax_flip_tangent(&self) -> bool {
        unsafe { SpatialMaterial_get_depth_deep_parallax_flip_tangent(self.this) }
    }

    #[inline]
    pub fn get_depth_deep_parallax_max_layers(&self) -> i64 {
        unsafe { SpatialMaterial_get_depth_deep_parallax_max_layers(self.this) }
    }

    #[inline]
    pub fn get_depth_deep_parallax_min_layers(&self) -> i64 {
        unsafe { SpatialMaterial_get_depth_deep_parallax_min_layers(self.this) }
    }

    #[inline]
    pub fn get_depth_draw_mode(&self) -> SpatialMaterialDepthDrawMode {
        unsafe { SpatialMaterial_get_depth_draw_mode(self.this) }
    }

    #[inline]
    pub fn get_depth_scale(&self) -> f64 {
        unsafe { SpatialMaterial_get_depth_scale(self.this) }
    }

    #[inline]
    pub fn get_detail_blend_mode(&self) -> SpatialMaterialBlendMode {
        unsafe { SpatialMaterial_get_detail_blend_mode(self.this) }
    }

    #[inline]
    pub fn get_detail_uv(&self) -> SpatialMaterialDetailUV {
        unsafe { SpatialMaterial_get_detail_uv(self.this) }
    }

    #[inline]
    pub fn get_diffuse_mode(&self) -> SpatialMaterialDiffuseMode {
        unsafe { SpatialMaterial_get_diffuse_mode(self.this) }
    }

    #[inline]
    pub fn get_distance_fade(&self) -> SpatialMaterialDistanceFadeMode {
        unsafe { SpatialMaterial_get_distance_fade(self.this) }
    }

    #[inline]
    pub fn get_distance_fade_max_distance(&self) -> f64 {
        unsafe { SpatialMaterial_get_distance_fade_max_distance(self.this) }
    }

    #[inline]
    pub fn get_distance_fade_min_distance(&self) -> f64 {
        unsafe { SpatialMaterial_get_distance_fade_min_distance(self.this) }
    }

    #[inline]
    pub fn get_emission(&self) -> Color {
        unsafe { SpatialMaterial_get_emission(self.this) }
    }

    #[inline]
    pub fn get_emission_energy(&self) -> f64 {
        unsafe { SpatialMaterial_get_emission_energy(self.this) }
    }

    #[inline]
    pub fn get_emission_operator(&self) -> SpatialMaterialEmissionOperator {
        unsafe { SpatialMaterial_get_emission_operator(self.this) }
    }

    #[inline]
    pub fn get_feature(&self, feature: i64) -> bool {
        unsafe { SpatialMaterial_get_feature(self.this, feature) }
    }

    #[inline]
    pub fn get_flag(&self, flag: i64) -> bool {
        unsafe { SpatialMaterial_get_flag(self.this, flag) }
    }

    #[inline]
    pub fn get_grow(&self) -> f64 {
        unsafe { SpatialMaterial_get_grow(self.this) }
    }

    #[inline]
    pub fn get_line_width(&self) -> f64 {
        unsafe { SpatialMaterial_get_line_width(self.this) }
    }

    #[inline]
    pub fn get_metallic(&self) -> f64 {
        unsafe { SpatialMaterial_get_metallic(self.this) }
    }

    #[inline]
    pub fn get_metallic_texture_channel(&self) -> SpatialMaterialTextureChannel {
        unsafe { SpatialMaterial_get_metallic_texture_channel(self.this) }
    }

    #[inline]
    pub fn get_normal_scale(&self) -> f64 {
        unsafe { SpatialMaterial_get_normal_scale(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_h_frames(&self) -> i64 {
        unsafe { SpatialMaterial_get_particles_anim_h_frames(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_loop(&self) -> bool {
        unsafe { SpatialMaterial_get_particles_anim_loop(self.this) }
    }

    #[inline]
    pub fn get_particles_anim_v_frames(&self) -> i64 {
        unsafe { SpatialMaterial_get_particles_anim_v_frames(self.this) }
    }

    #[inline]
    pub fn get_point_size(&self) -> f64 {
        unsafe { SpatialMaterial_get_point_size(self.this) }
    }

    #[inline]
    pub fn get_proximity_fade_distance(&self) -> f64 {
        unsafe { SpatialMaterial_get_proximity_fade_distance(self.this) }
    }

    #[inline]
    pub fn get_refraction(&self) -> f64 {
        unsafe { SpatialMaterial_get_refraction(self.this) }
    }

    #[inline]
    pub fn get_refraction_texture_channel(&self) -> SpatialMaterialTextureChannel {
        unsafe { SpatialMaterial_get_refraction_texture_channel(self.this) }
    }

    #[inline]
    pub fn get_rim(&self) -> f64 {
        unsafe { SpatialMaterial_get_rim(self.this) }
    }

    #[inline]
    pub fn get_rim_tint(&self) -> f64 {
        unsafe { SpatialMaterial_get_rim_tint(self.this) }
    }

    #[inline]
    pub fn get_roughness(&self) -> f64 {
        unsafe { SpatialMaterial_get_roughness(self.this) }
    }

    #[inline]
    pub fn get_roughness_texture_channel(&self) -> SpatialMaterialTextureChannel {
        unsafe { SpatialMaterial_get_roughness_texture_channel(self.this) }
    }

    #[inline]
    pub fn get_specular(&self) -> f64 {
        unsafe { SpatialMaterial_get_specular(self.this) }
    }

    #[inline]
    pub fn get_specular_mode(&self) -> SpatialMaterialSpecularMode {
        unsafe { SpatialMaterial_get_specular_mode(self.this) }
    }

    #[inline]
    pub fn get_subsurface_scattering_strength(&self) -> f64 {
        unsafe { SpatialMaterial_get_subsurface_scattering_strength(self.this) }
    }

    #[inline]
    pub fn get_texture(&self, param: i64) -> Option<Texture> {
        unsafe { SpatialMaterial_get_texture(self.this, param) }
    }

    #[inline]
    pub fn get_transmission(&self) -> Color {
        unsafe { SpatialMaterial_get_transmission(self.this) }
    }

    #[inline]
    pub fn get_uv1_offset(&self) -> Vector3 {
        unsafe { SpatialMaterial_get_uv1_offset(self.this) }
    }

    #[inline]
    pub fn get_uv1_scale(&self) -> Vector3 {
        unsafe { SpatialMaterial_get_uv1_scale(self.this) }
    }

    #[inline]
    pub fn get_uv1_triplanar_blend_sharpness(&self) -> f64 {
        unsafe { SpatialMaterial_get_uv1_triplanar_blend_sharpness(self.this) }
    }

    #[inline]
    pub fn get_uv2_offset(&self) -> Vector3 {
        unsafe { SpatialMaterial_get_uv2_offset(self.this) }
    }

    #[inline]
    pub fn get_uv2_scale(&self) -> Vector3 {
        unsafe { SpatialMaterial_get_uv2_scale(self.this) }
    }

    #[inline]
    pub fn get_uv2_triplanar_blend_sharpness(&self) -> f64 {
        unsafe { SpatialMaterial_get_uv2_triplanar_blend_sharpness(self.this) }
    }

    #[inline]
    pub fn is_depth_deep_parallax_enabled(&self) -> bool {
        unsafe { SpatialMaterial_is_depth_deep_parallax_enabled(self.this) }
    }

    #[inline]
    pub fn is_grow_enabled(&self) -> bool {
        unsafe { SpatialMaterial_is_grow_enabled(self.this) }
    }

    #[inline]
    pub fn is_proximity_fade_enabled(&self) -> bool {
        unsafe { SpatialMaterial_is_proximity_fade_enabled(self.this) }
    }

    #[inline]
    pub fn set_albedo(&mut self, albedo: Color) -> () {
        unsafe { SpatialMaterial_set_albedo(self.this, albedo) }
    }

    #[inline]
    pub fn set_alpha_scissor_threshold(&mut self, threshold: f64) -> () {
        unsafe { SpatialMaterial_set_alpha_scissor_threshold(self.this, threshold) }
    }

    #[inline]
    pub fn set_anisotropy(&mut self, anisotropy: f64) -> () {
        unsafe { SpatialMaterial_set_anisotropy(self.this, anisotropy) }
    }

    #[inline]
    pub fn set_ao_light_affect(&mut self, amount: f64) -> () {
        unsafe { SpatialMaterial_set_ao_light_affect(self.this, amount) }
    }

    #[inline]
    pub fn set_ao_texture_channel(&mut self, channel: i64) -> () {
        unsafe { SpatialMaterial_set_ao_texture_channel(self.this, channel) }
    }

    #[inline]
    pub fn set_billboard_mode(&mut self, mode: i64) -> () {
        unsafe { SpatialMaterial_set_billboard_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_blend_mode(&mut self, blend_mode: i64) -> () {
        unsafe { SpatialMaterial_set_blend_mode(self.this, blend_mode) }
    }

    #[inline]
    pub fn set_clearcoat(&mut self, clearcoat: f64) -> () {
        unsafe { SpatialMaterial_set_clearcoat(self.this, clearcoat) }
    }

    #[inline]
    pub fn set_clearcoat_gloss(&mut self, clearcoat_gloss: f64) -> () {
        unsafe { SpatialMaterial_set_clearcoat_gloss(self.this, clearcoat_gloss) }
    }

    #[inline]
    pub fn set_cull_mode(&mut self, cull_mode: i64) -> () {
        unsafe { SpatialMaterial_set_cull_mode(self.this, cull_mode) }
    }

    #[inline]
    pub fn set_depth_deep_parallax(&mut self, enable: bool) -> () {
        unsafe { SpatialMaterial_set_depth_deep_parallax(self.this, enable) }
    }

    #[inline]
    pub fn set_depth_deep_parallax_flip_binormal(&mut self, flip: bool) -> () {
        unsafe { SpatialMaterial_set_depth_deep_parallax_flip_binormal(self.this, flip) }
    }

    #[inline]
    pub fn set_depth_deep_parallax_flip_tangent(&mut self, flip: bool) -> () {
        unsafe { SpatialMaterial_set_depth_deep_parallax_flip_tangent(self.this, flip) }
    }

    #[inline]
    pub fn set_depth_deep_parallax_max_layers(&mut self, layer: i64) -> () {
        unsafe { SpatialMaterial_set_depth_deep_parallax_max_layers(self.this, layer) }
    }

    #[inline]
    pub fn set_depth_deep_parallax_min_layers(&mut self, layer: i64) -> () {
        unsafe { SpatialMaterial_set_depth_deep_parallax_min_layers(self.this, layer) }
    }

    #[inline]
    pub fn set_depth_draw_mode(&mut self, depth_draw_mode: i64) -> () {
        unsafe { SpatialMaterial_set_depth_draw_mode(self.this, depth_draw_mode) }
    }

    #[inline]
    pub fn set_depth_scale(&mut self, depth_scale: f64) -> () {
        unsafe { SpatialMaterial_set_depth_scale(self.this, depth_scale) }
    }

    #[inline]
    pub fn set_detail_blend_mode(&mut self, detail_blend_mode: i64) -> () {
        unsafe { SpatialMaterial_set_detail_blend_mode(self.this, detail_blend_mode) }
    }

    #[inline]
    pub fn set_detail_uv(&mut self, detail_uv: i64) -> () {
        unsafe { SpatialMaterial_set_detail_uv(self.this, detail_uv) }
    }

    #[inline]
    pub fn set_diffuse_mode(&mut self, diffuse_mode: i64) -> () {
        unsafe { SpatialMaterial_set_diffuse_mode(self.this, diffuse_mode) }
    }

    #[inline]
    pub fn set_distance_fade(&mut self, mode: i64) -> () {
        unsafe { SpatialMaterial_set_distance_fade(self.this, mode) }
    }

    #[inline]
    pub fn set_distance_fade_max_distance(&mut self, distance: f64) -> () {
        unsafe { SpatialMaterial_set_distance_fade_max_distance(self.this, distance) }
    }

    #[inline]
    pub fn set_distance_fade_min_distance(&mut self, distance: f64) -> () {
        unsafe { SpatialMaterial_set_distance_fade_min_distance(self.this, distance) }
    }

    #[inline]
    pub fn set_emission(&mut self, emission: Color) -> () {
        unsafe { SpatialMaterial_set_emission(self.this, emission) }
    }

    #[inline]
    pub fn set_emission_energy(&mut self, emission_energy: f64) -> () {
        unsafe { SpatialMaterial_set_emission_energy(self.this, emission_energy) }
    }

    #[inline]
    pub fn set_emission_operator(&mut self, operator: i64) -> () {
        unsafe { SpatialMaterial_set_emission_operator(self.this, operator) }
    }

    #[inline]
    pub fn set_feature(&mut self, feature: i64, enable: bool) -> () {
        unsafe { SpatialMaterial_set_feature(self.this, feature, enable) }
    }

    #[inline]
    pub fn set_flag(&mut self, flag: i64, enable: bool) -> () {
        unsafe { SpatialMaterial_set_flag(self.this, flag, enable) }
    }

    #[inline]
    pub fn set_grow(&mut self, amount: f64) -> () {
        unsafe { SpatialMaterial_set_grow(self.this, amount) }
    }

    #[inline]
    pub fn set_grow_enabled(&mut self, enable: bool) -> () {
        unsafe { SpatialMaterial_set_grow_enabled(self.this, enable) }
    }

    #[inline]
    pub fn set_line_width(&mut self, line_width: f64) -> () {
        unsafe { SpatialMaterial_set_line_width(self.this, line_width) }
    }

    #[inline]
    pub fn set_metallic(&mut self, metallic: f64) -> () {
        unsafe { SpatialMaterial_set_metallic(self.this, metallic) }
    }

    #[inline]
    pub fn set_metallic_texture_channel(&mut self, channel: i64) -> () {
        unsafe { SpatialMaterial_set_metallic_texture_channel(self.this, channel) }
    }

    #[inline]
    pub fn set_normal_scale(&mut self, normal_scale: f64) -> () {
        unsafe { SpatialMaterial_set_normal_scale(self.this, normal_scale) }
    }

    #[inline]
    pub fn set_particles_anim_h_frames(&mut self, frames: i64) -> () {
        unsafe { SpatialMaterial_set_particles_anim_h_frames(self.this, frames) }
    }

    #[inline]
    pub fn set_particles_anim_loop(&mut self, _loop: bool) -> () {
        unsafe { SpatialMaterial_set_particles_anim_loop(self.this, _loop) }
    }

    #[inline]
    pub fn set_particles_anim_v_frames(&mut self, frames: i64) -> () {
        unsafe { SpatialMaterial_set_particles_anim_v_frames(self.this, frames) }
    }

    #[inline]
    pub fn set_point_size(&mut self, point_size: f64) -> () {
        unsafe { SpatialMaterial_set_point_size(self.this, point_size) }
    }

    #[inline]
    pub fn set_proximity_fade(&mut self, enabled: bool) -> () {
        unsafe { SpatialMaterial_set_proximity_fade(self.this, enabled) }
    }

    #[inline]
    pub fn set_proximity_fade_distance(&mut self, distance: f64) -> () {
        unsafe { SpatialMaterial_set_proximity_fade_distance(self.this, distance) }
    }

    #[inline]
    pub fn set_refraction(&mut self, refraction: f64) -> () {
        unsafe { SpatialMaterial_set_refraction(self.this, refraction) }
    }

    #[inline]
    pub fn set_refraction_texture_channel(&mut self, channel: i64) -> () {
        unsafe { SpatialMaterial_set_refraction_texture_channel(self.this, channel) }
    }

    #[inline]
    pub fn set_rim(&mut self, rim: f64) -> () {
        unsafe { SpatialMaterial_set_rim(self.this, rim) }
    }

    #[inline]
    pub fn set_rim_tint(&mut self, rim_tint: f64) -> () {
        unsafe { SpatialMaterial_set_rim_tint(self.this, rim_tint) }
    }

    #[inline]
    pub fn set_roughness(&mut self, roughness: f64) -> () {
        unsafe { SpatialMaterial_set_roughness(self.this, roughness) }
    }

    #[inline]
    pub fn set_roughness_texture_channel(&mut self, channel: i64) -> () {
        unsafe { SpatialMaterial_set_roughness_texture_channel(self.this, channel) }
    }

    #[inline]
    pub fn set_specular(&mut self, specular: f64) -> () {
        unsafe { SpatialMaterial_set_specular(self.this, specular) }
    }

    #[inline]
    pub fn set_specular_mode(&mut self, specular_mode: i64) -> () {
        unsafe { SpatialMaterial_set_specular_mode(self.this, specular_mode) }
    }

    #[inline]
    pub fn set_subsurface_scattering_strength(&mut self, strength: f64) -> () {
        unsafe { SpatialMaterial_set_subsurface_scattering_strength(self.this, strength) }
    }

    #[inline]
    pub fn set_texture(&mut self, param: i64, texture: Option<Texture>) -> () {
        unsafe { SpatialMaterial_set_texture(self.this, param, texture) }
    }

    #[inline]
    pub fn set_transmission(&mut self, transmission: Color) -> () {
        unsafe { SpatialMaterial_set_transmission(self.this, transmission) }
    }

    #[inline]
    pub fn set_uv1_offset(&mut self, offset: Vector3) -> () {
        unsafe { SpatialMaterial_set_uv1_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_uv1_scale(&mut self, scale: Vector3) -> () {
        unsafe { SpatialMaterial_set_uv1_scale(self.this, scale) }
    }

    #[inline]
    pub fn set_uv1_triplanar_blend_sharpness(&mut self, sharpness: f64) -> () {
        unsafe { SpatialMaterial_set_uv1_triplanar_blend_sharpness(self.this, sharpness) }
    }

    #[inline]
    pub fn set_uv2_offset(&mut self, offset: Vector3) -> () {
        unsafe { SpatialMaterial_set_uv2_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_uv2_scale(&mut self, scale: Vector3) -> () {
        unsafe { SpatialMaterial_set_uv2_scale(self.this, scale) }
    }

    #[inline]
    pub fn set_uv2_triplanar_blend_sharpness(&mut self, sharpness: f64) -> () {
        unsafe { SpatialMaterial_set_uv2_triplanar_blend_sharpness(self.this, sharpness) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_material(&self) -> Material {
        unsafe {{ object::add_ref(self.this); }}
        Material { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpatialVelocityTracker` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spatialvelocitytracker.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SpatialVelocityTracker inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpatialVelocityTracker {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpatialVelocityTracker {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpatialVelocityTrackerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SpatialVelocityTracker {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_tracked_linear_velocity(&self) -> Vector3 {
        unsafe { SpatialVelocityTracker_get_tracked_linear_velocity(self.this) }
    }

    #[inline]
    pub fn is_tracking_physics_step(&self) -> bool {
        unsafe { SpatialVelocityTracker_is_tracking_physics_step(self.this) }
    }

    #[inline]
    pub fn reset(&mut self, position: Vector3) -> () {
        unsafe { SpatialVelocityTracker_reset(self.this, position) }
    }

    #[inline]
    pub fn set_track_physics_step(&mut self, enable: bool) -> () {
        unsafe { SpatialVelocityTracker_set_track_physics_step(self.this, enable) }
    }

    #[inline]
    pub fn update_position(&mut self, position: Vector3) -> () {
        unsafe { SpatialVelocityTracker_update_position(self.this, position) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SphereMesh` inherits `PrimitiveMesh` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spheremesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SphereMesh inherits methods from:
/// - [PrimitiveMesh](struct.PrimitiveMesh.html)
/// - [Mesh](struct.Mesh.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SphereMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SphereMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SphereMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SphereMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_height(&self) -> f64 {
        unsafe { SphereMesh_get_height(self.this) }
    }

    #[inline]
    pub fn get_is_hemisphere(&self) -> bool {
        unsafe { SphereMesh_get_is_hemisphere(self.this) }
    }

    #[inline]
    pub fn get_radial_segments(&self) -> i64 {
        unsafe { SphereMesh_get_radial_segments(self.this) }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { SphereMesh_get_radius(self.this) }
    }

    #[inline]
    pub fn get_rings(&self) -> i64 {
        unsafe { SphereMesh_get_rings(self.this) }
    }

    #[inline]
    pub fn set_height(&mut self, height: f64) -> () {
        unsafe { SphereMesh_set_height(self.this, height) }
    }

    #[inline]
    pub fn set_is_hemisphere(&mut self, is_hemisphere: bool) -> () {
        unsafe { SphereMesh_set_is_hemisphere(self.this, is_hemisphere) }
    }

    #[inline]
    pub fn set_radial_segments(&mut self, radial_segments: i64) -> () {
        unsafe { SphereMesh_set_radial_segments(self.this, radial_segments) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { SphereMesh_set_radius(self.this, radius) }
    }

    #[inline]
    pub fn set_rings(&mut self, rings: i64) -> () {
        unsafe { SphereMesh_set_rings(self.this, rings) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_primitive_mesh(&self) -> PrimitiveMesh {
        unsafe {{ object::add_ref(self.this); }}
        PrimitiveMesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_mesh(&self) -> Mesh {
        unsafe {{ object::add_ref(self.this); }}
        Mesh { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SphereShape` inherits `Shape` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_sphereshape.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SphereShape inherits methods from:
/// - [Shape](struct.Shape.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SphereShape {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SphereShape {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SphereShapeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SphereShape {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_radius(&self) -> f64 {
        unsafe { SphereShape_get_radius(self.this) }
    }

    #[inline]
    pub fn set_radius(&mut self, radius: f64) -> () {
        unsafe { SphereShape_set_radius(self.this, radius) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shape(&self) -> Shape {
        unsafe {{ object::add_ref(self.this); }}
        Shape { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpinBox` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spinbox.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SpinBox` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SpinBox::free`.
///
/// ## Class hierarchy
///
/// SpinBox inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpinBox {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpinBox {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SpinBox::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpinBoxMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SpinBox {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        SpinBox__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _line_edit_focus_exit(&mut self) -> () {
        SpinBox__line_edit_focus_exit(self.this)
    }

    #[inline]
    pub unsafe fn _line_edit_input(&mut self, arg0: Option<InputEvent>) -> () {
        SpinBox__line_edit_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _range_click_timeout(&mut self) -> () {
        SpinBox__range_click_timeout(self.this)
    }

    #[inline]
    pub unsafe fn _text_entered(&mut self, arg0: GodotString) -> () {
        SpinBox__text_entered(self.this, arg0)
    }

    #[inline]
    pub unsafe fn apply(&mut self) -> () {
        SpinBox_apply(self.this)
    }

    #[inline]
    pub unsafe fn get_align(&self) -> LineEditAlign {
        SpinBox_get_align(self.this)
    }

    #[inline]
    pub unsafe fn get_line_edit(&mut self) -> Option<LineEdit> {
        SpinBox_get_line_edit(self.this)
    }

    #[inline]
    pub unsafe fn get_prefix(&self) -> GodotString {
        SpinBox_get_prefix(self.this)
    }

    #[inline]
    pub unsafe fn get_suffix(&self) -> GodotString {
        SpinBox_get_suffix(self.this)
    }

    #[inline]
    pub unsafe fn is_editable(&self) -> bool {
        SpinBox_is_editable(self.this)
    }

    #[inline]
    pub unsafe fn set_align(&mut self, align: i64) -> () {
        SpinBox_set_align(self.this, align)
    }

    #[inline]
    pub unsafe fn set_editable(&mut self, editable: bool) -> () {
        SpinBox_set_editable(self.this, editable)
    }

    #[inline]
    pub unsafe fn set_prefix(&mut self, prefix: GodotString) -> () {
        SpinBox_set_prefix(self.this, prefix)
    }

    #[inline]
    pub unsafe fn set_suffix(&mut self, suffix: GodotString) -> () {
        SpinBox_set_suffix(self.this, suffix)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SplitContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_splitcontainer.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// SplitContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SplitContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SplitContainerDraggerVisibility {
    DraggerVisible = 0,
    DraggerHidden = 1,
    DraggerHiddenCollapsed = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SplitContainer {
    pub const DRAGGER_HIDDEN: i64 = 1;
    pub const DRAGGER_VISIBLE: i64 = 0;
    pub const DRAGGER_HIDDEN_COLLAPSED: i64 = 2;
}
impl SplitContainer {
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        SplitContainer__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn clamp_split_offset(&mut self) -> () {
        SplitContainer_clamp_split_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_dragger_visibility(&self) -> SplitContainerDraggerVisibility {
        SplitContainer_get_dragger_visibility(self.this)
    }

    #[inline]
    pub unsafe fn get_split_offset(&self) -> i64 {
        SplitContainer_get_split_offset(self.this)
    }

    #[inline]
    pub unsafe fn is_collapsed(&self) -> bool {
        SplitContainer_is_collapsed(self.this)
    }

    #[inline]
    pub unsafe fn set_collapsed(&mut self, collapsed: bool) -> () {
        SplitContainer_set_collapsed(self.this, collapsed)
    }

    #[inline]
    pub unsafe fn set_dragger_visibility(&mut self, mode: i64) -> () {
        SplitContainer_set_dragger_visibility(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_split_offset(&mut self, offset: i64) -> () {
        SplitContainer_set_split_offset(self.this, offset)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpotLight` inherits `Light` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spotlight.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SpotLight` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SpotLight::free`.
///
/// ## Class hierarchy
///
/// SpotLight inherits methods from:
/// - [Light](struct.Light.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpotLight {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpotLight {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SpotLight::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpotLightMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SpotLight {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_light(&self) -> Light {
        // Not reference-counted.
        Light { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpringArm` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_springarm.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `SpringArm` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `SpringArm::free`.
///
/// ## Class hierarchy
///
/// SpringArm inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpringArm {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpringArm {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `SpringArm::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpringArmMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            SpringArm {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_excluded_object(&mut self, RID: Rid) -> () {
        SpringArm_add_excluded_object(self.this, RID)
    }

    #[inline]
    pub unsafe fn clear_excluded_objects(&mut self) -> () {
        SpringArm_clear_excluded_objects(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&mut self) -> i64 {
        SpringArm_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_hit_length(&mut self) -> f64 {
        SpringArm_get_hit_length(self.this)
    }

    #[inline]
    pub unsafe fn get_length(&self) -> f64 {
        SpringArm_get_length(self.this)
    }

    #[inline]
    pub unsafe fn get_margin(&mut self) -> f64 {
        SpringArm_get_margin(self.this)
    }

    #[inline]
    pub unsafe fn get_shape(&self) -> Option<Shape> {
        SpringArm_get_shape(self.this)
    }

    #[inline]
    pub unsafe fn remove_excluded_object(&mut self, RID: Rid) -> bool {
        SpringArm_remove_excluded_object(self.this, RID)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        SpringArm_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_length(&mut self, length: f64) -> () {
        SpringArm_set_length(self.this, length)
    }

    #[inline]
    pub unsafe fn set_margin(&mut self, margin: f64) -> () {
        SpringArm_set_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn set_shape(&mut self, shape: Option<Shape>) -> () {
        SpringArm_set_shape(self.this, shape)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Sprite` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_sprite.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Sprite` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Sprite::free`.
///
/// ## Class hierarchy
///
/// Sprite inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Sprite {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Sprite {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Sprite::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpriteMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Sprite {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _texture_changed(&mut self) -> () {
        Sprite__texture_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_frame(&self) -> i64 {
        Sprite_get_frame(self.this)
    }

    #[inline]
    pub unsafe fn get_frame_coords(&self) -> Vector2 {
        Sprite_get_frame_coords(self.this)
    }

    #[inline]
    pub unsafe fn get_hframes(&self) -> i64 {
        Sprite_get_hframes(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_map(&self) -> Option<Texture> {
        Sprite_get_normal_map(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        Sprite_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_rect(&self) -> Rect2 {
        Sprite_get_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_region_rect(&self) -> Rect2 {
        Sprite_get_region_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Sprite_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_vframes(&self) -> i64 {
        Sprite_get_vframes(self.this)
    }

    #[inline]
    pub unsafe fn is_centered(&self) -> bool {
        Sprite_is_centered(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_h(&self) -> bool {
        Sprite_is_flipped_h(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_v(&self) -> bool {
        Sprite_is_flipped_v(self.this)
    }

    #[inline]
    pub unsafe fn is_pixel_opaque(&self, pos: Vector2) -> bool {
        Sprite_is_pixel_opaque(self.this, pos)
    }

    #[inline]
    pub unsafe fn is_region(&self) -> bool {
        Sprite_is_region(self.this)
    }

    #[inline]
    pub unsafe fn is_region_filter_clip_enabled(&self) -> bool {
        Sprite_is_region_filter_clip_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_centered(&mut self, centered: bool) -> () {
        Sprite_set_centered(self.this, centered)
    }

    #[inline]
    pub unsafe fn set_flip_h(&mut self, flip_h: bool) -> () {
        Sprite_set_flip_h(self.this, flip_h)
    }

    #[inline]
    pub unsafe fn set_flip_v(&mut self, flip_v: bool) -> () {
        Sprite_set_flip_v(self.this, flip_v)
    }

    #[inline]
    pub unsafe fn set_frame(&mut self, frame: i64) -> () {
        Sprite_set_frame(self.this, frame)
    }

    #[inline]
    pub unsafe fn set_frame_coords(&mut self, coords: Vector2) -> () {
        Sprite_set_frame_coords(self.this, coords)
    }

    #[inline]
    pub unsafe fn set_hframes(&mut self, hframes: i64) -> () {
        Sprite_set_hframes(self.this, hframes)
    }

    #[inline]
    pub unsafe fn set_normal_map(&mut self, normal_map: Option<Texture>) -> () {
        Sprite_set_normal_map(self.this, normal_map)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        Sprite_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_region(&mut self, enabled: bool) -> () {
        Sprite_set_region(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_region_filter_clip(&mut self, enabled: bool) -> () {
        Sprite_set_region_filter_clip(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_region_rect(&mut self, rect: Rect2) -> () {
        Sprite_set_region_rect(self.this, rect)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Sprite_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_vframes(&mut self, vframes: i64) -> () {
        Sprite_set_vframes(self.this, vframes)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Sprite3D` inherits `SpriteBase3D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_sprite3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Sprite3D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Sprite3D::free`.
///
/// ## Class hierarchy
///
/// Sprite3D inherits methods from:
/// - [SpriteBase3D](struct.SpriteBase3D.html)
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Sprite3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Sprite3D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Sprite3D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Sprite3DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Sprite3D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_frame(&self) -> i64 {
        Sprite3D_get_frame(self.this)
    }

    #[inline]
    pub unsafe fn get_frame_coords(&self) -> Vector2 {
        Sprite3D_get_frame_coords(self.this)
    }

    #[inline]
    pub unsafe fn get_hframes(&self) -> i64 {
        Sprite3D_get_hframes(self.this)
    }

    #[inline]
    pub unsafe fn get_region_rect(&self) -> Rect2 {
        Sprite3D_get_region_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        Sprite3D_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_vframes(&self) -> i64 {
        Sprite3D_get_vframes(self.this)
    }

    #[inline]
    pub unsafe fn is_region(&self) -> bool {
        Sprite3D_is_region(self.this)
    }

    #[inline]
    pub unsafe fn set_frame(&mut self, frame: i64) -> () {
        Sprite3D_set_frame(self.this, frame)
    }

    #[inline]
    pub unsafe fn set_frame_coords(&mut self, coords: Vector2) -> () {
        Sprite3D_set_frame_coords(self.this, coords)
    }

    #[inline]
    pub unsafe fn set_hframes(&mut self, hframes: i64) -> () {
        Sprite3D_set_hframes(self.this, hframes)
    }

    #[inline]
    pub unsafe fn set_region(&mut self, enabled: bool) -> () {
        Sprite3D_set_region(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_region_rect(&mut self, rect: Rect2) -> () {
        Sprite3D_set_region_rect(self.this, rect)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        Sprite3D_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_vframes(&mut self, vframes: i64) -> () {
        Sprite3D_set_vframes(self.this, vframes)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_sprite_base_3d(&self) -> SpriteBase3D {
        // Not reference-counted.
        SpriteBase3D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpriteBase3D` inherits `GeometryInstance` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spritebase3d.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// SpriteBase3D inherits methods from:
/// - [GeometryInstance](struct.GeometryInstance.html)
/// - [VisualInstance](struct.VisualInstance.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpriteBase3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpriteBase3DDrawFlags {
    FlagTransparent = 0,
    FlagShaded = 1,
    FlagDoubleSided = 2,
    FlagMax = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum SpriteBase3DAlphaCutMode {
    Disabled = 0,
    Discard = 1,
    OpaquePrepass = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl SpriteBase3D {
    pub const ALPHA_CUT_DISABLED: i64 = 0;
    pub const FLAG_DOUBLE_SIDED: i64 = 2;
    pub const ALPHA_CUT_DISCARD: i64 = 1;
    pub const FLAG_MAX: i64 = 3;
    pub const FLAG_SHADED: i64 = 1;
    pub const FLAG_TRANSPARENT: i64 = 0;
    pub const ALPHA_CUT_OPAQUE_PREPASS: i64 = 2;
}
impl SpriteBase3D {
    #[inline]
    pub unsafe fn _im_update(&mut self) -> () {
        SpriteBase3D__im_update(self.this)
    }

    #[inline]
    pub unsafe fn _queue_update(&mut self) -> () {
        SpriteBase3D__queue_update(self.this)
    }

    #[inline]
    pub unsafe fn generate_triangle_mesh(&self) -> Option<TriangleMesh> {
        SpriteBase3D_generate_triangle_mesh(self.this)
    }

    #[inline]
    pub unsafe fn get_alpha_cut_mode(&self) -> SpriteBase3DAlphaCutMode {
        SpriteBase3D_get_alpha_cut_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_axis(&self) -> Vector3Axis {
        SpriteBase3D_get_axis(self.this)
    }

    #[inline]
    pub unsafe fn get_billboard_mode(&self) -> SpatialMaterialBillboardMode {
        SpriteBase3D_get_billboard_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_draw_flag(&self, flag: i64) -> bool {
        SpriteBase3D_get_draw_flag(self.this, flag)
    }

    #[inline]
    pub unsafe fn get_item_rect(&self) -> Rect2 {
        SpriteBase3D_get_item_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_modulate(&self) -> Color {
        SpriteBase3D_get_modulate(self.this)
    }

    #[inline]
    pub unsafe fn get_offset(&self) -> Vector2 {
        SpriteBase3D_get_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_opacity(&self) -> f64 {
        SpriteBase3D_get_opacity(self.this)
    }

    #[inline]
    pub unsafe fn get_pixel_size(&self) -> f64 {
        SpriteBase3D_get_pixel_size(self.this)
    }

    #[inline]
    pub unsafe fn is_centered(&self) -> bool {
        SpriteBase3D_is_centered(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_h(&self) -> bool {
        SpriteBase3D_is_flipped_h(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_v(&self) -> bool {
        SpriteBase3D_is_flipped_v(self.this)
    }

    #[inline]
    pub unsafe fn set_alpha_cut_mode(&mut self, mode: i64) -> () {
        SpriteBase3D_set_alpha_cut_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_axis(&mut self, axis: i64) -> () {
        SpriteBase3D_set_axis(self.this, axis)
    }

    #[inline]
    pub unsafe fn set_billboard_mode(&mut self, mode: i64) -> () {
        SpriteBase3D_set_billboard_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_centered(&mut self, centered: bool) -> () {
        SpriteBase3D_set_centered(self.this, centered)
    }

    #[inline]
    pub unsafe fn set_draw_flag(&mut self, flag: i64, enabled: bool) -> () {
        SpriteBase3D_set_draw_flag(self.this, flag, enabled)
    }

    #[inline]
    pub unsafe fn set_flip_h(&mut self, flip_h: bool) -> () {
        SpriteBase3D_set_flip_h(self.this, flip_h)
    }

    #[inline]
    pub unsafe fn set_flip_v(&mut self, flip_v: bool) -> () {
        SpriteBase3D_set_flip_v(self.this, flip_v)
    }

    #[inline]
    pub unsafe fn set_modulate(&mut self, modulate: Color) -> () {
        SpriteBase3D_set_modulate(self.this, modulate)
    }

    #[inline]
    pub unsafe fn set_offset(&mut self, offset: Vector2) -> () {
        SpriteBase3D_set_offset(self.this, offset)
    }

    #[inline]
    pub unsafe fn set_opacity(&mut self, opacity: f64) -> () {
        SpriteBase3D_set_opacity(self.this, opacity)
    }

    #[inline]
    pub unsafe fn set_pixel_size(&mut self, pixel_size: f64) -> () {
        SpriteBase3D_set_pixel_size(self.this, pixel_size)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_geometry_instance(&self) -> GeometryInstance {
        // Not reference-counted.
        GeometryInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_visual_instance(&self) -> VisualInstance {
        // Not reference-counted.
        VisualInstance { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SpriteFrames` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_spriteframes.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SpriteFrames inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SpriteFrames {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SpriteFrames {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SpriteFramesMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SpriteFrames {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_animations(&self) -> VariantArray {
        unsafe { SpriteFrames__get_animations(self.this) }
    }

    #[inline]
    pub fn _get_frames(&self) -> VariantArray {
        unsafe { SpriteFrames__get_frames(self.this) }
    }

    #[inline]
    pub fn _set_animations(&mut self, arg0: VariantArray) -> () {
        unsafe { SpriteFrames__set_animations(self.this, arg0) }
    }

    #[inline]
    pub fn _set_frames(&mut self, arg0: VariantArray) -> () {
        unsafe { SpriteFrames__set_frames(self.this, arg0) }
    }

    #[inline]
    pub fn add_animation(&mut self, anim: GodotString) -> () {
        unsafe { SpriteFrames_add_animation(self.this, anim) }
    }

    #[inline]
    pub fn add_frame(&mut self, anim: GodotString, frame: Option<Texture>, at_position: i64) -> () {
        unsafe { SpriteFrames_add_frame(self.this, anim, frame, at_position) }
    }

    #[inline]
    pub fn clear(&mut self, anim: GodotString) -> () {
        unsafe { SpriteFrames_clear(self.this, anim) }
    }

    #[inline]
    pub fn clear_all(&mut self) -> () {
        unsafe { SpriteFrames_clear_all(self.this) }
    }

    #[inline]
    pub fn get_animation_loop(&self, anim: GodotString) -> bool {
        unsafe { SpriteFrames_get_animation_loop(self.this, anim) }
    }

    #[inline]
    pub fn get_animation_names(&self) -> StringArray {
        unsafe { SpriteFrames_get_animation_names(self.this) }
    }

    #[inline]
    pub fn get_animation_speed(&self, anim: GodotString) -> f64 {
        unsafe { SpriteFrames_get_animation_speed(self.this, anim) }
    }

    #[inline]
    pub fn get_frame(&self, anim: GodotString, idx: i64) -> Option<Texture> {
        unsafe { SpriteFrames_get_frame(self.this, anim, idx) }
    }

    #[inline]
    pub fn get_frame_count(&self, anim: GodotString) -> i64 {
        unsafe { SpriteFrames_get_frame_count(self.this, anim) }
    }

    #[inline]
    pub fn has_animation(&self, anim: GodotString) -> bool {
        unsafe { SpriteFrames_has_animation(self.this, anim) }
    }

    #[inline]
    pub fn remove_animation(&mut self, anim: GodotString) -> () {
        unsafe { SpriteFrames_remove_animation(self.this, anim) }
    }

    #[inline]
    pub fn remove_frame(&mut self, anim: GodotString, idx: i64) -> () {
        unsafe { SpriteFrames_remove_frame(self.this, anim, idx) }
    }

    #[inline]
    pub fn rename_animation(&mut self, anim: GodotString, newname: GodotString) -> () {
        unsafe { SpriteFrames_rename_animation(self.this, anim, newname) }
    }

    #[inline]
    pub fn set_animation_loop(&mut self, anim: GodotString, _loop: bool) -> () {
        unsafe { SpriteFrames_set_animation_loop(self.this, anim, _loop) }
    }

    #[inline]
    pub fn set_animation_speed(&mut self, anim: GodotString, speed: f64) -> () {
        unsafe { SpriteFrames_set_animation_speed(self.this, anim, speed) }
    }

    #[inline]
    pub fn set_frame(&mut self, anim: GodotString, idx: i64, txt: Option<Texture>) -> () {
        unsafe { SpriteFrames_set_frame(self.this, anim, idx, txt) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StaticBody` inherits `PhysicsBody` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_staticbody.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `StaticBody` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `StaticBody::free`.
///
/// ## Class hierarchy
///
/// StaticBody inherits methods from:
/// - [PhysicsBody](struct.PhysicsBody.html)
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StaticBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StaticBody {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `StaticBody::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StaticBodyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            StaticBody {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _reload_physics_characteristics(&mut self) -> () {
        StaticBody__reload_physics_characteristics(self.this)
    }

    #[inline]
    pub unsafe fn get_bounce(&self) -> f64 {
        StaticBody_get_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_constant_angular_velocity(&self) -> Vector3 {
        StaticBody_get_constant_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_constant_linear_velocity(&self) -> Vector3 {
        StaticBody_get_constant_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_friction(&self) -> f64 {
        StaticBody_get_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_material_override(&self) -> Option<PhysicsMaterial> {
        StaticBody_get_physics_material_override(self.this)
    }

    #[inline]
    pub unsafe fn set_bounce(&mut self, bounce: f64) -> () {
        StaticBody_set_bounce(self.this, bounce)
    }

    #[inline]
    pub unsafe fn set_constant_angular_velocity(&mut self, vel: Vector3) -> () {
        StaticBody_set_constant_angular_velocity(self.this, vel)
    }

    #[inline]
    pub unsafe fn set_constant_linear_velocity(&mut self, vel: Vector3) -> () {
        StaticBody_set_constant_linear_velocity(self.this, vel)
    }

    #[inline]
    pub unsafe fn set_friction(&mut self, friction: f64) -> () {
        StaticBody_set_friction(self.this, friction)
    }

    #[inline]
    pub unsafe fn set_physics_material_override(&mut self, physics_material_override: Option<PhysicsMaterial>) -> () {
        StaticBody_set_physics_material_override(self.this, physics_material_override)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body(&self) -> PhysicsBody {
        // Not reference-counted.
        PhysicsBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StaticBody2D` inherits `PhysicsBody2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_staticbody2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `StaticBody2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `StaticBody2D::free`.
///
/// ## Class hierarchy
///
/// StaticBody2D inherits methods from:
/// - [PhysicsBody2D](struct.PhysicsBody2D.html)
/// - [CollisionObject2D](struct.CollisionObject2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StaticBody2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StaticBody2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `StaticBody2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StaticBody2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            StaticBody2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _reload_physics_characteristics(&mut self) -> () {
        StaticBody2D__reload_physics_characteristics(self.this)
    }

    #[inline]
    pub unsafe fn get_bounce(&self) -> f64 {
        StaticBody2D_get_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_constant_angular_velocity(&self) -> f64 {
        StaticBody2D_get_constant_angular_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_constant_linear_velocity(&self) -> Vector2 {
        StaticBody2D_get_constant_linear_velocity(self.this)
    }

    #[inline]
    pub unsafe fn get_friction(&self) -> f64 {
        StaticBody2D_get_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_material_override(&self) -> Option<PhysicsMaterial> {
        StaticBody2D_get_physics_material_override(self.this)
    }

    #[inline]
    pub unsafe fn set_bounce(&mut self, bounce: f64) -> () {
        StaticBody2D_set_bounce(self.this, bounce)
    }

    #[inline]
    pub unsafe fn set_constant_angular_velocity(&mut self, vel: f64) -> () {
        StaticBody2D_set_constant_angular_velocity(self.this, vel)
    }

    #[inline]
    pub unsafe fn set_constant_linear_velocity(&mut self, vel: Vector2) -> () {
        StaticBody2D_set_constant_linear_velocity(self.this, vel)
    }

    #[inline]
    pub unsafe fn set_friction(&mut self, friction: f64) -> () {
        StaticBody2D_set_friction(self.this, friction)
    }

    #[inline]
    pub unsafe fn set_physics_material_override(&mut self, physics_material_override: Option<PhysicsMaterial>) -> () {
        StaticBody2D_set_physics_material_override(self.this, physics_material_override)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body_2d(&self) -> PhysicsBody2D {
        // Not reference-counted.
        PhysicsBody2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object_2d(&self) -> CollisionObject2D {
        // Not reference-counted.
        CollisionObject2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamPeer` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streampeer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamPeer inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamPeer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StreamPeer {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_16(&mut self) -> i64 {
        unsafe { StreamPeer_get_16(self.this) }
    }

    #[inline]
    pub fn get_32(&mut self) -> i64 {
        unsafe { StreamPeer_get_32(self.this) }
    }

    #[inline]
    pub fn get_64(&mut self) -> i64 {
        unsafe { StreamPeer_get_64(self.this) }
    }

    #[inline]
    pub fn get_8(&mut self) -> i64 {
        unsafe { StreamPeer_get_8(self.this) }
    }

    #[inline]
    pub fn get_available_bytes(&self) -> i64 {
        unsafe { StreamPeer_get_available_bytes(self.this) }
    }

    #[inline]
    pub fn get_data(&mut self, bytes: i64) -> VariantArray {
        unsafe { StreamPeer_get_data(self.this, bytes) }
    }

    #[inline]
    pub fn get_double(&mut self) -> f64 {
        unsafe { StreamPeer_get_double(self.this) }
    }

    #[inline]
    pub fn get_float(&mut self) -> f64 {
        unsafe { StreamPeer_get_float(self.this) }
    }

    #[inline]
    pub fn get_partial_data(&mut self, bytes: i64) -> VariantArray {
        unsafe { StreamPeer_get_partial_data(self.this, bytes) }
    }

    #[inline]
    pub fn get_string(&mut self, bytes: i64) -> GodotString {
        unsafe { StreamPeer_get_string(self.this, bytes) }
    }

    #[inline]
    pub fn get_u16(&mut self) -> i64 {
        unsafe { StreamPeer_get_u16(self.this) }
    }

    #[inline]
    pub fn get_u32(&mut self) -> i64 {
        unsafe { StreamPeer_get_u32(self.this) }
    }

    #[inline]
    pub fn get_u64(&mut self) -> i64 {
        unsafe { StreamPeer_get_u64(self.this) }
    }

    #[inline]
    pub fn get_u8(&mut self) -> i64 {
        unsafe { StreamPeer_get_u8(self.this) }
    }

    #[inline]
    pub fn get_utf8_string(&mut self, bytes: i64) -> GodotString {
        unsafe { StreamPeer_get_utf8_string(self.this, bytes) }
    }

    #[inline]
    pub fn get_var(&mut self, allow_objects: bool) -> Variant {
        unsafe { StreamPeer_get_var(self.this, allow_objects) }
    }

    #[inline]
    pub fn is_big_endian_enabled(&self) -> bool {
        unsafe { StreamPeer_is_big_endian_enabled(self.this) }
    }

    #[inline]
    pub fn put_16(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_16(self.this, value) }
    }

    #[inline]
    pub fn put_32(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_32(self.this, value) }
    }

    #[inline]
    pub fn put_64(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_64(self.this, value) }
    }

    #[inline]
    pub fn put_8(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_8(self.this, value) }
    }

    #[inline]
    pub fn put_data(&mut self, data: ByteArray) -> GodotResult {
        unsafe { StreamPeer_put_data(self.this, data) }
    }

    #[inline]
    pub fn put_double(&mut self, value: f64) -> () {
        unsafe { StreamPeer_put_double(self.this, value) }
    }

    #[inline]
    pub fn put_float(&mut self, value: f64) -> () {
        unsafe { StreamPeer_put_float(self.this, value) }
    }

    #[inline]
    pub fn put_partial_data(&mut self, data: ByteArray) -> VariantArray {
        unsafe { StreamPeer_put_partial_data(self.this, data) }
    }

    #[inline]
    pub fn put_string(&mut self, value: GodotString) -> () {
        unsafe { StreamPeer_put_string(self.this, value) }
    }

    #[inline]
    pub fn put_u16(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_u16(self.this, value) }
    }

    #[inline]
    pub fn put_u32(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_u32(self.this, value) }
    }

    #[inline]
    pub fn put_u64(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_u64(self.this, value) }
    }

    #[inline]
    pub fn put_u8(&mut self, value: i64) -> () {
        unsafe { StreamPeer_put_u8(self.this, value) }
    }

    #[inline]
    pub fn put_utf8_string(&mut self, value: GodotString) -> () {
        unsafe { StreamPeer_put_utf8_string(self.this, value) }
    }

    #[inline]
    pub fn put_var(&mut self, value: Variant, full_objects: bool) -> () {
        unsafe { StreamPeer_put_var(self.this, value, full_objects) }
    }

    #[inline]
    pub fn set_big_endian(&mut self, enable: bool) -> () {
        unsafe { StreamPeer_set_big_endian(self.this, enable) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamPeerBuffer` inherits `StreamPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streampeerbuffer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamPeerBuffer inherits methods from:
/// - [StreamPeer](struct.StreamPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamPeerBuffer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StreamPeerBuffer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StreamPeerBufferMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StreamPeerBuffer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { StreamPeerBuffer_clear(self.this) }
    }

    #[inline]
    pub fn duplicate(&self) -> Option<StreamPeerBuffer> {
        unsafe { StreamPeerBuffer_duplicate(self.this) }
    }

    #[inline]
    pub fn get_data_array(&self) -> ByteArray {
        unsafe { StreamPeerBuffer_get_data_array(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> i64 {
        unsafe { StreamPeerBuffer_get_position(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> i64 {
        unsafe { StreamPeerBuffer_get_size(self.this) }
    }

    #[inline]
    pub fn resize(&mut self, size: i64) -> () {
        unsafe { StreamPeerBuffer_resize(self.this, size) }
    }

    #[inline]
    pub fn seek(&mut self, position: i64) -> () {
        unsafe { StreamPeerBuffer_seek(self.this, position) }
    }

    #[inline]
    pub fn set_data_array(&mut self, data: ByteArray) -> () {
        unsafe { StreamPeerBuffer_set_data_array(self.this, data) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_stream_peer(&self) -> StreamPeer {
        unsafe {{ object::add_ref(self.this); }}
        StreamPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamPeerGDNative` inherits `StreamPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streampeergdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamPeerGDNative inherits methods from:
/// - [StreamPeer](struct.StreamPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamPeerGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StreamPeerGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StreamPeerGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StreamPeerGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_stream_peer(&self) -> StreamPeer {
        unsafe {{ object::add_ref(self.this); }}
        StreamPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamPeerSSL` inherits `StreamPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streampeerssl.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamPeerSSL inherits methods from:
/// - [StreamPeer](struct.StreamPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamPeerSSL {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum StreamPeerSSLStatus {
    Disconnected = 0,
    Handshaking = 1,
    Connected = 2,
    Error = 3,
    ErrorHostnameMismatch = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl StreamPeerSSL {
    pub const STATUS_CONNECTED: i64 = 2;
    pub const STATUS_DISCONNECTED: i64 = 0;
    pub const STATUS_ERROR: i64 = 3;
    pub const STATUS_ERROR_HOSTNAME_MISMATCH: i64 = 4;
    pub const STATUS_HANDSHAKING: i64 = 1;
}
impl StreamPeerSSL {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StreamPeerSSLMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StreamPeerSSL {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn accept_stream(&mut self, stream: Option<StreamPeer>, private_key: Option<CryptoKey>, certificate: Option<X509Certificate>, chain: Option<X509Certificate>) -> GodotResult {
        unsafe { StreamPeerSSL_accept_stream(self.this, stream, private_key, certificate, chain) }
    }

    #[inline]
    pub fn connect_to_stream(&mut self, stream: Option<StreamPeer>, validate_certs: bool, for_hostname: GodotString, valid_certificate: Option<X509Certificate>) -> GodotResult {
        unsafe { StreamPeerSSL_connect_to_stream(self.this, stream, validate_certs, for_hostname, valid_certificate) }
    }

    #[inline]
    pub fn disconnect_from_stream(&mut self) -> () {
        unsafe { StreamPeerSSL_disconnect_from_stream(self.this) }
    }

    #[inline]
    pub fn get_status(&self) -> StreamPeerSSLStatus {
        unsafe { StreamPeerSSL_get_status(self.this) }
    }

    #[inline]
    pub fn is_blocking_handshake_enabled(&self) -> bool {
        unsafe { StreamPeerSSL_is_blocking_handshake_enabled(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> () {
        unsafe { StreamPeerSSL_poll(self.this) }
    }

    #[inline]
    pub fn set_blocking_handshake_enabled(&mut self, enabled: bool) -> () {
        unsafe { StreamPeerSSL_set_blocking_handshake_enabled(self.this, enabled) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_stream_peer(&self) -> StreamPeer {
        unsafe {{ object::add_ref(self.this); }}
        StreamPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamPeerTCP` inherits `StreamPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streampeertcp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamPeerTCP inherits methods from:
/// - [StreamPeer](struct.StreamPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamPeerTCP {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum StreamPeerTCPStatus {
    None = 0,
    Connecting = 1,
    Connected = 2,
    Error = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl StreamPeerTCP {
    pub const STATUS_CONNECTING: i64 = 1;
    pub const STATUS_ERROR: i64 = 3;
    pub const STATUS_NONE: i64 = 0;
    pub const STATUS_CONNECTED: i64 = 2;
}
impl StreamPeerTCP {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StreamPeerTCPMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StreamPeerTCP {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn connect_to_host(&mut self, host: GodotString, port: i64) -> GodotResult {
        unsafe { StreamPeerTCP_connect_to_host(self.this, host, port) }
    }

    #[inline]
    pub fn disconnect_from_host(&mut self) -> () {
        unsafe { StreamPeerTCP_disconnect_from_host(self.this) }
    }

    #[inline]
    pub fn get_connected_host(&self) -> GodotString {
        unsafe { StreamPeerTCP_get_connected_host(self.this) }
    }

    #[inline]
    pub fn get_connected_port(&self) -> i64 {
        unsafe { StreamPeerTCP_get_connected_port(self.this) }
    }

    #[inline]
    pub fn get_status(&mut self) -> StreamPeerTCPStatus {
        unsafe { StreamPeerTCP_get_status(self.this) }
    }

    #[inline]
    pub fn is_connected_to_host(&self) -> bool {
        unsafe { StreamPeerTCP_is_connected_to_host(self.this) }
    }

    #[inline]
    pub fn set_no_delay(&mut self, enabled: bool) -> () {
        unsafe { StreamPeerTCP_set_no_delay(self.this, enabled) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_stream_peer(&self) -> StreamPeer {
        unsafe {{ object::add_ref(self.this); }}
        StreamPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StreamTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_streamtexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StreamTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StreamTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StreamTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StreamTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StreamTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_load_path(&self) -> GodotString {
        unsafe { StreamTexture_get_load_path(self.this) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { StreamTexture_load(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StyleBox` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_stylebox.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StyleBox inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StyleBox {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StyleBox {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn draw(&self, canvas_item: Rid, rect: Rect2) -> () {
        unsafe { StyleBox_draw(self.this, canvas_item, rect) }
    }

    #[inline]
    pub fn get_center_size(&self) -> Vector2 {
        unsafe { StyleBox_get_center_size(self.this) }
    }

    #[inline]
    pub fn get_current_item_drawn(&self) -> Option<CanvasItem> {
        unsafe { StyleBox_get_current_item_drawn(self.this) }
    }

    #[inline]
    pub fn get_default_margin(&self, margin: i64) -> f64 {
        unsafe { StyleBox_get_default_margin(self.this, margin) }
    }

    #[inline]
    pub fn get_margin(&self, margin: i64) -> f64 {
        unsafe { StyleBox_get_margin(self.this, margin) }
    }

    #[inline]
    pub fn get_minimum_size(&self) -> Vector2 {
        unsafe { StyleBox_get_minimum_size(self.this) }
    }

    #[inline]
    pub fn get_offset(&self) -> Vector2 {
        unsafe { StyleBox_get_offset(self.this) }
    }

    #[inline]
    pub fn set_default_margin(&mut self, margin: i64, offset: f64) -> () {
        unsafe { StyleBox_set_default_margin(self.this, margin, offset) }
    }

    #[inline]
    pub fn test_mask(&self, point: Vector2, rect: Rect2) -> bool {
        unsafe { StyleBox_test_mask(self.this, point, rect) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StyleBoxEmpty` inherits `StyleBox` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_styleboxempty.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StyleBoxEmpty inherits methods from:
/// - [StyleBox](struct.StyleBox.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StyleBoxEmpty {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StyleBoxEmpty {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StyleBoxEmptyMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StyleBoxEmpty {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_style_box(&self) -> StyleBox {
        unsafe {{ object::add_ref(self.this); }}
        StyleBox { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StyleBoxFlat` inherits `StyleBox` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_styleboxflat.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StyleBoxFlat inherits methods from:
/// - [StyleBox](struct.StyleBox.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StyleBoxFlat {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StyleBoxFlat {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StyleBoxFlatMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StyleBoxFlat {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_aa_size(&self) -> i64 {
        unsafe { StyleBoxFlat_get_aa_size(self.this) }
    }

    #[inline]
    pub fn get_bg_color(&self) -> Color {
        unsafe { StyleBoxFlat_get_bg_color(self.this) }
    }

    #[inline]
    pub fn get_border_blend(&self) -> bool {
        unsafe { StyleBoxFlat_get_border_blend(self.this) }
    }

    #[inline]
    pub fn get_border_color(&self) -> Color {
        unsafe { StyleBoxFlat_get_border_color(self.this) }
    }

    #[inline]
    pub fn get_border_width(&self, margin: i64) -> i64 {
        unsafe { StyleBoxFlat_get_border_width(self.this, margin) }
    }

    #[inline]
    pub fn get_border_width_min(&self) -> i64 {
        unsafe { StyleBoxFlat_get_border_width_min(self.this) }
    }

    #[inline]
    pub fn get_corner_detail(&self) -> i64 {
        unsafe { StyleBoxFlat_get_corner_detail(self.this) }
    }

    #[inline]
    pub fn get_corner_radius(&self, corner: i64) -> i64 {
        unsafe { StyleBoxFlat_get_corner_radius(self.this, corner) }
    }

    #[inline]
    pub fn get_expand_margin(&self, margin: i64) -> f64 {
        unsafe { StyleBoxFlat_get_expand_margin(self.this, margin) }
    }

    #[inline]
    pub fn get_shadow_color(&self) -> Color {
        unsafe { StyleBoxFlat_get_shadow_color(self.this) }
    }

    #[inline]
    pub fn get_shadow_offset(&self) -> Vector2 {
        unsafe { StyleBoxFlat_get_shadow_offset(self.this) }
    }

    #[inline]
    pub fn get_shadow_size(&self) -> i64 {
        unsafe { StyleBoxFlat_get_shadow_size(self.this) }
    }

    #[inline]
    pub fn is_anti_aliased(&self) -> bool {
        unsafe { StyleBoxFlat_is_anti_aliased(self.this) }
    }

    #[inline]
    pub fn is_draw_center_enabled(&self) -> bool {
        unsafe { StyleBoxFlat_is_draw_center_enabled(self.this) }
    }

    #[inline]
    pub fn set_aa_size(&mut self, size: i64) -> () {
        unsafe { StyleBoxFlat_set_aa_size(self.this, size) }
    }

    #[inline]
    pub fn set_anti_aliased(&mut self, anti_aliased: bool) -> () {
        unsafe { StyleBoxFlat_set_anti_aliased(self.this, anti_aliased) }
    }

    #[inline]
    pub fn set_bg_color(&mut self, color: Color) -> () {
        unsafe { StyleBoxFlat_set_bg_color(self.this, color) }
    }

    #[inline]
    pub fn set_border_blend(&mut self, blend: bool) -> () {
        unsafe { StyleBoxFlat_set_border_blend(self.this, blend) }
    }

    #[inline]
    pub fn set_border_color(&mut self, color: Color) -> () {
        unsafe { StyleBoxFlat_set_border_color(self.this, color) }
    }

    #[inline]
    pub fn set_border_width(&mut self, margin: i64, width: i64) -> () {
        unsafe { StyleBoxFlat_set_border_width(self.this, margin, width) }
    }

    #[inline]
    pub fn set_border_width_all(&mut self, width: i64) -> () {
        unsafe { StyleBoxFlat_set_border_width_all(self.this, width) }
    }

    #[inline]
    pub fn set_corner_detail(&mut self, detail: i64) -> () {
        unsafe { StyleBoxFlat_set_corner_detail(self.this, detail) }
    }

    #[inline]
    pub fn set_corner_radius(&mut self, corner: i64, radius: i64) -> () {
        unsafe { StyleBoxFlat_set_corner_radius(self.this, corner, radius) }
    }

    #[inline]
    pub fn set_corner_radius_all(&mut self, radius: i64) -> () {
        unsafe { StyleBoxFlat_set_corner_radius_all(self.this, radius) }
    }

    #[inline]
    pub fn set_corner_radius_individual(&mut self, radius_top_left: i64, radius_top_right: i64, radius_bottom_right: i64, radius_bottom_left: i64) -> () {
        unsafe { StyleBoxFlat_set_corner_radius_individual(self.this, radius_top_left, radius_top_right, radius_bottom_right, radius_bottom_left) }
    }

    #[inline]
    pub fn set_draw_center(&mut self, draw_center: bool) -> () {
        unsafe { StyleBoxFlat_set_draw_center(self.this, draw_center) }
    }

    #[inline]
    pub fn set_expand_margin(&mut self, margin: i64, size: f64) -> () {
        unsafe { StyleBoxFlat_set_expand_margin(self.this, margin, size) }
    }

    #[inline]
    pub fn set_expand_margin_all(&mut self, size: f64) -> () {
        unsafe { StyleBoxFlat_set_expand_margin_all(self.this, size) }
    }

    #[inline]
    pub fn set_expand_margin_individual(&mut self, size_left: f64, size_top: f64, size_right: f64, size_bottom: f64) -> () {
        unsafe { StyleBoxFlat_set_expand_margin_individual(self.this, size_left, size_top, size_right, size_bottom) }
    }

    #[inline]
    pub fn set_shadow_color(&mut self, color: Color) -> () {
        unsafe { StyleBoxFlat_set_shadow_color(self.this, color) }
    }

    #[inline]
    pub fn set_shadow_offset(&mut self, offset: Vector2) -> () {
        unsafe { StyleBoxFlat_set_shadow_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_shadow_size(&mut self, size: i64) -> () {
        unsafe { StyleBoxFlat_set_shadow_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_style_box(&self) -> StyleBox {
        unsafe {{ object::add_ref(self.this); }}
        StyleBox { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StyleBoxLine` inherits `StyleBox` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_styleboxline.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StyleBoxLine inherits methods from:
/// - [StyleBox](struct.StyleBox.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StyleBoxLine {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl StyleBoxLine {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StyleBoxLineMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StyleBoxLine {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_color(&self) -> Color {
        unsafe { StyleBoxLine_get_color(self.this) }
    }

    #[inline]
    pub fn get_grow_begin(&self) -> f64 {
        unsafe { StyleBoxLine_get_grow_begin(self.this) }
    }

    #[inline]
    pub fn get_grow_end(&self) -> f64 {
        unsafe { StyleBoxLine_get_grow_end(self.this) }
    }

    #[inline]
    pub fn get_thickness(&self) -> i64 {
        unsafe { StyleBoxLine_get_thickness(self.this) }
    }

    #[inline]
    pub fn is_vertical(&self) -> bool {
        unsafe { StyleBoxLine_is_vertical(self.this) }
    }

    #[inline]
    pub fn set_color(&mut self, color: Color) -> () {
        unsafe { StyleBoxLine_set_color(self.this, color) }
    }

    #[inline]
    pub fn set_grow_begin(&mut self, offset: f64) -> () {
        unsafe { StyleBoxLine_set_grow_begin(self.this, offset) }
    }

    #[inline]
    pub fn set_grow_end(&mut self, offset: f64) -> () {
        unsafe { StyleBoxLine_set_grow_end(self.this, offset) }
    }

    #[inline]
    pub fn set_thickness(&mut self, thickness: i64) -> () {
        unsafe { StyleBoxLine_set_thickness(self.this, thickness) }
    }

    #[inline]
    pub fn set_vertical(&mut self, vertical: bool) -> () {
        unsafe { StyleBoxLine_set_vertical(self.this, vertical) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_style_box(&self) -> StyleBox {
        unsafe {{ object::add_ref(self.this); }}
        StyleBox { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class StyleBoxTexture` inherits `StyleBox` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_styleboxtexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// StyleBoxTexture inherits methods from:
/// - [StyleBox](struct.StyleBox.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct StyleBoxTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum StyleBoxTextureAxisStretchMode {
    ModeStretch = 0,
    ModeTile = 1,
    ModeTileFit = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl StyleBoxTexture {
    pub const AXIS_STRETCH_MODE_TILE: i64 = 1;
    pub const AXIS_STRETCH_MODE_STRETCH: i64 = 0;
    pub const AXIS_STRETCH_MODE_TILE_FIT: i64 = 2;
}
impl StyleBoxTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = StyleBoxTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            StyleBoxTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_expand_margin_size(&self, margin: i64) -> f64 {
        unsafe { StyleBoxTexture_get_expand_margin_size(self.this, margin) }
    }

    #[inline]
    pub fn get_h_axis_stretch_mode(&self) -> StyleBoxTextureAxisStretchMode {
        unsafe { StyleBoxTexture_get_h_axis_stretch_mode(self.this) }
    }

    #[inline]
    pub fn get_margin_size(&self, margin: i64) -> f64 {
        unsafe { StyleBoxTexture_get_margin_size(self.this, margin) }
    }

    #[inline]
    pub fn get_modulate(&self) -> Color {
        unsafe { StyleBoxTexture_get_modulate(self.this) }
    }

    #[inline]
    pub fn get_normal_map(&self) -> Option<Texture> {
        unsafe { StyleBoxTexture_get_normal_map(self.this) }
    }

    #[inline]
    pub fn get_region_rect(&self) -> Rect2 {
        unsafe { StyleBoxTexture_get_region_rect(self.this) }
    }

    #[inline]
    pub fn get_texture(&self) -> Option<Texture> {
        unsafe { StyleBoxTexture_get_texture(self.this) }
    }

    #[inline]
    pub fn get_v_axis_stretch_mode(&self) -> StyleBoxTextureAxisStretchMode {
        unsafe { StyleBoxTexture_get_v_axis_stretch_mode(self.this) }
    }

    #[inline]
    pub fn is_draw_center_enabled(&self) -> bool {
        unsafe { StyleBoxTexture_is_draw_center_enabled(self.this) }
    }

    #[inline]
    pub fn set_draw_center(&mut self, enable: bool) -> () {
        unsafe { StyleBoxTexture_set_draw_center(self.this, enable) }
    }

    #[inline]
    pub fn set_expand_margin_all(&mut self, size: f64) -> () {
        unsafe { StyleBoxTexture_set_expand_margin_all(self.this, size) }
    }

    #[inline]
    pub fn set_expand_margin_individual(&mut self, size_left: f64, size_top: f64, size_right: f64, size_bottom: f64) -> () {
        unsafe { StyleBoxTexture_set_expand_margin_individual(self.this, size_left, size_top, size_right, size_bottom) }
    }

    #[inline]
    pub fn set_expand_margin_size(&mut self, margin: i64, size: f64) -> () {
        unsafe { StyleBoxTexture_set_expand_margin_size(self.this, margin, size) }
    }

    #[inline]
    pub fn set_h_axis_stretch_mode(&mut self, mode: i64) -> () {
        unsafe { StyleBoxTexture_set_h_axis_stretch_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_margin_size(&mut self, margin: i64, size: f64) -> () {
        unsafe { StyleBoxTexture_set_margin_size(self.this, margin, size) }
    }

    #[inline]
    pub fn set_modulate(&mut self, color: Color) -> () {
        unsafe { StyleBoxTexture_set_modulate(self.this, color) }
    }

    #[inline]
    pub fn set_normal_map(&mut self, normal_map: Option<Texture>) -> () {
        unsafe { StyleBoxTexture_set_normal_map(self.this, normal_map) }
    }

    #[inline]
    pub fn set_region_rect(&mut self, region: Rect2) -> () {
        unsafe { StyleBoxTexture_set_region_rect(self.this, region) }
    }

    #[inline]
    pub fn set_texture(&mut self, texture: Option<Texture>) -> () {
        unsafe { StyleBoxTexture_set_texture(self.this, texture) }
    }

    #[inline]
    pub fn set_v_axis_stretch_mode(&mut self, mode: i64) -> () {
        unsafe { StyleBoxTexture_set_v_axis_stretch_mode(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_style_box(&self) -> StyleBox {
        unsafe {{ object::add_ref(self.this); }}
        StyleBox { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class SurfaceTool` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_surfacetool.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// SurfaceTool inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct SurfaceTool {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl SurfaceTool {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SurfaceToolMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            SurfaceTool {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_bones(&mut self, bones: Int32Array) -> () {
        unsafe { SurfaceTool_add_bones(self.this, bones) }
    }

    #[inline]
    pub fn add_color(&mut self, color: Color) -> () {
        unsafe { SurfaceTool_add_color(self.this, color) }
    }

    #[inline]
    pub fn add_index(&mut self, index: i64) -> () {
        unsafe { SurfaceTool_add_index(self.this, index) }
    }

    #[inline]
    pub fn add_normal(&mut self, normal: Vector3) -> () {
        unsafe { SurfaceTool_add_normal(self.this, normal) }
    }

    #[inline]
    pub fn add_smooth_group(&mut self, smooth: bool) -> () {
        unsafe { SurfaceTool_add_smooth_group(self.this, smooth) }
    }

    #[inline]
    pub fn add_tangent(&mut self, tangent: Plane) -> () {
        unsafe { SurfaceTool_add_tangent(self.this, tangent) }
    }

    #[inline]
    pub fn add_triangle_fan(&mut self, vertices: Vector3Array, uvs: Vector2Array, colors: ColorArray, uv2s: Vector2Array, normals: Vector3Array, tangents: VariantArray) -> () {
        unsafe { SurfaceTool_add_triangle_fan(self.this, vertices, uvs, colors, uv2s, normals, tangents) }
    }

    #[inline]
    pub fn add_uv(&mut self, uv: Vector2) -> () {
        unsafe { SurfaceTool_add_uv(self.this, uv) }
    }

    #[inline]
    pub fn add_uv2(&mut self, uv2: Vector2) -> () {
        unsafe { SurfaceTool_add_uv2(self.this, uv2) }
    }

    #[inline]
    pub fn add_vertex(&mut self, vertex: Vector3) -> () {
        unsafe { SurfaceTool_add_vertex(self.this, vertex) }
    }

    #[inline]
    pub fn add_weights(&mut self, weights: Float32Array) -> () {
        unsafe { SurfaceTool_add_weights(self.this, weights) }
    }

    #[inline]
    pub fn append_from(&mut self, existing: Option<Mesh>, surface: i64, transform: Transform) -> () {
        unsafe { SurfaceTool_append_from(self.this, existing, surface, transform) }
    }

    #[inline]
    pub fn begin(&mut self, primitive: i64) -> () {
        unsafe { SurfaceTool_begin(self.this, primitive) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { SurfaceTool_clear(self.this) }
    }

    #[inline]
    pub fn commit(&mut self, existing: Option<ArrayMesh>, flags: i64) -> Option<ArrayMesh> {
        unsafe { SurfaceTool_commit(self.this, existing, flags) }
    }

    #[inline]
    pub fn commit_to_arrays(&mut self) -> VariantArray {
        unsafe { SurfaceTool_commit_to_arrays(self.this) }
    }

    #[inline]
    pub fn create_from(&mut self, existing: Option<Mesh>, surface: i64) -> () {
        unsafe { SurfaceTool_create_from(self.this, existing, surface) }
    }

    #[inline]
    pub fn create_from_blend_shape(&mut self, existing: Option<Mesh>, surface: i64, blend_shape: GodotString) -> () {
        unsafe { SurfaceTool_create_from_blend_shape(self.this, existing, surface, blend_shape) }
    }

    #[inline]
    pub fn deindex(&mut self) -> () {
        unsafe { SurfaceTool_deindex(self.this) }
    }

    #[inline]
    pub fn generate_normals(&mut self, flip: bool) -> () {
        unsafe { SurfaceTool_generate_normals(self.this, flip) }
    }

    #[inline]
    pub fn generate_tangents(&mut self) -> () {
        unsafe { SurfaceTool_generate_tangents(self.this) }
    }

    #[inline]
    pub fn index(&mut self) -> () {
        unsafe { SurfaceTool_index(self.this) }
    }

    #[inline]
    pub fn set_material(&mut self, material: Option<Material>) -> () {
        unsafe { SurfaceTool_set_material(self.this, material) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TCP_Server` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tcp_server.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TCP_Server inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TCP_Server {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl TCP_Server {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TCP_ServerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            TCP_Server {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn is_connection_available(&self) -> bool {
        unsafe { TCP_Server_is_connection_available(self.this) }
    }

    #[inline]
    pub fn is_listening(&self) -> bool {
        unsafe { TCP_Server_is_listening(self.this) }
    }

    #[inline]
    pub fn listen(&mut self, port: i64, bind_address: GodotString) -> GodotResult {
        unsafe { TCP_Server_listen(self.this, port, bind_address) }
    }

    #[inline]
    pub fn stop(&mut self) -> () {
        unsafe { TCP_Server_stop(self.this) }
    }

    #[inline]
    pub fn take_connection(&mut self) -> Option<StreamPeerTCP> {
        unsafe { TCP_Server_take_connection(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TabContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tabcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TabContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TabContainer::free`.
///
/// ## Class hierarchy
///
/// TabContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TabContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TabContainerTabAlign {
    AlignLeft = 0,
    AlignCenter = 1,
    AlignRight = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TabContainer {
    pub const ALIGN_LEFT: i64 = 0;
    pub const ALIGN_RIGHT: i64 = 2;
    pub const ALIGN_CENTER: i64 = 1;
}
impl TabContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TabContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TabContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TabContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _child_renamed_callback(&mut self) -> () {
        TabContainer__child_renamed_callback(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        TabContainer__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _on_mouse_exited(&mut self) -> () {
        TabContainer__on_mouse_exited(self.this)
    }

    #[inline]
    pub unsafe fn _on_theme_changed(&mut self) -> () {
        TabContainer__on_theme_changed(self.this)
    }

    #[inline]
    pub unsafe fn _update_current_tab(&mut self) -> () {
        TabContainer__update_current_tab(self.this)
    }

    #[inline]
    pub unsafe fn are_tabs_visible(&self) -> bool {
        TabContainer_are_tabs_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_current_tab(&self) -> i64 {
        TabContainer_get_current_tab(self.this)
    }

    #[inline]
    pub unsafe fn get_current_tab_control(&self) -> Option<Control> {
        TabContainer_get_current_tab_control(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_to_rearrange_enabled(&self) -> bool {
        TabContainer_get_drag_to_rearrange_enabled(self.this)
    }

    #[inline]
    pub unsafe fn get_popup(&self) -> Option<Popup> {
        TabContainer_get_popup(self.this)
    }

    #[inline]
    pub unsafe fn get_previous_tab(&self) -> i64 {
        TabContainer_get_previous_tab(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_align(&self) -> TabContainerTabAlign {
        TabContainer_get_tab_align(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_control(&self, idx: i64) -> Option<Control> {
        TabContainer_get_tab_control(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_tab_count(&self) -> i64 {
        TabContainer_get_tab_count(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_disabled(&self, tab_idx: i64) -> bool {
        TabContainer_get_tab_disabled(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tab_icon(&self, tab_idx: i64) -> Option<Texture> {
        TabContainer_get_tab_icon(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tab_title(&self, tab_idx: i64) -> GodotString {
        TabContainer_get_tab_title(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tabs_rearrange_group(&self) -> i64 {
        TabContainer_get_tabs_rearrange_group(self.this)
    }

    #[inline]
    pub unsafe fn get_use_hidden_tabs_for_min_size(&self) -> bool {
        TabContainer_get_use_hidden_tabs_for_min_size(self.this)
    }

    #[inline]
    pub unsafe fn set_current_tab(&mut self, tab_idx: i64) -> () {
        TabContainer_set_current_tab(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn set_drag_to_rearrange_enabled(&mut self, enabled: bool) -> () {
        TabContainer_set_drag_to_rearrange_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_popup(&mut self, popup: Option<Node>) -> () {
        TabContainer_set_popup(self.this, popup)
    }

    #[inline]
    pub unsafe fn set_tab_align(&mut self, align: i64) -> () {
        TabContainer_set_tab_align(self.this, align)
    }

    #[inline]
    pub unsafe fn set_tab_disabled(&mut self, tab_idx: i64, disabled: bool) -> () {
        TabContainer_set_tab_disabled(self.this, tab_idx, disabled)
    }

    #[inline]
    pub unsafe fn set_tab_icon(&mut self, tab_idx: i64, icon: Option<Texture>) -> () {
        TabContainer_set_tab_icon(self.this, tab_idx, icon)
    }

    #[inline]
    pub unsafe fn set_tab_title(&mut self, tab_idx: i64, title: GodotString) -> () {
        TabContainer_set_tab_title(self.this, tab_idx, title)
    }

    #[inline]
    pub unsafe fn set_tabs_rearrange_group(&mut self, group_id: i64) -> () {
        TabContainer_set_tabs_rearrange_group(self.this, group_id)
    }

    #[inline]
    pub unsafe fn set_tabs_visible(&mut self, visible: bool) -> () {
        TabContainer_set_tabs_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn set_use_hidden_tabs_for_min_size(&mut self, enabled: bool) -> () {
        TabContainer_set_use_hidden_tabs_for_min_size(self.this, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Tabs` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tabs.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Tabs` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Tabs::free`.
///
/// ## Class hierarchy
///
/// Tabs inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Tabs {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TabsCloseButtonDisplayPolicy {
    CloseButtonShowNever = 0,
    CloseButtonShowActiveOnly = 1,
    CloseButtonShowAlways = 2,
    CloseButtonMax = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TabsTabAlign {
    AlignLeft = 0,
    AlignCenter = 1,
    AlignRight = 2,
    AlignMax = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Tabs {
    pub const ALIGN_LEFT: i64 = 0;
    pub const ALIGN_CENTER: i64 = 1;
    pub const CLOSE_BUTTON_MAX: i64 = 3;
    pub const CLOSE_BUTTON_SHOW_ACTIVE_ONLY: i64 = 1;
    pub const CLOSE_BUTTON_SHOW_ALWAYS: i64 = 2;
    pub const ALIGN_MAX: i64 = 3;
    pub const CLOSE_BUTTON_SHOW_NEVER: i64 = 0;
    pub const ALIGN_RIGHT: i64 = 2;
}
impl Tabs {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Tabs::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TabsMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Tabs {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        Tabs__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _on_mouse_exited(&mut self) -> () {
        Tabs__on_mouse_exited(self.this)
    }

    #[inline]
    pub unsafe fn _update_hover(&mut self) -> () {
        Tabs__update_hover(self.this)
    }

    #[inline]
    pub unsafe fn add_tab(&mut self, title: GodotString, icon: Option<Texture>) -> () {
        Tabs_add_tab(self.this, title, icon)
    }

    #[inline]
    pub unsafe fn ensure_tab_visible(&mut self, idx: i64) -> () {
        Tabs_ensure_tab_visible(self.this, idx)
    }

    #[inline]
    pub unsafe fn get_current_tab(&self) -> i64 {
        Tabs_get_current_tab(self.this)
    }

    #[inline]
    pub unsafe fn get_drag_to_rearrange_enabled(&self) -> bool {
        Tabs_get_drag_to_rearrange_enabled(self.this)
    }

    #[inline]
    pub unsafe fn get_offset_buttons_visible(&self) -> bool {
        Tabs_get_offset_buttons_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_scrolling_enabled(&self) -> bool {
        Tabs_get_scrolling_enabled(self.this)
    }

    #[inline]
    pub unsafe fn get_select_with_rmb(&self) -> bool {
        Tabs_get_select_with_rmb(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_align(&self) -> TabsTabAlign {
        Tabs_get_tab_align(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_close_display_policy(&self) -> TabsCloseButtonDisplayPolicy {
        Tabs_get_tab_close_display_policy(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_count(&self) -> i64 {
        Tabs_get_tab_count(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_disabled(&self, tab_idx: i64) -> bool {
        Tabs_get_tab_disabled(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tab_icon(&self, tab_idx: i64) -> Option<Texture> {
        Tabs_get_tab_icon(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tab_offset(&self) -> i64 {
        Tabs_get_tab_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_tab_rect(&self, tab_idx: i64) -> Rect2 {
        Tabs_get_tab_rect(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tab_title(&self, tab_idx: i64) -> GodotString {
        Tabs_get_tab_title(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn get_tabs_rearrange_group(&self) -> i64 {
        Tabs_get_tabs_rearrange_group(self.this)
    }

    #[inline]
    pub unsafe fn move_tab(&mut self, from: i64, to: i64) -> () {
        Tabs_move_tab(self.this, from, to)
    }

    #[inline]
    pub unsafe fn remove_tab(&mut self, tab_idx: i64) -> () {
        Tabs_remove_tab(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn set_current_tab(&mut self, tab_idx: i64) -> () {
        Tabs_set_current_tab(self.this, tab_idx)
    }

    #[inline]
    pub unsafe fn set_drag_to_rearrange_enabled(&mut self, enabled: bool) -> () {
        Tabs_set_drag_to_rearrange_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_scrolling_enabled(&mut self, enabled: bool) -> () {
        Tabs_set_scrolling_enabled(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_select_with_rmb(&mut self, enabled: bool) -> () {
        Tabs_set_select_with_rmb(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_tab_align(&mut self, align: i64) -> () {
        Tabs_set_tab_align(self.this, align)
    }

    #[inline]
    pub unsafe fn set_tab_close_display_policy(&mut self, policy: i64) -> () {
        Tabs_set_tab_close_display_policy(self.this, policy)
    }

    #[inline]
    pub unsafe fn set_tab_disabled(&mut self, tab_idx: i64, disabled: bool) -> () {
        Tabs_set_tab_disabled(self.this, tab_idx, disabled)
    }

    #[inline]
    pub unsafe fn set_tab_icon(&mut self, tab_idx: i64, icon: Option<Texture>) -> () {
        Tabs_set_tab_icon(self.this, tab_idx, icon)
    }

    #[inline]
    pub unsafe fn set_tab_title(&mut self, tab_idx: i64, title: GodotString) -> () {
        Tabs_set_tab_title(self.this, tab_idx, title)
    }

    #[inline]
    pub unsafe fn set_tabs_rearrange_group(&mut self, group_id: i64) -> () {
        Tabs_set_tabs_rearrange_group(self.this, group_id)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextEdit` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_textedit.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TextEdit` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TextEdit::free`.
///
/// ## Class hierarchy
///
/// TextEdit inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextEdit {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextEditSearchFlags {
    SearchMatchCase = 1,
    SearchWholeWords = 2,
    SearchBackwards = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextEditSearchResult {
    Column = 0,
    Line = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextEditMenuItems {
    MenuCut = 0,
    MenuCopy = 1,
    MenuPaste = 2,
    MenuClear = 3,
    MenuSelectAll = 4,
    MenuUndo = 5,
    MenuRedo = 6,
    MenuMax = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TextEdit {
    pub const MENU_CLEAR: i64 = 3;
    pub const MENU_UNDO: i64 = 5;
    pub const SEARCH_BACKWARDS: i64 = 4;
    pub const SEARCH_RESULT_LINE: i64 = 1;
    pub const MENU_MAX: i64 = 7;
    pub const SEARCH_RESULT_COLUMN: i64 = 0;
    pub const SEARCH_WHOLE_WORDS: i64 = 2;
    pub const MENU_PASTE: i64 = 2;
    pub const SEARCH_MATCH_CASE: i64 = 1;
    pub const MENU_COPY: i64 = 1;
    pub const MENU_SELECT_ALL: i64 = 4;
    pub const MENU_REDO: i64 = 6;
    pub const MENU_CUT: i64 = 0;
}
impl TextEdit {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TextEdit::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextEditMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TextEdit {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _click_selection_held(&mut self) -> () {
        TextEdit__click_selection_held(self.this)
    }

    #[inline]
    pub unsafe fn _cursor_changed_emit(&mut self) -> () {
        TextEdit__cursor_changed_emit(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        TextEdit__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _push_current_op(&mut self) -> () {
        TextEdit__push_current_op(self.this)
    }

    #[inline]
    pub unsafe fn _scroll_moved(&mut self, arg0: f64) -> () {
        TextEdit__scroll_moved(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _text_changed_emit(&mut self) -> () {
        TextEdit__text_changed_emit(self.this)
    }

    #[inline]
    pub unsafe fn _toggle_draw_caret(&mut self) -> () {
        TextEdit__toggle_draw_caret(self.this)
    }

    #[inline]
    pub unsafe fn _update_wrap_at(&mut self) -> () {
        TextEdit__update_wrap_at(self.this)
    }

    #[inline]
    pub unsafe fn _v_scroll_input(&mut self) -> () {
        TextEdit__v_scroll_input(self.this)
    }

    #[inline]
    pub unsafe fn add_color_region(&mut self, begin_key: GodotString, end_key: GodotString, color: Color, line_only: bool) -> () {
        TextEdit_add_color_region(self.this, begin_key, end_key, color, line_only)
    }

    #[inline]
    pub unsafe fn add_keyword_color(&mut self, keyword: GodotString, color: Color) -> () {
        TextEdit_add_keyword_color(self.this, keyword, color)
    }

    #[inline]
    pub unsafe fn can_fold(&self, line: i64) -> bool {
        TextEdit_can_fold(self.this, line)
    }

    #[inline]
    pub unsafe fn center_viewport_to_cursor(&mut self) -> () {
        TextEdit_center_viewport_to_cursor(self.this)
    }

    #[inline]
    pub unsafe fn clear_colors(&mut self) -> () {
        TextEdit_clear_colors(self.this)
    }

    #[inline]
    pub unsafe fn clear_undo_history(&mut self) -> () {
        TextEdit_clear_undo_history(self.this)
    }

    #[inline]
    pub unsafe fn copy(&mut self) -> () {
        TextEdit_copy(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_blink_enabled(&self) -> bool {
        TextEdit_cursor_get_blink_enabled(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_blink_speed(&self) -> f64 {
        TextEdit_cursor_get_blink_speed(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_column(&self) -> i64 {
        TextEdit_cursor_get_column(self.this)
    }

    #[inline]
    pub unsafe fn cursor_get_line(&self) -> i64 {
        TextEdit_cursor_get_line(self.this)
    }

    #[inline]
    pub unsafe fn cursor_is_block_mode(&self) -> bool {
        TextEdit_cursor_is_block_mode(self.this)
    }

    #[inline]
    pub unsafe fn cursor_set_blink_enabled(&mut self, enable: bool) -> () {
        TextEdit_cursor_set_blink_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn cursor_set_blink_speed(&mut self, blink_speed: f64) -> () {
        TextEdit_cursor_set_blink_speed(self.this, blink_speed)
    }

    #[inline]
    pub unsafe fn cursor_set_block_mode(&mut self, enable: bool) -> () {
        TextEdit_cursor_set_block_mode(self.this, enable)
    }

    #[inline]
    pub unsafe fn cursor_set_column(&mut self, column: i64, adjust_viewport: bool) -> () {
        TextEdit_cursor_set_column(self.this, column, adjust_viewport)
    }

    #[inline]
    pub unsafe fn cursor_set_line(&mut self, line: i64, adjust_viewport: bool, can_be_hidden: bool, wrap_index: i64) -> () {
        TextEdit_cursor_set_line(self.this, line, adjust_viewport, can_be_hidden, wrap_index)
    }

    #[inline]
    pub unsafe fn cut(&mut self) -> () {
        TextEdit_cut(self.this)
    }

    #[inline]
    pub unsafe fn deselect(&mut self) -> () {
        TextEdit_deselect(self.this)
    }

    #[inline]
    pub unsafe fn draw_minimap(&mut self, draw: bool) -> () {
        TextEdit_draw_minimap(self.this, draw)
    }

    #[inline]
    pub unsafe fn fold_all_lines(&mut self) -> () {
        TextEdit_fold_all_lines(self.this)
    }

    #[inline]
    pub unsafe fn fold_line(&mut self, line: i64) -> () {
        TextEdit_fold_line(self.this, line)
    }

    #[inline]
    pub unsafe fn get_breakpoints(&self) -> VariantArray {
        TextEdit_get_breakpoints(self.this)
    }

    #[inline]
    pub unsafe fn get_h_scroll(&self) -> i64 {
        TextEdit_get_h_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_keyword_color(&self, keyword: GodotString) -> Color {
        TextEdit_get_keyword_color(self.this, keyword)
    }

    #[inline]
    pub unsafe fn get_line(&self, line: i64) -> GodotString {
        TextEdit_get_line(self.this, line)
    }

    #[inline]
    pub unsafe fn get_line_count(&self) -> i64 {
        TextEdit_get_line_count(self.this)
    }

    #[inline]
    pub unsafe fn get_menu(&self) -> Option<PopupMenu> {
        TextEdit_get_menu(self.this)
    }

    #[inline]
    pub unsafe fn get_minimap_width(&self) -> i64 {
        TextEdit_get_minimap_width(self.this)
    }

    #[inline]
    pub unsafe fn get_selection_from_column(&self) -> i64 {
        TextEdit_get_selection_from_column(self.this)
    }

    #[inline]
    pub unsafe fn get_selection_from_line(&self) -> i64 {
        TextEdit_get_selection_from_line(self.this)
    }

    #[inline]
    pub unsafe fn get_selection_text(&self) -> GodotString {
        TextEdit_get_selection_text(self.this)
    }

    #[inline]
    pub unsafe fn get_selection_to_column(&self) -> i64 {
        TextEdit_get_selection_to_column(self.this)
    }

    #[inline]
    pub unsafe fn get_selection_to_line(&self) -> i64 {
        TextEdit_get_selection_to_line(self.this)
    }

    #[inline]
    pub unsafe fn get_text(&mut self) -> GodotString {
        TextEdit_get_text(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scroll(&self) -> f64 {
        TextEdit_get_v_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_v_scroll_speed(&self) -> f64 {
        TextEdit_get_v_scroll_speed(self.this)
    }

    #[inline]
    pub unsafe fn get_word_under_cursor(&self) -> GodotString {
        TextEdit_get_word_under_cursor(self.this)
    }

    #[inline]
    pub unsafe fn has_keyword_color(&self, keyword: GodotString) -> bool {
        TextEdit_has_keyword_color(self.this, keyword)
    }

    #[inline]
    pub unsafe fn insert_text_at_cursor(&mut self, text: GodotString) -> () {
        TextEdit_insert_text_at_cursor(self.this, text)
    }

    #[inline]
    pub unsafe fn is_breakpoint_gutter_enabled(&self) -> bool {
        TextEdit_is_breakpoint_gutter_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_context_menu_enabled(&mut self) -> bool {
        TextEdit_is_context_menu_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_drawing_fold_gutter(&self) -> bool {
        TextEdit_is_drawing_fold_gutter(self.this)
    }

    #[inline]
    pub unsafe fn is_drawing_minimap(&self) -> bool {
        TextEdit_is_drawing_minimap(self.this)
    }

    #[inline]
    pub unsafe fn is_drawing_spaces(&self) -> bool {
        TextEdit_is_drawing_spaces(self.this)
    }

    #[inline]
    pub unsafe fn is_drawing_tabs(&self) -> bool {
        TextEdit_is_drawing_tabs(self.this)
    }

    #[inline]
    pub unsafe fn is_folded(&self, line: i64) -> bool {
        TextEdit_is_folded(self.this, line)
    }

    #[inline]
    pub unsafe fn is_hiding_enabled(&self) -> bool {
        TextEdit_is_hiding_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_highlight_all_occurrences_enabled(&self) -> bool {
        TextEdit_is_highlight_all_occurrences_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_highlight_current_line_enabled(&self) -> bool {
        TextEdit_is_highlight_current_line_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_line_hidden(&self, line: i64) -> bool {
        TextEdit_is_line_hidden(self.this, line)
    }

    #[inline]
    pub unsafe fn is_overriding_selected_font_color(&self) -> bool {
        TextEdit_is_overriding_selected_font_color(self.this)
    }

    #[inline]
    pub unsafe fn is_readonly(&self) -> bool {
        TextEdit_is_readonly(self.this)
    }

    #[inline]
    pub unsafe fn is_right_click_moving_caret(&self) -> bool {
        TextEdit_is_right_click_moving_caret(self.this)
    }

    #[inline]
    pub unsafe fn is_selecting_enabled(&self) -> bool {
        TextEdit_is_selecting_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_selection_active(&self) -> bool {
        TextEdit_is_selection_active(self.this)
    }

    #[inline]
    pub unsafe fn is_shortcut_keys_enabled(&self) -> bool {
        TextEdit_is_shortcut_keys_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_show_line_numbers_enabled(&self) -> bool {
        TextEdit_is_show_line_numbers_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_smooth_scroll_enabled(&self) -> bool {
        TextEdit_is_smooth_scroll_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_syntax_coloring_enabled(&self) -> bool {
        TextEdit_is_syntax_coloring_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_wrap_enabled(&self) -> bool {
        TextEdit_is_wrap_enabled(self.this)
    }

    #[inline]
    pub unsafe fn menu_option(&mut self, option: i64) -> () {
        TextEdit_menu_option(self.this, option)
    }

    #[inline]
    pub unsafe fn paste(&mut self) -> () {
        TextEdit_paste(self.this)
    }

    #[inline]
    pub unsafe fn redo(&mut self) -> () {
        TextEdit_redo(self.this)
    }

    #[inline]
    pub unsafe fn remove_breakpoints(&mut self) -> () {
        TextEdit_remove_breakpoints(self.this)
    }

    #[inline]
    pub unsafe fn search(&self, key: GodotString, flags: i64, from_line: i64, from_column: i64) -> Int32Array {
        TextEdit_search(self.this, key, flags, from_line, from_column)
    }

    #[inline]
    pub unsafe fn select(&mut self, from_line: i64, from_column: i64, to_line: i64, to_column: i64) -> () {
        TextEdit_select(self.this, from_line, from_column, to_line, to_column)
    }

    #[inline]
    pub unsafe fn select_all(&mut self) -> () {
        TextEdit_select_all(self.this)
    }

    #[inline]
    pub unsafe fn set_breakpoint_gutter_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_breakpoint_gutter_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_context_menu_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_context_menu_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_draw_fold_gutter(&mut self, arg0: bool) -> () {
        TextEdit_set_draw_fold_gutter(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_draw_spaces(&mut self, arg0: bool) -> () {
        TextEdit_set_draw_spaces(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_draw_tabs(&mut self, arg0: bool) -> () {
        TextEdit_set_draw_tabs(self.this, arg0)
    }

    #[inline]
    pub unsafe fn set_h_scroll(&mut self, value: i64) -> () {
        TextEdit_set_h_scroll(self.this, value)
    }

    #[inline]
    pub unsafe fn set_hiding_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_hiding_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_highlight_all_occurrences(&mut self, enable: bool) -> () {
        TextEdit_set_highlight_all_occurrences(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_highlight_current_line(&mut self, enabled: bool) -> () {
        TextEdit_set_highlight_current_line(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_line_as_hidden(&mut self, line: i64, enable: bool) -> () {
        TextEdit_set_line_as_hidden(self.this, line, enable)
    }

    #[inline]
    pub unsafe fn set_minimap_width(&mut self, width: i64) -> () {
        TextEdit_set_minimap_width(self.this, width)
    }

    #[inline]
    pub unsafe fn set_override_selected_font_color(&mut self, _override: bool) -> () {
        TextEdit_set_override_selected_font_color(self.this, _override)
    }

    #[inline]
    pub unsafe fn set_readonly(&mut self, enable: bool) -> () {
        TextEdit_set_readonly(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_right_click_moves_caret(&mut self, enable: bool) -> () {
        TextEdit_set_right_click_moves_caret(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_selecting_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_selecting_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_shortcut_keys_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_shortcut_keys_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_show_line_numbers(&mut self, enable: bool) -> () {
        TextEdit_set_show_line_numbers(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_smooth_scroll_enable(&mut self, enable: bool) -> () {
        TextEdit_set_smooth_scroll_enable(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_syntax_coloring(&mut self, enable: bool) -> () {
        TextEdit_set_syntax_coloring(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, text: GodotString) -> () {
        TextEdit_set_text(self.this, text)
    }

    #[inline]
    pub unsafe fn set_v_scroll(&mut self, value: f64) -> () {
        TextEdit_set_v_scroll(self.this, value)
    }

    #[inline]
    pub unsafe fn set_v_scroll_speed(&mut self, speed: f64) -> () {
        TextEdit_set_v_scroll_speed(self.this, speed)
    }

    #[inline]
    pub unsafe fn set_wrap_enabled(&mut self, enable: bool) -> () {
        TextEdit_set_wrap_enabled(self.this, enable)
    }

    #[inline]
    pub unsafe fn toggle_fold_line(&mut self, line: i64) -> () {
        TextEdit_toggle_fold_line(self.this, line)
    }

    #[inline]
    pub unsafe fn undo(&mut self) -> () {
        TextEdit_undo(self.this)
    }

    #[inline]
    pub unsafe fn unfold_line(&mut self, line: i64) -> () {
        TextEdit_unfold_line(self.this, line)
    }

    #[inline]
    pub unsafe fn unhide_all_lines(&mut self) -> () {
        TextEdit_unhide_all_lines(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextFile` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_textfile.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TextFile inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextFile {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl TextFile {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextFileMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            TextFile {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Texture` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Texture inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Texture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextureFlags {
    FlagMipmaps = 1,
    FlagRepeat = 2,
    FlagFilter = 4,
    Default = 7,
    FlagAnisotropicFilter = 8,
    FlagConvertToLinear = 16,
    FlagMirroredRepeat = 32,
    FlagVideoSurface = 2048,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Texture {
    pub const FLAG_FILTER: i64 = 4;
    pub const FLAG_MIPMAPS: i64 = 1;
    pub const FLAG_MIRRORED_REPEAT: i64 = 32;
    pub const FLAG_VIDEO_SURFACE: i64 = 2048;
    pub const FLAG_REPEAT: i64 = 2;
    pub const FLAG_CONVERT_TO_LINEAR: i64 = 16;
    pub const FLAG_ANISOTROPIC_FILTER: i64 = 8;
    pub const FLAGS_DEFAULT: i64 = 7;
}
impl Texture {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn draw(&self, canvas_item: Rid, position: Vector2, modulate: Color, transpose: bool, normal_map: Option<Texture>) -> () {
        unsafe { Texture_draw(self.this, canvas_item, position, modulate, transpose, normal_map) }
    }

    #[inline]
    pub fn draw_rect(&self, canvas_item: Rid, rect: Rect2, tile: bool, modulate: Color, transpose: bool, normal_map: Option<Texture>) -> () {
        unsafe { Texture_draw_rect(self.this, canvas_item, rect, tile, modulate, transpose, normal_map) }
    }

    #[inline]
    pub fn draw_rect_region(&self, canvas_item: Rid, rect: Rect2, src_rect: Rect2, modulate: Color, transpose: bool, normal_map: Option<Texture>, clip_uv: bool) -> () {
        unsafe { Texture_draw_rect_region(self.this, canvas_item, rect, src_rect, modulate, transpose, normal_map, clip_uv) }
    }

    #[inline]
    pub fn get_data(&self) -> Option<Image> {
        unsafe { Texture_get_data(self.this) }
    }

    #[inline]
    pub fn get_flags(&self) -> i64 {
        unsafe { Texture_get_flags(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> i64 {
        unsafe { Texture_get_height(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { Texture_get_size(self.this) }
    }

    #[inline]
    pub fn get_width(&self) -> i64 {
        unsafe { Texture_get_width(self.this) }
    }

    #[inline]
    pub fn has_alpha(&self) -> bool {
        unsafe { Texture_has_alpha(self.this) }
    }

    #[inline]
    pub fn set_flags(&mut self, flags: i64) -> () {
        unsafe { Texture_set_flags(self.this, flags) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Texture3D` inherits `TextureLayered` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texture3d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Texture3D inherits methods from:
/// - [TextureLayered](struct.TextureLayered.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Texture3D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Texture3D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = Texture3DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Texture3D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture_layered(&self) -> TextureLayered {
        unsafe {{ object::add_ref(self.this); }}
        TextureLayered { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextureArray` inherits `TextureLayered` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texturearray.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TextureArray inherits methods from:
/// - [TextureLayered](struct.TextureLayered.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextureArray {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl TextureArray {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextureArrayMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            TextureArray {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture_layered(&self) -> TextureLayered {
        unsafe {{ object::add_ref(self.this); }}
        TextureLayered { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextureButton` inherits `BaseButton` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texturebutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TextureButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TextureButton::free`.
///
/// ## Class hierarchy
///
/// TextureButton inherits methods from:
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextureButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextureButtonStretchMode {
    Scale = 0,
    Tile = 1,
    Keep = 2,
    KeepCentered = 3,
    KeepAspect = 4,
    KeepAspectCentered = 5,
    KeepAspectCovered = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TextureButton {
    pub const STRETCH_KEEP_ASPECT_CENTERED: i64 = 5;
    pub const STRETCH_KEEP_ASPECT_COVERED: i64 = 6;
    pub const STRETCH_KEEP: i64 = 2;
    pub const STRETCH_KEEP_ASPECT: i64 = 4;
    pub const STRETCH_SCALE: i64 = 0;
    pub const STRETCH_KEEP_CENTERED: i64 = 3;
    pub const STRETCH_TILE: i64 = 1;
}
impl TextureButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TextureButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextureButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TextureButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_click_mask(&self) -> Option<BitMap> {
        TextureButton_get_click_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_disabled_texture(&self) -> Option<Texture> {
        TextureButton_get_disabled_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_expand(&self) -> bool {
        TextureButton_get_expand(self.this)
    }

    #[inline]
    pub unsafe fn get_focused_texture(&self) -> Option<Texture> {
        TextureButton_get_focused_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_hover_texture(&self) -> Option<Texture> {
        TextureButton_get_hover_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_normal_texture(&self) -> Option<Texture> {
        TextureButton_get_normal_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_pressed_texture(&self) -> Option<Texture> {
        TextureButton_get_pressed_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_stretch_mode(&self) -> TextureButtonStretchMode {
        TextureButton_get_stretch_mode(self.this)
    }

    #[inline]
    pub unsafe fn set_click_mask(&mut self, mask: Option<BitMap>) -> () {
        TextureButton_set_click_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_disabled_texture(&mut self, texture: Option<Texture>) -> () {
        TextureButton_set_disabled_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_expand(&mut self, p_expand: bool) -> () {
        TextureButton_set_expand(self.this, p_expand)
    }

    #[inline]
    pub unsafe fn set_focused_texture(&mut self, texture: Option<Texture>) -> () {
        TextureButton_set_focused_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_hover_texture(&mut self, texture: Option<Texture>) -> () {
        TextureButton_set_hover_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_normal_texture(&mut self, texture: Option<Texture>) -> () {
        TextureButton_set_normal_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_pressed_texture(&mut self, texture: Option<Texture>) -> () {
        TextureButton_set_pressed_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_stretch_mode(&mut self, p_mode: i64) -> () {
        TextureButton_set_stretch_mode(self.this, p_mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextureLayered` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texturelayered.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TextureLayered inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextureLayered {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextureLayeredFlags {
    FlagMipmaps = 1,
    FlagRepeat = 2,
    FlagFilter = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TextureLayered {
    pub const FLAG_FILTER: i64 = 4;
    pub const FLAGS_DEFAULT: i64 = 4;
    pub const FLAG_MIPMAPS: i64 = 1;
    pub const FLAG_REPEAT: i64 = 2;
}
impl TextureLayered {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { TextureLayered__get_data(self.this) }
    }

    #[inline]
    pub fn _set_data(&mut self, data: Dictionary) -> () {
        unsafe { TextureLayered__set_data(self.this, data) }
    }

    #[inline]
    pub fn create(&mut self, width: i64, height: i64, depth: i64, format: i64, flags: i64) -> () {
        unsafe { TextureLayered_create(self.this, width, height, depth, format, flags) }
    }

    #[inline]
    pub fn get_depth(&self) -> i64 {
        unsafe { TextureLayered_get_depth(self.this) }
    }

    #[inline]
    pub fn get_flags(&self) -> i64 {
        unsafe { TextureLayered_get_flags(self.this) }
    }

    #[inline]
    pub fn get_format(&self) -> ImageFormat {
        unsafe { TextureLayered_get_format(self.this) }
    }

    #[inline]
    pub fn get_height(&self) -> i64 {
        unsafe { TextureLayered_get_height(self.this) }
    }

    #[inline]
    pub fn get_layer_data(&self, layer: i64) -> Option<Image> {
        unsafe { TextureLayered_get_layer_data(self.this, layer) }
    }

    #[inline]
    pub fn get_width(&self) -> i64 {
        unsafe { TextureLayered_get_width(self.this) }
    }

    #[inline]
    pub fn set_data_partial(&mut self, image: Option<Image>, x_offset: i64, y_offset: i64, layer: i64, mipmap: i64) -> () {
        unsafe { TextureLayered_set_data_partial(self.this, image, x_offset, y_offset, layer, mipmap) }
    }

    #[inline]
    pub fn set_flags(&mut self, flags: i64) -> () {
        unsafe { TextureLayered_set_flags(self.this, flags) }
    }

    #[inline]
    pub fn set_layer_data(&mut self, image: Option<Image>, layer: i64) -> () {
        unsafe { TextureLayered_set_layer_data(self.this, image, layer) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextureProgress` inherits `Range` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_textureprogress.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TextureProgress` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TextureProgress::free`.
///
/// ## Class hierarchy
///
/// TextureProgress inherits methods from:
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextureProgress {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextureProgressFillMode {
    LeftToRight = 0,
    RightToLeft = 1,
    TopToBottom = 2,
    BottomToTop = 3,
    Clockwise = 4,
    CounterClockwise = 5,
    BilinearLeftAndRight = 6,
    BilinearTopAndBottom = 7,
    ClockwiseAndCounterClockwise = 8,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TextureProgress {
    pub const FILL_CLOCKWISE_AND_COUNTER_CLOCKWISE: i64 = 8;
    pub const FILL_COUNTER_CLOCKWISE: i64 = 5;
    pub const FILL_TOP_TO_BOTTOM: i64 = 2;
    pub const FILL_BOTTOM_TO_TOP: i64 = 3;
    pub const FILL_CLOCKWISE: i64 = 4;
    pub const FILL_RIGHT_TO_LEFT: i64 = 1;
    pub const FILL_BILINEAR_TOP_AND_BOTTOM: i64 = 7;
    pub const FILL_LEFT_TO_RIGHT: i64 = 0;
    pub const FILL_BILINEAR_LEFT_AND_RIGHT: i64 = 6;
}
impl TextureProgress {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TextureProgress::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextureProgressMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TextureProgress {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_fill_degrees(&mut self) -> f64 {
        TextureProgress_get_fill_degrees(self.this)
    }

    #[inline]
    pub unsafe fn get_fill_mode(&mut self) -> i64 {
        TextureProgress_get_fill_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_nine_patch_stretch(&self) -> bool {
        TextureProgress_get_nine_patch_stretch(self.this)
    }

    #[inline]
    pub unsafe fn get_over_texture(&self) -> Option<Texture> {
        TextureProgress_get_over_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_progress_texture(&self) -> Option<Texture> {
        TextureProgress_get_progress_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_radial_center_offset(&mut self) -> Vector2 {
        TextureProgress_get_radial_center_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_radial_initial_angle(&mut self) -> f64 {
        TextureProgress_get_radial_initial_angle(self.this)
    }

    #[inline]
    pub unsafe fn get_stretch_margin(&self, margin: i64) -> i64 {
        TextureProgress_get_stretch_margin(self.this, margin)
    }

    #[inline]
    pub unsafe fn get_tint_over(&self) -> Color {
        TextureProgress_get_tint_over(self.this)
    }

    #[inline]
    pub unsafe fn get_tint_progress(&self) -> Color {
        TextureProgress_get_tint_progress(self.this)
    }

    #[inline]
    pub unsafe fn get_tint_under(&self) -> Color {
        TextureProgress_get_tint_under(self.this)
    }

    #[inline]
    pub unsafe fn get_under_texture(&self) -> Option<Texture> {
        TextureProgress_get_under_texture(self.this)
    }

    #[inline]
    pub unsafe fn set_fill_degrees(&mut self, mode: f64) -> () {
        TextureProgress_set_fill_degrees(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_fill_mode(&mut self, mode: i64) -> () {
        TextureProgress_set_fill_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_nine_patch_stretch(&mut self, stretch: bool) -> () {
        TextureProgress_set_nine_patch_stretch(self.this, stretch)
    }

    #[inline]
    pub unsafe fn set_over_texture(&mut self, tex: Option<Texture>) -> () {
        TextureProgress_set_over_texture(self.this, tex)
    }

    #[inline]
    pub unsafe fn set_progress_texture(&mut self, tex: Option<Texture>) -> () {
        TextureProgress_set_progress_texture(self.this, tex)
    }

    #[inline]
    pub unsafe fn set_radial_center_offset(&mut self, mode: Vector2) -> () {
        TextureProgress_set_radial_center_offset(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_radial_initial_angle(&mut self, mode: f64) -> () {
        TextureProgress_set_radial_initial_angle(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_stretch_margin(&mut self, margin: i64, value: i64) -> () {
        TextureProgress_set_stretch_margin(self.this, margin, value)
    }

    #[inline]
    pub unsafe fn set_tint_over(&mut self, tint: Color) -> () {
        TextureProgress_set_tint_over(self.this, tint)
    }

    #[inline]
    pub unsafe fn set_tint_progress(&mut self, tint: Color) -> () {
        TextureProgress_set_tint_progress(self.this, tint)
    }

    #[inline]
    pub unsafe fn set_tint_under(&mut self, tint: Color) -> () {
        TextureProgress_set_tint_under(self.this, tint)
    }

    #[inline]
    pub unsafe fn set_under_texture(&mut self, tex: Option<Texture>) -> () {
        TextureProgress_set_under_texture(self.this, tex)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TextureRect` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_texturerect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TextureRect` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TextureRect::free`.
///
/// ## Class hierarchy
///
/// TextureRect inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TextureRect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TextureRectStretchMode {
    ScaleOnExpand = 0,
    Scale = 1,
    Tile = 2,
    Keep = 3,
    KeepCentered = 4,
    KeepAspect = 5,
    KeepAspectCentered = 6,
    KeepAspectCovered = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TextureRect {
    pub const STRETCH_TILE: i64 = 2;
    pub const STRETCH_SCALE: i64 = 1;
    pub const STRETCH_KEEP_ASPECT: i64 = 5;
    pub const STRETCH_KEEP_ASPECT_CENTERED: i64 = 6;
    pub const STRETCH_KEEP: i64 = 3;
    pub const STRETCH_KEEP_ASPECT_COVERED: i64 = 7;
    pub const STRETCH_KEEP_CENTERED: i64 = 4;
    pub const STRETCH_SCALE_ON_EXPAND: i64 = 0;
}
impl TextureRect {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TextureRect::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TextureRectMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TextureRect {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _texture_changed(&mut self) -> () {
        TextureRect__texture_changed(self.this)
    }

    #[inline]
    pub unsafe fn get_stretch_mode(&self) -> TextureRectStretchMode {
        TextureRect_get_stretch_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        TextureRect_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn has_expand(&self) -> bool {
        TextureRect_has_expand(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_h(&self) -> bool {
        TextureRect_is_flipped_h(self.this)
    }

    #[inline]
    pub unsafe fn is_flipped_v(&self) -> bool {
        TextureRect_is_flipped_v(self.this)
    }

    #[inline]
    pub unsafe fn set_expand(&mut self, enable: bool) -> () {
        TextureRect_set_expand(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_flip_h(&mut self, enable: bool) -> () {
        TextureRect_set_flip_h(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_flip_v(&mut self, enable: bool) -> () {
        TextureRect_set_flip_v(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_stretch_mode(&mut self, stretch_mode: i64) -> () {
        TextureRect_set_stretch_mode(self.this, stretch_mode)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        TextureRect_set_texture(self.this, texture)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Theme` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_theme.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Theme inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Theme {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Theme {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ThemeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Theme {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _emit_theme_changed(&mut self) -> () {
        unsafe { Theme__emit_theme_changed(self.this) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { Theme_clear(self.this) }
    }

    #[inline]
    pub fn clear_color(&mut self, name: GodotString, _type: GodotString) -> () {
        unsafe { Theme_clear_color(self.this, name, _type) }
    }

    #[inline]
    pub fn clear_constant(&mut self, name: GodotString, _type: GodotString) -> () {
        unsafe { Theme_clear_constant(self.this, name, _type) }
    }

    #[inline]
    pub fn clear_font(&mut self, name: GodotString, _type: GodotString) -> () {
        unsafe { Theme_clear_font(self.this, name, _type) }
    }

    #[inline]
    pub fn clear_icon(&mut self, name: GodotString, _type: GodotString) -> () {
        unsafe { Theme_clear_icon(self.this, name, _type) }
    }

    #[inline]
    pub fn clear_stylebox(&mut self, name: GodotString, _type: GodotString) -> () {
        unsafe { Theme_clear_stylebox(self.this, name, _type) }
    }

    #[inline]
    pub fn copy_default_theme(&mut self) -> () {
        unsafe { Theme_copy_default_theme(self.this) }
    }

    #[inline]
    pub fn copy_theme(&mut self, other: Option<Theme>) -> () {
        unsafe { Theme_copy_theme(self.this, other) }
    }

    #[inline]
    pub fn get_color(&self, name: GodotString, _type: GodotString) -> Color {
        unsafe { Theme_get_color(self.this, name, _type) }
    }

    #[inline]
    pub fn get_color_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_color_list(self.this, _type) }
    }

    #[inline]
    pub fn get_constant(&self, name: GodotString, _type: GodotString) -> i64 {
        unsafe { Theme_get_constant(self.this, name, _type) }
    }

    #[inline]
    pub fn get_constant_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_constant_list(self.this, _type) }
    }

    #[inline]
    pub fn get_default_font(&self) -> Option<Font> {
        unsafe { Theme_get_default_font(self.this) }
    }

    #[inline]
    pub fn get_font(&self, name: GodotString, _type: GodotString) -> Option<Font> {
        unsafe { Theme_get_font(self.this, name, _type) }
    }

    #[inline]
    pub fn get_font_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_font_list(self.this, _type) }
    }

    #[inline]
    pub fn get_icon(&self, name: GodotString, _type: GodotString) -> Option<Texture> {
        unsafe { Theme_get_icon(self.this, name, _type) }
    }

    #[inline]
    pub fn get_icon_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_icon_list(self.this, _type) }
    }

    #[inline]
    pub fn get_stylebox(&self, name: GodotString, _type: GodotString) -> Option<StyleBox> {
        unsafe { Theme_get_stylebox(self.this, name, _type) }
    }

    #[inline]
    pub fn get_stylebox_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_stylebox_list(self.this, _type) }
    }

    #[inline]
    pub fn get_stylebox_types(&self) -> StringArray {
        unsafe { Theme_get_stylebox_types(self.this) }
    }

    #[inline]
    pub fn get_type_list(&self, _type: GodotString) -> StringArray {
        unsafe { Theme_get_type_list(self.this, _type) }
    }

    #[inline]
    pub fn has_color(&self, name: GodotString, _type: GodotString) -> bool {
        unsafe { Theme_has_color(self.this, name, _type) }
    }

    #[inline]
    pub fn has_constant(&self, name: GodotString, _type: GodotString) -> bool {
        unsafe { Theme_has_constant(self.this, name, _type) }
    }

    #[inline]
    pub fn has_font(&self, name: GodotString, _type: GodotString) -> bool {
        unsafe { Theme_has_font(self.this, name, _type) }
    }

    #[inline]
    pub fn has_icon(&self, name: GodotString, _type: GodotString) -> bool {
        unsafe { Theme_has_icon(self.this, name, _type) }
    }

    #[inline]
    pub fn has_stylebox(&self, name: GodotString, _type: GodotString) -> bool {
        unsafe { Theme_has_stylebox(self.this, name, _type) }
    }

    #[inline]
    pub fn set_color(&mut self, name: GodotString, _type: GodotString, color: Color) -> () {
        unsafe { Theme_set_color(self.this, name, _type, color) }
    }

    #[inline]
    pub fn set_constant(&mut self, name: GodotString, _type: GodotString, constant: i64) -> () {
        unsafe { Theme_set_constant(self.this, name, _type, constant) }
    }

    #[inline]
    pub fn set_default_font(&mut self, font: Option<Font>) -> () {
        unsafe { Theme_set_default_font(self.this, font) }
    }

    #[inline]
    pub fn set_font(&mut self, name: GodotString, _type: GodotString, font: Option<Font>) -> () {
        unsafe { Theme_set_font(self.this, name, _type, font) }
    }

    #[inline]
    pub fn set_icon(&mut self, name: GodotString, _type: GodotString, texture: Option<Texture>) -> () {
        unsafe { Theme_set_icon(self.this, name, _type, texture) }
    }

    #[inline]
    pub fn set_stylebox(&mut self, name: GodotString, _type: GodotString, texture: Option<StyleBox>) -> () {
        unsafe { Theme_set_stylebox(self.this, name, _type, texture) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TileMap` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tilemap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TileMap` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TileMap::free`.
///
/// ## Class hierarchy
///
/// TileMap inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TileMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileMapMode {
    ModeSquare = 0,
    ModeIsometric = 1,
    ModeCustom = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileMapTileOrigin {
    TopLeft = 0,
    Center = 1,
    BottomLeft = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileMapHalfOffset {
    X = 0,
    Y = 1,
    Disabled = 2,
    NegativeX = 3,
    NegativeY = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TileMap {
    pub const HALF_OFFSET_Y: i64 = 1;
    pub const INVALID_CELL: i64 = -1;
    pub const MODE_ISOMETRIC: i64 = 1;
    pub const HALF_OFFSET_NEGATIVE_Y: i64 = 4;
    pub const HALF_OFFSET_NEGATIVE_X: i64 = 3;
    pub const HALF_OFFSET_X: i64 = 0;
    pub const MODE_CUSTOM: i64 = 2;
    pub const MODE_SQUARE: i64 = 0;
    pub const TILE_ORIGIN_BOTTOM_LEFT: i64 = 2;
    pub const TILE_ORIGIN_CENTER: i64 = 1;
    pub const TILE_ORIGIN_TOP_LEFT: i64 = 0;
    pub const HALF_OFFSET_DISABLED: i64 = 2;
}
impl TileMap {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TileMap::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TileMapMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TileMap {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _clear_quadrants(&mut self) -> () {
        TileMap__clear_quadrants(self.this)
    }

    #[inline]
    pub unsafe fn _get_old_cell_size(&self) -> i64 {
        TileMap__get_old_cell_size(self.this)
    }

    #[inline]
    pub unsafe fn _get_tile_data(&self) -> Int32Array {
        TileMap__get_tile_data(self.this)
    }

    #[inline]
    pub unsafe fn _recreate_quadrants(&mut self) -> () {
        TileMap__recreate_quadrants(self.this)
    }

    #[inline]
    pub unsafe fn _set_celld(&mut self, position: Vector2, data: Dictionary) -> () {
        TileMap__set_celld(self.this, position, data)
    }

    #[inline]
    pub unsafe fn _set_old_cell_size(&mut self, size: i64) -> () {
        TileMap__set_old_cell_size(self.this, size)
    }

    #[inline]
    pub unsafe fn _set_tile_data(&mut self, arg0: Int32Array) -> () {
        TileMap__set_tile_data(self.this, arg0)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        TileMap_clear(self.this)
    }

    #[inline]
    pub unsafe fn fix_invalid_tiles(&mut self) -> () {
        TileMap_fix_invalid_tiles(self.this)
    }

    #[inline]
    pub unsafe fn get_cell(&self, x: i64, y: i64) -> i64 {
        TileMap_get_cell(self.this, x, y)
    }

    #[inline]
    pub unsafe fn get_cell_autotile_coord(&self, x: i64, y: i64) -> Vector2 {
        TileMap_get_cell_autotile_coord(self.this, x, y)
    }

    #[inline]
    pub unsafe fn get_cell_size(&self) -> Vector2 {
        TileMap_get_cell_size(self.this)
    }

    #[inline]
    pub unsafe fn get_cellv(&self, position: Vector2) -> i64 {
        TileMap_get_cellv(self.this, position)
    }

    #[inline]
    pub unsafe fn get_clip_uv(&self) -> bool {
        TileMap_get_clip_uv(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_bounce(&self) -> f64 {
        TileMap_get_collision_bounce(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_friction(&self) -> f64 {
        TileMap_get_collision_friction(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer(&self) -> i64 {
        TileMap_get_collision_layer(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_layer_bit(&self, bit: i64) -> bool {
        TileMap_get_collision_layer_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_mask(&self) -> i64 {
        TileMap_get_collision_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_mask_bit(&self, bit: i64) -> bool {
        TileMap_get_collision_mask_bit(self.this, bit)
    }

    #[inline]
    pub unsafe fn get_collision_use_kinematic(&self) -> bool {
        TileMap_get_collision_use_kinematic(self.this)
    }

    #[inline]
    pub unsafe fn get_collision_use_parent(&self) -> bool {
        TileMap_get_collision_use_parent(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_transform(&self) -> Transform2D {
        TileMap_get_custom_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_half_offset(&self) -> TileMapHalfOffset {
        TileMap_get_half_offset(self.this)
    }

    #[inline]
    pub unsafe fn get_mode(&self) -> TileMapMode {
        TileMap_get_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_occluder_light_mask(&self) -> i64 {
        TileMap_get_occluder_light_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_quadrant_size(&self) -> i64 {
        TileMap_get_quadrant_size(self.this)
    }

    #[inline]
    pub unsafe fn get_tile_origin(&self) -> TileMapTileOrigin {
        TileMap_get_tile_origin(self.this)
    }

    #[inline]
    pub unsafe fn get_tileset(&self) -> Option<TileSet> {
        TileMap_get_tileset(self.this)
    }

    #[inline]
    pub unsafe fn get_used_cells(&self) -> VariantArray {
        TileMap_get_used_cells(self.this)
    }

    #[inline]
    pub unsafe fn get_used_cells_by_id(&self, id: i64) -> VariantArray {
        TileMap_get_used_cells_by_id(self.this, id)
    }

    #[inline]
    pub unsafe fn get_used_rect(&mut self) -> Rect2 {
        TileMap_get_used_rect(self.this)
    }

    #[inline]
    pub unsafe fn is_cell_transposed(&self, x: i64, y: i64) -> bool {
        TileMap_is_cell_transposed(self.this, x, y)
    }

    #[inline]
    pub unsafe fn is_cell_x_flipped(&self, x: i64, y: i64) -> bool {
        TileMap_is_cell_x_flipped(self.this, x, y)
    }

    #[inline]
    pub unsafe fn is_cell_y_flipped(&self, x: i64, y: i64) -> bool {
        TileMap_is_cell_y_flipped(self.this, x, y)
    }

    #[inline]
    pub unsafe fn is_centered_textures_enabled(&self) -> bool {
        TileMap_is_centered_textures_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_compatibility_mode_enabled(&self) -> bool {
        TileMap_is_compatibility_mode_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_y_sort_mode_enabled(&self) -> bool {
        TileMap_is_y_sort_mode_enabled(self.this)
    }

    #[inline]
    pub unsafe fn map_to_world(&self, map_position: Vector2, ignore_half_ofs: bool) -> Vector2 {
        TileMap_map_to_world(self.this, map_position, ignore_half_ofs)
    }

    #[inline]
    pub unsafe fn set_cell(&mut self, x: i64, y: i64, tile: i64, flip_x: bool, flip_y: bool, transpose: bool, autotile_coord: Vector2) -> () {
        TileMap_set_cell(self.this, x, y, tile, flip_x, flip_y, transpose, autotile_coord)
    }

    #[inline]
    pub unsafe fn set_cell_size(&mut self, size: Vector2) -> () {
        TileMap_set_cell_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_cellv(&mut self, position: Vector2, tile: i64, flip_x: bool, flip_y: bool, transpose: bool) -> () {
        TileMap_set_cellv(self.this, position, tile, flip_x, flip_y, transpose)
    }

    #[inline]
    pub unsafe fn set_centered_textures(&mut self, enable: bool) -> () {
        TileMap_set_centered_textures(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_clip_uv(&mut self, enable: bool) -> () {
        TileMap_set_clip_uv(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_collision_bounce(&mut self, value: f64) -> () {
        TileMap_set_collision_bounce(self.this, value)
    }

    #[inline]
    pub unsafe fn set_collision_friction(&mut self, value: f64) -> () {
        TileMap_set_collision_friction(self.this, value)
    }

    #[inline]
    pub unsafe fn set_collision_layer(&mut self, layer: i64) -> () {
        TileMap_set_collision_layer(self.this, layer)
    }

    #[inline]
    pub unsafe fn set_collision_layer_bit(&mut self, bit: i64, value: bool) -> () {
        TileMap_set_collision_layer_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_mask(&mut self, mask: i64) -> () {
        TileMap_set_collision_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_collision_mask_bit(&mut self, bit: i64, value: bool) -> () {
        TileMap_set_collision_mask_bit(self.this, bit, value)
    }

    #[inline]
    pub unsafe fn set_collision_use_kinematic(&mut self, use_kinematic: bool) -> () {
        TileMap_set_collision_use_kinematic(self.this, use_kinematic)
    }

    #[inline]
    pub unsafe fn set_collision_use_parent(&mut self, use_parent: bool) -> () {
        TileMap_set_collision_use_parent(self.this, use_parent)
    }

    #[inline]
    pub unsafe fn set_compatibility_mode(&mut self, enable: bool) -> () {
        TileMap_set_compatibility_mode(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_custom_transform(&mut self, custom_transform: Transform2D) -> () {
        TileMap_set_custom_transform(self.this, custom_transform)
    }

    #[inline]
    pub unsafe fn set_half_offset(&mut self, half_offset: i64) -> () {
        TileMap_set_half_offset(self.this, half_offset)
    }

    #[inline]
    pub unsafe fn set_mode(&mut self, mode: i64) -> () {
        TileMap_set_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_occluder_light_mask(&mut self, mask: i64) -> () {
        TileMap_set_occluder_light_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_quadrant_size(&mut self, size: i64) -> () {
        TileMap_set_quadrant_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_tile_origin(&mut self, origin: i64) -> () {
        TileMap_set_tile_origin(self.this, origin)
    }

    #[inline]
    pub unsafe fn set_tileset(&mut self, tileset: Option<TileSet>) -> () {
        TileMap_set_tileset(self.this, tileset)
    }

    #[inline]
    pub unsafe fn set_y_sort_mode(&mut self, enable: bool) -> () {
        TileMap_set_y_sort_mode(self.this, enable)
    }

    #[inline]
    pub unsafe fn update_bitmask_area(&mut self, position: Vector2) -> () {
        TileMap_update_bitmask_area(self.this, position)
    }

    #[inline]
    pub unsafe fn update_bitmask_region(&mut self, start: Vector2, end: Vector2) -> () {
        TileMap_update_bitmask_region(self.this, start, end)
    }

    #[inline]
    pub unsafe fn update_dirty_quadrants(&mut self) -> () {
        TileMap_update_dirty_quadrants(self.this)
    }

    #[inline]
    pub unsafe fn world_to_map(&self, world_position: Vector2) -> Vector2 {
        TileMap_world_to_map(self.this, world_position)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TileSet` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tileset.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TileSet inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TileSet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileSetTileMode {
    SingleTile = 0,
    AutoTile = 1,
    AtlasTile = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileSetAutotileBindings {
    BindTopleft = 1,
    BindTop = 2,
    BindTopright = 4,
    BindLeft = 8,
    BindCenter = 16,
    BindRight = 32,
    BindBottomleft = 64,
    BindBottom = 128,
    BindBottomright = 256,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TileSetBitmaskMode {
    Bitmask2x2 = 0,
    Bitmask3x3Minimal = 1,
    Bitmask3x3 = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TileSet {
    pub const AUTO_TILE: i64 = 1;
    pub const BIND_BOTTOM: i64 = 128;
    pub const BIND_BOTTOMRIGHT: i64 = 256;
    pub const ATLAS_TILE: i64 = 2;
    pub const BIND_TOPLEFT: i64 = 1;
    pub const BITMASK_2X2: i64 = 0;
    pub const BITMASK_3X3_MINIMAL: i64 = 1;
    pub const BIND_BOTTOMLEFT: i64 = 64;
    pub const BIND_TOPRIGHT: i64 = 4;
    pub const BITMASK_3X3: i64 = 2;
    pub const BIND_LEFT: i64 = 8;
    pub const BIND_TOP: i64 = 2;
    pub const BIND_RIGHT: i64 = 32;
    pub const BIND_CENTER: i64 = 16;
    pub const SINGLE_TILE: i64 = 0;
}
impl TileSet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TileSetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            TileSet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _forward_atlas_subtile_selection(&mut self, atlastile_id: i64, tilemap: Option<Object>, tile_location: Vector2) -> Vector2 {
        unsafe { TileSet__forward_atlas_subtile_selection(self.this, atlastile_id, tilemap, tile_location) }
    }

    #[inline]
    pub fn _forward_subtile_selection(&mut self, autotile_id: i64, bitmask: i64, tilemap: Option<Object>, tile_location: Vector2) -> Vector2 {
        unsafe { TileSet__forward_subtile_selection(self.this, autotile_id, bitmask, tilemap, tile_location) }
    }

    #[inline]
    pub fn _is_tile_bound(&mut self, drawn_id: i64, neighbor_id: i64) -> bool {
        unsafe { TileSet__is_tile_bound(self.this, drawn_id, neighbor_id) }
    }

    #[inline]
    pub fn autotile_clear_bitmask_map(&mut self, id: i64) -> () {
        unsafe { TileSet_autotile_clear_bitmask_map(self.this, id) }
    }

    #[inline]
    pub fn autotile_get_bitmask(&mut self, id: i64, coord: Vector2) -> i64 {
        unsafe { TileSet_autotile_get_bitmask(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_get_bitmask_mode(&self, id: i64) -> TileSetBitmaskMode {
        unsafe { TileSet_autotile_get_bitmask_mode(self.this, id) }
    }

    #[inline]
    pub fn autotile_get_icon_coordinate(&self, id: i64) -> Vector2 {
        unsafe { TileSet_autotile_get_icon_coordinate(self.this, id) }
    }

    #[inline]
    pub fn autotile_get_light_occluder(&self, id: i64, coord: Vector2) -> Option<OccluderPolygon2D> {
        unsafe { TileSet_autotile_get_light_occluder(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_get_navigation_polygon(&self, id: i64, coord: Vector2) -> Option<NavigationPolygon> {
        unsafe { TileSet_autotile_get_navigation_polygon(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_get_size(&self, id: i64) -> Vector2 {
        unsafe { TileSet_autotile_get_size(self.this, id) }
    }

    #[inline]
    pub fn autotile_get_spacing(&self, id: i64) -> i64 {
        unsafe { TileSet_autotile_get_spacing(self.this, id) }
    }

    #[inline]
    pub fn autotile_get_subtile_priority(&mut self, id: i64, coord: Vector2) -> i64 {
        unsafe { TileSet_autotile_get_subtile_priority(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_get_z_index(&mut self, id: i64, coord: Vector2) -> i64 {
        unsafe { TileSet_autotile_get_z_index(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_set_bitmask(&mut self, id: i64, bitmask: Vector2, flag: i64) -> () {
        unsafe { TileSet_autotile_set_bitmask(self.this, id, bitmask, flag) }
    }

    #[inline]
    pub fn autotile_set_bitmask_mode(&mut self, id: i64, mode: i64) -> () {
        unsafe { TileSet_autotile_set_bitmask_mode(self.this, id, mode) }
    }

    #[inline]
    pub fn autotile_set_icon_coordinate(&mut self, id: i64, coord: Vector2) -> () {
        unsafe { TileSet_autotile_set_icon_coordinate(self.this, id, coord) }
    }

    #[inline]
    pub fn autotile_set_light_occluder(&mut self, id: i64, light_occluder: Option<OccluderPolygon2D>, coord: Vector2) -> () {
        unsafe { TileSet_autotile_set_light_occluder(self.this, id, light_occluder, coord) }
    }

    #[inline]
    pub fn autotile_set_navigation_polygon(&mut self, id: i64, navigation_polygon: Option<NavigationPolygon>, coord: Vector2) -> () {
        unsafe { TileSet_autotile_set_navigation_polygon(self.this, id, navigation_polygon, coord) }
    }

    #[inline]
    pub fn autotile_set_size(&mut self, id: i64, size: Vector2) -> () {
        unsafe { TileSet_autotile_set_size(self.this, id, size) }
    }

    #[inline]
    pub fn autotile_set_spacing(&mut self, id: i64, spacing: i64) -> () {
        unsafe { TileSet_autotile_set_spacing(self.this, id, spacing) }
    }

    #[inline]
    pub fn autotile_set_subtile_priority(&mut self, id: i64, coord: Vector2, priority: i64) -> () {
        unsafe { TileSet_autotile_set_subtile_priority(self.this, id, coord, priority) }
    }

    #[inline]
    pub fn autotile_set_z_index(&mut self, id: i64, coord: Vector2, z_index: i64) -> () {
        unsafe { TileSet_autotile_set_z_index(self.this, id, coord, z_index) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { TileSet_clear(self.this) }
    }

    #[inline]
    pub fn create_tile(&mut self, id: i64) -> () {
        unsafe { TileSet_create_tile(self.this, id) }
    }

    #[inline]
    pub fn find_tile_by_name(&self, name: GodotString) -> i64 {
        unsafe { TileSet_find_tile_by_name(self.this, name) }
    }

    #[inline]
    pub fn get_last_unused_tile_id(&self) -> i64 {
        unsafe { TileSet_get_last_unused_tile_id(self.this) }
    }

    #[inline]
    pub fn get_tiles_ids(&self) -> VariantArray {
        unsafe { TileSet_get_tiles_ids(self.this) }
    }

    #[inline]
    pub fn remove_tile(&mut self, id: i64) -> () {
        unsafe { TileSet_remove_tile(self.this, id) }
    }

    #[inline]
    pub fn tile_add_shape(&mut self, id: i64, shape: Option<Shape2D>, shape_transform: Transform2D, one_way: bool, autotile_coord: Vector2) -> () {
        unsafe { TileSet_tile_add_shape(self.this, id, shape, shape_transform, one_way, autotile_coord) }
    }

    #[inline]
    pub fn tile_get_light_occluder(&self, id: i64) -> Option<OccluderPolygon2D> {
        unsafe { TileSet_tile_get_light_occluder(self.this, id) }
    }

    #[inline]
    pub fn tile_get_material(&self, id: i64) -> Option<ShaderMaterial> {
        unsafe { TileSet_tile_get_material(self.this, id) }
    }

    #[inline]
    pub fn tile_get_modulate(&self, id: i64) -> Color {
        unsafe { TileSet_tile_get_modulate(self.this, id) }
    }

    #[inline]
    pub fn tile_get_name(&self, id: i64) -> GodotString {
        unsafe { TileSet_tile_get_name(self.this, id) }
    }

    #[inline]
    pub fn tile_get_navigation_polygon(&self, id: i64) -> Option<NavigationPolygon> {
        unsafe { TileSet_tile_get_navigation_polygon(self.this, id) }
    }

    #[inline]
    pub fn tile_get_navigation_polygon_offset(&self, id: i64) -> Vector2 {
        unsafe { TileSet_tile_get_navigation_polygon_offset(self.this, id) }
    }

    #[inline]
    pub fn tile_get_normal_map(&self, id: i64) -> Option<Texture> {
        unsafe { TileSet_tile_get_normal_map(self.this, id) }
    }

    #[inline]
    pub fn tile_get_occluder_offset(&self, id: i64) -> Vector2 {
        unsafe { TileSet_tile_get_occluder_offset(self.this, id) }
    }

    #[inline]
    pub fn tile_get_region(&self, id: i64) -> Rect2 {
        unsafe { TileSet_tile_get_region(self.this, id) }
    }

    #[inline]
    pub fn tile_get_shape(&self, id: i64, shape_id: i64) -> Option<Shape2D> {
        unsafe { TileSet_tile_get_shape(self.this, id, shape_id) }
    }

    #[inline]
    pub fn tile_get_shape_count(&self, id: i64) -> i64 {
        unsafe { TileSet_tile_get_shape_count(self.this, id) }
    }

    #[inline]
    pub fn tile_get_shape_offset(&self, id: i64, shape_id: i64) -> Vector2 {
        unsafe { TileSet_tile_get_shape_offset(self.this, id, shape_id) }
    }

    #[inline]
    pub fn tile_get_shape_one_way(&self, id: i64, shape_id: i64) -> bool {
        unsafe { TileSet_tile_get_shape_one_way(self.this, id, shape_id) }
    }

    #[inline]
    pub fn tile_get_shape_one_way_margin(&self, id: i64, shape_id: i64) -> f64 {
        unsafe { TileSet_tile_get_shape_one_way_margin(self.this, id, shape_id) }
    }

    #[inline]
    pub fn tile_get_shape_transform(&self, id: i64, shape_id: i64) -> Transform2D {
        unsafe { TileSet_tile_get_shape_transform(self.this, id, shape_id) }
    }

    #[inline]
    pub fn tile_get_shapes(&self, id: i64) -> VariantArray {
        unsafe { TileSet_tile_get_shapes(self.this, id) }
    }

    #[inline]
    pub fn tile_get_texture(&self, id: i64) -> Option<Texture> {
        unsafe { TileSet_tile_get_texture(self.this, id) }
    }

    #[inline]
    pub fn tile_get_texture_offset(&self, id: i64) -> Vector2 {
        unsafe { TileSet_tile_get_texture_offset(self.this, id) }
    }

    #[inline]
    pub fn tile_get_tile_mode(&self, id: i64) -> TileSetTileMode {
        unsafe { TileSet_tile_get_tile_mode(self.this, id) }
    }

    #[inline]
    pub fn tile_get_z_index(&self, id: i64) -> i64 {
        unsafe { TileSet_tile_get_z_index(self.this, id) }
    }

    #[inline]
    pub fn tile_set_light_occluder(&mut self, id: i64, light_occluder: Option<OccluderPolygon2D>) -> () {
        unsafe { TileSet_tile_set_light_occluder(self.this, id, light_occluder) }
    }

    #[inline]
    pub fn tile_set_material(&mut self, id: i64, material: Option<ShaderMaterial>) -> () {
        unsafe { TileSet_tile_set_material(self.this, id, material) }
    }

    #[inline]
    pub fn tile_set_modulate(&mut self, id: i64, color: Color) -> () {
        unsafe { TileSet_tile_set_modulate(self.this, id, color) }
    }

    #[inline]
    pub fn tile_set_name(&mut self, id: i64, name: GodotString) -> () {
        unsafe { TileSet_tile_set_name(self.this, id, name) }
    }

    #[inline]
    pub fn tile_set_navigation_polygon(&mut self, id: i64, navigation_polygon: Option<NavigationPolygon>) -> () {
        unsafe { TileSet_tile_set_navigation_polygon(self.this, id, navigation_polygon) }
    }

    #[inline]
    pub fn tile_set_navigation_polygon_offset(&mut self, id: i64, navigation_polygon_offset: Vector2) -> () {
        unsafe { TileSet_tile_set_navigation_polygon_offset(self.this, id, navigation_polygon_offset) }
    }

    #[inline]
    pub fn tile_set_normal_map(&mut self, id: i64, normal_map: Option<Texture>) -> () {
        unsafe { TileSet_tile_set_normal_map(self.this, id, normal_map) }
    }

    #[inline]
    pub fn tile_set_occluder_offset(&mut self, id: i64, occluder_offset: Vector2) -> () {
        unsafe { TileSet_tile_set_occluder_offset(self.this, id, occluder_offset) }
    }

    #[inline]
    pub fn tile_set_region(&mut self, id: i64, region: Rect2) -> () {
        unsafe { TileSet_tile_set_region(self.this, id, region) }
    }

    #[inline]
    pub fn tile_set_shape(&mut self, id: i64, shape_id: i64, shape: Option<Shape2D>) -> () {
        unsafe { TileSet_tile_set_shape(self.this, id, shape_id, shape) }
    }

    #[inline]
    pub fn tile_set_shape_offset(&mut self, id: i64, shape_id: i64, shape_offset: Vector2) -> () {
        unsafe { TileSet_tile_set_shape_offset(self.this, id, shape_id, shape_offset) }
    }

    #[inline]
    pub fn tile_set_shape_one_way(&mut self, id: i64, shape_id: i64, one_way: bool) -> () {
        unsafe { TileSet_tile_set_shape_one_way(self.this, id, shape_id, one_way) }
    }

    #[inline]
    pub fn tile_set_shape_one_way_margin(&mut self, id: i64, shape_id: i64, one_way: f64) -> () {
        unsafe { TileSet_tile_set_shape_one_way_margin(self.this, id, shape_id, one_way) }
    }

    #[inline]
    pub fn tile_set_shape_transform(&mut self, id: i64, shape_id: i64, shape_transform: Transform2D) -> () {
        unsafe { TileSet_tile_set_shape_transform(self.this, id, shape_id, shape_transform) }
    }

    #[inline]
    pub fn tile_set_shapes(&mut self, id: i64, shapes: VariantArray) -> () {
        unsafe { TileSet_tile_set_shapes(self.this, id, shapes) }
    }

    #[inline]
    pub fn tile_set_texture(&mut self, id: i64, texture: Option<Texture>) -> () {
        unsafe { TileSet_tile_set_texture(self.this, id, texture) }
    }

    #[inline]
    pub fn tile_set_texture_offset(&mut self, id: i64, texture_offset: Vector2) -> () {
        unsafe { TileSet_tile_set_texture_offset(self.this, id, texture_offset) }
    }

    #[inline]
    pub fn tile_set_tile_mode(&mut self, id: i64, tilemode: i64) -> () {
        unsafe { TileSet_tile_set_tile_mode(self.this, id, tilemode) }
    }

    #[inline]
    pub fn tile_set_z_index(&mut self, id: i64, z_index: i64) -> () {
        unsafe { TileSet_tile_set_z_index(self.this, id, z_index) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Timer` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_timer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Timer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Timer::free`.
///
/// ## Class hierarchy
///
/// Timer inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Timer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TimerTimerProcessMode {
    Physics = 0,
    Idle = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Timer {
    pub const TIMER_PROCESS_PHYSICS: i64 = 0;
    pub const TIMER_PROCESS_IDLE: i64 = 1;
}
impl Timer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Timer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TimerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Timer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_time_left(&self) -> f64 {
        Timer_get_time_left(self.this)
    }

    #[inline]
    pub unsafe fn get_timer_process_mode(&self) -> TimerTimerProcessMode {
        Timer_get_timer_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_wait_time(&self) -> f64 {
        Timer_get_wait_time(self.this)
    }

    #[inline]
    pub unsafe fn has_autostart(&self) -> bool {
        Timer_has_autostart(self.this)
    }

    #[inline]
    pub unsafe fn is_one_shot(&self) -> bool {
        Timer_is_one_shot(self.this)
    }

    #[inline]
    pub unsafe fn is_paused(&self) -> bool {
        Timer_is_paused(self.this)
    }

    #[inline]
    pub unsafe fn is_stopped(&self) -> bool {
        Timer_is_stopped(self.this)
    }

    #[inline]
    pub unsafe fn set_autostart(&mut self, enable: bool) -> () {
        Timer_set_autostart(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_one_shot(&mut self, enable: bool) -> () {
        Timer_set_one_shot(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_paused(&mut self, paused: bool) -> () {
        Timer_set_paused(self.this, paused)
    }

    #[inline]
    pub unsafe fn set_timer_process_mode(&mut self, mode: i64) -> () {
        Timer_set_timer_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_wait_time(&mut self, time_sec: f64) -> () {
        Timer_set_wait_time(self.this, time_sec)
    }

    #[inline]
    pub unsafe fn start(&mut self, time_sec: f64) -> () {
        Timer_start(self.this, time_sec)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        Timer_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ToolButton` inherits `Button` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_toolbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ToolButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ToolButton::free`.
///
/// ## Class hierarchy
///
/// ToolButton inherits methods from:
/// - [Button](struct.Button.html)
/// - [BaseButton](struct.BaseButton.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ToolButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ToolButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ToolButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ToolButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ToolButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_button(&self) -> Button {
        // Not reference-counted.
        Button { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_base_button(&self) -> BaseButton {
        // Not reference-counted.
        BaseButton { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TouchScreenButton` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_touchscreenbutton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `TouchScreenButton` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `TouchScreenButton::free`.
///
/// ## Class hierarchy
///
/// TouchScreenButton inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TouchScreenButton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TouchScreenButtonVisibilityMode {
    Always = 0,
    TouchscreenOnly = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TouchScreenButton {
    pub const VISIBILITY_ALWAYS: i64 = 0;
    pub const VISIBILITY_TOUCHSCREEN_ONLY: i64 = 1;
}
impl TouchScreenButton {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `TouchScreenButton::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TouchScreenButtonMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            TouchScreenButton {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _input(&mut self, arg0: Option<InputEvent>) -> () {
        TouchScreenButton__input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_action(&self) -> GodotString {
        TouchScreenButton_get_action(self.this)
    }

    #[inline]
    pub unsafe fn get_bitmask(&self) -> Option<BitMap> {
        TouchScreenButton_get_bitmask(self.this)
    }

    #[inline]
    pub unsafe fn get_shape(&self) -> Option<Shape2D> {
        TouchScreenButton_get_shape(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<Texture> {
        TouchScreenButton_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_texture_pressed(&self) -> Option<Texture> {
        TouchScreenButton_get_texture_pressed(self.this)
    }

    #[inline]
    pub unsafe fn get_visibility_mode(&self) -> TouchScreenButtonVisibilityMode {
        TouchScreenButton_get_visibility_mode(self.this)
    }

    #[inline]
    pub unsafe fn is_passby_press_enabled(&self) -> bool {
        TouchScreenButton_is_passby_press_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_pressed(&self) -> bool {
        TouchScreenButton_is_pressed(self.this)
    }

    #[inline]
    pub unsafe fn is_shape_centered(&self) -> bool {
        TouchScreenButton_is_shape_centered(self.this)
    }

    #[inline]
    pub unsafe fn is_shape_visible(&self) -> bool {
        TouchScreenButton_is_shape_visible(self.this)
    }

    #[inline]
    pub unsafe fn set_action(&mut self, action: GodotString) -> () {
        TouchScreenButton_set_action(self.this, action)
    }

    #[inline]
    pub unsafe fn set_bitmask(&mut self, bitmask: Option<BitMap>) -> () {
        TouchScreenButton_set_bitmask(self.this, bitmask)
    }

    #[inline]
    pub unsafe fn set_passby_press(&mut self, enabled: bool) -> () {
        TouchScreenButton_set_passby_press(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_shape(&mut self, shape: Option<Shape2D>) -> () {
        TouchScreenButton_set_shape(self.this, shape)
    }

    #[inline]
    pub unsafe fn set_shape_centered(&mut self, bool: bool) -> () {
        TouchScreenButton_set_shape_centered(self.this, bool)
    }

    #[inline]
    pub unsafe fn set_shape_visible(&mut self, bool: bool) -> () {
        TouchScreenButton_set_shape_visible(self.this, bool)
    }

    #[inline]
    pub unsafe fn set_texture(&mut self, texture: Option<Texture>) -> () {
        TouchScreenButton_set_texture(self.this, texture)
    }

    #[inline]
    pub unsafe fn set_texture_pressed(&mut self, texture_pressed: Option<Texture>) -> () {
        TouchScreenButton_set_texture_pressed(self.this, texture_pressed)
    }

    #[inline]
    pub unsafe fn set_visibility_mode(&mut self, mode: i64) -> () {
        TouchScreenButton_set_visibility_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Translation` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_translation.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Translation inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Translation {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Translation {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TranslationMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Translation {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_messages(&self) -> StringArray {
        unsafe { Translation__get_messages(self.this) }
    }

    #[inline]
    pub fn _set_messages(&mut self, arg0: StringArray) -> () {
        unsafe { Translation__set_messages(self.this, arg0) }
    }

    #[inline]
    pub fn add_message(&mut self, src_message: GodotString, xlated_message: GodotString) -> () {
        unsafe { Translation_add_message(self.this, src_message, xlated_message) }
    }

    #[inline]
    pub fn erase_message(&mut self, src_message: GodotString) -> () {
        unsafe { Translation_erase_message(self.this, src_message) }
    }

    #[inline]
    pub fn get_locale(&self) -> GodotString {
        unsafe { Translation_get_locale(self.this) }
    }

    #[inline]
    pub fn get_message(&self, src_message: GodotString) -> GodotString {
        unsafe { Translation_get_message(self.this, src_message) }
    }

    #[inline]
    pub fn get_message_count(&self) -> i64 {
        unsafe { Translation_get_message_count(self.this) }
    }

    #[inline]
    pub fn get_message_list(&self) -> StringArray {
        unsafe { Translation_get_message_list(self.this) }
    }

    #[inline]
    pub fn set_locale(&mut self, locale: GodotString) -> () {
        unsafe { Translation_set_locale(self.this, locale) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class TranslationServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_translationserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// TranslationServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TranslationServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl TranslationServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"TranslationServer\0".as_ptr() as *mut _);

            TranslationServer {
                this
            }
        }
    }
    #[inline]
    pub fn add_translation(&mut self, translation: Option<Translation>) -> () {
        unsafe { TranslationServer_add_translation(self.this, translation) }
    }

    #[inline]
    pub fn clear(&mut self) -> () {
        unsafe { TranslationServer_clear(self.this) }
    }

    #[inline]
    pub fn get_loaded_locales(&self) -> VariantArray {
        unsafe { TranslationServer_get_loaded_locales(self.this) }
    }

    #[inline]
    pub fn get_locale(&self) -> GodotString {
        unsafe { TranslationServer_get_locale(self.this) }
    }

    #[inline]
    pub fn get_locale_name(&self, locale: GodotString) -> GodotString {
        unsafe { TranslationServer_get_locale_name(self.this, locale) }
    }

    #[inline]
    pub fn remove_translation(&mut self, translation: Option<Translation>) -> () {
        unsafe { TranslationServer_remove_translation(self.this, translation) }
    }

    #[inline]
    pub fn set_locale(&mut self, locale: GodotString) -> () {
        unsafe { TranslationServer_set_locale(self.this, locale) }
    }

    #[inline]
    pub fn translate(&self, message: GodotString) -> GodotString {
        unsafe { TranslationServer_translate(self.this, message) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Tree` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tree.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Tree` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Tree::free`.
///
/// ## Class hierarchy
///
/// Tree inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Tree {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TreeSelectMode {
    Single = 0,
    Row = 1,
    Multi = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TreeDropModeFlags {
    DropModeDisabled = 0,
    DropModeOnItem = 1,
    DropModeInbetween = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Tree {
    pub const DROP_MODE_INBETWEEN: i64 = 2;
    pub const SELECT_SINGLE: i64 = 0;
    pub const DROP_MODE_ON_ITEM: i64 = 1;
    pub const DROP_MODE_DISABLED: i64 = 0;
    pub const SELECT_MULTI: i64 = 2;
    pub const SELECT_ROW: i64 = 1;
}
impl Tree {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Tree::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TreeMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Tree {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        Tree__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _popup_select(&mut self, arg0: i64) -> () {
        Tree__popup_select(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _range_click_timeout(&mut self) -> () {
        Tree__range_click_timeout(self.this)
    }

    #[inline]
    pub unsafe fn _scroll_moved(&mut self, arg0: f64) -> () {
        Tree__scroll_moved(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _text_editor_enter(&mut self, arg0: GodotString) -> () {
        Tree__text_editor_enter(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _text_editor_modal_close(&mut self) -> () {
        Tree__text_editor_modal_close(self.this)
    }

    #[inline]
    pub unsafe fn _value_editor_changed(&mut self, arg0: f64) -> () {
        Tree__value_editor_changed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn are_column_titles_visible(&self) -> bool {
        Tree_are_column_titles_visible(self.this)
    }

    #[inline]
    pub unsafe fn clear(&mut self) -> () {
        Tree_clear(self.this)
    }

    #[inline]
    pub unsafe fn create_item(&mut self, parent: Option<Object>, idx: i64) -> Option<TreeItem> {
        Tree_create_item(self.this, parent, idx)
    }

    #[inline]
    pub unsafe fn ensure_cursor_is_visible(&mut self) -> () {
        Tree_ensure_cursor_is_visible(self.this)
    }

    #[inline]
    pub unsafe fn get_allow_reselect(&self) -> bool {
        Tree_get_allow_reselect(self.this)
    }

    #[inline]
    pub unsafe fn get_allow_rmb_select(&self) -> bool {
        Tree_get_allow_rmb_select(self.this)
    }

    #[inline]
    pub unsafe fn get_column_at_position(&self, position: Vector2) -> i64 {
        Tree_get_column_at_position(self.this, position)
    }

    #[inline]
    pub unsafe fn get_column_title(&self, column: i64) -> GodotString {
        Tree_get_column_title(self.this, column)
    }

    #[inline]
    pub unsafe fn get_column_width(&self, column: i64) -> i64 {
        Tree_get_column_width(self.this, column)
    }

    #[inline]
    pub unsafe fn get_columns(&self) -> i64 {
        Tree_get_columns(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_popup_rect(&self) -> Rect2 {
        Tree_get_custom_popup_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_drop_mode_flags(&self) -> i64 {
        Tree_get_drop_mode_flags(self.this)
    }

    #[inline]
    pub unsafe fn get_drop_section_at_position(&self, position: Vector2) -> i64 {
        Tree_get_drop_section_at_position(self.this, position)
    }

    #[inline]
    pub unsafe fn get_edited(&self) -> Option<TreeItem> {
        Tree_get_edited(self.this)
    }

    #[inline]
    pub unsafe fn get_edited_column(&self) -> i64 {
        Tree_get_edited_column(self.this)
    }

    #[inline]
    pub unsafe fn get_item_area_rect(&self, item: Option<Object>, column: i64) -> Rect2 {
        Tree_get_item_area_rect(self.this, item, column)
    }

    #[inline]
    pub unsafe fn get_item_at_position(&self, position: Vector2) -> Option<TreeItem> {
        Tree_get_item_at_position(self.this, position)
    }

    #[inline]
    pub unsafe fn get_next_selected(&mut self, from: Option<Object>) -> Option<TreeItem> {
        Tree_get_next_selected(self.this, from)
    }

    #[inline]
    pub unsafe fn get_pressed_button(&self) -> i64 {
        Tree_get_pressed_button(self.this)
    }

    #[inline]
    pub unsafe fn get_root(&mut self) -> Option<TreeItem> {
        Tree_get_root(self.this)
    }

    #[inline]
    pub unsafe fn get_scroll(&self) -> Vector2 {
        Tree_get_scroll(self.this)
    }

    #[inline]
    pub unsafe fn get_select_mode(&self) -> TreeSelectMode {
        Tree_get_select_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_selected(&self) -> Option<TreeItem> {
        Tree_get_selected(self.this)
    }

    #[inline]
    pub unsafe fn get_selected_column(&self) -> i64 {
        Tree_get_selected_column(self.this)
    }

    #[inline]
    pub unsafe fn is_folding_hidden(&self) -> bool {
        Tree_is_folding_hidden(self.this)
    }

    #[inline]
    pub unsafe fn is_root_hidden(&self) -> bool {
        Tree_is_root_hidden(self.this)
    }

    #[inline]
    pub unsafe fn set_allow_reselect(&mut self, allow: bool) -> () {
        Tree_set_allow_reselect(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_allow_rmb_select(&mut self, allow: bool) -> () {
        Tree_set_allow_rmb_select(self.this, allow)
    }

    #[inline]
    pub unsafe fn set_column_expand(&mut self, column: i64, expand: bool) -> () {
        Tree_set_column_expand(self.this, column, expand)
    }

    #[inline]
    pub unsafe fn set_column_min_width(&mut self, column: i64, min_width: i64) -> () {
        Tree_set_column_min_width(self.this, column, min_width)
    }

    #[inline]
    pub unsafe fn set_column_title(&mut self, column: i64, title: GodotString) -> () {
        Tree_set_column_title(self.this, column, title)
    }

    #[inline]
    pub unsafe fn set_column_titles_visible(&mut self, visible: bool) -> () {
        Tree_set_column_titles_visible(self.this, visible)
    }

    #[inline]
    pub unsafe fn set_columns(&mut self, amount: i64) -> () {
        Tree_set_columns(self.this, amount)
    }

    #[inline]
    pub unsafe fn set_drop_mode_flags(&mut self, flags: i64) -> () {
        Tree_set_drop_mode_flags(self.this, flags)
    }

    #[inline]
    pub unsafe fn set_hide_folding(&mut self, hide: bool) -> () {
        Tree_set_hide_folding(self.this, hide)
    }

    #[inline]
    pub unsafe fn set_hide_root(&mut self, enable: bool) -> () {
        Tree_set_hide_root(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_select_mode(&mut self, mode: i64) -> () {
        Tree_set_select_mode(self.this, mode)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TreeItem` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_treeitem.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// TreeItem inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TreeItem {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TreeItemTreeCellMode {
    CellModeString = 0,
    CellModeCheck = 1,
    CellModeRange = 2,
    CellModeIcon = 3,
    CellModeCustom = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TreeItemTextAlign {
    AlignLeft = 0,
    AlignCenter = 1,
    AlignRight = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl TreeItem {
    pub const CELL_MODE_ICON: i64 = 3;
    pub const CELL_MODE_CUSTOM: i64 = 4;
    pub const CELL_MODE_RANGE: i64 = 2;
    pub const ALIGN_CENTER: i64 = 1;
    pub const ALIGN_LEFT: i64 = 0;
    pub const ALIGN_RIGHT: i64 = 2;
    pub const CELL_MODE_STRING: i64 = 0;
    pub const CELL_MODE_CHECK: i64 = 1;
}
impl TreeItem {
    #[inline]
    pub unsafe fn add_button(&mut self, column: i64, button: Option<Texture>, button_idx: i64, disabled: bool, tooltip: GodotString) -> () {
        TreeItem_add_button(self.this, column, button, button_idx, disabled, tooltip)
    }

    #[inline]
    pub unsafe fn call_recursive(&mut self, method: GodotString, varargs: &[Variant]) -> Variant {
        TreeItem_call_recursive(self.this, method, varargs)
    }

    #[inline]
    pub unsafe fn clear_custom_bg_color(&mut self, column: i64) -> () {
        TreeItem_clear_custom_bg_color(self.this, column)
    }

    #[inline]
    pub unsafe fn clear_custom_color(&mut self, column: i64) -> () {
        TreeItem_clear_custom_color(self.this, column)
    }

    #[inline]
    pub unsafe fn deselect(&mut self, column: i64) -> () {
        TreeItem_deselect(self.this, column)
    }

    #[inline]
    pub unsafe fn erase_button(&mut self, column: i64, button_idx: i64) -> () {
        TreeItem_erase_button(self.this, column, button_idx)
    }

    #[inline]
    pub unsafe fn get_button(&self, column: i64, button_idx: i64) -> Option<Texture> {
        TreeItem_get_button(self.this, column, button_idx)
    }

    #[inline]
    pub unsafe fn get_button_count(&self, column: i64) -> i64 {
        TreeItem_get_button_count(self.this, column)
    }

    #[inline]
    pub unsafe fn get_button_tooltip(&self, column: i64, button_idx: i64) -> GodotString {
        TreeItem_get_button_tooltip(self.this, column, button_idx)
    }

    #[inline]
    pub unsafe fn get_cell_mode(&self, column: i64) -> TreeItemTreeCellMode {
        TreeItem_get_cell_mode(self.this, column)
    }

    #[inline]
    pub unsafe fn get_children(&mut self) -> Option<TreeItem> {
        TreeItem_get_children(self.this)
    }

    #[inline]
    pub unsafe fn get_custom_bg_color(&self, column: i64) -> Color {
        TreeItem_get_custom_bg_color(self.this, column)
    }

    #[inline]
    pub unsafe fn get_custom_color(&self, column: i64) -> Color {
        TreeItem_get_custom_color(self.this, column)
    }

    #[inline]
    pub unsafe fn get_custom_minimum_height(&self) -> i64 {
        TreeItem_get_custom_minimum_height(self.this)
    }

    #[inline]
    pub unsafe fn get_expand_right(&self, column: i64) -> bool {
        TreeItem_get_expand_right(self.this, column)
    }

    #[inline]
    pub unsafe fn get_icon(&self, column: i64) -> Option<Texture> {
        TreeItem_get_icon(self.this, column)
    }

    #[inline]
    pub unsafe fn get_icon_max_width(&self, column: i64) -> i64 {
        TreeItem_get_icon_max_width(self.this, column)
    }

    #[inline]
    pub unsafe fn get_icon_modulate(&self, column: i64) -> Color {
        TreeItem_get_icon_modulate(self.this, column)
    }

    #[inline]
    pub unsafe fn get_icon_region(&self, column: i64) -> Rect2 {
        TreeItem_get_icon_region(self.this, column)
    }

    #[inline]
    pub unsafe fn get_metadata(&self, column: i64) -> Variant {
        TreeItem_get_metadata(self.this, column)
    }

    #[inline]
    pub unsafe fn get_next(&mut self) -> Option<TreeItem> {
        TreeItem_get_next(self.this)
    }

    #[inline]
    pub unsafe fn get_next_visible(&mut self, wrap: bool) -> Option<TreeItem> {
        TreeItem_get_next_visible(self.this, wrap)
    }

    #[inline]
    pub unsafe fn get_parent(&mut self) -> Option<TreeItem> {
        TreeItem_get_parent(self.this)
    }

    #[inline]
    pub unsafe fn get_prev(&mut self) -> Option<TreeItem> {
        TreeItem_get_prev(self.this)
    }

    #[inline]
    pub unsafe fn get_prev_visible(&mut self, wrap: bool) -> Option<TreeItem> {
        TreeItem_get_prev_visible(self.this, wrap)
    }

    #[inline]
    pub unsafe fn get_range(&self, column: i64) -> f64 {
        TreeItem_get_range(self.this, column)
    }

    #[inline]
    pub unsafe fn get_range_config(&mut self, column: i64) -> Dictionary {
        TreeItem_get_range_config(self.this, column)
    }

    #[inline]
    pub unsafe fn get_text(&self, column: i64) -> GodotString {
        TreeItem_get_text(self.this, column)
    }

    #[inline]
    pub unsafe fn get_text_align(&self, column: i64) -> TreeItemTextAlign {
        TreeItem_get_text_align(self.this, column)
    }

    #[inline]
    pub unsafe fn get_tooltip(&self, column: i64) -> GodotString {
        TreeItem_get_tooltip(self.this, column)
    }

    #[inline]
    pub unsafe fn is_button_disabled(&self, column: i64, button_idx: i64) -> bool {
        TreeItem_is_button_disabled(self.this, column, button_idx)
    }

    #[inline]
    pub unsafe fn is_checked(&self, column: i64) -> bool {
        TreeItem_is_checked(self.this, column)
    }

    #[inline]
    pub unsafe fn is_collapsed(&mut self) -> bool {
        TreeItem_is_collapsed(self.this)
    }

    #[inline]
    pub unsafe fn is_custom_set_as_button(&self, column: i64) -> bool {
        TreeItem_is_custom_set_as_button(self.this, column)
    }

    #[inline]
    pub unsafe fn is_editable(&mut self, column: i64) -> bool {
        TreeItem_is_editable(self.this, column)
    }

    #[inline]
    pub unsafe fn is_folding_disabled(&self) -> bool {
        TreeItem_is_folding_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_selectable(&self, column: i64) -> bool {
        TreeItem_is_selectable(self.this, column)
    }

    #[inline]
    pub unsafe fn is_selected(&mut self, column: i64) -> bool {
        TreeItem_is_selected(self.this, column)
    }

    #[inline]
    pub unsafe fn move_to_bottom(&mut self) -> () {
        TreeItem_move_to_bottom(self.this)
    }

    #[inline]
    pub unsafe fn move_to_top(&mut self) -> () {
        TreeItem_move_to_top(self.this)
    }

    #[inline]
    pub unsafe fn remove_child(&mut self, child: Option<Object>) -> () {
        TreeItem_remove_child(self.this, child)
    }

    #[inline]
    pub unsafe fn select(&mut self, column: i64) -> () {
        TreeItem_select(self.this, column)
    }

    #[inline]
    pub unsafe fn set_button(&mut self, column: i64, button_idx: i64, button: Option<Texture>) -> () {
        TreeItem_set_button(self.this, column, button_idx, button)
    }

    #[inline]
    pub unsafe fn set_button_disabled(&mut self, column: i64, button_idx: i64, disabled: bool) -> () {
        TreeItem_set_button_disabled(self.this, column, button_idx, disabled)
    }

    #[inline]
    pub unsafe fn set_cell_mode(&mut self, column: i64, mode: i64) -> () {
        TreeItem_set_cell_mode(self.this, column, mode)
    }

    #[inline]
    pub unsafe fn set_checked(&mut self, column: i64, checked: bool) -> () {
        TreeItem_set_checked(self.this, column, checked)
    }

    #[inline]
    pub unsafe fn set_collapsed(&mut self, enable: bool) -> () {
        TreeItem_set_collapsed(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_custom_as_button(&mut self, column: i64, enable: bool) -> () {
        TreeItem_set_custom_as_button(self.this, column, enable)
    }

    #[inline]
    pub unsafe fn set_custom_bg_color(&mut self, column: i64, color: Color, just_outline: bool) -> () {
        TreeItem_set_custom_bg_color(self.this, column, color, just_outline)
    }

    #[inline]
    pub unsafe fn set_custom_color(&mut self, column: i64, color: Color) -> () {
        TreeItem_set_custom_color(self.this, column, color)
    }

    #[inline]
    pub unsafe fn set_custom_draw(&mut self, column: i64, object: Option<Object>, callback: GodotString) -> () {
        TreeItem_set_custom_draw(self.this, column, object, callback)
    }

    #[inline]
    pub unsafe fn set_custom_minimum_height(&mut self, height: i64) -> () {
        TreeItem_set_custom_minimum_height(self.this, height)
    }

    #[inline]
    pub unsafe fn set_disable_folding(&mut self, disable: bool) -> () {
        TreeItem_set_disable_folding(self.this, disable)
    }

    #[inline]
    pub unsafe fn set_editable(&mut self, column: i64, enabled: bool) -> () {
        TreeItem_set_editable(self.this, column, enabled)
    }

    #[inline]
    pub unsafe fn set_expand_right(&mut self, column: i64, enable: bool) -> () {
        TreeItem_set_expand_right(self.this, column, enable)
    }

    #[inline]
    pub unsafe fn set_icon(&mut self, column: i64, texture: Option<Texture>) -> () {
        TreeItem_set_icon(self.this, column, texture)
    }

    #[inline]
    pub unsafe fn set_icon_max_width(&mut self, column: i64, width: i64) -> () {
        TreeItem_set_icon_max_width(self.this, column, width)
    }

    #[inline]
    pub unsafe fn set_icon_modulate(&mut self, column: i64, modulate: Color) -> () {
        TreeItem_set_icon_modulate(self.this, column, modulate)
    }

    #[inline]
    pub unsafe fn set_icon_region(&mut self, column: i64, region: Rect2) -> () {
        TreeItem_set_icon_region(self.this, column, region)
    }

    #[inline]
    pub unsafe fn set_metadata(&mut self, column: i64, meta: Variant) -> () {
        TreeItem_set_metadata(self.this, column, meta)
    }

    #[inline]
    pub unsafe fn set_range(&mut self, column: i64, value: f64) -> () {
        TreeItem_set_range(self.this, column, value)
    }

    #[inline]
    pub unsafe fn set_range_config(&mut self, column: i64, min: f64, max: f64, step: f64, expr: bool) -> () {
        TreeItem_set_range_config(self.this, column, min, max, step, expr)
    }

    #[inline]
    pub unsafe fn set_selectable(&mut self, column: i64, selectable: bool) -> () {
        TreeItem_set_selectable(self.this, column, selectable)
    }

    #[inline]
    pub unsafe fn set_text(&mut self, column: i64, text: GodotString) -> () {
        TreeItem_set_text(self.this, column, text)
    }

    #[inline]
    pub unsafe fn set_text_align(&mut self, column: i64, text_align: i64) -> () {
        TreeItem_set_text_align(self.this, column, text_align)
    }

    #[inline]
    pub unsafe fn set_tooltip(&mut self, column: i64, tooltip: GodotString) -> () {
        TreeItem_set_tooltip(self.this, column, tooltip)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class TriangleMesh` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_trianglemesh.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// TriangleMesh inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct TriangleMesh {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl TriangleMesh {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TriangleMeshMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            TriangleMesh {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Tween` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_tween.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Tween` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Tween::free`.
///
/// ## Class hierarchy
///
/// Tween inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Tween {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TweenTransitionType {
    TransLinear = 0,
    TransSine = 1,
    TransQuint = 2,
    TransQuart = 3,
    TransQuad = 4,
    TransExpo = 5,
    TransElastic = 6,
    TransCubic = 7,
    TransCirc = 8,
    TransBounce = 9,
    TransBack = 10,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TweenTweenProcessMode {
    Physics = 0,
    Idle = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TweenEaseType {
    EaseIn = 0,
    EaseOut = 1,
    EaseInOut = 2,
    EaseOutIn = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Tween {
    pub const TRANS_CIRC: i64 = 8;
    pub const TRANS_SINE: i64 = 1;
    pub const TWEEN_PROCESS_IDLE: i64 = 1;
    pub const TRANS_ELASTIC: i64 = 6;
    pub const TWEEN_PROCESS_PHYSICS: i64 = 0;
    pub const TRANS_CUBIC: i64 = 7;
    pub const TRANS_QUINT: i64 = 2;
    pub const TRANS_QUAD: i64 = 4;
    pub const TRANS_BOUNCE: i64 = 9;
    pub const TRANS_LINEAR: i64 = 0;
    pub const EASE_OUT_IN: i64 = 3;
    pub const EASE_IN_OUT: i64 = 2;
    pub const TRANS_QUART: i64 = 3;
    pub const TRANS_EXPO: i64 = 5;
    pub const TRANS_BACK: i64 = 10;
    pub const EASE_IN: i64 = 0;
    pub const EASE_OUT: i64 = 1;
}
impl Tween {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Tween::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = TweenMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Tween {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _remove_by_uid(&mut self, uid: i64) -> () {
        Tween__remove_by_uid(self.this, uid)
    }

    #[inline]
    pub unsafe fn follow_method(&mut self, object: Option<Object>, method: GodotString, initial_val: Variant, target: Option<Object>, target_method: GodotString, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_follow_method(self.this, object, method, initial_val, target, target_method, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn follow_property(&mut self, object: Option<Object>, property: NodePath, initial_val: Variant, target: Option<Object>, target_property: NodePath, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_follow_property(self.this, object, property, initial_val, target, target_property, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn get_runtime(&self) -> f64 {
        Tween_get_runtime(self.this)
    }

    #[inline]
    pub unsafe fn get_speed_scale(&self) -> f64 {
        Tween_get_speed_scale(self.this)
    }

    #[inline]
    pub unsafe fn get_tween_process_mode(&self) -> TweenTweenProcessMode {
        Tween_get_tween_process_mode(self.this)
    }

    #[inline]
    pub unsafe fn interpolate_callback(&mut self, object: Option<Object>, duration: f64, callback: GodotString, arg1: Variant, arg2: Variant, arg3: Variant, arg4: Variant, arg5: Variant) -> bool {
        Tween_interpolate_callback(self.this, object, duration, callback, arg1, arg2, arg3, arg4, arg5)
    }

    #[inline]
    pub unsafe fn interpolate_deferred_callback(&mut self, object: Option<Object>, duration: f64, callback: GodotString, arg1: Variant, arg2: Variant, arg3: Variant, arg4: Variant, arg5: Variant) -> bool {
        Tween_interpolate_deferred_callback(self.this, object, duration, callback, arg1, arg2, arg3, arg4, arg5)
    }

    #[inline]
    pub unsafe fn interpolate_method(&mut self, object: Option<Object>, method: GodotString, initial_val: Variant, final_val: Variant, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_interpolate_method(self.this, object, method, initial_val, final_val, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn interpolate_property(&mut self, object: Option<Object>, property: NodePath, initial_val: Variant, final_val: Variant, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_interpolate_property(self.this, object, property, initial_val, final_val, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn is_active(&self) -> bool {
        Tween_is_active(self.this)
    }

    #[inline]
    pub unsafe fn is_repeat(&self) -> bool {
        Tween_is_repeat(self.this)
    }

    #[inline]
    pub unsafe fn remove(&mut self, object: Option<Object>, key: GodotString) -> bool {
        Tween_remove(self.this, object, key)
    }

    #[inline]
    pub unsafe fn remove_all(&mut self) -> bool {
        Tween_remove_all(self.this)
    }

    #[inline]
    pub unsafe fn reset(&mut self, object: Option<Object>, key: GodotString) -> bool {
        Tween_reset(self.this, object, key)
    }

    #[inline]
    pub unsafe fn reset_all(&mut self) -> bool {
        Tween_reset_all(self.this)
    }

    #[inline]
    pub unsafe fn resume(&mut self, object: Option<Object>, key: GodotString) -> bool {
        Tween_resume(self.this, object, key)
    }

    #[inline]
    pub unsafe fn resume_all(&mut self) -> bool {
        Tween_resume_all(self.this)
    }

    #[inline]
    pub unsafe fn seek(&mut self, time: f64) -> bool {
        Tween_seek(self.this, time)
    }

    #[inline]
    pub unsafe fn set_active(&mut self, active: bool) -> () {
        Tween_set_active(self.this, active)
    }

    #[inline]
    pub unsafe fn set_repeat(&mut self, repeat: bool) -> () {
        Tween_set_repeat(self.this, repeat)
    }

    #[inline]
    pub unsafe fn set_speed_scale(&mut self, speed: f64) -> () {
        Tween_set_speed_scale(self.this, speed)
    }

    #[inline]
    pub unsafe fn set_tween_process_mode(&mut self, mode: i64) -> () {
        Tween_set_tween_process_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn start(&mut self) -> bool {
        Tween_start(self.this)
    }

    #[inline]
    pub unsafe fn stop(&mut self, object: Option<Object>, key: GodotString) -> bool {
        Tween_stop(self.this, object, key)
    }

    #[inline]
    pub unsafe fn stop_all(&mut self) -> bool {
        Tween_stop_all(self.this)
    }

    #[inline]
    pub unsafe fn targeting_method(&mut self, object: Option<Object>, method: GodotString, initial: Option<Object>, initial_method: GodotString, final_val: Variant, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_targeting_method(self.this, object, method, initial, initial_method, final_val, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn targeting_property(&mut self, object: Option<Object>, property: NodePath, initial: Option<Object>, initial_val: NodePath, final_val: Variant, duration: f64, trans_type: i64, ease_type: i64, delay: f64) -> bool {
        Tween_targeting_property(self.this, object, property, initial, initial_val, final_val, duration, trans_type, ease_type, delay)
    }

    #[inline]
    pub unsafe fn tell(&self) -> f64 {
        Tween_tell(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class UPNP` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_upnp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// UPNP inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct UPNP {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum UPNPUPNPResult {
    Success = 0,
    NotAuthorized = 1,
    PortMappingNotFound = 2,
    InconsistentParameters = 3,
    NoSuchEntryInArray = 4,
    ActionFailed = 5,
    SrcIpWildcardNotPermitted = 6,
    ExtPortWildcardNotPermitted = 7,
    IntPortWildcardNotPermitted = 8,
    RemoteHostMustBeWildcard = 9,
    ExtPortMustBeWildcard = 10,
    NoPortMapsAvailable = 11,
    ConflictWithOtherMechanism = 12,
    ConflictWithOtherMapping = 13,
    SamePortValuesRequired = 14,
    OnlyPermanentLeaseSupported = 15,
    InvalidGateway = 16,
    InvalidPort = 17,
    InvalidProtocol = 18,
    InvalidDuration = 19,
    InvalidArgs = 20,
    InvalidResponse = 21,
    InvalidParam = 22,
    HttpError = 23,
    SocketError = 24,
    MemAllocError = 25,
    NoGateway = 26,
    NoDevices = 27,
    UnknownError = 28,
}
/// Constants
#[allow(non_upper_case_globals)]
impl UPNP {
    pub const UPNP_RESULT_PORT_MAPPING_NOT_FOUND: i64 = 2;
    pub const UPNP_RESULT_INVALID_DURATION: i64 = 19;
    pub const UPNP_RESULT_SRC_IP_WILDCARD_NOT_PERMITTED: i64 = 6;
    pub const UPNP_RESULT_EXT_PORT_WILDCARD_NOT_PERMITTED: i64 = 7;
    pub const UPNP_RESULT_NO_SUCH_ENTRY_IN_ARRAY: i64 = 4;
    pub const UPNP_RESULT_INVALID_PROTOCOL: i64 = 18;
    pub const UPNP_RESULT_NOT_AUTHORIZED: i64 = 1;
    pub const UPNP_RESULT_ACTION_FAILED: i64 = 5;
    pub const UPNP_RESULT_INT_PORT_WILDCARD_NOT_PERMITTED: i64 = 8;
    pub const UPNP_RESULT_NO_GATEWAY: i64 = 26;
    pub const UPNP_RESULT_INVALID_GATEWAY: i64 = 16;
    pub const UPNP_RESULT_INVALID_PORT: i64 = 17;
    pub const UPNP_RESULT_INCONSISTENT_PARAMETERS: i64 = 3;
    pub const UPNP_RESULT_INVALID_RESPONSE: i64 = 21;
    pub const UPNP_RESULT_REMOTE_HOST_MUST_BE_WILDCARD: i64 = 9;
    pub const UPNP_RESULT_SOCKET_ERROR: i64 = 24;
    pub const UPNP_RESULT_UNKNOWN_ERROR: i64 = 28;
    pub const UPNP_RESULT_CONFLICT_WITH_OTHER_MECHANISM: i64 = 12;
    pub const UPNP_RESULT_INVALID_ARGS: i64 = 20;
    pub const UPNP_RESULT_MEM_ALLOC_ERROR: i64 = 25;
    pub const UPNP_RESULT_ONLY_PERMANENT_LEASE_SUPPORTED: i64 = 15;
    pub const UPNP_RESULT_EXT_PORT_MUST_BE_WILDCARD: i64 = 10;
    pub const UPNP_RESULT_INVALID_PARAM: i64 = 22;
    pub const UPNP_RESULT_HTTP_ERROR: i64 = 23;
    pub const UPNP_RESULT_CONFLICT_WITH_OTHER_MAPPING: i64 = 13;
    pub const UPNP_RESULT_NO_DEVICES: i64 = 27;
    pub const UPNP_RESULT_SAME_PORT_VALUES_REQUIRED: i64 = 14;
    pub const UPNP_RESULT_SUCCESS: i64 = 0;
    pub const UPNP_RESULT_NO_PORT_MAPS_AVAILABLE: i64 = 11;
}
impl UPNP {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = UPNPMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            UPNP {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_device(&mut self, device: Option<UPNPDevice>) -> () {
        unsafe { UPNP_add_device(self.this, device) }
    }

    #[inline]
    pub fn add_port_mapping(&self, port: i64, port_internal: i64, desc: GodotString, proto: GodotString, duration: i64) -> i64 {
        unsafe { UPNP_add_port_mapping(self.this, port, port_internal, desc, proto, duration) }
    }

    #[inline]
    pub fn clear_devices(&mut self) -> () {
        unsafe { UPNP_clear_devices(self.this) }
    }

    #[inline]
    pub fn delete_port_mapping(&self, port: i64, proto: GodotString) -> i64 {
        unsafe { UPNP_delete_port_mapping(self.this, port, proto) }
    }

    #[inline]
    pub fn discover(&mut self, timeout: i64, ttl: i64, device_filter: GodotString) -> i64 {
        unsafe { UPNP_discover(self.this, timeout, ttl, device_filter) }
    }

    #[inline]
    pub fn get_device(&self, index: i64) -> Option<UPNPDevice> {
        unsafe { UPNP_get_device(self.this, index) }
    }

    #[inline]
    pub fn get_device_count(&self) -> i64 {
        unsafe { UPNP_get_device_count(self.this) }
    }

    #[inline]
    pub fn get_discover_local_port(&self) -> i64 {
        unsafe { UPNP_get_discover_local_port(self.this) }
    }

    #[inline]
    pub fn get_discover_multicast_if(&self) -> GodotString {
        unsafe { UPNP_get_discover_multicast_if(self.this) }
    }

    #[inline]
    pub fn get_gateway(&self) -> Option<UPNPDevice> {
        unsafe { UPNP_get_gateway(self.this) }
    }

    #[inline]
    pub fn is_discover_ipv6(&self) -> bool {
        unsafe { UPNP_is_discover_ipv6(self.this) }
    }

    #[inline]
    pub fn query_external_address(&self) -> GodotString {
        unsafe { UPNP_query_external_address(self.this) }
    }

    #[inline]
    pub fn remove_device(&mut self, index: i64) -> () {
        unsafe { UPNP_remove_device(self.this, index) }
    }

    #[inline]
    pub fn set_device(&mut self, index: i64, device: Option<UPNPDevice>) -> () {
        unsafe { UPNP_set_device(self.this, index, device) }
    }

    #[inline]
    pub fn set_discover_ipv6(&mut self, ipv6: bool) -> () {
        unsafe { UPNP_set_discover_ipv6(self.this, ipv6) }
    }

    #[inline]
    pub fn set_discover_local_port(&mut self, port: i64) -> () {
        unsafe { UPNP_set_discover_local_port(self.this, port) }
    }

    #[inline]
    pub fn set_discover_multicast_if(&mut self, m_if: GodotString) -> () {
        unsafe { UPNP_set_discover_multicast_if(self.this, m_if) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class UPNPDevice` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_upnpdevice.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// UPNPDevice inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct UPNPDevice {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum UPNPDeviceIGDStatus {
    Ok = 0,
    HttpError = 1,
    HttpEmpty = 2,
    NoUrls = 3,
    NoIgd = 4,
    Disconnected = 5,
    UnknownDevice = 6,
    InvalidControl = 7,
    MallocError = 8,
    UnknownError = 9,
}
/// Constants
#[allow(non_upper_case_globals)]
impl UPNPDevice {
    pub const IGD_STATUS_NO_URLS: i64 = 3;
    pub const IGD_STATUS_INVALID_CONTROL: i64 = 7;
    pub const IGD_STATUS_HTTP_EMPTY: i64 = 2;
    pub const IGD_STATUS_HTTP_ERROR: i64 = 1;
    pub const IGD_STATUS_MALLOC_ERROR: i64 = 8;
    pub const IGD_STATUS_UNKNOWN_DEVICE: i64 = 6;
    pub const IGD_STATUS_NO_IGD: i64 = 4;
    pub const IGD_STATUS_OK: i64 = 0;
    pub const IGD_STATUS_UNKNOWN_ERROR: i64 = 9;
    pub const IGD_STATUS_DISCONNECTED: i64 = 5;
}
impl UPNPDevice {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = UPNPDeviceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            UPNPDevice {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_port_mapping(&self, port: i64, port_internal: i64, desc: GodotString, proto: GodotString, duration: i64) -> i64 {
        unsafe { UPNPDevice_add_port_mapping(self.this, port, port_internal, desc, proto, duration) }
    }

    #[inline]
    pub fn delete_port_mapping(&self, port: i64, proto: GodotString) -> i64 {
        unsafe { UPNPDevice_delete_port_mapping(self.this, port, proto) }
    }

    #[inline]
    pub fn get_description_url(&self) -> GodotString {
        unsafe { UPNPDevice_get_description_url(self.this) }
    }

    #[inline]
    pub fn get_igd_control_url(&self) -> GodotString {
        unsafe { UPNPDevice_get_igd_control_url(self.this) }
    }

    #[inline]
    pub fn get_igd_our_addr(&self) -> GodotString {
        unsafe { UPNPDevice_get_igd_our_addr(self.this) }
    }

    #[inline]
    pub fn get_igd_service_type(&self) -> GodotString {
        unsafe { UPNPDevice_get_igd_service_type(self.this) }
    }

    #[inline]
    pub fn get_igd_status(&self) -> UPNPDeviceIGDStatus {
        unsafe { UPNPDevice_get_igd_status(self.this) }
    }

    #[inline]
    pub fn get_service_type(&self) -> GodotString {
        unsafe { UPNPDevice_get_service_type(self.this) }
    }

    #[inline]
    pub fn is_valid_gateway(&self) -> bool {
        unsafe { UPNPDevice_is_valid_gateway(self.this) }
    }

    #[inline]
    pub fn query_external_address(&self) -> GodotString {
        unsafe { UPNPDevice_query_external_address(self.this) }
    }

    #[inline]
    pub fn set_description_url(&mut self, url: GodotString) -> () {
        unsafe { UPNPDevice_set_description_url(self.this, url) }
    }

    #[inline]
    pub fn set_igd_control_url(&mut self, url: GodotString) -> () {
        unsafe { UPNPDevice_set_igd_control_url(self.this, url) }
    }

    #[inline]
    pub fn set_igd_our_addr(&mut self, addr: GodotString) -> () {
        unsafe { UPNPDevice_set_igd_our_addr(self.this, addr) }
    }

    #[inline]
    pub fn set_igd_service_type(&mut self, _type: GodotString) -> () {
        unsafe { UPNPDevice_set_igd_service_type(self.this, _type) }
    }

    #[inline]
    pub fn set_igd_status(&mut self, status: i64) -> () {
        unsafe { UPNPDevice_set_igd_status(self.this, status) }
    }

    #[inline]
    pub fn set_service_type(&mut self, _type: GodotString) -> () {
        unsafe { UPNPDevice_set_service_type(self.this, _type) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class UndoRedo` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_undoredo.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `UndoRedo` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `UndoRedo::free`.
///
/// ## Class hierarchy
///
/// UndoRedo inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct UndoRedo {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum UndoRedoMergeMode {
    Disable = 0,
    Ends = 1,
    All = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl UndoRedo {
    pub const MERGE_ALL: i64 = 2;
    pub const MERGE_DISABLE: i64 = 0;
    pub const MERGE_ENDS: i64 = 1;
}
impl UndoRedo {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `UndoRedo::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = UndoRedoMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            UndoRedo {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn add_do_method(&mut self, object: Option<Object>, method: GodotString, varargs: &[Variant]) -> Variant {
        UndoRedo_add_do_method(self.this, object, method, varargs)
    }

    #[inline]
    pub unsafe fn add_do_property(&mut self, object: Option<Object>, property: GodotString, value: Variant) -> () {
        UndoRedo_add_do_property(self.this, object, property, value)
    }

    #[inline]
    pub unsafe fn add_do_reference(&mut self, object: Option<Object>) -> () {
        UndoRedo_add_do_reference(self.this, object)
    }

    #[inline]
    pub unsafe fn add_undo_method(&mut self, object: Option<Object>, method: GodotString, varargs: &[Variant]) -> Variant {
        UndoRedo_add_undo_method(self.this, object, method, varargs)
    }

    #[inline]
    pub unsafe fn add_undo_property(&mut self, object: Option<Object>, property: GodotString, value: Variant) -> () {
        UndoRedo_add_undo_property(self.this, object, property, value)
    }

    #[inline]
    pub unsafe fn add_undo_reference(&mut self, object: Option<Object>) -> () {
        UndoRedo_add_undo_reference(self.this, object)
    }

    #[inline]
    pub unsafe fn clear_history(&mut self, increase_version: bool) -> () {
        UndoRedo_clear_history(self.this, increase_version)
    }

    #[inline]
    pub unsafe fn commit_action(&mut self) -> () {
        UndoRedo_commit_action(self.this)
    }

    #[inline]
    pub unsafe fn create_action(&mut self, name: GodotString, merge_mode: i64) -> () {
        UndoRedo_create_action(self.this, name, merge_mode)
    }

    #[inline]
    pub unsafe fn get_current_action_name(&self) -> GodotString {
        UndoRedo_get_current_action_name(self.this)
    }

    #[inline]
    pub unsafe fn get_version(&self) -> i64 {
        UndoRedo_get_version(self.this)
    }

    #[inline]
    pub unsafe fn has_redo(&mut self) -> bool {
        UndoRedo_has_redo(self.this)
    }

    #[inline]
    pub unsafe fn has_undo(&mut self) -> bool {
        UndoRedo_has_undo(self.this)
    }

    #[inline]
    pub unsafe fn is_commiting_action(&self) -> bool {
        UndoRedo_is_commiting_action(self.this)
    }

    #[inline]
    pub unsafe fn redo(&mut self) -> bool {
        UndoRedo_redo(self.this)
    }

    #[inline]
    pub unsafe fn undo(&mut self) -> bool {
        UndoRedo_undo(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VBoxContainer` inherits `BoxContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vboxcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VBoxContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VBoxContainer::free`.
///
/// ## Class hierarchy
///
/// VBoxContainer inherits methods from:
/// - [BoxContainer](struct.BoxContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VBoxContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VBoxContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VBoxContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VBoxContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VBoxContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_box_container(&self) -> BoxContainer {
        // Not reference-counted.
        BoxContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VScrollBar` inherits `ScrollBar` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vscrollbar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VScrollBar` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VScrollBar::free`.
///
/// ## Class hierarchy
///
/// VScrollBar inherits methods from:
/// - [ScrollBar](struct.ScrollBar.html)
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VScrollBar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VScrollBar {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VScrollBar::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VScrollBarMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VScrollBar {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_scroll_bar(&self) -> ScrollBar {
        // Not reference-counted.
        ScrollBar { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VSeparator` inherits `Separator` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vseparator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VSeparator` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VSeparator::free`.
///
/// ## Class hierarchy
///
/// VSeparator inherits methods from:
/// - [Separator](struct.Separator.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VSeparator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VSeparator {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VSeparator::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VSeparatorMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VSeparator {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_separator(&self) -> Separator {
        // Not reference-counted.
        Separator { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VSlider` inherits `Slider` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vslider.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VSlider` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VSlider::free`.
///
/// ## Class hierarchy
///
/// VSlider inherits methods from:
/// - [Slider](struct.Slider.html)
/// - [Range](struct.Range.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VSlider {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VSlider {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VSlider::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VSliderMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VSlider {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_slider(&self) -> Slider {
        // Not reference-counted.
        Slider { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_range(&self) -> Range {
        // Not reference-counted.
        Range { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VSplitContainer` inherits `SplitContainer` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vsplitcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VSplitContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VSplitContainer::free`.
///
/// ## Class hierarchy
///
/// VSplitContainer inherits methods from:
/// - [SplitContainer](struct.SplitContainer.html)
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VSplitContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VSplitContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VSplitContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VSplitContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VSplitContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_split_container(&self) -> SplitContainer {
        // Not reference-counted.
        SplitContainer { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VehicleBody` inherits `RigidBody` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vehiclebody.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VehicleBody` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VehicleBody::free`.
///
/// ## Class hierarchy
///
/// VehicleBody inherits methods from:
/// - [RigidBody](struct.RigidBody.html)
/// - [PhysicsBody](struct.PhysicsBody.html)
/// - [CollisionObject](struct.CollisionObject.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VehicleBody {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VehicleBody {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VehicleBody::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VehicleBodyMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VehicleBody {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_brake(&self) -> f64 {
        VehicleBody_get_brake(self.this)
    }

    #[inline]
    pub unsafe fn get_engine_force(&self) -> f64 {
        VehicleBody_get_engine_force(self.this)
    }

    #[inline]
    pub unsafe fn get_steering(&self) -> f64 {
        VehicleBody_get_steering(self.this)
    }

    #[inline]
    pub unsafe fn set_brake(&mut self, brake: f64) -> () {
        VehicleBody_set_brake(self.this, brake)
    }

    #[inline]
    pub unsafe fn set_engine_force(&mut self, engine_force: f64) -> () {
        VehicleBody_set_engine_force(self.this, engine_force)
    }

    #[inline]
    pub unsafe fn set_steering(&mut self, steering: f64) -> () {
        VehicleBody_set_steering(self.this, steering)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_rigid_body(&self) -> RigidBody {
        // Not reference-counted.
        RigidBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_physics_body(&self) -> PhysicsBody {
        // Not reference-counted.
        PhysicsBody { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_collision_object(&self) -> CollisionObject {
        // Not reference-counted.
        CollisionObject { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VehicleWheel` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_vehiclewheel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VehicleWheel` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VehicleWheel::free`.
///
/// ## Class hierarchy
///
/// VehicleWheel inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VehicleWheel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VehicleWheel {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VehicleWheel::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VehicleWheelMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VehicleWheel {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_brake(&self) -> f64 {
        VehicleWheel_get_brake(self.this)
    }

    #[inline]
    pub unsafe fn get_damping_compression(&self) -> f64 {
        VehicleWheel_get_damping_compression(self.this)
    }

    #[inline]
    pub unsafe fn get_damping_relaxation(&self) -> f64 {
        VehicleWheel_get_damping_relaxation(self.this)
    }

    #[inline]
    pub unsafe fn get_engine_force(&self) -> f64 {
        VehicleWheel_get_engine_force(self.this)
    }

    #[inline]
    pub unsafe fn get_friction_slip(&self) -> f64 {
        VehicleWheel_get_friction_slip(self.this)
    }

    #[inline]
    pub unsafe fn get_radius(&self) -> f64 {
        VehicleWheel_get_radius(self.this)
    }

    #[inline]
    pub unsafe fn get_roll_influence(&self) -> f64 {
        VehicleWheel_get_roll_influence(self.this)
    }

    #[inline]
    pub unsafe fn get_rpm(&self) -> f64 {
        VehicleWheel_get_rpm(self.this)
    }

    #[inline]
    pub unsafe fn get_skidinfo(&self) -> f64 {
        VehicleWheel_get_skidinfo(self.this)
    }

    #[inline]
    pub unsafe fn get_steering(&self) -> f64 {
        VehicleWheel_get_steering(self.this)
    }

    #[inline]
    pub unsafe fn get_suspension_max_force(&self) -> f64 {
        VehicleWheel_get_suspension_max_force(self.this)
    }

    #[inline]
    pub unsafe fn get_suspension_rest_length(&self) -> f64 {
        VehicleWheel_get_suspension_rest_length(self.this)
    }

    #[inline]
    pub unsafe fn get_suspension_stiffness(&self) -> f64 {
        VehicleWheel_get_suspension_stiffness(self.this)
    }

    #[inline]
    pub unsafe fn get_suspension_travel(&self) -> f64 {
        VehicleWheel_get_suspension_travel(self.this)
    }

    #[inline]
    pub unsafe fn is_in_contact(&self) -> bool {
        VehicleWheel_is_in_contact(self.this)
    }

    #[inline]
    pub unsafe fn is_used_as_steering(&self) -> bool {
        VehicleWheel_is_used_as_steering(self.this)
    }

    #[inline]
    pub unsafe fn is_used_as_traction(&self) -> bool {
        VehicleWheel_is_used_as_traction(self.this)
    }

    #[inline]
    pub unsafe fn set_brake(&mut self, brake: f64) -> () {
        VehicleWheel_set_brake(self.this, brake)
    }

    #[inline]
    pub unsafe fn set_damping_compression(&mut self, length: f64) -> () {
        VehicleWheel_set_damping_compression(self.this, length)
    }

    #[inline]
    pub unsafe fn set_damping_relaxation(&mut self, length: f64) -> () {
        VehicleWheel_set_damping_relaxation(self.this, length)
    }

    #[inline]
    pub unsafe fn set_engine_force(&mut self, engine_force: f64) -> () {
        VehicleWheel_set_engine_force(self.this, engine_force)
    }

    #[inline]
    pub unsafe fn set_friction_slip(&mut self, length: f64) -> () {
        VehicleWheel_set_friction_slip(self.this, length)
    }

    #[inline]
    pub unsafe fn set_radius(&mut self, length: f64) -> () {
        VehicleWheel_set_radius(self.this, length)
    }

    #[inline]
    pub unsafe fn set_roll_influence(&mut self, roll_influence: f64) -> () {
        VehicleWheel_set_roll_influence(self.this, roll_influence)
    }

    #[inline]
    pub unsafe fn set_steering(&mut self, steering: f64) -> () {
        VehicleWheel_set_steering(self.this, steering)
    }

    #[inline]
    pub unsafe fn set_suspension_max_force(&mut self, length: f64) -> () {
        VehicleWheel_set_suspension_max_force(self.this, length)
    }

    #[inline]
    pub unsafe fn set_suspension_rest_length(&mut self, length: f64) -> () {
        VehicleWheel_set_suspension_rest_length(self.this, length)
    }

    #[inline]
    pub unsafe fn set_suspension_stiffness(&mut self, length: f64) -> () {
        VehicleWheel_set_suspension_stiffness(self.this, length)
    }

    #[inline]
    pub unsafe fn set_suspension_travel(&mut self, length: f64) -> () {
        VehicleWheel_set_suspension_travel(self.this, length)
    }

    #[inline]
    pub unsafe fn set_use_as_steering(&mut self, enable: bool) -> () {
        VehicleWheel_set_use_as_steering(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_use_as_traction(&mut self, enable: bool) -> () {
        VehicleWheel_set_use_as_traction(self.this, enable)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VideoPlayer` inherits `Control` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_videoplayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VideoPlayer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VideoPlayer::free`.
///
/// ## Class hierarchy
///
/// VideoPlayer inherits methods from:
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VideoPlayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VideoPlayer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VideoPlayer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VideoPlayerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VideoPlayer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_audio_track(&self) -> i64 {
        VideoPlayer_get_audio_track(self.this)
    }

    #[inline]
    pub unsafe fn get_buffering_msec(&self) -> i64 {
        VideoPlayer_get_buffering_msec(self.this)
    }

    #[inline]
    pub unsafe fn get_bus(&self) -> GodotString {
        VideoPlayer_get_bus(self.this)
    }

    #[inline]
    pub unsafe fn get_stream(&self) -> Option<VideoStream> {
        VideoPlayer_get_stream(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_name(&self) -> GodotString {
        VideoPlayer_get_stream_name(self.this)
    }

    #[inline]
    pub unsafe fn get_stream_position(&self) -> f64 {
        VideoPlayer_get_stream_position(self.this)
    }

    #[inline]
    pub unsafe fn get_video_texture(&self) -> Option<Texture> {
        VideoPlayer_get_video_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_volume(&self) -> f64 {
        VideoPlayer_get_volume(self.this)
    }

    #[inline]
    pub unsafe fn get_volume_db(&self) -> f64 {
        VideoPlayer_get_volume_db(self.this)
    }

    #[inline]
    pub unsafe fn has_autoplay(&self) -> bool {
        VideoPlayer_has_autoplay(self.this)
    }

    #[inline]
    pub unsafe fn has_expand(&self) -> bool {
        VideoPlayer_has_expand(self.this)
    }

    #[inline]
    pub unsafe fn is_paused(&self) -> bool {
        VideoPlayer_is_paused(self.this)
    }

    #[inline]
    pub unsafe fn is_playing(&self) -> bool {
        VideoPlayer_is_playing(self.this)
    }

    #[inline]
    pub unsafe fn play(&mut self) -> () {
        VideoPlayer_play(self.this)
    }

    #[inline]
    pub unsafe fn set_audio_track(&mut self, track: i64) -> () {
        VideoPlayer_set_audio_track(self.this, track)
    }

    #[inline]
    pub unsafe fn set_autoplay(&mut self, enabled: bool) -> () {
        VideoPlayer_set_autoplay(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_buffering_msec(&mut self, msec: i64) -> () {
        VideoPlayer_set_buffering_msec(self.this, msec)
    }

    #[inline]
    pub unsafe fn set_bus(&mut self, bus: GodotString) -> () {
        VideoPlayer_set_bus(self.this, bus)
    }

    #[inline]
    pub unsafe fn set_expand(&mut self, enable: bool) -> () {
        VideoPlayer_set_expand(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_paused(&mut self, paused: bool) -> () {
        VideoPlayer_set_paused(self.this, paused)
    }

    #[inline]
    pub unsafe fn set_stream(&mut self, stream: Option<VideoStream>) -> () {
        VideoPlayer_set_stream(self.this, stream)
    }

    #[inline]
    pub unsafe fn set_stream_position(&mut self, position: f64) -> () {
        VideoPlayer_set_stream_position(self.this, position)
    }

    #[inline]
    pub unsafe fn set_volume(&mut self, volume: f64) -> () {
        VideoPlayer_set_volume(self.this, volume)
    }

    #[inline]
    pub unsafe fn set_volume_db(&mut self, db: f64) -> () {
        VideoPlayer_set_volume_db(self.this, db)
    }

    #[inline]
    pub unsafe fn stop(&mut self) -> () {
        VideoPlayer_stop(self.this)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VideoStream` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_videostream.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VideoStream inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VideoStream {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VideoStream {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VideoStreamGDNative` inherits `VideoStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_videostreamgdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VideoStreamGDNative inherits methods from:
/// - [VideoStream](struct.VideoStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VideoStreamGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VideoStreamGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VideoStreamGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VideoStreamGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_file(&mut self) -> GodotString {
        unsafe { VideoStreamGDNative_get_file(self.this) }
    }

    #[inline]
    pub fn set_file(&mut self, file: GodotString) -> () {
        unsafe { VideoStreamGDNative_set_file(self.this, file) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_video_stream(&self) -> VideoStream {
        unsafe {{ object::add_ref(self.this); }}
        VideoStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VideoStreamTheora` inherits `VideoStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_videostreamtheora.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VideoStreamTheora inherits methods from:
/// - [VideoStream](struct.VideoStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VideoStreamTheora {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VideoStreamTheora {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VideoStreamTheoraMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VideoStreamTheora {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_file(&mut self) -> GodotString {
        unsafe { VideoStreamTheora_get_file(self.this) }
    }

    #[inline]
    pub fn set_file(&mut self, file: GodotString) -> () {
        unsafe { VideoStreamTheora_set_file(self.this, file) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_video_stream(&self) -> VideoStream {
        unsafe {{ object::add_ref(self.this); }}
        VideoStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VideoStreamWebm` inherits `VideoStream` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_videostreamwebm.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VideoStreamWebm inherits methods from:
/// - [VideoStream](struct.VideoStream.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VideoStreamWebm {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VideoStreamWebm {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VideoStreamWebmMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VideoStreamWebm {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_file(&mut self) -> GodotString {
        unsafe { VideoStreamWebm_get_file(self.this) }
    }

    #[inline]
    pub fn set_file(&mut self, file: GodotString) -> () {
        unsafe { VideoStreamWebm_set_file(self.this, file) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_video_stream(&self) -> VideoStream {
        unsafe {{ object::add_ref(self.this); }}
        VideoStream { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Viewport` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_viewport.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `Viewport` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `Viewport::free`.
///
/// ## Class hierarchy
///
/// Viewport inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Viewport {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportClearMode {
    ModeAlways = 0,
    ModeNever = 1,
    ModeOnlyNextFrame = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportRenderInfo {
    ObjectsInFrame = 0,
    VerticesInFrame = 1,
    MaterialChangesInFrame = 2,
    ShaderChangesInFrame = 3,
    SurfaceChangesInFrame = 4,
    DrawCallsInFrame = 5,
    Max = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportUsage {
    Usage2d = 0,
    Usage2dNoSampling = 1,
    Usage3d = 2,
    Usage3dNoEffects = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportDebugDraw {
    Disabled = 0,
    Unshaded = 1,
    Overdraw = 2,
    Wireframe = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportShadowAtlasQuadrantSubdiv {
    Disabled = 0,
    ShadowAtlasQuadrantSubdiv1 = 1,
    ShadowAtlasQuadrantSubdiv4 = 2,
    ShadowAtlasQuadrantSubdiv16 = 3,
    ShadowAtlasQuadrantSubdiv64 = 4,
    ShadowAtlasQuadrantSubdiv256 = 5,
    ShadowAtlasQuadrantSubdiv1024 = 6,
    Max = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportUpdateMode {
    Disabled = 0,
    Once = 1,
    WhenVisible = 2,
    Always = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ViewportMSAA {
    Disabled = 0,
    Msaa2x = 1,
    Msaa4x = 2,
    Msaa8x = 3,
    Msaa16x = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Viewport {
    pub const RENDER_INFO_MATERIAL_CHANGES_IN_FRAME: i64 = 2;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_4: i64 = 2;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_16: i64 = 3;
    pub const UPDATE_ONCE: i64 = 1;
    pub const DEBUG_DRAW_UNSHADED: i64 = 1;
    pub const USAGE_3D: i64 = 2;
    pub const RENDER_INFO_OBJECTS_IN_FRAME: i64 = 0;
    pub const CLEAR_MODE_ALWAYS: i64 = 0;
    pub const DEBUG_DRAW_OVERDRAW: i64 = 2;
    pub const UPDATE_WHEN_VISIBLE: i64 = 2;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED: i64 = 0;
    pub const UPDATE_ALWAYS: i64 = 3;
    pub const RENDER_INFO_VERTICES_IN_FRAME: i64 = 1;
    pub const RENDER_INFO_DRAW_CALLS_IN_FRAME: i64 = 5;
    pub const MSAA_DISABLED: i64 = 0;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_1024: i64 = 6;
    pub const MSAA_2X: i64 = 1;
    pub const RENDER_INFO_MAX: i64 = 6;
    pub const MSAA_8X: i64 = 3;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_64: i64 = 4;
    pub const DEBUG_DRAW_DISABLED: i64 = 0;
    pub const USAGE_2D: i64 = 0;
    pub const CLEAR_MODE_NEVER: i64 = 1;
    pub const RENDER_INFO_SHADER_CHANGES_IN_FRAME: i64 = 3;
    pub const CLEAR_MODE_ONLY_NEXT_FRAME: i64 = 2;
    pub const DEBUG_DRAW_WIREFRAME: i64 = 3;
    pub const MSAA_16X: i64 = 4;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_1: i64 = 1;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_MAX: i64 = 7;
    pub const MSAA_4X: i64 = 2;
    pub const SHADOW_ATLAS_QUADRANT_SUBDIV_256: i64 = 5;
    pub const RENDER_INFO_SURFACE_CHANGES_IN_FRAME: i64 = 4;
    pub const UPDATE_DISABLED: i64 = 0;
    pub const USAGE_2D_NO_SAMPLING: i64 = 1;
    pub const USAGE_3D_NO_EFFECTS: i64 = 3;
}
impl Viewport {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `Viewport::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ViewportMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            Viewport {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _gui_remove_focus(&mut self) -> () {
        Viewport__gui_remove_focus(self.this)
    }

    #[inline]
    pub unsafe fn _gui_show_tooltip(&mut self) -> () {
        Viewport__gui_show_tooltip(self.this)
    }

    #[inline]
    pub unsafe fn _own_world_changed(&mut self) -> () {
        Viewport__own_world_changed(self.this)
    }

    #[inline]
    pub unsafe fn _post_gui_grab_click_focus(&mut self) -> () {
        Viewport__post_gui_grab_click_focus(self.this)
    }

    #[inline]
    pub unsafe fn _subwindow_visibility_changed(&mut self) -> () {
        Viewport__subwindow_visibility_changed(self.this)
    }

    #[inline]
    pub unsafe fn _vp_input(&mut self, arg0: Option<InputEvent>) -> () {
        Viewport__vp_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn _vp_input_text(&mut self, text: GodotString) -> () {
        Viewport__vp_input_text(self.this, text)
    }

    #[inline]
    pub unsafe fn _vp_unhandled_input(&mut self, arg0: Option<InputEvent>) -> () {
        Viewport__vp_unhandled_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn find_world(&self) -> Option<World> {
        Viewport_find_world(self.this)
    }

    #[inline]
    pub unsafe fn find_world_2d(&self) -> Option<World2D> {
        Viewport_find_world_2d(self.this)
    }

    #[inline]
    pub unsafe fn get_camera(&self) -> Option<Camera> {
        Viewport_get_camera(self.this)
    }

    #[inline]
    pub unsafe fn get_canvas_transform(&self) -> Transform2D {
        Viewport_get_canvas_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_clear_mode(&self) -> ViewportClearMode {
        Viewport_get_clear_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_debug_draw(&self) -> ViewportDebugDraw {
        Viewport_get_debug_draw(self.this)
    }

    #[inline]
    pub unsafe fn get_final_transform(&self) -> Transform2D {
        Viewport_get_final_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_global_canvas_transform(&self) -> Transform2D {
        Viewport_get_global_canvas_transform(self.this)
    }

    #[inline]
    pub unsafe fn get_hdr(&self) -> bool {
        Viewport_get_hdr(self.this)
    }

    #[inline]
    pub unsafe fn get_keep_3d_linear(&self) -> bool {
        Viewport_get_keep_3d_linear(self.this)
    }

    #[inline]
    pub unsafe fn get_modal_stack_top(&self) -> Option<Control> {
        Viewport_get_modal_stack_top(self.this)
    }

    #[inline]
    pub unsafe fn get_mouse_position(&self) -> Vector2 {
        Viewport_get_mouse_position(self.this)
    }

    #[inline]
    pub unsafe fn get_msaa(&self) -> ViewportMSAA {
        Viewport_get_msaa(self.this)
    }

    #[inline]
    pub unsafe fn get_physics_object_picking(&mut self) -> bool {
        Viewport_get_physics_object_picking(self.this)
    }

    #[inline]
    pub unsafe fn get_render_info(&mut self, info: i64) -> i64 {
        Viewport_get_render_info(self.this, info)
    }

    #[inline]
    pub unsafe fn get_shadow_atlas_quadrant_subdiv(&self, quadrant: i64) -> ViewportShadowAtlasQuadrantSubdiv {
        Viewport_get_shadow_atlas_quadrant_subdiv(self.this, quadrant)
    }

    #[inline]
    pub unsafe fn get_shadow_atlas_size(&self) -> i64 {
        Viewport_get_shadow_atlas_size(self.this)
    }

    #[inline]
    pub unsafe fn get_size(&self) -> Vector2 {
        Viewport_get_size(self.this)
    }

    #[inline]
    pub unsafe fn get_size_override(&self) -> Vector2 {
        Viewport_get_size_override(self.this)
    }

    #[inline]
    pub unsafe fn get_texture(&self) -> Option<ViewportTexture> {
        Viewport_get_texture(self.this)
    }

    #[inline]
    pub unsafe fn get_update_mode(&self) -> ViewportUpdateMode {
        Viewport_get_update_mode(self.this)
    }

    #[inline]
    pub unsafe fn get_usage(&self) -> ViewportUsage {
        Viewport_get_usage(self.this)
    }

    #[inline]
    pub unsafe fn get_vflip(&self) -> bool {
        Viewport_get_vflip(self.this)
    }

    #[inline]
    pub unsafe fn get_viewport_rid(&self) -> Rid {
        Viewport_get_viewport_rid(self.this)
    }

    #[inline]
    pub unsafe fn get_visible_rect(&self) -> Rect2 {
        Viewport_get_visible_rect(self.this)
    }

    #[inline]
    pub unsafe fn get_world(&self) -> Option<World> {
        Viewport_get_world(self.this)
    }

    #[inline]
    pub unsafe fn get_world_2d(&self) -> Option<World2D> {
        Viewport_get_world_2d(self.this)
    }

    #[inline]
    pub unsafe fn gui_get_drag_data(&self) -> Variant {
        Viewport_gui_get_drag_data(self.this)
    }

    #[inline]
    pub unsafe fn gui_has_modal_stack(&self) -> bool {
        Viewport_gui_has_modal_stack(self.this)
    }

    #[inline]
    pub unsafe fn gui_is_dragging(&self) -> bool {
        Viewport_gui_is_dragging(self.this)
    }

    #[inline]
    pub unsafe fn has_transparent_background(&self) -> bool {
        Viewport_has_transparent_background(self.this)
    }

    #[inline]
    pub unsafe fn input(&mut self, local_event: Option<InputEvent>) -> () {
        Viewport_input(self.this, local_event)
    }

    #[inline]
    pub unsafe fn is_3d_disabled(&self) -> bool {
        Viewport_is_3d_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_audio_listener(&self) -> bool {
        Viewport_is_audio_listener(self.this)
    }

    #[inline]
    pub unsafe fn is_audio_listener_2d(&self) -> bool {
        Viewport_is_audio_listener_2d(self.this)
    }

    #[inline]
    pub unsafe fn is_handling_input_locally(&self) -> bool {
        Viewport_is_handling_input_locally(self.this)
    }

    #[inline]
    pub unsafe fn is_input_disabled(&self) -> bool {
        Viewport_is_input_disabled(self.this)
    }

    #[inline]
    pub unsafe fn is_input_handled(&self) -> bool {
        Viewport_is_input_handled(self.this)
    }

    #[inline]
    pub unsafe fn is_size_override_enabled(&self) -> bool {
        Viewport_is_size_override_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_size_override_stretch_enabled(&self) -> bool {
        Viewport_is_size_override_stretch_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_snap_controls_to_pixels_enabled(&self) -> bool {
        Viewport_is_snap_controls_to_pixels_enabled(self.this)
    }

    #[inline]
    pub unsafe fn is_using_own_world(&self) -> bool {
        Viewport_is_using_own_world(self.this)
    }

    #[inline]
    pub unsafe fn is_using_render_direct_to_screen(&self) -> bool {
        Viewport_is_using_render_direct_to_screen(self.this)
    }

    #[inline]
    pub unsafe fn set_as_audio_listener(&mut self, enable: bool) -> () {
        Viewport_set_as_audio_listener(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_as_audio_listener_2d(&mut self, enable: bool) -> () {
        Viewport_set_as_audio_listener_2d(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_attach_to_screen_rect(&mut self, rect: Rect2) -> () {
        Viewport_set_attach_to_screen_rect(self.this, rect)
    }

    #[inline]
    pub unsafe fn set_canvas_transform(&mut self, xform: Transform2D) -> () {
        Viewport_set_canvas_transform(self.this, xform)
    }

    #[inline]
    pub unsafe fn set_clear_mode(&mut self, mode: i64) -> () {
        Viewport_set_clear_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_debug_draw(&mut self, debug_draw: i64) -> () {
        Viewport_set_debug_draw(self.this, debug_draw)
    }

    #[inline]
    pub unsafe fn set_disable_3d(&mut self, disable: bool) -> () {
        Viewport_set_disable_3d(self.this, disable)
    }

    #[inline]
    pub unsafe fn set_disable_input(&mut self, disable: bool) -> () {
        Viewport_set_disable_input(self.this, disable)
    }

    #[inline]
    pub unsafe fn set_global_canvas_transform(&mut self, xform: Transform2D) -> () {
        Viewport_set_global_canvas_transform(self.this, xform)
    }

    #[inline]
    pub unsafe fn set_handle_input_locally(&mut self, enable: bool) -> () {
        Viewport_set_handle_input_locally(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_hdr(&mut self, enable: bool) -> () {
        Viewport_set_hdr(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_input_as_handled(&mut self) -> () {
        Viewport_set_input_as_handled(self.this)
    }

    #[inline]
    pub unsafe fn set_keep_3d_linear(&mut self, keep_3d_linear: bool) -> () {
        Viewport_set_keep_3d_linear(self.this, keep_3d_linear)
    }

    #[inline]
    pub unsafe fn set_msaa(&mut self, msaa: i64) -> () {
        Viewport_set_msaa(self.this, msaa)
    }

    #[inline]
    pub unsafe fn set_physics_object_picking(&mut self, enable: bool) -> () {
        Viewport_set_physics_object_picking(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_shadow_atlas_quadrant_subdiv(&mut self, quadrant: i64, subdiv: i64) -> () {
        Viewport_set_shadow_atlas_quadrant_subdiv(self.this, quadrant, subdiv)
    }

    #[inline]
    pub unsafe fn set_shadow_atlas_size(&mut self, size: i64) -> () {
        Viewport_set_shadow_atlas_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_size(&mut self, size: Vector2) -> () {
        Viewport_set_size(self.this, size)
    }

    #[inline]
    pub unsafe fn set_size_override(&mut self, enable: bool, size: Vector2, margin: Vector2) -> () {
        Viewport_set_size_override(self.this, enable, size, margin)
    }

    #[inline]
    pub unsafe fn set_size_override_stretch(&mut self, enabled: bool) -> () {
        Viewport_set_size_override_stretch(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_snap_controls_to_pixels(&mut self, enabled: bool) -> () {
        Viewport_set_snap_controls_to_pixels(self.this, enabled)
    }

    #[inline]
    pub unsafe fn set_transparent_background(&mut self, enable: bool) -> () {
        Viewport_set_transparent_background(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_update_mode(&mut self, mode: i64) -> () {
        Viewport_set_update_mode(self.this, mode)
    }

    #[inline]
    pub unsafe fn set_usage(&mut self, usage: i64) -> () {
        Viewport_set_usage(self.this, usage)
    }

    #[inline]
    pub unsafe fn set_use_arvr(&mut self, _use: bool) -> () {
        Viewport_set_use_arvr(self.this, _use)
    }

    #[inline]
    pub unsafe fn set_use_own_world(&mut self, enable: bool) -> () {
        Viewport_set_use_own_world(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_use_render_direct_to_screen(&mut self, enable: bool) -> () {
        Viewport_set_use_render_direct_to_screen(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_vflip(&mut self, enable: bool) -> () {
        Viewport_set_vflip(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_world(&mut self, world: Option<World>) -> () {
        Viewport_set_world(self.this, world)
    }

    #[inline]
    pub unsafe fn set_world_2d(&mut self, world_2d: Option<World2D>) -> () {
        Viewport_set_world_2d(self.this, world_2d)
    }

    #[inline]
    pub unsafe fn unhandled_input(&mut self, local_event: Option<InputEvent>) -> () {
        Viewport_unhandled_input(self.this, local_event)
    }

    #[inline]
    pub unsafe fn update_worlds(&mut self) -> () {
        Viewport_update_worlds(self.this)
    }

    #[inline]
    pub unsafe fn use_arvr(&mut self) -> bool {
        Viewport_use_arvr(self.this)
    }

    #[inline]
    pub unsafe fn warp_mouse(&mut self, to_position: Vector2) -> () {
        Viewport_warp_mouse(self.this, to_position)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ViewportContainer` inherits `Container` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_viewportcontainer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `ViewportContainer` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `ViewportContainer::free`.
///
/// ## Class hierarchy
///
/// ViewportContainer inherits methods from:
/// - [Container](struct.Container.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ViewportContainer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ViewportContainer {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `ViewportContainer::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ViewportContainerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            ViewportContainer {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _input(&mut self, event: Option<InputEvent>) -> () {
        ViewportContainer__input(self.this, event)
    }

    #[inline]
    pub unsafe fn _unhandled_input(&mut self, event: Option<InputEvent>) -> () {
        ViewportContainer__unhandled_input(self.this, event)
    }

    #[inline]
    pub unsafe fn get_stretch_shrink(&self) -> i64 {
        ViewportContainer_get_stretch_shrink(self.this)
    }

    #[inline]
    pub unsafe fn is_stretch_enabled(&self) -> bool {
        ViewportContainer_is_stretch_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_stretch(&mut self, enable: bool) -> () {
        ViewportContainer_set_stretch(self.this, enable)
    }

    #[inline]
    pub unsafe fn set_stretch_shrink(&mut self, amount: i64) -> () {
        ViewportContainer_set_stretch_shrink(self.this, amount)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_container(&self) -> Container {
        // Not reference-counted.
        Container { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class ViewportTexture` inherits `Texture` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_viewporttexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// ViewportTexture inherits methods from:
/// - [Texture](struct.Texture.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ViewportTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ViewportTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ViewportTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            ViewportTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_viewport_path_in_scene(&self) -> NodePath {
        unsafe { ViewportTexture_get_viewport_path_in_scene(self.this) }
    }

    #[inline]
    pub fn set_viewport_path_in_scene(&mut self, path: NodePath) -> () {
        unsafe { ViewportTexture_set_viewport_path_in_scene(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_texture(&self) -> Texture {
        unsafe {{ object::add_ref(self.this); }}
        Texture { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisibilityEnabler` inherits `VisibilityNotifier` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visibilityenabler.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VisibilityEnabler` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VisibilityEnabler::free`.
///
/// ## Class hierarchy
///
/// VisibilityEnabler inherits methods from:
/// - [VisibilityNotifier](struct.VisibilityNotifier.html)
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisibilityEnabler {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisibilityEnablerEnabler {
    PauseAnimations = 0,
    FreezeBodies = 1,
    Max = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisibilityEnabler {
    pub const ENABLER_MAX: i64 = 2;
    pub const ENABLER_PAUSE_ANIMATIONS: i64 = 0;
    pub const ENABLER_FREEZE_BODIES: i64 = 1;
}
impl VisibilityEnabler {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VisibilityEnabler::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisibilityEnablerMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VisibilityEnabler {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        VisibilityEnabler__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn is_enabler_enabled(&self, enabler: i64) -> bool {
        VisibilityEnabler_is_enabler_enabled(self.this, enabler)
    }

    #[inline]
    pub unsafe fn set_enabler(&mut self, enabler: i64, enabled: bool) -> () {
        VisibilityEnabler_set_enabler(self.this, enabler, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visibility_notifier(&self) -> VisibilityNotifier {
        // Not reference-counted.
        VisibilityNotifier { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisibilityEnabler2D` inherits `VisibilityNotifier2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visibilityenabler2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VisibilityEnabler2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VisibilityEnabler2D::free`.
///
/// ## Class hierarchy
///
/// VisibilityEnabler2D inherits methods from:
/// - [VisibilityNotifier2D](struct.VisibilityNotifier2D.html)
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisibilityEnabler2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisibilityEnabler2DEnabler {
    PauseAnimations = 0,
    FreezeBodies = 1,
    PauseParticles = 2,
    ParentProcess = 3,
    ParentPhysicsProcess = 4,
    PauseAnimatedSprites = 5,
    Max = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisibilityEnabler2D {
    pub const ENABLER_PARENT_PROCESS: i64 = 3;
    pub const ENABLER_MAX: i64 = 6;
    pub const ENABLER_FREEZE_BODIES: i64 = 1;
    pub const ENABLER_PAUSE_ANIMATED_SPRITES: i64 = 5;
    pub const ENABLER_PAUSE_ANIMATIONS: i64 = 0;
    pub const ENABLER_PAUSE_PARTICLES: i64 = 2;
    pub const ENABLER_PARENT_PHYSICS_PROCESS: i64 = 4;
}
impl VisibilityEnabler2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VisibilityEnabler2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisibilityEnabler2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VisibilityEnabler2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _node_removed(&mut self, arg0: Option<Node>) -> () {
        VisibilityEnabler2D__node_removed(self.this, arg0)
    }

    #[inline]
    pub unsafe fn is_enabler_enabled(&self, enabler: i64) -> bool {
        VisibilityEnabler2D_is_enabler_enabled(self.this, enabler)
    }

    #[inline]
    pub unsafe fn set_enabler(&mut self, enabler: i64, enabled: bool) -> () {
        VisibilityEnabler2D_set_enabler(self.this, enabler, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_visibility_notifier_2d(&self) -> VisibilityNotifier2D {
        // Not reference-counted.
        VisibilityNotifier2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisibilityNotifier` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visibilitynotifier.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VisibilityNotifier` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VisibilityNotifier::free`.
///
/// ## Class hierarchy
///
/// VisibilityNotifier inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisibilityNotifier {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisibilityNotifier {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VisibilityNotifier::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisibilityNotifierMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VisibilityNotifier {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_aabb(&self) -> Aabb {
        VisibilityNotifier_get_aabb(self.this)
    }

    #[inline]
    pub unsafe fn is_on_screen(&self) -> bool {
        VisibilityNotifier_is_on_screen(self.this)
    }

    #[inline]
    pub unsafe fn set_aabb(&mut self, rect: Aabb) -> () {
        VisibilityNotifier_set_aabb(self.this, rect)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisibilityNotifier2D` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visibilitynotifier2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `VisibilityNotifier2D` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `VisibilityNotifier2D::free`.
///
/// ## Class hierarchy
///
/// VisibilityNotifier2D inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisibilityNotifier2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisibilityNotifier2D {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `VisibilityNotifier2D::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisibilityNotifier2DMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            VisibilityNotifier2D {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_rect(&self) -> Rect2 {
        VisibilityNotifier2D_get_rect(self.this)
    }

    #[inline]
    pub unsafe fn is_on_screen(&self) -> bool {
        VisibilityNotifier2D_is_on_screen(self.this)
    }

    #[inline]
    pub unsafe fn set_rect(&mut self, rect: Rect2) -> () {
        VisibilityNotifier2D_set_rect(self.this, rect)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualInstance` inherits `Spatial` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualinstance.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// VisualInstance inherits methods from:
/// - [Spatial](struct.Spatial.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualInstance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualInstance {
    #[inline]
    pub unsafe fn _get_visual_instance_rid(&self) -> Rid {
        VisualInstance__get_visual_instance_rid(self.this)
    }

    #[inline]
    pub unsafe fn get_aabb(&self) -> Aabb {
        VisualInstance_get_aabb(self.this)
    }

    #[inline]
    pub unsafe fn get_base(&self) -> Rid {
        VisualInstance_get_base(self.this)
    }

    #[inline]
    pub unsafe fn get_instance(&self) -> Rid {
        VisualInstance_get_instance(self.this)
    }

    #[inline]
    pub unsafe fn get_layer_mask(&self) -> i64 {
        VisualInstance_get_layer_mask(self.this)
    }

    #[inline]
    pub unsafe fn get_layer_mask_bit(&self, layer: i64) -> bool {
        VisualInstance_get_layer_mask_bit(self.this, layer)
    }

    #[inline]
    pub unsafe fn get_transformed_aabb(&self) -> Aabb {
        VisualInstance_get_transformed_aabb(self.this)
    }

    #[inline]
    pub unsafe fn set_base(&mut self, base: Rid) -> () {
        VisualInstance_set_base(self.this, base)
    }

    #[inline]
    pub unsafe fn set_layer_mask(&mut self, mask: i64) -> () {
        VisualInstance_set_layer_mask(self.this, mask)
    }

    #[inline]
    pub unsafe fn set_layer_mask_bit(&mut self, layer: i64, enabled: bool) -> () {
        VisualInstance_set_layer_mask_bit(self.this, layer, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_spatial(&self) -> Spatial {
        // Not reference-counted.
        Spatial { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScript` inherits `Script` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscript.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScript inherits methods from:
/// - [Script](struct.Script.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScript {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScript {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScript {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_data(&self) -> Dictionary {
        unsafe { VisualScript__get_data(self.this) }
    }

    #[inline]
    pub fn _node_ports_changed(&mut self, arg0: i64) -> () {
        unsafe { VisualScript__node_ports_changed(self.this, arg0) }
    }

    #[inline]
    pub fn _set_data(&mut self, data: Dictionary) -> () {
        unsafe { VisualScript__set_data(self.this, data) }
    }

    #[inline]
    pub fn add_custom_signal(&mut self, name: GodotString) -> () {
        unsafe { VisualScript_add_custom_signal(self.this, name) }
    }

    #[inline]
    pub fn add_function(&mut self, name: GodotString) -> () {
        unsafe { VisualScript_add_function(self.this, name) }
    }

    #[inline]
    pub fn add_node(&mut self, func: GodotString, id: i64, node: Option<VisualScriptNode>, position: Vector2) -> () {
        unsafe { VisualScript_add_node(self.this, func, id, node, position) }
    }

    #[inline]
    pub fn add_variable(&mut self, name: GodotString, default_value: Variant, export: bool) -> () {
        unsafe { VisualScript_add_variable(self.this, name, default_value, export) }
    }

    #[inline]
    pub fn custom_signal_add_argument(&mut self, name: GodotString, _type: i64, argname: GodotString, index: i64) -> () {
        unsafe { VisualScript_custom_signal_add_argument(self.this, name, _type, argname, index) }
    }

    #[inline]
    pub fn custom_signal_get_argument_count(&self, name: GodotString) -> i64 {
        unsafe { VisualScript_custom_signal_get_argument_count(self.this, name) }
    }

    #[inline]
    pub fn custom_signal_get_argument_name(&self, name: GodotString, argidx: i64) -> GodotString {
        unsafe { VisualScript_custom_signal_get_argument_name(self.this, name, argidx) }
    }

    #[inline]
    pub fn custom_signal_get_argument_type(&self, name: GodotString, argidx: i64) -> VariantType {
        unsafe { VisualScript_custom_signal_get_argument_type(self.this, name, argidx) }
    }

    #[inline]
    pub fn custom_signal_remove_argument(&mut self, name: GodotString, argidx: i64) -> () {
        unsafe { VisualScript_custom_signal_remove_argument(self.this, name, argidx) }
    }

    #[inline]
    pub fn custom_signal_set_argument_name(&mut self, name: GodotString, argidx: i64, argname: GodotString) -> () {
        unsafe { VisualScript_custom_signal_set_argument_name(self.this, name, argidx, argname) }
    }

    #[inline]
    pub fn custom_signal_set_argument_type(&mut self, name: GodotString, argidx: i64, _type: i64) -> () {
        unsafe { VisualScript_custom_signal_set_argument_type(self.this, name, argidx, _type) }
    }

    #[inline]
    pub fn custom_signal_swap_argument(&mut self, name: GodotString, argidx: i64, withidx: i64) -> () {
        unsafe { VisualScript_custom_signal_swap_argument(self.this, name, argidx, withidx) }
    }

    #[inline]
    pub fn data_connect(&mut self, func: GodotString, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> () {
        unsafe { VisualScript_data_connect(self.this, func, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn data_disconnect(&mut self, func: GodotString, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> () {
        unsafe { VisualScript_data_disconnect(self.this, func, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn get_function_node_id(&self, name: GodotString) -> i64 {
        unsafe { VisualScript_get_function_node_id(self.this, name) }
    }

    #[inline]
    pub fn get_function_scroll(&self, name: GodotString) -> Vector2 {
        unsafe { VisualScript_get_function_scroll(self.this, name) }
    }

    #[inline]
    pub fn get_node(&self, func: GodotString, id: i64) -> Option<VisualScriptNode> {
        unsafe { VisualScript_get_node(self.this, func, id) }
    }

    #[inline]
    pub fn get_node_position(&self, func: GodotString, id: i64) -> Vector2 {
        unsafe { VisualScript_get_node_position(self.this, func, id) }
    }

    #[inline]
    pub fn get_variable_default_value(&self, name: GodotString) -> Variant {
        unsafe { VisualScript_get_variable_default_value(self.this, name) }
    }

    #[inline]
    pub fn get_variable_export(&self, name: GodotString) -> bool {
        unsafe { VisualScript_get_variable_export(self.this, name) }
    }

    #[inline]
    pub fn get_variable_info(&self, name: GodotString) -> Dictionary {
        unsafe { VisualScript_get_variable_info(self.this, name) }
    }

    #[inline]
    pub fn has_custom_signal(&self, name: GodotString) -> bool {
        unsafe { VisualScript_has_custom_signal(self.this, name) }
    }

    #[inline]
    pub fn has_data_connection(&self, func: GodotString, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> bool {
        unsafe { VisualScript_has_data_connection(self.this, func, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn has_function(&self, name: GodotString) -> bool {
        unsafe { VisualScript_has_function(self.this, name) }
    }

    #[inline]
    pub fn has_node(&self, func: GodotString, id: i64) -> bool {
        unsafe { VisualScript_has_node(self.this, func, id) }
    }

    #[inline]
    pub fn has_sequence_connection(&self, func: GodotString, from_node: i64, from_output: i64, to_node: i64) -> bool {
        unsafe { VisualScript_has_sequence_connection(self.this, func, from_node, from_output, to_node) }
    }

    #[inline]
    pub fn has_variable(&self, name: GodotString) -> bool {
        unsafe { VisualScript_has_variable(self.this, name) }
    }

    #[inline]
    pub fn remove_custom_signal(&mut self, name: GodotString) -> () {
        unsafe { VisualScript_remove_custom_signal(self.this, name) }
    }

    #[inline]
    pub fn remove_function(&mut self, name: GodotString) -> () {
        unsafe { VisualScript_remove_function(self.this, name) }
    }

    #[inline]
    pub fn remove_node(&mut self, func: GodotString, id: i64) -> () {
        unsafe { VisualScript_remove_node(self.this, func, id) }
    }

    #[inline]
    pub fn remove_variable(&mut self, name: GodotString) -> () {
        unsafe { VisualScript_remove_variable(self.this, name) }
    }

    #[inline]
    pub fn rename_custom_signal(&mut self, name: GodotString, new_name: GodotString) -> () {
        unsafe { VisualScript_rename_custom_signal(self.this, name, new_name) }
    }

    #[inline]
    pub fn rename_function(&mut self, name: GodotString, new_name: GodotString) -> () {
        unsafe { VisualScript_rename_function(self.this, name, new_name) }
    }

    #[inline]
    pub fn rename_variable(&mut self, name: GodotString, new_name: GodotString) -> () {
        unsafe { VisualScript_rename_variable(self.this, name, new_name) }
    }

    #[inline]
    pub fn sequence_connect(&mut self, func: GodotString, from_node: i64, from_output: i64, to_node: i64) -> () {
        unsafe { VisualScript_sequence_connect(self.this, func, from_node, from_output, to_node) }
    }

    #[inline]
    pub fn sequence_disconnect(&mut self, func: GodotString, from_node: i64, from_output: i64, to_node: i64) -> () {
        unsafe { VisualScript_sequence_disconnect(self.this, func, from_node, from_output, to_node) }
    }

    #[inline]
    pub fn set_function_scroll(&mut self, name: GodotString, ofs: Vector2) -> () {
        unsafe { VisualScript_set_function_scroll(self.this, name, ofs) }
    }

    #[inline]
    pub fn set_instance_base_type(&mut self, _type: GodotString) -> () {
        unsafe { VisualScript_set_instance_base_type(self.this, _type) }
    }

    #[inline]
    pub fn set_node_position(&mut self, func: GodotString, id: i64, position: Vector2) -> () {
        unsafe { VisualScript_set_node_position(self.this, func, id, position) }
    }

    #[inline]
    pub fn set_variable_default_value(&mut self, name: GodotString, value: Variant) -> () {
        unsafe { VisualScript_set_variable_default_value(self.this, name, value) }
    }

    #[inline]
    pub fn set_variable_export(&mut self, name: GodotString, enable: bool) -> () {
        unsafe { VisualScript_set_variable_export(self.this, name, enable) }
    }

    #[inline]
    pub fn set_variable_info(&mut self, name: GodotString, value: Dictionary) -> () {
        unsafe { VisualScript_set_variable_info(self.this, name, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_script(&self) -> Script {
        unsafe {{ object::add_ref(self.this); }}
        Script { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptBasicTypeConstant` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptbasictypeconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptBasicTypeConstant inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptBasicTypeConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptBasicTypeConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptBasicTypeConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptBasicTypeConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_basic_type(&self) -> VariantType {
        unsafe { VisualScriptBasicTypeConstant_get_basic_type(self.this) }
    }

    #[inline]
    pub fn get_basic_type_constant(&self) -> GodotString {
        unsafe { VisualScriptBasicTypeConstant_get_basic_type_constant(self.this) }
    }

    #[inline]
    pub fn set_basic_type(&mut self, name: i64) -> () {
        unsafe { VisualScriptBasicTypeConstant_set_basic_type(self.this, name) }
    }

    #[inline]
    pub fn set_basic_type_constant(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptBasicTypeConstant_set_basic_type_constant(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptBuiltinFunc` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptbuiltinfunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptBuiltinFunc inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptBuiltinFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptBuiltinFuncBuiltinFunc {
    MathSin = 0,
    MathCos = 1,
    MathTan = 2,
    MathSinh = 3,
    MathCosh = 4,
    MathTanh = 5,
    MathAsin = 6,
    MathAcos = 7,
    MathAtan = 8,
    MathAtan2 = 9,
    MathSqrt = 10,
    MathFmod = 11,
    MathFposmod = 12,
    MathFloor = 13,
    MathCeil = 14,
    MathRound = 15,
    MathAbs = 16,
    MathSign = 17,
    MathPow = 18,
    MathLog = 19,
    MathExp = 20,
    MathIsnan = 21,
    MathIsinf = 22,
    MathEase = 23,
    MathDecimals = 24,
    MathStepify = 25,
    MathLerp = 26,
    MathInverseLerp = 27,
    MathRangeLerp = 28,
    MathMoveToward = 29,
    MathDectime = 30,
    MathRandomize = 31,
    MathRand = 32,
    MathRandf = 33,
    MathRandom = 34,
    MathSeed = 35,
    MathRandseed = 36,
    MathDeg2rad = 37,
    MathRad2deg = 38,
    MathLinear2db = 39,
    MathDb2linear = 40,
    MathPolar2cartesian = 41,
    MathCartesian2polar = 42,
    MathWrap = 43,
    MathWrapf = 44,
    LogicMax = 45,
    LogicMin = 46,
    LogicClamp = 47,
    LogicNearestPo2 = 48,
    ObjWeakref = 49,
    FuncFuncref = 50,
    TypeConvert = 51,
    TypeOf = 52,
    TypeExists = 53,
    TextChar = 54,
    TextStr = 55,
    TextPrint = 56,
    TextPrinterr = 57,
    TextPrintraw = 58,
    VarToStr = 59,
    StrToVar = 60,
    VarToBytes = 61,
    BytesToVar = 62,
    Colorn = 63,
    MathSmoothstep = 64,
    MathPosmod = 65,
    MathLerpAngle = 66,
    TextOrd = 67,
    FuncMax = 68,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptBuiltinFunc {
    pub const MATH_CARTESIAN2POLAR: i64 = 42;
    pub const TEXT_CHAR: i64 = 54;
    pub const FUNC_FUNCREF: i64 = 50;
    pub const MATH_LINEAR2DB: i64 = 39;
    pub const MATH_MOVE_TOWARD: i64 = 29;
    pub const TEXT_PRINT: i64 = 56;
    pub const TYPE_EXISTS: i64 = 53;
    pub const MATH_POSMOD: i64 = 65;
    pub const MATH_DEG2RAD: i64 = 37;
    pub const LOGIC_CLAMP: i64 = 47;
    pub const TEXT_STR: i64 = 55;
    pub const MATH_ACOS: i64 = 7;
    pub const MATH_DECIMALS: i64 = 24;
    pub const MATH_RAND: i64 = 32;
    pub const MATH_COSH: i64 = 4;
    pub const TYPE_OF: i64 = 52;
    pub const TEXT_PRINTERR: i64 = 57;
    pub const MATH_WRAPF: i64 = 44;
    pub const MATH_RANDOM: i64 = 34;
    pub const MATH_POW: i64 = 18;
    pub const STR_TO_VAR: i64 = 60;
    pub const MATH_DECTIME: i64 = 30;
    pub const VAR_TO_STR: i64 = 59;
    pub const MATH_FMOD: i64 = 11;
    pub const MATH_ISINF: i64 = 22;
    pub const MATH_TANH: i64 = 5;
    pub const TYPE_CONVERT: i64 = 51;
    pub const MATH_FLOOR: i64 = 13;
    pub const LOGIC_MIN: i64 = 46;
    pub const MATH_EXP: i64 = 20;
    pub const MATH_RANDSEED: i64 = 36;
    pub const MATH_INVERSE_LERP: i64 = 27;
    pub const MATH_SEED: i64 = 35;
    pub const MATH_ISNAN: i64 = 21;
    pub const MATH_ROUND: i64 = 15;
    pub const COLORN: i64 = 63;
    pub const TEXT_ORD: i64 = 67;
    pub const MATH_DB2LINEAR: i64 = 40;
    pub const MATH_SQRT: i64 = 10;
    pub const VAR_TO_BYTES: i64 = 61;
    pub const MATH_CEIL: i64 = 14;
    pub const MATH_ABS: i64 = 16;
    pub const MATH_EASE: i64 = 23;
    pub const MATH_SINH: i64 = 3;
    pub const MATH_FPOSMOD: i64 = 12;
    pub const TEXT_PRINTRAW: i64 = 58;
    pub const MATH_SIGN: i64 = 17;
    pub const FUNC_MAX: i64 = 68;
    pub const MATH_RANGE_LERP: i64 = 28;
    pub const MATH_ATAN: i64 = 8;
    pub const MATH_RANDOMIZE: i64 = 31;
    pub const MATH_ATAN2: i64 = 9;
    pub const MATH_LERP: i64 = 26;
    pub const MATH_LERP_ANGLE: i64 = 66;
    pub const MATH_RAD2DEG: i64 = 38;
    pub const MATH_ASIN: i64 = 6;
    pub const MATH_SIN: i64 = 0;
    pub const MATH_STEPIFY: i64 = 25;
    pub const MATH_WRAP: i64 = 43;
    pub const BYTES_TO_VAR: i64 = 62;
    pub const MATH_TAN: i64 = 2;
    pub const OBJ_WEAKREF: i64 = 49;
    pub const MATH_RANDF: i64 = 33;
    pub const MATH_COS: i64 = 1;
    pub const MATH_SMOOTHSTEP: i64 = 64;
    pub const LOGIC_NEAREST_PO2: i64 = 48;
    pub const MATH_POLAR2CARTESIAN: i64 = 41;
    pub const LOGIC_MAX: i64 = 45;
    pub const MATH_LOG: i64 = 19;
}
impl VisualScriptBuiltinFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptBuiltinFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptBuiltinFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_func(&mut self) -> VisualScriptBuiltinFuncBuiltinFunc {
        unsafe { VisualScriptBuiltinFunc_get_func(self.this) }
    }

    #[inline]
    pub fn set_func(&mut self, which: i64) -> () {
        unsafe { VisualScriptBuiltinFunc_set_func(self.this, which) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptClassConstant` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptclassconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptClassConstant inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptClassConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptClassConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptClassConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptClassConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_base_type(&mut self) -> GodotString {
        unsafe { VisualScriptClassConstant_get_base_type(self.this) }
    }

    #[inline]
    pub fn get_class_constant(&mut self) -> GodotString {
        unsafe { VisualScriptClassConstant_get_class_constant(self.this) }
    }

    #[inline]
    pub fn set_base_type(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptClassConstant_set_base_type(self.this, name) }
    }

    #[inline]
    pub fn set_class_constant(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptClassConstant_set_class_constant(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptComment` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptcomment.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptComment inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptComment {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptComment {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptCommentMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptComment {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_description(&self) -> GodotString {
        unsafe { VisualScriptComment_get_description(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { VisualScriptComment_get_size(self.this) }
    }

    #[inline]
    pub fn get_title(&self) -> GodotString {
        unsafe { VisualScriptComment_get_title(self.this) }
    }

    #[inline]
    pub fn set_description(&mut self, description: GodotString) -> () {
        unsafe { VisualScriptComment_set_description(self.this, description) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector2) -> () {
        unsafe { VisualScriptComment_set_size(self.this, size) }
    }

    #[inline]
    pub fn set_title(&mut self, title: GodotString) -> () {
        unsafe { VisualScriptComment_set_title(self.this, title) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptComposeArray` inherits `VisualScriptLists` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptcomposearray.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptComposeArray inherits methods from:
/// - [VisualScriptLists](struct.VisualScriptLists.html)
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptComposeArray {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptComposeArray {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptComposeArrayMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptComposeArray {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_lists(&self) -> VisualScriptLists {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptLists { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptCondition` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptcondition.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptCondition inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptCondition {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptCondition {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptConditionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptCondition {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptConstant` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptConstant inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant_type(&self) -> VariantType {
        unsafe { VisualScriptConstant_get_constant_type(self.this) }
    }

    #[inline]
    pub fn get_constant_value(&self) -> Variant {
        unsafe { VisualScriptConstant_get_constant_value(self.this) }
    }

    #[inline]
    pub fn set_constant_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptConstant_set_constant_type(self.this, _type) }
    }

    #[inline]
    pub fn set_constant_value(&mut self, value: Variant) -> () {
        unsafe { VisualScriptConstant_set_constant_value(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptConstructor` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptconstructor.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptConstructor inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptConstructor {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptConstructor {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptConstructorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptConstructor {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constructor(&self) -> Dictionary {
        unsafe { VisualScriptConstructor_get_constructor(self.this) }
    }

    #[inline]
    pub fn get_constructor_type(&self) -> VariantType {
        unsafe { VisualScriptConstructor_get_constructor_type(self.this) }
    }

    #[inline]
    pub fn set_constructor(&mut self, constructor: Dictionary) -> () {
        unsafe { VisualScriptConstructor_set_constructor(self.this, constructor) }
    }

    #[inline]
    pub fn set_constructor_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptConstructor_set_constructor_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptCustomNode` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptcustomnode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptCustomNode inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptCustomNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptCustomNodeStartMode {
    ModeBeginSequence = 0,
    ModeContinueSequence = 1,
    ModeResumeYield = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptCustomNode {
    pub const START_MODE_BEGIN_SEQUENCE: i64 = 0;
    pub const START_MODE_CONTINUE_SEQUENCE: i64 = 1;
    pub const STEP_EXIT_FUNCTION_BIT: i64 = 134217728;
    pub const STEP_YIELD_BIT: i64 = 268435456;
    pub const STEP_GO_BACK_BIT: i64 = 33554432;
    pub const START_MODE_RESUME_YIELD: i64 = 2;
    pub const STEP_NO_ADVANCE_BIT: i64 = 67108864;
    pub const STEP_PUSH_STACK_BIT: i64 = 16777216;
}
impl VisualScriptCustomNode {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptCustomNodeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptCustomNode {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_caption(&mut self) -> GodotString {
        unsafe { VisualScriptCustomNode__get_caption(self.this) }
    }

    #[inline]
    pub fn _get_category(&mut self) -> GodotString {
        unsafe { VisualScriptCustomNode__get_category(self.this) }
    }

    #[inline]
    pub fn _get_input_value_port_count(&mut self) -> i64 {
        unsafe { VisualScriptCustomNode__get_input_value_port_count(self.this) }
    }

    #[inline]
    pub fn _get_input_value_port_name(&mut self, idx: i64) -> GodotString {
        unsafe { VisualScriptCustomNode__get_input_value_port_name(self.this, idx) }
    }

    #[inline]
    pub fn _get_input_value_port_type(&mut self, idx: i64) -> i64 {
        unsafe { VisualScriptCustomNode__get_input_value_port_type(self.this, idx) }
    }

    #[inline]
    pub fn _get_output_sequence_port_count(&mut self) -> i64 {
        unsafe { VisualScriptCustomNode__get_output_sequence_port_count(self.this) }
    }

    #[inline]
    pub fn _get_output_sequence_port_text(&mut self, idx: i64) -> GodotString {
        unsafe { VisualScriptCustomNode__get_output_sequence_port_text(self.this, idx) }
    }

    #[inline]
    pub fn _get_output_value_port_count(&mut self) -> i64 {
        unsafe { VisualScriptCustomNode__get_output_value_port_count(self.this) }
    }

    #[inline]
    pub fn _get_output_value_port_name(&mut self, idx: i64) -> GodotString {
        unsafe { VisualScriptCustomNode__get_output_value_port_name(self.this, idx) }
    }

    #[inline]
    pub fn _get_output_value_port_type(&mut self, idx: i64) -> i64 {
        unsafe { VisualScriptCustomNode__get_output_value_port_type(self.this, idx) }
    }

    #[inline]
    pub fn _get_text(&mut self) -> GodotString {
        unsafe { VisualScriptCustomNode__get_text(self.this) }
    }

    #[inline]
    pub fn _get_working_memory_size(&mut self) -> i64 {
        unsafe { VisualScriptCustomNode__get_working_memory_size(self.this) }
    }

    #[inline]
    pub fn _has_input_sequence_port(&mut self) -> bool {
        unsafe { VisualScriptCustomNode__has_input_sequence_port(self.this) }
    }

    #[inline]
    pub fn _script_changed(&mut self) -> () {
        unsafe { VisualScriptCustomNode__script_changed(self.this) }
    }

    #[inline]
    pub fn _step(&mut self, inputs: VariantArray, outputs: VariantArray, start_mode: i64, working_mem: VariantArray) -> Variant {
        unsafe { VisualScriptCustomNode__step(self.this, inputs, outputs, start_mode, working_mem) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptDeconstruct` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptdeconstruct.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptDeconstruct inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptDeconstruct {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptDeconstruct {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptDeconstructMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptDeconstruct {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_elem_cache(&self) -> VariantArray {
        unsafe { VisualScriptDeconstruct__get_elem_cache(self.this) }
    }

    #[inline]
    pub fn _set_elem_cache(&mut self, _cache: VariantArray) -> () {
        unsafe { VisualScriptDeconstruct__set_elem_cache(self.this, _cache) }
    }

    #[inline]
    pub fn get_deconstruct_type(&self) -> VariantType {
        unsafe { VisualScriptDeconstruct_get_deconstruct_type(self.this) }
    }

    #[inline]
    pub fn set_deconstruct_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptDeconstruct_set_deconstruct_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptEmitSignal` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptemitsignal.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptEmitSignal inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptEmitSignal {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptEmitSignal {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptEmitSignalMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptEmitSignal {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_signal(&self) -> GodotString {
        unsafe { VisualScriptEmitSignal_get_signal(self.this) }
    }

    #[inline]
    pub fn set_signal(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptEmitSignal_set_signal(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptEngineSingleton` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptenginesingleton.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptEngineSingleton inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptEngineSingleton {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptEngineSingleton {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptEngineSingletonMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptEngineSingleton {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_singleton(&mut self) -> GodotString {
        unsafe { VisualScriptEngineSingleton_get_singleton(self.this) }
    }

    #[inline]
    pub fn set_singleton(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptEngineSingleton_set_singleton(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptExpression` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptexpression.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptExpression inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptExpression {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptExpression {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptExpressionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptExpression {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptFunction` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptfunction.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptFunction inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptFunction {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptFunction {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptFunctionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptFunction {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptFunctionCall` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptfunctioncall.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptFunctionCall inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptFunctionCall {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptFunctionCallRPCCallMode {
    RpcDisabled = 0,
    RpcReliable = 1,
    RpcUnreliable = 2,
    RpcReliableToId = 3,
    RpcUnreliableToId = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptFunctionCallCallMode {
    ModeSelf = 0,
    ModeNodePath = 1,
    ModeInstance = 2,
    ModeBasicType = 3,
    ModeSingleton = 4,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptFunctionCall {
    pub const CALL_MODE_SINGLETON: i64 = 4;
    pub const RPC_DISABLED: i64 = 0;
    pub const CALL_MODE_INSTANCE: i64 = 2;
    pub const RPC_UNRELIABLE_TO_ID: i64 = 4;
    pub const RPC_UNRELIABLE: i64 = 2;
    pub const CALL_MODE_SELF: i64 = 0;
    pub const RPC_RELIABLE_TO_ID: i64 = 3;
    pub const CALL_MODE_BASIC_TYPE: i64 = 3;
    pub const CALL_MODE_NODE_PATH: i64 = 1;
    pub const RPC_RELIABLE: i64 = 1;
}
impl VisualScriptFunctionCall {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptFunctionCallMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptFunctionCall {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_argument_cache(&self) -> Dictionary {
        unsafe { VisualScriptFunctionCall__get_argument_cache(self.this) }
    }

    #[inline]
    pub fn _set_argument_cache(&mut self, argument_cache: Dictionary) -> () {
        unsafe { VisualScriptFunctionCall__set_argument_cache(self.this, argument_cache) }
    }

    #[inline]
    pub fn get_base_path(&self) -> NodePath {
        unsafe { VisualScriptFunctionCall_get_base_path(self.this) }
    }

    #[inline]
    pub fn get_base_script(&self) -> GodotString {
        unsafe { VisualScriptFunctionCall_get_base_script(self.this) }
    }

    #[inline]
    pub fn get_base_type(&self) -> GodotString {
        unsafe { VisualScriptFunctionCall_get_base_type(self.this) }
    }

    #[inline]
    pub fn get_basic_type(&self) -> VariantType {
        unsafe { VisualScriptFunctionCall_get_basic_type(self.this) }
    }

    #[inline]
    pub fn get_call_mode(&self) -> VisualScriptFunctionCallCallMode {
        unsafe { VisualScriptFunctionCall_get_call_mode(self.this) }
    }

    #[inline]
    pub fn get_function(&self) -> GodotString {
        unsafe { VisualScriptFunctionCall_get_function(self.this) }
    }

    #[inline]
    pub fn get_rpc_call_mode(&self) -> VisualScriptFunctionCallRPCCallMode {
        unsafe { VisualScriptFunctionCall_get_rpc_call_mode(self.this) }
    }

    #[inline]
    pub fn get_singleton(&self) -> GodotString {
        unsafe { VisualScriptFunctionCall_get_singleton(self.this) }
    }

    #[inline]
    pub fn get_use_default_args(&self) -> i64 {
        unsafe { VisualScriptFunctionCall_get_use_default_args(self.this) }
    }

    #[inline]
    pub fn get_validate(&self) -> bool {
        unsafe { VisualScriptFunctionCall_get_validate(self.this) }
    }

    #[inline]
    pub fn set_base_path(&mut self, base_path: NodePath) -> () {
        unsafe { VisualScriptFunctionCall_set_base_path(self.this, base_path) }
    }

    #[inline]
    pub fn set_base_script(&mut self, base_script: GodotString) -> () {
        unsafe { VisualScriptFunctionCall_set_base_script(self.this, base_script) }
    }

    #[inline]
    pub fn set_base_type(&mut self, base_type: GodotString) -> () {
        unsafe { VisualScriptFunctionCall_set_base_type(self.this, base_type) }
    }

    #[inline]
    pub fn set_basic_type(&mut self, basic_type: i64) -> () {
        unsafe { VisualScriptFunctionCall_set_basic_type(self.this, basic_type) }
    }

    #[inline]
    pub fn set_call_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptFunctionCall_set_call_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_function(&mut self, function: GodotString) -> () {
        unsafe { VisualScriptFunctionCall_set_function(self.this, function) }
    }

    #[inline]
    pub fn set_rpc_call_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptFunctionCall_set_rpc_call_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_singleton(&mut self, singleton: GodotString) -> () {
        unsafe { VisualScriptFunctionCall_set_singleton(self.this, singleton) }
    }

    #[inline]
    pub fn set_use_default_args(&mut self, amount: i64) -> () {
        unsafe { VisualScriptFunctionCall_set_use_default_args(self.this, amount) }
    }

    #[inline]
    pub fn set_validate(&mut self, enable: bool) -> () {
        unsafe { VisualScriptFunctionCall_set_validate(self.this, enable) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptFunctionState` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptfunctionstate.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptFunctionState inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptFunctionState {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptFunctionState {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptFunctionStateMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptFunctionState {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _signal_callback(&mut self, varargs: &[Variant]) -> Variant {
        unsafe { VisualScriptFunctionState__signal_callback(self.this, varargs) }
    }

    #[inline]
    pub fn connect_to_signal(&mut self, obj: Option<Object>, signals: GodotString, args: VariantArray) -> () {
        unsafe { VisualScriptFunctionState_connect_to_signal(self.this, obj, signals, args) }
    }

    #[inline]
    pub fn is_valid(&self) -> bool {
        unsafe { VisualScriptFunctionState_is_valid(self.this) }
    }

    #[inline]
    pub fn resume(&mut self, args: VariantArray) -> Variant {
        unsafe { VisualScriptFunctionState_resume(self.this, args) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptGlobalConstant` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptglobalconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptGlobalConstant inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptGlobalConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptGlobalConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptGlobalConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptGlobalConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_global_constant(&mut self) -> i64 {
        unsafe { VisualScriptGlobalConstant_get_global_constant(self.this) }
    }

    #[inline]
    pub fn set_global_constant(&mut self, index: i64) -> () {
        unsafe { VisualScriptGlobalConstant_set_global_constant(self.this, index) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptIndexGet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptindexget.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptIndexGet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptIndexGet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptIndexGet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptIndexGetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptIndexGet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptIndexSet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptindexset.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptIndexSet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptIndexSet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptIndexSet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptIndexSetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptIndexSet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptInputAction` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptinputaction.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptInputAction inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptInputAction {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptInputActionMode {
    ModePressed = 0,
    ModeReleased = 1,
    ModeJustPressed = 2,
    ModeJustReleased = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptInputAction {
    pub const MODE_JUST_PRESSED: i64 = 2;
    pub const MODE_JUST_RELEASED: i64 = 3;
    pub const MODE_PRESSED: i64 = 0;
    pub const MODE_RELEASED: i64 = 1;
}
impl VisualScriptInputAction {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptInputActionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptInputAction {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_action_mode(&self) -> VisualScriptInputActionMode {
        unsafe { VisualScriptInputAction_get_action_mode(self.this) }
    }

    #[inline]
    pub fn get_action_name(&self) -> GodotString {
        unsafe { VisualScriptInputAction_get_action_name(self.this) }
    }

    #[inline]
    pub fn set_action_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptInputAction_set_action_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_action_name(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptInputAction_set_action_name(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptIterator` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptiterator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptIterator inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptIterator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptIterator {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptIteratorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptIterator {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptLists` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptlists.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptLists inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptLists {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptLists {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_input_data_port(&mut self, _type: i64, name: GodotString, index: i64) -> () {
        unsafe { VisualScriptLists_add_input_data_port(self.this, _type, name, index) }
    }

    #[inline]
    pub fn add_output_data_port(&mut self, _type: i64, name: GodotString, index: i64) -> () {
        unsafe { VisualScriptLists_add_output_data_port(self.this, _type, name, index) }
    }

    #[inline]
    pub fn remove_input_data_port(&mut self, index: i64) -> () {
        unsafe { VisualScriptLists_remove_input_data_port(self.this, index) }
    }

    #[inline]
    pub fn remove_output_data_port(&mut self, index: i64) -> () {
        unsafe { VisualScriptLists_remove_output_data_port(self.this, index) }
    }

    #[inline]
    pub fn set_input_data_port_name(&mut self, index: i64, name: GodotString) -> () {
        unsafe { VisualScriptLists_set_input_data_port_name(self.this, index, name) }
    }

    #[inline]
    pub fn set_input_data_port_type(&mut self, index: i64, _type: i64) -> () {
        unsafe { VisualScriptLists_set_input_data_port_type(self.this, index, _type) }
    }

    #[inline]
    pub fn set_output_data_port_name(&mut self, index: i64, name: GodotString) -> () {
        unsafe { VisualScriptLists_set_output_data_port_name(self.this, index, name) }
    }

    #[inline]
    pub fn set_output_data_port_type(&mut self, index: i64, _type: i64) -> () {
        unsafe { VisualScriptLists_set_output_data_port_type(self.this, index, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptLocalVar` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptlocalvar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptLocalVar inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptLocalVar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptLocalVar {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptLocalVarMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptLocalVar {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_var_name(&self) -> GodotString {
        unsafe { VisualScriptLocalVar_get_var_name(self.this) }
    }

    #[inline]
    pub fn get_var_type(&self) -> VariantType {
        unsafe { VisualScriptLocalVar_get_var_type(self.this) }
    }

    #[inline]
    pub fn set_var_name(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptLocalVar_set_var_name(self.this, name) }
    }

    #[inline]
    pub fn set_var_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptLocalVar_set_var_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptLocalVarSet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptlocalvarset.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptLocalVarSet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptLocalVarSet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptLocalVarSet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptLocalVarSetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptLocalVarSet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_var_name(&self) -> GodotString {
        unsafe { VisualScriptLocalVarSet_get_var_name(self.this) }
    }

    #[inline]
    pub fn get_var_type(&self) -> VariantType {
        unsafe { VisualScriptLocalVarSet_get_var_type(self.this) }
    }

    #[inline]
    pub fn set_var_name(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptLocalVarSet_set_var_name(self.this, name) }
    }

    #[inline]
    pub fn set_var_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptLocalVarSet_set_var_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptMathConstant` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptmathconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptMathConstant inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptMathConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptMathConstantMathConstant {
    One = 0,
    Pi = 1,
    HalfPi = 2,
    Tau = 3,
    E = 4,
    Sqrt2 = 5,
    Inf = 6,
    Nan = 7,
    Max = 8,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptMathConstant {
    pub const MATH_CONSTANT_SQRT2: i64 = 5;
    pub const MATH_CONSTANT_E: i64 = 4;
    pub const MATH_CONSTANT_PI: i64 = 1;
    pub const MATH_CONSTANT_INF: i64 = 6;
    pub const MATH_CONSTANT_ONE: i64 = 0;
    pub const MATH_CONSTANT_NAN: i64 = 7;
    pub const MATH_CONSTANT_MAX: i64 = 8;
    pub const MATH_CONSTANT_HALF_PI: i64 = 2;
    pub const MATH_CONSTANT_TAU: i64 = 3;
}
impl VisualScriptMathConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptMathConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptMathConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_math_constant(&mut self) -> VisualScriptMathConstantMathConstant {
        unsafe { VisualScriptMathConstant_get_math_constant(self.this) }
    }

    #[inline]
    pub fn set_math_constant(&mut self, which: i64) -> () {
        unsafe { VisualScriptMathConstant_set_math_constant(self.this, which) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptNode` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptnode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptNode inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptNode {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_default_input_values(&self) -> VariantArray {
        unsafe { VisualScriptNode__get_default_input_values(self.this) }
    }

    #[inline]
    pub fn _set_default_input_values(&mut self, values: VariantArray) -> () {
        unsafe { VisualScriptNode__set_default_input_values(self.this, values) }
    }

    #[inline]
    pub fn get_default_input_value(&self, port_idx: i64) -> Variant {
        unsafe { VisualScriptNode_get_default_input_value(self.this, port_idx) }
    }

    #[inline]
    pub fn get_visual_script(&self) -> Option<VisualScript> {
        unsafe { VisualScriptNode_get_visual_script(self.this) }
    }

    #[inline]
    pub fn ports_changed_notify(&mut self) -> () {
        unsafe { VisualScriptNode_ports_changed_notify(self.this) }
    }

    #[inline]
    pub fn set_default_input_value(&mut self, port_idx: i64, value: Variant) -> () {
        unsafe { VisualScriptNode_set_default_input_value(self.this, port_idx, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptOperator` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptoperator.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptOperator inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptOperator {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptOperator {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptOperatorMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptOperator {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VariantOperator {
        unsafe { VisualScriptOperator_get_operator(self.this) }
    }

    #[inline]
    pub fn get_typed(&self) -> VariantType {
        unsafe { VisualScriptOperator_get_typed(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualScriptOperator_set_operator(self.this, op) }
    }

    #[inline]
    pub fn set_typed(&mut self, _type: i64) -> () {
        unsafe { VisualScriptOperator_set_typed(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptPreload` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptpreload.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptPreload inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptPreload {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptPreload {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptPreloadMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptPreload {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_preload(&self) -> Option<Resource> {
        unsafe { VisualScriptPreload_get_preload(self.this) }
    }

    #[inline]
    pub fn set_preload(&mut self, resource: Option<Resource>) -> () {
        unsafe { VisualScriptPreload_set_preload(self.this, resource) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptPropertyGet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptpropertyget.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptPropertyGet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptPropertyGet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptPropertyGetCallMode {
    ModeSelf = 0,
    ModeNodePath = 1,
    ModeInstance = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptPropertyGet {
    pub const CALL_MODE_SELF: i64 = 0;
    pub const CALL_MODE_INSTANCE: i64 = 2;
    pub const CALL_MODE_NODE_PATH: i64 = 1;
}
impl VisualScriptPropertyGet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptPropertyGetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptPropertyGet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_type_cache(&self) -> VariantType {
        unsafe { VisualScriptPropertyGet__get_type_cache(self.this) }
    }

    #[inline]
    pub fn _set_type_cache(&mut self, type_cache: i64) -> () {
        unsafe { VisualScriptPropertyGet__set_type_cache(self.this, type_cache) }
    }

    #[inline]
    pub fn get_base_path(&self) -> NodePath {
        unsafe { VisualScriptPropertyGet_get_base_path(self.this) }
    }

    #[inline]
    pub fn get_base_script(&self) -> GodotString {
        unsafe { VisualScriptPropertyGet_get_base_script(self.this) }
    }

    #[inline]
    pub fn get_base_type(&self) -> GodotString {
        unsafe { VisualScriptPropertyGet_get_base_type(self.this) }
    }

    #[inline]
    pub fn get_basic_type(&self) -> VariantType {
        unsafe { VisualScriptPropertyGet_get_basic_type(self.this) }
    }

    #[inline]
    pub fn get_call_mode(&self) -> VisualScriptPropertyGetCallMode {
        unsafe { VisualScriptPropertyGet_get_call_mode(self.this) }
    }

    #[inline]
    pub fn get_index(&self) -> GodotString {
        unsafe { VisualScriptPropertyGet_get_index(self.this) }
    }

    #[inline]
    pub fn get_property(&self) -> GodotString {
        unsafe { VisualScriptPropertyGet_get_property(self.this) }
    }

    #[inline]
    pub fn set_base_path(&mut self, base_path: NodePath) -> () {
        unsafe { VisualScriptPropertyGet_set_base_path(self.this, base_path) }
    }

    #[inline]
    pub fn set_base_script(&mut self, base_script: GodotString) -> () {
        unsafe { VisualScriptPropertyGet_set_base_script(self.this, base_script) }
    }

    #[inline]
    pub fn set_base_type(&mut self, base_type: GodotString) -> () {
        unsafe { VisualScriptPropertyGet_set_base_type(self.this, base_type) }
    }

    #[inline]
    pub fn set_basic_type(&mut self, basic_type: i64) -> () {
        unsafe { VisualScriptPropertyGet_set_basic_type(self.this, basic_type) }
    }

    #[inline]
    pub fn set_call_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptPropertyGet_set_call_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_index(&mut self, index: GodotString) -> () {
        unsafe { VisualScriptPropertyGet_set_index(self.this, index) }
    }

    #[inline]
    pub fn set_property(&mut self, property: GodotString) -> () {
        unsafe { VisualScriptPropertyGet_set_property(self.this, property) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptPropertySet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptpropertyset.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptPropertySet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptPropertySet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptPropertySetAssignOp {
    None = 0,
    Add = 1,
    Sub = 2,
    Mul = 3,
    Div = 4,
    Mod = 5,
    ShiftLeft = 6,
    ShiftRight = 7,
    BitAnd = 8,
    BitOr = 9,
    BitXor = 10,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptPropertySetCallMode {
    ModeSelf = 0,
    ModeNodePath = 1,
    ModeInstance = 2,
    ModeBasicType = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptPropertySet {
    pub const ASSIGN_OP_SUB: i64 = 2;
    pub const ASSIGN_OP_ADD: i64 = 1;
    pub const ASSIGN_OP_BIT_AND: i64 = 8;
    pub const ASSIGN_OP_NONE: i64 = 0;
    pub const ASSIGN_OP_MUL: i64 = 3;
    pub const ASSIGN_OP_SHIFT_LEFT: i64 = 6;
    pub const CALL_MODE_SELF: i64 = 0;
    pub const ASSIGN_OP_SHIFT_RIGHT: i64 = 7;
    pub const CALL_MODE_BASIC_TYPE: i64 = 3;
    pub const CALL_MODE_INSTANCE: i64 = 2;
    pub const ASSIGN_OP_DIV: i64 = 4;
    pub const ASSIGN_OP_BIT_XOR: i64 = 10;
    pub const ASSIGN_OP_MOD: i64 = 5;
    pub const ASSIGN_OP_BIT_OR: i64 = 9;
    pub const CALL_MODE_NODE_PATH: i64 = 1;
}
impl VisualScriptPropertySet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptPropertySetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptPropertySet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_type_cache(&self) -> Dictionary {
        unsafe { VisualScriptPropertySet__get_type_cache(self.this) }
    }

    #[inline]
    pub fn _set_type_cache(&mut self, type_cache: Dictionary) -> () {
        unsafe { VisualScriptPropertySet__set_type_cache(self.this, type_cache) }
    }

    #[inline]
    pub fn get_assign_op(&self) -> VisualScriptPropertySetAssignOp {
        unsafe { VisualScriptPropertySet_get_assign_op(self.this) }
    }

    #[inline]
    pub fn get_base_path(&self) -> NodePath {
        unsafe { VisualScriptPropertySet_get_base_path(self.this) }
    }

    #[inline]
    pub fn get_base_script(&self) -> GodotString {
        unsafe { VisualScriptPropertySet_get_base_script(self.this) }
    }

    #[inline]
    pub fn get_base_type(&self) -> GodotString {
        unsafe { VisualScriptPropertySet_get_base_type(self.this) }
    }

    #[inline]
    pub fn get_basic_type(&self) -> VariantType {
        unsafe { VisualScriptPropertySet_get_basic_type(self.this) }
    }

    #[inline]
    pub fn get_call_mode(&self) -> VisualScriptPropertySetCallMode {
        unsafe { VisualScriptPropertySet_get_call_mode(self.this) }
    }

    #[inline]
    pub fn get_index(&self) -> GodotString {
        unsafe { VisualScriptPropertySet_get_index(self.this) }
    }

    #[inline]
    pub fn get_property(&self) -> GodotString {
        unsafe { VisualScriptPropertySet_get_property(self.this) }
    }

    #[inline]
    pub fn set_assign_op(&mut self, assign_op: i64) -> () {
        unsafe { VisualScriptPropertySet_set_assign_op(self.this, assign_op) }
    }

    #[inline]
    pub fn set_base_path(&mut self, base_path: NodePath) -> () {
        unsafe { VisualScriptPropertySet_set_base_path(self.this, base_path) }
    }

    #[inline]
    pub fn set_base_script(&mut self, base_script: GodotString) -> () {
        unsafe { VisualScriptPropertySet_set_base_script(self.this, base_script) }
    }

    #[inline]
    pub fn set_base_type(&mut self, base_type: GodotString) -> () {
        unsafe { VisualScriptPropertySet_set_base_type(self.this, base_type) }
    }

    #[inline]
    pub fn set_basic_type(&mut self, basic_type: i64) -> () {
        unsafe { VisualScriptPropertySet_set_basic_type(self.this, basic_type) }
    }

    #[inline]
    pub fn set_call_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptPropertySet_set_call_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_index(&mut self, index: GodotString) -> () {
        unsafe { VisualScriptPropertySet_set_index(self.this, index) }
    }

    #[inline]
    pub fn set_property(&mut self, property: GodotString) -> () {
        unsafe { VisualScriptPropertySet_set_property(self.this, property) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptResourcePath` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptresourcepath.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptResourcePath inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptResourcePath {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptResourcePath {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptResourcePathMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptResourcePath {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_resource_path(&mut self) -> GodotString {
        unsafe { VisualScriptResourcePath_get_resource_path(self.this) }
    }

    #[inline]
    pub fn set_resource_path(&mut self, path: GodotString) -> () {
        unsafe { VisualScriptResourcePath_set_resource_path(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptReturn` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptreturn.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptReturn inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptReturn {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptReturn {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptReturnMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptReturn {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_return_type(&self) -> VariantType {
        unsafe { VisualScriptReturn_get_return_type(self.this) }
    }

    #[inline]
    pub fn is_return_value_enabled(&self) -> bool {
        unsafe { VisualScriptReturn_is_return_value_enabled(self.this) }
    }

    #[inline]
    pub fn set_enable_return_value(&mut self, enable: bool) -> () {
        unsafe { VisualScriptReturn_set_enable_return_value(self.this, enable) }
    }

    #[inline]
    pub fn set_return_type(&mut self, _type: i64) -> () {
        unsafe { VisualScriptReturn_set_return_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSceneNode` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptscenenode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSceneNode inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSceneNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSceneNode {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSceneNodeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSceneNode {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_node_path(&mut self) -> NodePath {
        unsafe { VisualScriptSceneNode_get_node_path(self.this) }
    }

    #[inline]
    pub fn set_node_path(&mut self, path: NodePath) -> () {
        unsafe { VisualScriptSceneNode_set_node_path(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSceneTree` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptscenetree.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSceneTree inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSceneTree {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSceneTree {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSceneTreeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSceneTree {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSelect` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptselect.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSelect inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSelect {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSelect {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSelectMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSelect {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_typed(&self) -> VariantType {
        unsafe { VisualScriptSelect_get_typed(self.this) }
    }

    #[inline]
    pub fn set_typed(&mut self, _type: i64) -> () {
        unsafe { VisualScriptSelect_set_typed(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSelf` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptself.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSelf inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSelf {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSelf {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSelfMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSelf {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSequence` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptsequence.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSequence inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSequence {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSequence {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSequenceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSequence {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_steps(&self) -> i64 {
        unsafe { VisualScriptSequence_get_steps(self.this) }
    }

    #[inline]
    pub fn set_steps(&mut self, steps: i64) -> () {
        unsafe { VisualScriptSequence_set_steps(self.this, steps) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSubCall` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptsubcall.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSubCall inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSubCall {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSubCall {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSubCallMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSubCall {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _subcall(&mut self, arguments: Variant) -> Variant {
        unsafe { VisualScriptSubCall__subcall(self.this, arguments) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptSwitch` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptswitch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptSwitch inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptSwitch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptSwitch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptSwitchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptSwitch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptTypeCast` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscripttypecast.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptTypeCast inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptTypeCast {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptTypeCast {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptTypeCastMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptTypeCast {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_base_script(&self) -> GodotString {
        unsafe { VisualScriptTypeCast_get_base_script(self.this) }
    }

    #[inline]
    pub fn get_base_type(&self) -> GodotString {
        unsafe { VisualScriptTypeCast_get_base_type(self.this) }
    }

    #[inline]
    pub fn set_base_script(&mut self, path: GodotString) -> () {
        unsafe { VisualScriptTypeCast_set_base_script(self.this, path) }
    }

    #[inline]
    pub fn set_base_type(&mut self, _type: GodotString) -> () {
        unsafe { VisualScriptTypeCast_set_base_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptVariableGet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptvariableget.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptVariableGet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptVariableGet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptVariableGet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptVariableGetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptVariableGet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_variable(&self) -> GodotString {
        unsafe { VisualScriptVariableGet_get_variable(self.this) }
    }

    #[inline]
    pub fn set_variable(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptVariableGet_set_variable(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptVariableSet` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptvariableset.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptVariableSet inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptVariableSet {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptVariableSet {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptVariableSetMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptVariableSet {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_variable(&self) -> GodotString {
        unsafe { VisualScriptVariableSet_get_variable(self.this) }
    }

    #[inline]
    pub fn set_variable(&mut self, name: GodotString) -> () {
        unsafe { VisualScriptVariableSet_set_variable(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptWhile` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptwhile.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptWhile inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptWhile {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptWhile {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptWhileMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptWhile {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptYield` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptyield.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptYield inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptYield {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptYieldYieldMode {
    Frame = 1,
    PhysicsFrame = 2,
    Wait = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptYield {
    pub const YIELD_PHYSICS_FRAME: i64 = 2;
    pub const YIELD_FRAME: i64 = 1;
    pub const YIELD_WAIT: i64 = 3;
}
impl VisualScriptYield {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptYieldMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptYield {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_wait_time(&mut self) -> f64 {
        unsafe { VisualScriptYield_get_wait_time(self.this) }
    }

    #[inline]
    pub fn get_yield_mode(&mut self) -> VisualScriptYieldYieldMode {
        unsafe { VisualScriptYield_get_yield_mode(self.this) }
    }

    #[inline]
    pub fn set_wait_time(&mut self, sec: f64) -> () {
        unsafe { VisualScriptYield_set_wait_time(self.this, sec) }
    }

    #[inline]
    pub fn set_yield_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptYield_set_yield_mode(self.this, mode) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualScriptYieldSignal` inherits `VisualScriptNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscriptyieldsignal.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualScriptYieldSignal inherits methods from:
/// - [VisualScriptNode](struct.VisualScriptNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptYieldSignal {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualScriptYieldSignalCallMode {
    ModeSelf = 0,
    ModeNodePath = 1,
    ModeInstance = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualScriptYieldSignal {
    pub const CALL_MODE_SELF: i64 = 0;
    pub const CALL_MODE_NODE_PATH: i64 = 1;
    pub const CALL_MODE_INSTANCE: i64 = 2;
}
impl VisualScriptYieldSignal {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualScriptYieldSignalMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualScriptYieldSignal {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_base_path(&self) -> NodePath {
        unsafe { VisualScriptYieldSignal_get_base_path(self.this) }
    }

    #[inline]
    pub fn get_base_type(&self) -> GodotString {
        unsafe { VisualScriptYieldSignal_get_base_type(self.this) }
    }

    #[inline]
    pub fn get_call_mode(&self) -> VisualScriptYieldSignalCallMode {
        unsafe { VisualScriptYieldSignal_get_call_mode(self.this) }
    }

    #[inline]
    pub fn get_signal(&self) -> GodotString {
        unsafe { VisualScriptYieldSignal_get_signal(self.this) }
    }

    #[inline]
    pub fn set_base_path(&mut self, base_path: NodePath) -> () {
        unsafe { VisualScriptYieldSignal_set_base_path(self.this, base_path) }
    }

    #[inline]
    pub fn set_base_type(&mut self, base_type: GodotString) -> () {
        unsafe { VisualScriptYieldSignal_set_base_type(self.this, base_type) }
    }

    #[inline]
    pub fn set_call_mode(&mut self, mode: i64) -> () {
        unsafe { VisualScriptYieldSignal_set_call_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_signal(&mut self, signal: GodotString) -> () {
        unsafe { VisualScriptYieldSignal_set_signal(self.this, signal) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_script_node(&self) -> VisualScriptNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualScriptNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class VisualServer` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualserver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// VisualServer inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerReflectionProbeUpdateMode {
    Once = 0,
    Always = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightDirectionalShadowDepthRangeMode {
    Stable = 0,
    Optimized = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerBlendShapeMode {
    ModeNormalized = 0,
    ModeRelative = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerPrimitiveType {
    PrimitivePoints = 0,
    PrimitiveLines = 1,
    PrimitiveLineStrip = 2,
    PrimitiveLineLoop = 3,
    PrimitiveTriangles = 4,
    PrimitiveTriangleStrip = 5,
    PrimitiveTriangleFan = 6,
    PrimitiveMax = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerTextureType {
    TextureType2d = 0,
    Cubemap = 1,
    TextureType2dArray = 2,
    TextureType3d = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentSSAOQuality {
    EnvSsaoQualityLow = 0,
    EnvSsaoQualityMedium = 1,
    EnvSsaoQualityHigh = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentDOFBlurQuality {
    EnvDofBlurQualityLow = 0,
    EnvDofBlurQualityMedium = 1,
    EnvDofBlurQualityHigh = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerRenderInfo {
    InfoObjectsInFrame = 0,
    InfoVerticesInFrame = 1,
    InfoMaterialChangesInFrame = 2,
    InfoShaderChangesInFrame = 3,
    InfoSurfaceChangesInFrame = 4,
    InfoDrawCallsInFrame = 5,
    InfoUsageVideoMemTotal = 6,
    InfoVideoMemUsed = 7,
    InfoTextureMemUsed = 8,
    InfoVertexMemUsed = 9,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerNinePatchAxisMode {
    NinePatchStretch = 0,
    NinePatchTile = 1,
    NinePatchTileFit = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportRenderInfo {
    ObjectsInFrame = 0,
    VerticesInFrame = 1,
    MaterialChangesInFrame = 2,
    ShaderChangesInFrame = 3,
    SurfaceChangesInFrame = 4,
    DrawCallsInFrame = 5,
    Max = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportClearMode {
    Always = 0,
    Never = 1,
    OnlyNextFrame = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightOmniShadowDetail {
    Vertical = 0,
    Horizontal = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerShaderMode {
    Spatial = 0,
    CanvasItem = 1,
    Particles = 2,
    Max = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerMultimeshTransformFormat {
    MultimeshTransform2d = 0,
    MultimeshTransform3d = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerShadowCastingSetting {
    Off = 0,
    On = 1,
    DoubleSided = 2,
    ShadowsOnly = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportDebugDraw {
    Disabled = 0,
    Unshaded = 1,
    Overdraw = 2,
    Wireframe = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportUsage {
    ViewportUsage2d = 0,
    ViewportUsage2dNoSampling = 1,
    ViewportUsage3d = 2,
    ViewportUsage3dNoEffects = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentBG {
    EnvBgClearColor = 0,
    EnvBgColor = 1,
    EnvBgSky = 2,
    EnvBgColorSky = 3,
    EnvBgCanvas = 4,
    EnvBgKeep = 5,
    EnvBgMax = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerMultimeshCustomDataFormat {
    MultimeshCustomDataNone = 0,
    MultimeshCustomData8bit = 1,
    MultimeshCustomDataFloat = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightOmniShadowMode {
    DualParaboloid = 0,
    Cube = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerTextureFlags {
    TextureFlagMipmaps = 1,
    TextureFlagRepeat = 2,
    TextureFlagFilter = 4,
    Default = 7,
    TextureFlagAnisotropicFilter = 8,
    TextureFlagConvertToLinear = 16,
    TextureFlagMirroredRepeat = 32,
    TextureFlagUsedForStreaming = 2048,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerFeatures {
    haders = 0,
    FeatureMultithreaded = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerInstanceType {
    InstanceNone = 0,
    InstanceMesh = 1,
    InstanceMultimesh = 2,
    InstanceImmediate = 3,
    InstanceParticles = 4,
    InstanceLight = 5,
    InstanceReflectionProbe = 6,
    InstanceGiProbe = 7,
    InstanceLightmapCapture = 8,
    InstanceMax = 9,
    InstanceGeometryMask = 30,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentSSAOBlur {
    EnvSsaoBlurDisabled = 0,
    EnvSsaoBlur1x1 = 1,
    EnvSsaoBlur2x2 = 2,
    EnvSsaoBlur3x3 = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentToneMapper {
    EnvToneMapperLinear = 0,
    EnvToneMapperReinhard = 1,
    EnvToneMapperFilmic = 2,
    EnvToneMapperAces = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerEnvironmentGlowBlendMode {
    GlowBlendModeAdditive = 0,
    GlowBlendModeScreen = 1,
    GlowBlendModeSoftlight = 2,
    GlowBlendModeReplace = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerMultimeshColorFormat {
    MultimeshColorNone = 0,
    MultimeshColor8bit = 1,
    MultimeshColorFloat = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerCanvasLightShadowFilter {
    CanvasLightFilterNone = 0,
    CanvasLightFilterPcf3 = 1,
    CanvasLightFilterPcf5 = 2,
    CanvasLightFilterPcf7 = 3,
    CanvasLightFilterPcf9 = 4,
    CanvasLightFilterPcf13 = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerScenarioDebugMode {
    Disabled = 0,
    Wireframe = 1,
    Overdraw = 2,
    Shadeless = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportUpdateMode {
    Disabled = 0,
    Once = 1,
    WhenVisible = 2,
    Always = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerArrayFormat {
    Vertex = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    TexUv = 16,
    TexUv2 = 32,
    Bones = 64,
    Weights = 128,
    Index = 256,
    ArrayCompressVertex = 512,
    ArrayCompressNormal = 1024,
    ArrayCompressTangent = 2048,
    ArrayCompressColor = 4096,
    ArrayCompressTexUv = 8192,
    ArrayCompressTexUv2 = 16384,
    ArrayCompressBones = 32768,
    ArrayCompressWeights = 65536,
    ArrayCompressDefault = 97280,
    ArrayCompressIndex = 131072,
    ArrayFlagUse2dVertices = 262144,
    ArrayFlagUse16BitBones = 524288,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerParticlesDrawOrder {
    Index = 0,
    Lifetime = 1,
    ViewDepth = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerCanvasLightMode {
    ModeAdd = 0,
    ModeSub = 1,
    ModeMix = 2,
    ModeMask = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightDirectionalShadowMode {
    Orthogonal = 0,
    Parallel2Splits = 1,
    Parallel4Splits = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightParam {
    Energy = 0,
    Specular = 2,
    Range = 3,
    Attenuation = 4,
    SpotAngle = 5,
    SpotAttenuation = 6,
    ContactShadowSize = 7,
    ShadowMaxDistance = 8,
    ShadowSplit1Offset = 9,
    ShadowSplit2Offset = 10,
    ShadowSplit3Offset = 11,
    ShadowNormalBias = 12,
    ShadowBias = 13,
    ShadowBiasSplitScale = 14,
    Max = 15,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerArrayType {
    ArrayVertex = 0,
    ArrayNormal = 1,
    ArrayTangent = 2,
    ArrayColor = 3,
    ArrayTexUv = 4,
    ArrayTexUv2 = 5,
    ArrayBones = 6,
    ArrayWeights = 7,
    ArrayIndex = 8,
    ArrayMax = 9,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerCanvasOccluderPolygonCullMode {
    Disabled = 0,
    Clockwise = 1,
    CounterClockwise = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerInstanceFlags {
    InstanceFlagUseBakedLight = 0,
    InstanceFlagDrawNextFrameIfVisible = 1,
    InstanceFlagMax = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerViewportMSAA {
    Disabled = 0,
    ViewportMsaa2x = 1,
    ViewportMsaa4x = 2,
    ViewportMsaa8x = 3,
    ViewportMsaa16x = 4,
    Ext2x = 5,
    Ext4x = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerLightType {
    LightDirectional = 0,
    LightOmni = 1,
    LightSpot = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualServerCubeMapSide {
    CubemapLeft = 0,
    CubemapRight = 1,
    CubemapBottom = 2,
    CubemapTop = 3,
    CubemapFront = 4,
    CubemapBack = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualServer {
    pub const CANVAS_LIGHT_MODE_MIX: i64 = 2;
    pub const ENV_DOF_BLUR_QUALITY_MEDIUM: i64 = 1;
    pub const LIGHT_DIRECTIONAL_SHADOW_DEPTH_RANGE_OPTIMIZED: i64 = 1;
    pub const SHADER_CANVAS_ITEM: i64 = 1;
    pub const CANVAS_ITEM_Z_MAX: i64 = 4096;
    pub const PRIMITIVE_TRIANGLE_FAN: i64 = 6;
    pub const SHADOW_CASTING_SETTING_OFF: i64 = 0;
    pub const VIEWPORT_CLEAR_NEVER: i64 = 1;
    pub const ARRAY_INDEX: i64 = 8;
    pub const ARRAY_NORMAL: i64 = 1;
    pub const ARRAY_FORMAT_VERTEX: i64 = 1;
    pub const CUBEMAP_BOTTOM: i64 = 2;
    pub const MATERIAL_RENDER_PRIORITY_MIN: i64 = -128;
    pub const TEXTURE_TYPE_2D_ARRAY: i64 = 2;
    pub const INSTANCE_NONE: i64 = 0;
    pub const VIEWPORT_MSAA_DISABLED: i64 = 0;
    pub const VIEWPORT_RENDER_INFO_SURFACE_CHANGES_IN_FRAME: i64 = 4;
    pub const VIEWPORT_UPDATE_ALWAYS: i64 = 3;
    pub const FEATURE_MULTITHREADED: i64 = 1;
    pub const MULTIMESH_TRANSFORM_2D: i64 = 0;
    pub const CANVAS_LIGHT_FILTER_PCF13: i64 = 5;
    pub const ARRAY_WEIGHTS_SIZE: i64 = 4;
    pub const LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS: i64 = 2;
    pub const SHADER_MAX: i64 = 3;
    pub const VIEWPORT_USAGE_2D_NO_SAMPLING: i64 = 1;
    pub const ARRAY_COMPRESS_BONES: i64 = 32768;
    pub const VIEWPORT_RENDER_INFO_MAX: i64 = 6;
    pub const CUBEMAP_RIGHT: i64 = 1;
    pub const ENV_TONE_MAPPER_ACES: i64 = 3;
    pub const VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME: i64 = 0;
    pub const LIGHT_OMNI_SHADOW_CUBE: i64 = 1;
    pub const ARRAY_FORMAT_INDEX: i64 = 256;
    pub const ENV_SSAO_QUALITY_MEDIUM: i64 = 1;
    pub const MULTIMESH_TRANSFORM_3D: i64 = 1;
    pub const SCENARIO_DEBUG_DISABLED: i64 = 0;
    pub const ENV_DOF_BLUR_QUALITY_LOW: i64 = 0;
    pub const CANVAS_LIGHT_FILTER_PCF3: i64 = 1;
    pub const INSTANCE_MAX: i64 = 9;
    pub const LIGHT_OMNI: i64 = 1;
    pub const TEXTURE_FLAG_REPEAT: i64 = 2;
    pub const INFO_VIDEO_MEM_USED: i64 = 7;
    pub const VIEWPORT_MSAA_4X: i64 = 2;
    pub const VIEWPORT_MSAA_2X: i64 = 1;
    pub const VIEWPORT_CLEAR_ONLY_NEXT_FRAME: i64 = 2;
    pub const MULTIMESH_COLOR_FLOAT: i64 = 2;
    pub const ARRAY_FORMAT_COLOR: i64 = 8;
    pub const MULTIMESH_CUSTOM_DATA_NONE: i64 = 0;
    pub const CUBEMAP_TOP: i64 = 3;
    pub const LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET: i64 = 9;
    pub const ARRAY_FORMAT_NORMAL: i64 = 2;
    pub const MATERIAL_RENDER_PRIORITY_MAX: i64 = 127;
    pub const PARTICLES_DRAW_ORDER_VIEW_DEPTH: i64 = 2;
    pub const PRIMITIVE_TRIANGLES: i64 = 4;
    pub const INSTANCE_FLAG_MAX: i64 = 2;
    pub const ENV_TONE_MAPPER_LINEAR: i64 = 0;
    pub const LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET: i64 = 11;
    pub const MAX_GLOW_LEVELS: i64 = 7;
    pub const LIGHT_PARAM_ENERGY: i64 = 0;
    pub const ENV_TONE_MAPPER_FILMIC: i64 = 2;
    pub const CUBEMAP_FRONT: i64 = 4;
    pub const INSTANCE_LIGHT: i64 = 5;
    pub const ARRAY_FLAG_USE_2D_VERTICES: i64 = 262144;
    pub const VIEWPORT_RENDER_INFO_VERTICES_IN_FRAME: i64 = 1;
    pub const ARRAY_FORMAT_BONES: i64 = 64;
    pub const CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE: i64 = 2;
    pub const CANVAS_LIGHT_FILTER_PCF9: i64 = 4;
    pub const MAX_CURSORS: i64 = 8;
    pub const TEXTURE_FLAG_MIRRORED_REPEAT: i64 = 32;
    pub const ARRAY_COMPRESS_TEX_UV2: i64 = 16384;
    pub const ARRAY_FLAG_USE_16_BIT_BONES: i64 = 524288;
    pub const CANVAS_LIGHT_FILTER_PCF5: i64 = 2;
    pub const VIEWPORT_DEBUG_DRAW_UNSHADED: i64 = 1;
    pub const NINE_PATCH_TILE: i64 = 1;
    pub const INSTANCE_GI_PROBE: i64 = 7;
    pub const ARRAY_COMPRESS_TANGENT: i64 = 2048;
    pub const ENV_BG_KEEP: i64 = 5;
    pub const ARRAY_FORMAT_WEIGHTS: i64 = 128;
    pub const ENV_BG_MAX: i64 = 7;
    pub const ENV_BG_CANVAS: i64 = 4;
    pub const INFO_MATERIAL_CHANGES_IN_FRAME: i64 = 2;
    pub const ENV_TONE_MAPPER_REINHARD: i64 = 1;
    pub const VIEWPORT_DEBUG_DRAW_WIREFRAME: i64 = 3;
    pub const PRIMITIVE_LINE_LOOP: i64 = 3;
    pub const SHADOW_CASTING_SETTING_ON: i64 = 1;
    pub const VIEWPORT_MSAA_EXT_4X: i64 = 6;
    pub const ARRAY_FORMAT_TEX_UV: i64 = 16;
    pub const INFO_OBJECTS_IN_FRAME: i64 = 0;
    pub const PARTICLES_DRAW_ORDER_INDEX: i64 = 0;
    pub const LIGHT_PARAM_SHADOW_BIAS_SPLIT_SCALE: i64 = 14;
    pub const GLOW_BLEND_MODE_SOFTLIGHT: i64 = 2;
    pub const LIGHT_PARAM_SHADOW_MAX_DISTANCE: i64 = 8;
    pub const LIGHT_SPOT: i64 = 2;
    pub const GLOW_BLEND_MODE_SCREEN: i64 = 1;
    pub const SHADOW_CASTING_SETTING_DOUBLE_SIDED: i64 = 2;
    pub const INSTANCE_LIGHTMAP_CAPTURE: i64 = 8;
    pub const INFO_SHADER_CHANGES_IN_FRAME: i64 = 3;
    pub const INFO_VERTEX_MEM_USED: i64 = 9;
    pub const CANVAS_LIGHT_MODE_ADD: i64 = 0;
    pub const CANVAS_LIGHT_MODE_SUB: i64 = 1;
    pub const CUBEMAP_LEFT: i64 = 0;
    pub const CANVAS_LIGHT_FILTER_NONE: i64 = 0;
    pub const ENV_SSAO_BLUR_1x1: i64 = 1;
    pub const ARRAY_COMPRESS_WEIGHTS: i64 = 65536;
    pub const LIGHT_DIRECTIONAL_SHADOW_DEPTH_RANGE_STABLE: i64 = 0;
    pub const LIGHT_PARAM_RANGE: i64 = 3;
    pub const ARRAY_TEX_UV: i64 = 4;
    pub const LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET: i64 = 10;
    pub const MULTIMESH_CUSTOM_DATA_8BIT: i64 = 1;
    pub const BLEND_SHAPE_MODE_RELATIVE: i64 = 1;
    pub const LIGHT_PARAM_MAX: i64 = 15;
    pub const NO_INDEX_ARRAY: i64 = -1;
    pub const LIGHT_PARAM_SPECULAR: i64 = 2;
    pub const TEXTURE_FLAGS_DEFAULT: i64 = 7;
    pub const VIEWPORT_DEBUG_DRAW_DISABLED: i64 = 0;
    pub const ARRAY_COMPRESS_VERTEX: i64 = 512;
    pub const VIEWPORT_MSAA_8X: i64 = 3;
    pub const VIEWPORT_MSAA_EXT_2X: i64 = 5;
    pub const VIEWPORT_RENDER_INFO_MATERIAL_CHANGES_IN_FRAME: i64 = 2;
    pub const ENV_BG_COLOR_SKY: i64 = 3;
    pub const LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS: i64 = 1;
    pub const LIGHT_OMNI_SHADOW_DETAIL_HORIZONTAL: i64 = 1;
    pub const TEXTURE_FLAG_CONVERT_TO_LINEAR: i64 = 16;
    pub const NINE_PATCH_TILE_FIT: i64 = 2;
    pub const CANVAS_LIGHT_MODE_MASK: i64 = 3;
    pub const LIGHT_PARAM_SPOT_ANGLE: i64 = 5;
    pub const PRIMITIVE_MAX: i64 = 7;
    pub const ENV_SSAO_BLUR_3x3: i64 = 3;
    pub const VIEWPORT_RENDER_INFO_SHADER_CHANGES_IN_FRAME: i64 = 3;
    pub const VIEWPORT_UPDATE_DISABLED: i64 = 0;
    pub const LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL: i64 = 0;
    pub const REFLECTION_PROBE_UPDATE_ALWAYS: i64 = 1;
    pub const SHADER_PARTICLES: i64 = 2;
    pub const INSTANCE_GEOMETRY_MASK: i64 = 30;
    pub const CANVAS_OCCLUDER_POLYGON_CULL_DISABLED: i64 = 0;
    pub const LIGHT_PARAM_CONTACT_SHADOW_SIZE: i64 = 7;
    pub const ENV_DOF_BLUR_QUALITY_HIGH: i64 = 2;
    pub const PRIMITIVE_LINE_STRIP: i64 = 2;
    pub const REFLECTION_PROBE_UPDATE_ONCE: i64 = 0;
    pub const ENV_SSAO_BLUR_2x2: i64 = 2;
    pub const VIEWPORT_UPDATE_WHEN_VISIBLE: i64 = 2;
    pub const SHADOW_CASTING_SETTING_SHADOWS_ONLY: i64 = 3;
    pub const SCENARIO_DEBUG_OVERDRAW: i64 = 2;
    pub const ARRAY_WEIGHTS: i64 = 7;
    pub const INFO_TEXTURE_MEM_USED: i64 = 8;
    pub const TEXTURE_FLAG_FILTER: i64 = 4;
    pub const ENV_SSAO_QUALITY_LOW: i64 = 0;
    pub const LIGHT_OMNI_SHADOW_DUAL_PARABOLOID: i64 = 0;
    pub const ENV_BG_CLEAR_COLOR: i64 = 0;
    pub const PRIMITIVE_POINTS: i64 = 0;
    pub const ARRAY_COLOR: i64 = 3;
    pub const ENV_SSAO_BLUR_DISABLED: i64 = 0;
    pub const ARRAY_VERTEX: i64 = 0;
    pub const MULTIMESH_COLOR_NONE: i64 = 0;
    pub const VIEWPORT_USAGE_3D_NO_EFFECTS: i64 = 3;
    pub const NINE_PATCH_STRETCH: i64 = 0;
    pub const MULTIMESH_CUSTOM_DATA_FLOAT: i64 = 2;
    pub const FEATURE_SHADERS: i64 = 0;
    pub const INSTANCE_FLAG_USE_BAKED_LIGHT: i64 = 0;
    pub const INSTANCE_PARTICLES: i64 = 4;
    pub const VIEWPORT_UPDATE_ONCE: i64 = 1;
    pub const PARTICLES_DRAW_ORDER_LIFETIME: i64 = 1;
    pub const VIEWPORT_USAGE_2D: i64 = 0;
    pub const INFO_VERTICES_IN_FRAME: i64 = 1;
    pub const TEXTURE_TYPE_2D: i64 = 0;
    pub const VIEWPORT_CLEAR_ALWAYS: i64 = 0;
    pub const TEXTURE_FLAG_ANISOTROPIC_FILTER: i64 = 8;
    pub const LIGHT_PARAM_ATTENUATION: i64 = 4;
    pub const INSTANCE_MULTIMESH: i64 = 2;
    pub const LIGHT_PARAM_SHADOW_BIAS: i64 = 13;
    pub const ARRAY_COMPRESS_NORMAL: i64 = 1024;
    pub const SHADER_SPATIAL: i64 = 0;
    pub const TEXTURE_FLAG_MIPMAPS: i64 = 1;
    pub const INFO_USAGE_VIDEO_MEM_TOTAL: i64 = 6;
    pub const MULTIMESH_COLOR_8BIT: i64 = 1;
    pub const ARRAY_FORMAT_TANGENT: i64 = 4;
    pub const INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE: i64 = 1;
    pub const ARRAY_COMPRESS_INDEX: i64 = 131072;
    pub const TEXTURE_TYPE_3D: i64 = 3;
    pub const SCENARIO_DEBUG_WIREFRAME: i64 = 1;
    pub const GLOW_BLEND_MODE_REPLACE: i64 = 3;
    pub const ENV_SSAO_QUALITY_HIGH: i64 = 2;
    pub const INSTANCE_IMMEDIATE: i64 = 3;
    pub const LIGHT_DIRECTIONAL: i64 = 0;
    pub const BLEND_SHAPE_MODE_NORMALIZED: i64 = 0;
    pub const LIGHT_PARAM_SPOT_ATTENUATION: i64 = 6;
    pub const LIGHT_PARAM_SHADOW_NORMAL_BIAS: i64 = 12;
    pub const CUBEMAP_BACK: i64 = 5;
    pub const CANVAS_ITEM_Z_MIN: i64 = -4096;
    pub const CANVAS_LIGHT_FILTER_PCF7: i64 = 3;
    pub const INFO_DRAW_CALLS_IN_FRAME: i64 = 5;
    pub const SCENARIO_DEBUG_SHADELESS: i64 = 3;
    pub const TEXTURE_FLAG_USED_FOR_STREAMING: i64 = 2048;
    pub const TEXTURE_TYPE_CUBEMAP: i64 = 1;
    pub const ENV_BG_COLOR: i64 = 1;
    pub const INFO_SURFACE_CHANGES_IN_FRAME: i64 = 4;
    pub const INSTANCE_REFLECTION_PROBE: i64 = 6;
    pub const ARRAY_MAX: i64 = 9;
    pub const CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE: i64 = 1;
    pub const ENV_BG_SKY: i64 = 2;
    pub const ARRAY_FORMAT_TEX_UV2: i64 = 32;
    pub const PRIMITIVE_LINES: i64 = 1;
    pub const VIEWPORT_DEBUG_DRAW_OVERDRAW: i64 = 2;
    pub const ARRAY_BONES: i64 = 6;
    pub const VIEWPORT_MSAA_16X: i64 = 4;
    pub const VIEWPORT_USAGE_3D: i64 = 2;
    pub const ARRAY_TANGENT: i64 = 2;
    pub const ARRAY_COMPRESS_DEFAULT: i64 = 97280;
    pub const GLOW_BLEND_MODE_ADDITIVE: i64 = 0;
    pub const LIGHT_OMNI_SHADOW_DETAIL_VERTICAL: i64 = 0;
    pub const PRIMITIVE_TRIANGLE_STRIP: i64 = 5;
    pub const INSTANCE_MESH: i64 = 1;
    pub const VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME: i64 = 5;
    pub const ARRAY_COMPRESS_TEX_UV: i64 = 8192;
    pub const ARRAY_COMPRESS_COLOR: i64 = 4096;
    pub const ARRAY_TEX_UV2: i64 = 5;
}
impl VisualServer {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"VisualServer\0".as_ptr() as *mut _);

            VisualServer {
                this
            }
        }
    }
    #[inline]
    pub fn black_bars_set_images(&mut self, left: Rid, top: Rid, right: Rid, bottom: Rid) -> () {
        unsafe { VisualServer_black_bars_set_images(self.this, left, top, right, bottom) }
    }

    #[inline]
    pub fn black_bars_set_margins(&mut self, left: i64, top: i64, right: i64, bottom: i64) -> () {
        unsafe { VisualServer_black_bars_set_margins(self.this, left, top, right, bottom) }
    }

    #[inline]
    pub fn camera_create(&mut self) -> Rid {
        unsafe { VisualServer_camera_create(self.this) }
    }

    #[inline]
    pub fn camera_set_cull_mask(&mut self, camera: Rid, layers: i64) -> () {
        unsafe { VisualServer_camera_set_cull_mask(self.this, camera, layers) }
    }

    #[inline]
    pub fn camera_set_environment(&mut self, camera: Rid, env: Rid) -> () {
        unsafe { VisualServer_camera_set_environment(self.this, camera, env) }
    }

    #[inline]
    pub fn camera_set_frustum(&mut self, camera: Rid, size: f64, offset: Vector2, z_near: f64, z_far: f64) -> () {
        unsafe { VisualServer_camera_set_frustum(self.this, camera, size, offset, z_near, z_far) }
    }

    #[inline]
    pub fn camera_set_orthogonal(&mut self, camera: Rid, size: f64, z_near: f64, z_far: f64) -> () {
        unsafe { VisualServer_camera_set_orthogonal(self.this, camera, size, z_near, z_far) }
    }

    #[inline]
    pub fn camera_set_perspective(&mut self, camera: Rid, fovy_degrees: f64, z_near: f64, z_far: f64) -> () {
        unsafe { VisualServer_camera_set_perspective(self.this, camera, fovy_degrees, z_near, z_far) }
    }

    #[inline]
    pub fn camera_set_transform(&mut self, camera: Rid, transform: Transform) -> () {
        unsafe { VisualServer_camera_set_transform(self.this, camera, transform) }
    }

    #[inline]
    pub fn camera_set_use_vertical_aspect(&mut self, camera: Rid, enable: bool) -> () {
        unsafe { VisualServer_camera_set_use_vertical_aspect(self.this, camera, enable) }
    }

    #[inline]
    pub fn canvas_create(&mut self) -> Rid {
        unsafe { VisualServer_canvas_create(self.this) }
    }

    #[inline]
    pub fn canvas_item_add_circle(&mut self, item: Rid, pos: Vector2, radius: f64, color: Color) -> () {
        unsafe { VisualServer_canvas_item_add_circle(self.this, item, pos, radius, color) }
    }

    #[inline]
    pub fn canvas_item_add_clip_ignore(&mut self, item: Rid, ignore: bool) -> () {
        unsafe { VisualServer_canvas_item_add_clip_ignore(self.this, item, ignore) }
    }

    #[inline]
    pub fn canvas_item_add_line(&mut self, item: Rid, from: Vector2, to: Vector2, color: Color, width: f64, antialiased: bool) -> () {
        unsafe { VisualServer_canvas_item_add_line(self.this, item, from, to, color, width, antialiased) }
    }

    #[inline]
    pub fn canvas_item_add_mesh(&mut self, item: Rid, mesh: Rid, transform: Transform2D, modulate: Color, texture: Rid, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_mesh(self.this, item, mesh, transform, modulate, texture, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_multimesh(&mut self, item: Rid, mesh: Rid, texture: Rid, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_multimesh(self.this, item, mesh, texture, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_nine_patch(&mut self, item: Rid, rect: Rect2, source: Rect2, texture: Rid, topleft: Vector2, bottomright: Vector2, x_axis_mode: i64, y_axis_mode: i64, draw_center: bool, modulate: Color, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_nine_patch(self.this, item, rect, source, texture, topleft, bottomright, x_axis_mode, y_axis_mode, draw_center, modulate, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_particles(&mut self, item: Rid, particles: Rid, texture: Rid, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_particles(self.this, item, particles, texture, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_polygon(&mut self, item: Rid, points: Vector2Array, colors: ColorArray, uvs: Vector2Array, texture: Rid, normal_map: Rid, antialiased: bool) -> () {
        unsafe { VisualServer_canvas_item_add_polygon(self.this, item, points, colors, uvs, texture, normal_map, antialiased) }
    }

    #[inline]
    pub fn canvas_item_add_polyline(&mut self, item: Rid, points: Vector2Array, colors: ColorArray, width: f64, antialiased: bool) -> () {
        unsafe { VisualServer_canvas_item_add_polyline(self.this, item, points, colors, width, antialiased) }
    }

    #[inline]
    pub fn canvas_item_add_primitive(&mut self, item: Rid, points: Vector2Array, colors: ColorArray, uvs: Vector2Array, texture: Rid, width: f64, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_primitive(self.this, item, points, colors, uvs, texture, width, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_rect(&mut self, item: Rid, rect: Rect2, color: Color) -> () {
        unsafe { VisualServer_canvas_item_add_rect(self.this, item, rect, color) }
    }

    #[inline]
    pub fn canvas_item_add_set_transform(&mut self, item: Rid, transform: Transform2D) -> () {
        unsafe { VisualServer_canvas_item_add_set_transform(self.this, item, transform) }
    }

    #[inline]
    pub fn canvas_item_add_texture_rect(&mut self, item: Rid, rect: Rect2, texture: Rid, tile: bool, modulate: Color, transpose: bool, normal_map: Rid) -> () {
        unsafe { VisualServer_canvas_item_add_texture_rect(self.this, item, rect, texture, tile, modulate, transpose, normal_map) }
    }

    #[inline]
    pub fn canvas_item_add_texture_rect_region(&mut self, item: Rid, rect: Rect2, texture: Rid, src_rect: Rect2, modulate: Color, transpose: bool, normal_map: Rid, clip_uv: bool) -> () {
        unsafe { VisualServer_canvas_item_add_texture_rect_region(self.this, item, rect, texture, src_rect, modulate, transpose, normal_map, clip_uv) }
    }

    #[inline]
    pub fn canvas_item_add_triangle_array(&mut self, item: Rid, indices: Int32Array, points: Vector2Array, colors: ColorArray, uvs: Vector2Array, bones: Int32Array, weights: Float32Array, texture: Rid, count: i64, normal_map: Rid, antialiased: bool, antialiasing_use_indices: bool) -> () {
        unsafe { VisualServer_canvas_item_add_triangle_array(self.this, item, indices, points, colors, uvs, bones, weights, texture, count, normal_map, antialiased, antialiasing_use_indices) }
    }

    #[inline]
    pub fn canvas_item_clear(&mut self, item: Rid) -> () {
        unsafe { VisualServer_canvas_item_clear(self.this, item) }
    }

    #[inline]
    pub fn canvas_item_create(&mut self) -> Rid {
        unsafe { VisualServer_canvas_item_create(self.this) }
    }

    #[inline]
    pub fn canvas_item_set_clip(&mut self, item: Rid, clip: bool) -> () {
        unsafe { VisualServer_canvas_item_set_clip(self.this, item, clip) }
    }

    #[inline]
    pub fn canvas_item_set_copy_to_backbuffer(&mut self, item: Rid, enabled: bool, rect: Rect2) -> () {
        unsafe { VisualServer_canvas_item_set_copy_to_backbuffer(self.this, item, enabled, rect) }
    }

    #[inline]
    pub fn canvas_item_set_custom_rect(&mut self, item: Rid, use_custom_rect: bool, rect: Rect2) -> () {
        unsafe { VisualServer_canvas_item_set_custom_rect(self.this, item, use_custom_rect, rect) }
    }

    #[inline]
    pub fn canvas_item_set_distance_field_mode(&mut self, item: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_item_set_distance_field_mode(self.this, item, enabled) }
    }

    #[inline]
    pub fn canvas_item_set_draw_behind_parent(&mut self, item: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_item_set_draw_behind_parent(self.this, item, enabled) }
    }

    #[inline]
    pub fn canvas_item_set_draw_index(&mut self, item: Rid, index: i64) -> () {
        unsafe { VisualServer_canvas_item_set_draw_index(self.this, item, index) }
    }

    #[inline]
    pub fn canvas_item_set_light_mask(&mut self, item: Rid, mask: i64) -> () {
        unsafe { VisualServer_canvas_item_set_light_mask(self.this, item, mask) }
    }

    #[inline]
    pub fn canvas_item_set_material(&mut self, item: Rid, material: Rid) -> () {
        unsafe { VisualServer_canvas_item_set_material(self.this, item, material) }
    }

    #[inline]
    pub fn canvas_item_set_modulate(&mut self, item: Rid, color: Color) -> () {
        unsafe { VisualServer_canvas_item_set_modulate(self.this, item, color) }
    }

    #[inline]
    pub fn canvas_item_set_parent(&mut self, item: Rid, parent: Rid) -> () {
        unsafe { VisualServer_canvas_item_set_parent(self.this, item, parent) }
    }

    #[inline]
    pub fn canvas_item_set_self_modulate(&mut self, item: Rid, color: Color) -> () {
        unsafe { VisualServer_canvas_item_set_self_modulate(self.this, item, color) }
    }

    #[inline]
    pub fn canvas_item_set_sort_children_by_y(&mut self, item: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_item_set_sort_children_by_y(self.this, item, enabled) }
    }

    #[inline]
    pub fn canvas_item_set_transform(&mut self, item: Rid, transform: Transform2D) -> () {
        unsafe { VisualServer_canvas_item_set_transform(self.this, item, transform) }
    }

    #[inline]
    pub fn canvas_item_set_use_parent_material(&mut self, item: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_item_set_use_parent_material(self.this, item, enabled) }
    }

    #[inline]
    pub fn canvas_item_set_visible(&mut self, item: Rid, visible: bool) -> () {
        unsafe { VisualServer_canvas_item_set_visible(self.this, item, visible) }
    }

    #[inline]
    pub fn canvas_item_set_z_as_relative_to_parent(&mut self, item: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_item_set_z_as_relative_to_parent(self.this, item, enabled) }
    }

    #[inline]
    pub fn canvas_item_set_z_index(&mut self, item: Rid, z_index: i64) -> () {
        unsafe { VisualServer_canvas_item_set_z_index(self.this, item, z_index) }
    }

    #[inline]
    pub fn canvas_light_attach_to_canvas(&mut self, light: Rid, canvas: Rid) -> () {
        unsafe { VisualServer_canvas_light_attach_to_canvas(self.this, light, canvas) }
    }

    #[inline]
    pub fn canvas_light_create(&mut self) -> Rid {
        unsafe { VisualServer_canvas_light_create(self.this) }
    }

    #[inline]
    pub fn canvas_light_occluder_attach_to_canvas(&mut self, occluder: Rid, canvas: Rid) -> () {
        unsafe { VisualServer_canvas_light_occluder_attach_to_canvas(self.this, occluder, canvas) }
    }

    #[inline]
    pub fn canvas_light_occluder_create(&mut self) -> Rid {
        unsafe { VisualServer_canvas_light_occluder_create(self.this) }
    }

    #[inline]
    pub fn canvas_light_occluder_set_enabled(&mut self, occluder: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_light_occluder_set_enabled(self.this, occluder, enabled) }
    }

    #[inline]
    pub fn canvas_light_occluder_set_light_mask(&mut self, occluder: Rid, mask: i64) -> () {
        unsafe { VisualServer_canvas_light_occluder_set_light_mask(self.this, occluder, mask) }
    }

    #[inline]
    pub fn canvas_light_occluder_set_polygon(&mut self, occluder: Rid, polygon: Rid) -> () {
        unsafe { VisualServer_canvas_light_occluder_set_polygon(self.this, occluder, polygon) }
    }

    #[inline]
    pub fn canvas_light_occluder_set_transform(&mut self, occluder: Rid, transform: Transform2D) -> () {
        unsafe { VisualServer_canvas_light_occluder_set_transform(self.this, occluder, transform) }
    }

    #[inline]
    pub fn canvas_light_set_color(&mut self, light: Rid, color: Color) -> () {
        unsafe { VisualServer_canvas_light_set_color(self.this, light, color) }
    }

    #[inline]
    pub fn canvas_light_set_enabled(&mut self, light: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_light_set_enabled(self.this, light, enabled) }
    }

    #[inline]
    pub fn canvas_light_set_energy(&mut self, light: Rid, energy: f64) -> () {
        unsafe { VisualServer_canvas_light_set_energy(self.this, light, energy) }
    }

    #[inline]
    pub fn canvas_light_set_height(&mut self, light: Rid, height: f64) -> () {
        unsafe { VisualServer_canvas_light_set_height(self.this, light, height) }
    }

    #[inline]
    pub fn canvas_light_set_item_cull_mask(&mut self, light: Rid, mask: i64) -> () {
        unsafe { VisualServer_canvas_light_set_item_cull_mask(self.this, light, mask) }
    }

    #[inline]
    pub fn canvas_light_set_item_shadow_cull_mask(&mut self, light: Rid, mask: i64) -> () {
        unsafe { VisualServer_canvas_light_set_item_shadow_cull_mask(self.this, light, mask) }
    }

    #[inline]
    pub fn canvas_light_set_layer_range(&mut self, light: Rid, min_layer: i64, max_layer: i64) -> () {
        unsafe { VisualServer_canvas_light_set_layer_range(self.this, light, min_layer, max_layer) }
    }

    #[inline]
    pub fn canvas_light_set_mode(&mut self, light: Rid, mode: i64) -> () {
        unsafe { VisualServer_canvas_light_set_mode(self.this, light, mode) }
    }

    #[inline]
    pub fn canvas_light_set_scale(&mut self, light: Rid, scale: f64) -> () {
        unsafe { VisualServer_canvas_light_set_scale(self.this, light, scale) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_buffer_size(&mut self, light: Rid, size: i64) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_buffer_size(self.this, light, size) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_color(&mut self, light: Rid, color: Color) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_color(self.this, light, color) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_enabled(&mut self, light: Rid, enabled: bool) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_enabled(self.this, light, enabled) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_filter(&mut self, light: Rid, filter: i64) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_filter(self.this, light, filter) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_gradient_length(&mut self, light: Rid, length: f64) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_gradient_length(self.this, light, length) }
    }

    #[inline]
    pub fn canvas_light_set_shadow_smooth(&mut self, light: Rid, smooth: f64) -> () {
        unsafe { VisualServer_canvas_light_set_shadow_smooth(self.this, light, smooth) }
    }

    #[inline]
    pub fn canvas_light_set_texture(&mut self, light: Rid, texture: Rid) -> () {
        unsafe { VisualServer_canvas_light_set_texture(self.this, light, texture) }
    }

    #[inline]
    pub fn canvas_light_set_texture_offset(&mut self, light: Rid, offset: Vector2) -> () {
        unsafe { VisualServer_canvas_light_set_texture_offset(self.this, light, offset) }
    }

    #[inline]
    pub fn canvas_light_set_transform(&mut self, light: Rid, transform: Transform2D) -> () {
        unsafe { VisualServer_canvas_light_set_transform(self.this, light, transform) }
    }

    #[inline]
    pub fn canvas_light_set_z_range(&mut self, light: Rid, min_z: i64, max_z: i64) -> () {
        unsafe { VisualServer_canvas_light_set_z_range(self.this, light, min_z, max_z) }
    }

    #[inline]
    pub fn canvas_occluder_polygon_create(&mut self) -> Rid {
        unsafe { VisualServer_canvas_occluder_polygon_create(self.this) }
    }

    #[inline]
    pub fn canvas_occluder_polygon_set_cull_mode(&mut self, occluder_polygon: Rid, mode: i64) -> () {
        unsafe { VisualServer_canvas_occluder_polygon_set_cull_mode(self.this, occluder_polygon, mode) }
    }

    #[inline]
    pub fn canvas_occluder_polygon_set_shape(&mut self, occluder_polygon: Rid, shape: Vector2Array, closed: bool) -> () {
        unsafe { VisualServer_canvas_occluder_polygon_set_shape(self.this, occluder_polygon, shape, closed) }
    }

    #[inline]
    pub fn canvas_occluder_polygon_set_shape_as_lines(&mut self, occluder_polygon: Rid, shape: Vector2Array) -> () {
        unsafe { VisualServer_canvas_occluder_polygon_set_shape_as_lines(self.this, occluder_polygon, shape) }
    }

    #[inline]
    pub fn canvas_set_item_mirroring(&mut self, canvas: Rid, item: Rid, mirroring: Vector2) -> () {
        unsafe { VisualServer_canvas_set_item_mirroring(self.this, canvas, item, mirroring) }
    }

    #[inline]
    pub fn canvas_set_modulate(&mut self, canvas: Rid, color: Color) -> () {
        unsafe { VisualServer_canvas_set_modulate(self.this, canvas, color) }
    }

    #[inline]
    pub fn directional_light_create(&mut self) -> Rid {
        unsafe { VisualServer_directional_light_create(self.this) }
    }

    #[inline]
    pub fn draw(&mut self, swap_buffers: bool, frame_step: f64) -> () {
        unsafe { VisualServer_draw(self.this, swap_buffers, frame_step) }
    }

    #[inline]
    pub fn environment_create(&mut self) -> Rid {
        unsafe { VisualServer_environment_create(self.this) }
    }

    #[inline]
    pub fn environment_set_adjustment(&mut self, env: Rid, enable: bool, brightness: f64, contrast: f64, saturation: f64, ramp: Rid) -> () {
        unsafe { VisualServer_environment_set_adjustment(self.this, env, enable, brightness, contrast, saturation, ramp) }
    }

    #[inline]
    pub fn environment_set_ambient_light(&mut self, env: Rid, color: Color, energy: f64, sky_contibution: f64) -> () {
        unsafe { VisualServer_environment_set_ambient_light(self.this, env, color, energy, sky_contibution) }
    }

    #[inline]
    pub fn environment_set_background(&mut self, env: Rid, bg: i64) -> () {
        unsafe { VisualServer_environment_set_background(self.this, env, bg) }
    }

    #[inline]
    pub fn environment_set_bg_color(&mut self, env: Rid, color: Color) -> () {
        unsafe { VisualServer_environment_set_bg_color(self.this, env, color) }
    }

    #[inline]
    pub fn environment_set_bg_energy(&mut self, env: Rid, energy: f64) -> () {
        unsafe { VisualServer_environment_set_bg_energy(self.this, env, energy) }
    }

    #[inline]
    pub fn environment_set_canvas_max_layer(&mut self, env: Rid, max_layer: i64) -> () {
        unsafe { VisualServer_environment_set_canvas_max_layer(self.this, env, max_layer) }
    }

    #[inline]
    pub fn environment_set_dof_blur_far(&mut self, env: Rid, enable: bool, distance: f64, transition: f64, far_amount: f64, quality: i64) -> () {
        unsafe { VisualServer_environment_set_dof_blur_far(self.this, env, enable, distance, transition, far_amount, quality) }
    }

    #[inline]
    pub fn environment_set_dof_blur_near(&mut self, env: Rid, enable: bool, distance: f64, transition: f64, far_amount: f64, quality: i64) -> () {
        unsafe { VisualServer_environment_set_dof_blur_near(self.this, env, enable, distance, transition, far_amount, quality) }
    }

    #[inline]
    pub fn environment_set_fog(&mut self, env: Rid, enable: bool, color: Color, sun_color: Color, sun_amount: f64) -> () {
        unsafe { VisualServer_environment_set_fog(self.this, env, enable, color, sun_color, sun_amount) }
    }

    #[inline]
    pub fn environment_set_fog_depth(&mut self, env: Rid, enable: bool, depth_begin: f64, depth_end: f64, depth_curve: f64, transmit: bool, transmit_curve: f64) -> () {
        unsafe { VisualServer_environment_set_fog_depth(self.this, env, enable, depth_begin, depth_end, depth_curve, transmit, transmit_curve) }
    }

    #[inline]
    pub fn environment_set_fog_height(&mut self, env: Rid, enable: bool, min_height: f64, max_height: f64, height_curve: f64) -> () {
        unsafe { VisualServer_environment_set_fog_height(self.this, env, enable, min_height, max_height, height_curve) }
    }

    #[inline]
    pub fn environment_set_glow(&mut self, env: Rid, enable: bool, level_flags: i64, intensity: f64, strength: f64, bloom_threshold: f64, blend_mode: i64, hdr_bleed_threshold: f64, hdr_bleed_scale: f64, hdr_luminance_cap: f64, bicubic_upscale: bool) -> () {
        unsafe { VisualServer_environment_set_glow(self.this, env, enable, level_flags, intensity, strength, bloom_threshold, blend_mode, hdr_bleed_threshold, hdr_bleed_scale, hdr_luminance_cap, bicubic_upscale) }
    }

    #[inline]
    pub fn environment_set_sky(&mut self, env: Rid, sky: Rid) -> () {
        unsafe { VisualServer_environment_set_sky(self.this, env, sky) }
    }

    #[inline]
    pub fn environment_set_sky_custom_fov(&mut self, env: Rid, scale: f64) -> () {
        unsafe { VisualServer_environment_set_sky_custom_fov(self.this, env, scale) }
    }

    #[inline]
    pub fn environment_set_sky_orientation(&mut self, env: Rid, orientation: Basis) -> () {
        unsafe { VisualServer_environment_set_sky_orientation(self.this, env, orientation) }
    }

    #[inline]
    pub fn environment_set_ssao(&mut self, env: Rid, enable: bool, radius: f64, intensity: f64, radius2: f64, intensity2: f64, bias: f64, light_affect: f64, ao_channel_affect: f64, color: Color, quality: i64, blur: i64, bilateral_sharpness: f64) -> () {
        unsafe { VisualServer_environment_set_ssao(self.this, env, enable, radius, intensity, radius2, intensity2, bias, light_affect, ao_channel_affect, color, quality, blur, bilateral_sharpness) }
    }

    #[inline]
    pub fn environment_set_ssr(&mut self, env: Rid, enable: bool, max_steps: i64, fade_in: f64, fade_out: f64, depth_tolerance: f64, roughness: bool) -> () {
        unsafe { VisualServer_environment_set_ssr(self.this, env, enable, max_steps, fade_in, fade_out, depth_tolerance, roughness) }
    }

    #[inline]
    pub fn environment_set_tonemap(&mut self, env: Rid, tone_mapper: i64, exposure: f64, white: f64, auto_exposure: bool, min_luminance: f64, max_luminance: f64, auto_exp_speed: f64, auto_exp_grey: f64) -> () {
        unsafe { VisualServer_environment_set_tonemap(self.this, env, tone_mapper, exposure, white, auto_exposure, min_luminance, max_luminance, auto_exp_speed, auto_exp_grey) }
    }

    #[inline]
    pub fn finish(&mut self) -> () {
        unsafe { VisualServer_finish(self.this) }
    }

    #[inline]
    pub fn force_draw(&mut self, swap_buffers: bool, frame_step: f64) -> () {
        unsafe { VisualServer_force_draw(self.this, swap_buffers, frame_step) }
    }

    #[inline]
    pub fn force_sync(&mut self) -> () {
        unsafe { VisualServer_force_sync(self.this) }
    }

    #[inline]
    pub fn free_rid(&mut self, rid: Rid) -> () {
        unsafe { VisualServer_free_rid(self.this, rid) }
    }

    #[inline]
    pub fn get_render_info(&mut self, info: i64) -> i64 {
        unsafe { VisualServer_get_render_info(self.this, info) }
    }

    #[inline]
    pub fn get_test_cube(&mut self) -> Rid {
        unsafe { VisualServer_get_test_cube(self.this) }
    }

    #[inline]
    pub fn get_test_texture(&mut self) -> Rid {
        unsafe { VisualServer_get_test_texture(self.this) }
    }

    #[inline]
    pub fn get_video_adapter_name(&self) -> GodotString {
        unsafe { VisualServer_get_video_adapter_name(self.this) }
    }

    #[inline]
    pub fn get_video_adapter_vendor(&self) -> GodotString {
        unsafe { VisualServer_get_video_adapter_vendor(self.this) }
    }

    #[inline]
    pub fn get_white_texture(&mut self) -> Rid {
        unsafe { VisualServer_get_white_texture(self.this) }
    }

    #[inline]
    pub fn gi_probe_create(&mut self) -> Rid {
        unsafe { VisualServer_gi_probe_create(self.this) }
    }

    #[inline]
    pub fn gi_probe_get_bias(&self, probe: Rid) -> f64 {
        unsafe { VisualServer_gi_probe_get_bias(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_bounds(&self, probe: Rid) -> Aabb {
        unsafe { VisualServer_gi_probe_get_bounds(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_cell_size(&self, probe: Rid) -> f64 {
        unsafe { VisualServer_gi_probe_get_cell_size(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_dynamic_data(&self, probe: Rid) -> Int32Array {
        unsafe { VisualServer_gi_probe_get_dynamic_data(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_dynamic_range(&self, probe: Rid) -> i64 {
        unsafe { VisualServer_gi_probe_get_dynamic_range(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_energy(&self, probe: Rid) -> f64 {
        unsafe { VisualServer_gi_probe_get_energy(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_normal_bias(&self, probe: Rid) -> f64 {
        unsafe { VisualServer_gi_probe_get_normal_bias(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_propagation(&self, probe: Rid) -> f64 {
        unsafe { VisualServer_gi_probe_get_propagation(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_get_to_cell_xform(&self, probe: Rid) -> Transform {
        unsafe { VisualServer_gi_probe_get_to_cell_xform(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_is_compressed(&self, probe: Rid) -> bool {
        unsafe { VisualServer_gi_probe_is_compressed(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_is_interior(&self, probe: Rid) -> bool {
        unsafe { VisualServer_gi_probe_is_interior(self.this, probe) }
    }

    #[inline]
    pub fn gi_probe_set_bias(&mut self, probe: Rid, bias: f64) -> () {
        unsafe { VisualServer_gi_probe_set_bias(self.this, probe, bias) }
    }

    #[inline]
    pub fn gi_probe_set_bounds(&mut self, probe: Rid, bounds: Aabb) -> () {
        unsafe { VisualServer_gi_probe_set_bounds(self.this, probe, bounds) }
    }

    #[inline]
    pub fn gi_probe_set_cell_size(&mut self, probe: Rid, range: f64) -> () {
        unsafe { VisualServer_gi_probe_set_cell_size(self.this, probe, range) }
    }

    #[inline]
    pub fn gi_probe_set_compress(&mut self, probe: Rid, enable: bool) -> () {
        unsafe { VisualServer_gi_probe_set_compress(self.this, probe, enable) }
    }

    #[inline]
    pub fn gi_probe_set_dynamic_data(&mut self, probe: Rid, data: Int32Array) -> () {
        unsafe { VisualServer_gi_probe_set_dynamic_data(self.this, probe, data) }
    }

    #[inline]
    pub fn gi_probe_set_dynamic_range(&mut self, probe: Rid, range: i64) -> () {
        unsafe { VisualServer_gi_probe_set_dynamic_range(self.this, probe, range) }
    }

    #[inline]
    pub fn gi_probe_set_energy(&mut self, probe: Rid, energy: f64) -> () {
        unsafe { VisualServer_gi_probe_set_energy(self.this, probe, energy) }
    }

    #[inline]
    pub fn gi_probe_set_interior(&mut self, probe: Rid, enable: bool) -> () {
        unsafe { VisualServer_gi_probe_set_interior(self.this, probe, enable) }
    }

    #[inline]
    pub fn gi_probe_set_normal_bias(&mut self, probe: Rid, bias: f64) -> () {
        unsafe { VisualServer_gi_probe_set_normal_bias(self.this, probe, bias) }
    }

    #[inline]
    pub fn gi_probe_set_propagation(&mut self, probe: Rid, propagation: f64) -> () {
        unsafe { VisualServer_gi_probe_set_propagation(self.this, probe, propagation) }
    }

    #[inline]
    pub fn gi_probe_set_to_cell_xform(&mut self, probe: Rid, xform: Transform) -> () {
        unsafe { VisualServer_gi_probe_set_to_cell_xform(self.this, probe, xform) }
    }

    #[inline]
    pub fn has_changed(&self) -> bool {
        unsafe { VisualServer_has_changed(self.this) }
    }

    #[inline]
    pub fn has_feature(&self, feature: i64) -> bool {
        unsafe { VisualServer_has_feature(self.this, feature) }
    }

    #[inline]
    pub fn has_os_feature(&self, feature: GodotString) -> bool {
        unsafe { VisualServer_has_os_feature(self.this, feature) }
    }

    #[inline]
    pub fn immediate_begin(&mut self, immediate: Rid, primitive: i64, texture: Rid) -> () {
        unsafe { VisualServer_immediate_begin(self.this, immediate, primitive, texture) }
    }

    #[inline]
    pub fn immediate_clear(&mut self, immediate: Rid) -> () {
        unsafe { VisualServer_immediate_clear(self.this, immediate) }
    }

    #[inline]
    pub fn immediate_color(&mut self, immediate: Rid, color: Color) -> () {
        unsafe { VisualServer_immediate_color(self.this, immediate, color) }
    }

    #[inline]
    pub fn immediate_create(&mut self) -> Rid {
        unsafe { VisualServer_immediate_create(self.this) }
    }

    #[inline]
    pub fn immediate_end(&mut self, immediate: Rid) -> () {
        unsafe { VisualServer_immediate_end(self.this, immediate) }
    }

    #[inline]
    pub fn immediate_get_material(&self, immediate: Rid) -> Rid {
        unsafe { VisualServer_immediate_get_material(self.this, immediate) }
    }

    #[inline]
    pub fn immediate_normal(&mut self, immediate: Rid, normal: Vector3) -> () {
        unsafe { VisualServer_immediate_normal(self.this, immediate, normal) }
    }

    #[inline]
    pub fn immediate_set_material(&mut self, immediate: Rid, material: Rid) -> () {
        unsafe { VisualServer_immediate_set_material(self.this, immediate, material) }
    }

    #[inline]
    pub fn immediate_tangent(&mut self, immediate: Rid, tangent: Plane) -> () {
        unsafe { VisualServer_immediate_tangent(self.this, immediate, tangent) }
    }

    #[inline]
    pub fn immediate_uv(&mut self, immediate: Rid, tex_uv: Vector2) -> () {
        unsafe { VisualServer_immediate_uv(self.this, immediate, tex_uv) }
    }

    #[inline]
    pub fn immediate_uv2(&mut self, immediate: Rid, tex_uv: Vector2) -> () {
        unsafe { VisualServer_immediate_uv2(self.this, immediate, tex_uv) }
    }

    #[inline]
    pub fn immediate_vertex(&mut self, immediate: Rid, vertex: Vector3) -> () {
        unsafe { VisualServer_immediate_vertex(self.this, immediate, vertex) }
    }

    #[inline]
    pub fn immediate_vertex_2d(&mut self, immediate: Rid, vertex: Vector2) -> () {
        unsafe { VisualServer_immediate_vertex_2d(self.this, immediate, vertex) }
    }

    #[inline]
    pub fn init(&mut self) -> () {
        unsafe { VisualServer_init(self.this) }
    }

    #[inline]
    pub fn instance_attach_object_instance_id(&mut self, instance: Rid, id: i64) -> () {
        unsafe { VisualServer_instance_attach_object_instance_id(self.this, instance, id) }
    }

    #[inline]
    pub fn instance_attach_skeleton(&mut self, instance: Rid, skeleton: Rid) -> () {
        unsafe { VisualServer_instance_attach_skeleton(self.this, instance, skeleton) }
    }

    #[inline]
    pub fn instance_create(&mut self) -> Rid {
        unsafe { VisualServer_instance_create(self.this) }
    }

    #[inline]
    pub fn instance_create2(&mut self, base: Rid, scenario: Rid) -> Rid {
        unsafe { VisualServer_instance_create2(self.this, base, scenario) }
    }

    #[inline]
    pub fn instance_geometry_set_as_instance_lod(&mut self, instance: Rid, as_lod_of_instance: Rid) -> () {
        unsafe { VisualServer_instance_geometry_set_as_instance_lod(self.this, instance, as_lod_of_instance) }
    }

    #[inline]
    pub fn instance_geometry_set_cast_shadows_setting(&mut self, instance: Rid, shadow_casting_setting: i64) -> () {
        unsafe { VisualServer_instance_geometry_set_cast_shadows_setting(self.this, instance, shadow_casting_setting) }
    }

    #[inline]
    pub fn instance_geometry_set_draw_range(&mut self, instance: Rid, min: f64, max: f64, min_margin: f64, max_margin: f64) -> () {
        unsafe { VisualServer_instance_geometry_set_draw_range(self.this, instance, min, max, min_margin, max_margin) }
    }

    #[inline]
    pub fn instance_geometry_set_flag(&mut self, instance: Rid, flag: i64, enabled: bool) -> () {
        unsafe { VisualServer_instance_geometry_set_flag(self.this, instance, flag, enabled) }
    }

    #[inline]
    pub fn instance_geometry_set_material_override(&mut self, instance: Rid, material: Rid) -> () {
        unsafe { VisualServer_instance_geometry_set_material_override(self.this, instance, material) }
    }

    #[inline]
    pub fn instance_set_base(&mut self, instance: Rid, base: Rid) -> () {
        unsafe { VisualServer_instance_set_base(self.this, instance, base) }
    }

    #[inline]
    pub fn instance_set_blend_shape_weight(&mut self, instance: Rid, shape: i64, weight: f64) -> () {
        unsafe { VisualServer_instance_set_blend_shape_weight(self.this, instance, shape, weight) }
    }

    #[inline]
    pub fn instance_set_custom_aabb(&mut self, instance: Rid, aabb: Aabb) -> () {
        unsafe { VisualServer_instance_set_custom_aabb(self.this, instance, aabb) }
    }

    #[inline]
    pub fn instance_set_exterior(&mut self, instance: Rid, enabled: bool) -> () {
        unsafe { VisualServer_instance_set_exterior(self.this, instance, enabled) }
    }

    #[inline]
    pub fn instance_set_extra_visibility_margin(&mut self, instance: Rid, margin: f64) -> () {
        unsafe { VisualServer_instance_set_extra_visibility_margin(self.this, instance, margin) }
    }

    #[inline]
    pub fn instance_set_layer_mask(&mut self, instance: Rid, mask: i64) -> () {
        unsafe { VisualServer_instance_set_layer_mask(self.this, instance, mask) }
    }

    #[inline]
    pub fn instance_set_scenario(&mut self, instance: Rid, scenario: Rid) -> () {
        unsafe { VisualServer_instance_set_scenario(self.this, instance, scenario) }
    }

    #[inline]
    pub fn instance_set_surface_material(&mut self, instance: Rid, surface: i64, material: Rid) -> () {
        unsafe { VisualServer_instance_set_surface_material(self.this, instance, surface, material) }
    }

    #[inline]
    pub fn instance_set_transform(&mut self, instance: Rid, transform: Transform) -> () {
        unsafe { VisualServer_instance_set_transform(self.this, instance, transform) }
    }

    #[inline]
    pub fn instance_set_use_lightmap(&mut self, instance: Rid, lightmap_instance: Rid, lightmap: Rid) -> () {
        unsafe { VisualServer_instance_set_use_lightmap(self.this, instance, lightmap_instance, lightmap) }
    }

    #[inline]
    pub fn instance_set_visible(&mut self, instance: Rid, visible: bool) -> () {
        unsafe { VisualServer_instance_set_visible(self.this, instance, visible) }
    }

    #[inline]
    pub fn instances_cull_aabb(&self, aabb: Aabb, scenario: Rid) -> VariantArray {
        unsafe { VisualServer_instances_cull_aabb(self.this, aabb, scenario) }
    }

    #[inline]
    pub fn instances_cull_convex(&self, convex: VariantArray, scenario: Rid) -> VariantArray {
        unsafe { VisualServer_instances_cull_convex(self.this, convex, scenario) }
    }

    #[inline]
    pub fn instances_cull_ray(&self, from: Vector3, to: Vector3, scenario: Rid) -> VariantArray {
        unsafe { VisualServer_instances_cull_ray(self.this, from, to, scenario) }
    }

    #[inline]
    pub fn light_directional_set_blend_splits(&mut self, light: Rid, enable: bool) -> () {
        unsafe { VisualServer_light_directional_set_blend_splits(self.this, light, enable) }
    }

    #[inline]
    pub fn light_directional_set_shadow_depth_range_mode(&mut self, light: Rid, range_mode: i64) -> () {
        unsafe { VisualServer_light_directional_set_shadow_depth_range_mode(self.this, light, range_mode) }
    }

    #[inline]
    pub fn light_directional_set_shadow_mode(&mut self, light: Rid, mode: i64) -> () {
        unsafe { VisualServer_light_directional_set_shadow_mode(self.this, light, mode) }
    }

    #[inline]
    pub fn light_omni_set_shadow_detail(&mut self, light: Rid, detail: i64) -> () {
        unsafe { VisualServer_light_omni_set_shadow_detail(self.this, light, detail) }
    }

    #[inline]
    pub fn light_omni_set_shadow_mode(&mut self, light: Rid, mode: i64) -> () {
        unsafe { VisualServer_light_omni_set_shadow_mode(self.this, light, mode) }
    }

    #[inline]
    pub fn light_set_color(&mut self, light: Rid, color: Color) -> () {
        unsafe { VisualServer_light_set_color(self.this, light, color) }
    }

    #[inline]
    pub fn light_set_cull_mask(&mut self, light: Rid, mask: i64) -> () {
        unsafe { VisualServer_light_set_cull_mask(self.this, light, mask) }
    }

    #[inline]
    pub fn light_set_negative(&mut self, light: Rid, enable: bool) -> () {
        unsafe { VisualServer_light_set_negative(self.this, light, enable) }
    }

    #[inline]
    pub fn light_set_param(&mut self, light: Rid, param: i64, value: f64) -> () {
        unsafe { VisualServer_light_set_param(self.this, light, param, value) }
    }

    #[inline]
    pub fn light_set_projector(&mut self, light: Rid, texture: Rid) -> () {
        unsafe { VisualServer_light_set_projector(self.this, light, texture) }
    }

    #[inline]
    pub fn light_set_reverse_cull_face_mode(&mut self, light: Rid, enabled: bool) -> () {
        unsafe { VisualServer_light_set_reverse_cull_face_mode(self.this, light, enabled) }
    }

    #[inline]
    pub fn light_set_shadow(&mut self, light: Rid, enabled: bool) -> () {
        unsafe { VisualServer_light_set_shadow(self.this, light, enabled) }
    }

    #[inline]
    pub fn light_set_shadow_color(&mut self, light: Rid, color: Color) -> () {
        unsafe { VisualServer_light_set_shadow_color(self.this, light, color) }
    }

    #[inline]
    pub fn light_set_use_gi(&mut self, light: Rid, enabled: bool) -> () {
        unsafe { VisualServer_light_set_use_gi(self.this, light, enabled) }
    }

    #[inline]
    pub fn lightmap_capture_create(&mut self) -> Rid {
        unsafe { VisualServer_lightmap_capture_create(self.this) }
    }

    #[inline]
    pub fn lightmap_capture_get_bounds(&self, capture: Rid) -> Aabb {
        unsafe { VisualServer_lightmap_capture_get_bounds(self.this, capture) }
    }

    #[inline]
    pub fn lightmap_capture_get_energy(&self, capture: Rid) -> f64 {
        unsafe { VisualServer_lightmap_capture_get_energy(self.this, capture) }
    }

    #[inline]
    pub fn lightmap_capture_get_octree(&self, capture: Rid) -> ByteArray {
        unsafe { VisualServer_lightmap_capture_get_octree(self.this, capture) }
    }

    #[inline]
    pub fn lightmap_capture_get_octree_cell_subdiv(&self, capture: Rid) -> i64 {
        unsafe { VisualServer_lightmap_capture_get_octree_cell_subdiv(self.this, capture) }
    }

    #[inline]
    pub fn lightmap_capture_get_octree_cell_transform(&self, capture: Rid) -> Transform {
        unsafe { VisualServer_lightmap_capture_get_octree_cell_transform(self.this, capture) }
    }

    #[inline]
    pub fn lightmap_capture_set_bounds(&mut self, capture: Rid, bounds: Aabb) -> () {
        unsafe { VisualServer_lightmap_capture_set_bounds(self.this, capture, bounds) }
    }

    #[inline]
    pub fn lightmap_capture_set_energy(&mut self, capture: Rid, energy: f64) -> () {
        unsafe { VisualServer_lightmap_capture_set_energy(self.this, capture, energy) }
    }

    #[inline]
    pub fn lightmap_capture_set_octree(&mut self, capture: Rid, octree: ByteArray) -> () {
        unsafe { VisualServer_lightmap_capture_set_octree(self.this, capture, octree) }
    }

    #[inline]
    pub fn lightmap_capture_set_octree_cell_subdiv(&mut self, capture: Rid, subdiv: i64) -> () {
        unsafe { VisualServer_lightmap_capture_set_octree_cell_subdiv(self.this, capture, subdiv) }
    }

    #[inline]
    pub fn lightmap_capture_set_octree_cell_transform(&mut self, capture: Rid, xform: Transform) -> () {
        unsafe { VisualServer_lightmap_capture_set_octree_cell_transform(self.this, capture, xform) }
    }

    #[inline]
    pub fn make_sphere_mesh(&mut self, latitudes: i64, longitudes: i64, radius: f64) -> Rid {
        unsafe { VisualServer_make_sphere_mesh(self.this, latitudes, longitudes, radius) }
    }

    #[inline]
    pub fn material_create(&mut self) -> Rid {
        unsafe { VisualServer_material_create(self.this) }
    }

    #[inline]
    pub fn material_get_param(&self, material: Rid, parameter: GodotString) -> Variant {
        unsafe { VisualServer_material_get_param(self.this, material, parameter) }
    }

    #[inline]
    pub fn material_get_param_default(&self, material: Rid, parameter: GodotString) -> Variant {
        unsafe { VisualServer_material_get_param_default(self.this, material, parameter) }
    }

    #[inline]
    pub fn material_get_shader(&self, shader_material: Rid) -> Rid {
        unsafe { VisualServer_material_get_shader(self.this, shader_material) }
    }

    #[inline]
    pub fn material_set_line_width(&mut self, material: Rid, width: f64) -> () {
        unsafe { VisualServer_material_set_line_width(self.this, material, width) }
    }

    #[inline]
    pub fn material_set_next_pass(&mut self, material: Rid, next_material: Rid) -> () {
        unsafe { VisualServer_material_set_next_pass(self.this, material, next_material) }
    }

    #[inline]
    pub fn material_set_param(&mut self, material: Rid, parameter: GodotString, value: Variant) -> () {
        unsafe { VisualServer_material_set_param(self.this, material, parameter, value) }
    }

    #[inline]
    pub fn material_set_render_priority(&mut self, material: Rid, priority: i64) -> () {
        unsafe { VisualServer_material_set_render_priority(self.this, material, priority) }
    }

    #[inline]
    pub fn material_set_shader(&mut self, shader_material: Rid, shader: Rid) -> () {
        unsafe { VisualServer_material_set_shader(self.this, shader_material, shader) }
    }

    #[inline]
    pub fn mesh_add_surface_from_arrays(&mut self, mesh: Rid, primitive: i64, arrays: VariantArray, blend_shapes: VariantArray, compress_format: i64) -> () {
        unsafe { VisualServer_mesh_add_surface_from_arrays(self.this, mesh, primitive, arrays, blend_shapes, compress_format) }
    }

    #[inline]
    pub fn mesh_clear(&mut self, mesh: Rid) -> () {
        unsafe { VisualServer_mesh_clear(self.this, mesh) }
    }

    #[inline]
    pub fn mesh_create(&mut self) -> Rid {
        unsafe { VisualServer_mesh_create(self.this) }
    }

    #[inline]
    pub fn mesh_get_blend_shape_count(&self, mesh: Rid) -> i64 {
        unsafe { VisualServer_mesh_get_blend_shape_count(self.this, mesh) }
    }

    #[inline]
    pub fn mesh_get_blend_shape_mode(&self, mesh: Rid) -> VisualServerBlendShapeMode {
        unsafe { VisualServer_mesh_get_blend_shape_mode(self.this, mesh) }
    }

    #[inline]
    pub fn mesh_get_custom_aabb(&self, mesh: Rid) -> Aabb {
        unsafe { VisualServer_mesh_get_custom_aabb(self.this, mesh) }
    }

    #[inline]
    pub fn mesh_get_surface_count(&self, mesh: Rid) -> i64 {
        unsafe { VisualServer_mesh_get_surface_count(self.this, mesh) }
    }

    #[inline]
    pub fn mesh_remove_surface(&mut self, mesh: Rid, index: i64) -> () {
        unsafe { VisualServer_mesh_remove_surface(self.this, mesh, index) }
    }

    #[inline]
    pub fn mesh_set_blend_shape_count(&mut self, mesh: Rid, amount: i64) -> () {
        unsafe { VisualServer_mesh_set_blend_shape_count(self.this, mesh, amount) }
    }

    #[inline]
    pub fn mesh_set_blend_shape_mode(&mut self, mesh: Rid, mode: i64) -> () {
        unsafe { VisualServer_mesh_set_blend_shape_mode(self.this, mesh, mode) }
    }

    #[inline]
    pub fn mesh_set_custom_aabb(&mut self, mesh: Rid, aabb: Aabb) -> () {
        unsafe { VisualServer_mesh_set_custom_aabb(self.this, mesh, aabb) }
    }

    #[inline]
    pub fn mesh_surface_get_aabb(&self, mesh: Rid, surface: i64) -> Aabb {
        unsafe { VisualServer_mesh_surface_get_aabb(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_array(&self, mesh: Rid, surface: i64) -> ByteArray {
        unsafe { VisualServer_mesh_surface_get_array(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_array_index_len(&self, mesh: Rid, surface: i64) -> i64 {
        unsafe { VisualServer_mesh_surface_get_array_index_len(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_array_len(&self, mesh: Rid, surface: i64) -> i64 {
        unsafe { VisualServer_mesh_surface_get_array_len(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_arrays(&self, mesh: Rid, surface: i64) -> VariantArray {
        unsafe { VisualServer_mesh_surface_get_arrays(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_blend_shape_arrays(&self, mesh: Rid, surface: i64) -> VariantArray {
        unsafe { VisualServer_mesh_surface_get_blend_shape_arrays(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_format(&self, mesh: Rid, surface: i64) -> i64 {
        unsafe { VisualServer_mesh_surface_get_format(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_format_offset(&self, format: i64, vertex_len: i64, index_len: i64, array_index: i64) -> i64 {
        unsafe { VisualServer_mesh_surface_get_format_offset(self.this, format, vertex_len, index_len, array_index) }
    }

    #[inline]
    pub fn mesh_surface_get_format_stride(&self, format: i64, vertex_len: i64, index_len: i64) -> i64 {
        unsafe { VisualServer_mesh_surface_get_format_stride(self.this, format, vertex_len, index_len) }
    }

    #[inline]
    pub fn mesh_surface_get_index_array(&self, mesh: Rid, surface: i64) -> ByteArray {
        unsafe { VisualServer_mesh_surface_get_index_array(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_material(&self, mesh: Rid, surface: i64) -> Rid {
        unsafe { VisualServer_mesh_surface_get_material(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_primitive_type(&self, mesh: Rid, surface: i64) -> VisualServerPrimitiveType {
        unsafe { VisualServer_mesh_surface_get_primitive_type(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_get_skeleton_aabb(&self, mesh: Rid, surface: i64) -> VariantArray {
        unsafe { VisualServer_mesh_surface_get_skeleton_aabb(self.this, mesh, surface) }
    }

    #[inline]
    pub fn mesh_surface_set_material(&mut self, mesh: Rid, surface: i64, material: Rid) -> () {
        unsafe { VisualServer_mesh_surface_set_material(self.this, mesh, surface, material) }
    }

    #[inline]
    pub fn mesh_surface_update_region(&mut self, mesh: Rid, surface: i64, offset: i64, data: ByteArray) -> () {
        unsafe { VisualServer_mesh_surface_update_region(self.this, mesh, surface, offset, data) }
    }

    #[inline]
    pub fn multimesh_allocate(&mut self, multimesh: Rid, instances: i64, transform_format: i64, color_format: i64, custom_data_format: i64) -> () {
        unsafe { VisualServer_multimesh_allocate(self.this, multimesh, instances, transform_format, color_format, custom_data_format) }
    }

    #[inline]
    pub fn multimesh_create(&mut self) -> Rid {
        unsafe { VisualServer_multimesh_create(self.this) }
    }

    #[inline]
    pub fn multimesh_get_aabb(&self, multimesh: Rid) -> Aabb {
        unsafe { VisualServer_multimesh_get_aabb(self.this, multimesh) }
    }

    #[inline]
    pub fn multimesh_get_instance_count(&self, multimesh: Rid) -> i64 {
        unsafe { VisualServer_multimesh_get_instance_count(self.this, multimesh) }
    }

    #[inline]
    pub fn multimesh_get_mesh(&self, multimesh: Rid) -> Rid {
        unsafe { VisualServer_multimesh_get_mesh(self.this, multimesh) }
    }

    #[inline]
    pub fn multimesh_get_visible_instances(&self, multimesh: Rid) -> i64 {
        unsafe { VisualServer_multimesh_get_visible_instances(self.this, multimesh) }
    }

    #[inline]
    pub fn multimesh_instance_get_color(&self, multimesh: Rid, index: i64) -> Color {
        unsafe { VisualServer_multimesh_instance_get_color(self.this, multimesh, index) }
    }

    #[inline]
    pub fn multimesh_instance_get_custom_data(&self, multimesh: Rid, index: i64) -> Color {
        unsafe { VisualServer_multimesh_instance_get_custom_data(self.this, multimesh, index) }
    }

    #[inline]
    pub fn multimesh_instance_get_transform(&self, multimesh: Rid, index: i64) -> Transform {
        unsafe { VisualServer_multimesh_instance_get_transform(self.this, multimesh, index) }
    }

    #[inline]
    pub fn multimesh_instance_get_transform_2d(&self, multimesh: Rid, index: i64) -> Transform2D {
        unsafe { VisualServer_multimesh_instance_get_transform_2d(self.this, multimesh, index) }
    }

    #[inline]
    pub fn multimesh_instance_set_color(&mut self, multimesh: Rid, index: i64, color: Color) -> () {
        unsafe { VisualServer_multimesh_instance_set_color(self.this, multimesh, index, color) }
    }

    #[inline]
    pub fn multimesh_instance_set_custom_data(&mut self, multimesh: Rid, index: i64, custom_data: Color) -> () {
        unsafe { VisualServer_multimesh_instance_set_custom_data(self.this, multimesh, index, custom_data) }
    }

    #[inline]
    pub fn multimesh_instance_set_transform(&mut self, multimesh: Rid, index: i64, transform: Transform) -> () {
        unsafe { VisualServer_multimesh_instance_set_transform(self.this, multimesh, index, transform) }
    }

    #[inline]
    pub fn multimesh_instance_set_transform_2d(&mut self, multimesh: Rid, index: i64, transform: Transform2D) -> () {
        unsafe { VisualServer_multimesh_instance_set_transform_2d(self.this, multimesh, index, transform) }
    }

    #[inline]
    pub fn multimesh_set_as_bulk_array(&mut self, multimesh: Rid, array: Float32Array) -> () {
        unsafe { VisualServer_multimesh_set_as_bulk_array(self.this, multimesh, array) }
    }

    #[inline]
    pub fn multimesh_set_mesh(&mut self, multimesh: Rid, mesh: Rid) -> () {
        unsafe { VisualServer_multimesh_set_mesh(self.this, multimesh, mesh) }
    }

    #[inline]
    pub fn multimesh_set_visible_instances(&mut self, multimesh: Rid, visible: i64) -> () {
        unsafe { VisualServer_multimesh_set_visible_instances(self.this, multimesh, visible) }
    }

    #[inline]
    pub fn omni_light_create(&mut self) -> Rid {
        unsafe { VisualServer_omni_light_create(self.this) }
    }

    #[inline]
    pub fn particles_create(&mut self) -> Rid {
        unsafe { VisualServer_particles_create(self.this) }
    }

    #[inline]
    pub fn particles_get_current_aabb(&mut self, particles: Rid) -> Aabb {
        unsafe { VisualServer_particles_get_current_aabb(self.this, particles) }
    }

    #[inline]
    pub fn particles_get_emitting(&mut self, particles: Rid) -> bool {
        unsafe { VisualServer_particles_get_emitting(self.this, particles) }
    }

    #[inline]
    pub fn particles_is_inactive(&mut self, particles: Rid) -> bool {
        unsafe { VisualServer_particles_is_inactive(self.this, particles) }
    }

    #[inline]
    pub fn particles_request_process(&mut self, particles: Rid) -> () {
        unsafe { VisualServer_particles_request_process(self.this, particles) }
    }

    #[inline]
    pub fn particles_restart(&mut self, particles: Rid) -> () {
        unsafe { VisualServer_particles_restart(self.this, particles) }
    }

    #[inline]
    pub fn particles_set_amount(&mut self, particles: Rid, amount: i64) -> () {
        unsafe { VisualServer_particles_set_amount(self.this, particles, amount) }
    }

    #[inline]
    pub fn particles_set_custom_aabb(&mut self, particles: Rid, aabb: Aabb) -> () {
        unsafe { VisualServer_particles_set_custom_aabb(self.this, particles, aabb) }
    }

    #[inline]
    pub fn particles_set_draw_order(&mut self, particles: Rid, order: i64) -> () {
        unsafe { VisualServer_particles_set_draw_order(self.this, particles, order) }
    }

    #[inline]
    pub fn particles_set_draw_pass_mesh(&mut self, particles: Rid, pass: i64, mesh: Rid) -> () {
        unsafe { VisualServer_particles_set_draw_pass_mesh(self.this, particles, pass, mesh) }
    }

    #[inline]
    pub fn particles_set_draw_passes(&mut self, particles: Rid, count: i64) -> () {
        unsafe { VisualServer_particles_set_draw_passes(self.this, particles, count) }
    }

    #[inline]
    pub fn particles_set_emission_transform(&mut self, particles: Rid, transform: Transform) -> () {
        unsafe { VisualServer_particles_set_emission_transform(self.this, particles, transform) }
    }

    #[inline]
    pub fn particles_set_emitting(&mut self, particles: Rid, emitting: bool) -> () {
        unsafe { VisualServer_particles_set_emitting(self.this, particles, emitting) }
    }

    #[inline]
    pub fn particles_set_explosiveness_ratio(&mut self, particles: Rid, ratio: f64) -> () {
        unsafe { VisualServer_particles_set_explosiveness_ratio(self.this, particles, ratio) }
    }

    #[inline]
    pub fn particles_set_fixed_fps(&mut self, particles: Rid, fps: i64) -> () {
        unsafe { VisualServer_particles_set_fixed_fps(self.this, particles, fps) }
    }

    #[inline]
    pub fn particles_set_fractional_delta(&mut self, particles: Rid, enable: bool) -> () {
        unsafe { VisualServer_particles_set_fractional_delta(self.this, particles, enable) }
    }

    #[inline]
    pub fn particles_set_lifetime(&mut self, particles: Rid, lifetime: f64) -> () {
        unsafe { VisualServer_particles_set_lifetime(self.this, particles, lifetime) }
    }

    #[inline]
    pub fn particles_set_one_shot(&mut self, particles: Rid, one_shot: bool) -> () {
        unsafe { VisualServer_particles_set_one_shot(self.this, particles, one_shot) }
    }

    #[inline]
    pub fn particles_set_pre_process_time(&mut self, particles: Rid, time: f64) -> () {
        unsafe { VisualServer_particles_set_pre_process_time(self.this, particles, time) }
    }

    #[inline]
    pub fn particles_set_process_material(&mut self, particles: Rid, material: Rid) -> () {
        unsafe { VisualServer_particles_set_process_material(self.this, particles, material) }
    }

    #[inline]
    pub fn particles_set_randomness_ratio(&mut self, particles: Rid, ratio: f64) -> () {
        unsafe { VisualServer_particles_set_randomness_ratio(self.this, particles, ratio) }
    }

    #[inline]
    pub fn particles_set_speed_scale(&mut self, particles: Rid, scale: f64) -> () {
        unsafe { VisualServer_particles_set_speed_scale(self.this, particles, scale) }
    }

    #[inline]
    pub fn particles_set_use_local_coordinates(&mut self, particles: Rid, enable: bool) -> () {
        unsafe { VisualServer_particles_set_use_local_coordinates(self.this, particles, enable) }
    }

    #[inline]
    pub fn reflection_probe_create(&mut self) -> Rid {
        unsafe { VisualServer_reflection_probe_create(self.this) }
    }

    #[inline]
    pub fn reflection_probe_set_as_interior(&mut self, probe: Rid, enable: bool) -> () {
        unsafe { VisualServer_reflection_probe_set_as_interior(self.this, probe, enable) }
    }

    #[inline]
    pub fn reflection_probe_set_cull_mask(&mut self, probe: Rid, layers: i64) -> () {
        unsafe { VisualServer_reflection_probe_set_cull_mask(self.this, probe, layers) }
    }

    #[inline]
    pub fn reflection_probe_set_enable_box_projection(&mut self, probe: Rid, enable: bool) -> () {
        unsafe { VisualServer_reflection_probe_set_enable_box_projection(self.this, probe, enable) }
    }

    #[inline]
    pub fn reflection_probe_set_enable_shadows(&mut self, probe: Rid, enable: bool) -> () {
        unsafe { VisualServer_reflection_probe_set_enable_shadows(self.this, probe, enable) }
    }

    #[inline]
    pub fn reflection_probe_set_extents(&mut self, probe: Rid, extents: Vector3) -> () {
        unsafe { VisualServer_reflection_probe_set_extents(self.this, probe, extents) }
    }

    #[inline]
    pub fn reflection_probe_set_intensity(&mut self, probe: Rid, intensity: f64) -> () {
        unsafe { VisualServer_reflection_probe_set_intensity(self.this, probe, intensity) }
    }

    #[inline]
    pub fn reflection_probe_set_interior_ambient(&mut self, probe: Rid, color: Color) -> () {
        unsafe { VisualServer_reflection_probe_set_interior_ambient(self.this, probe, color) }
    }

    #[inline]
    pub fn reflection_probe_set_interior_ambient_energy(&mut self, probe: Rid, energy: f64) -> () {
        unsafe { VisualServer_reflection_probe_set_interior_ambient_energy(self.this, probe, energy) }
    }

    #[inline]
    pub fn reflection_probe_set_interior_ambient_probe_contribution(&mut self, probe: Rid, contrib: f64) -> () {
        unsafe { VisualServer_reflection_probe_set_interior_ambient_probe_contribution(self.this, probe, contrib) }
    }

    #[inline]
    pub fn reflection_probe_set_max_distance(&mut self, probe: Rid, distance: f64) -> () {
        unsafe { VisualServer_reflection_probe_set_max_distance(self.this, probe, distance) }
    }

    #[inline]
    pub fn reflection_probe_set_origin_offset(&mut self, probe: Rid, offset: Vector3) -> () {
        unsafe { VisualServer_reflection_probe_set_origin_offset(self.this, probe, offset) }
    }

    #[inline]
    pub fn reflection_probe_set_update_mode(&mut self, probe: Rid, mode: i64) -> () {
        unsafe { VisualServer_reflection_probe_set_update_mode(self.this, probe, mode) }
    }

    #[inline]
    pub fn request_frame_drawn_callback(&mut self, _where: Option<Object>, method: GodotString, userdata: Variant) -> () {
        unsafe { VisualServer_request_frame_drawn_callback(self.this, _where, method, userdata) }
    }

    #[inline]
    pub fn scenario_create(&mut self) -> Rid {
        unsafe { VisualServer_scenario_create(self.this) }
    }

    #[inline]
    pub fn scenario_set_debug(&mut self, scenario: Rid, debug_mode: i64) -> () {
        unsafe { VisualServer_scenario_set_debug(self.this, scenario, debug_mode) }
    }

    #[inline]
    pub fn scenario_set_environment(&mut self, scenario: Rid, environment: Rid) -> () {
        unsafe { VisualServer_scenario_set_environment(self.this, scenario, environment) }
    }

    #[inline]
    pub fn scenario_set_fallback_environment(&mut self, scenario: Rid, environment: Rid) -> () {
        unsafe { VisualServer_scenario_set_fallback_environment(self.this, scenario, environment) }
    }

    #[inline]
    pub fn scenario_set_reflection_atlas_size(&mut self, scenario: Rid, size: i64, subdiv: i64) -> () {
        unsafe { VisualServer_scenario_set_reflection_atlas_size(self.this, scenario, size, subdiv) }
    }

    #[inline]
    pub fn set_boot_image(&mut self, image: Option<Image>, color: Color, scale: bool, use_filter: bool) -> () {
        unsafe { VisualServer_set_boot_image(self.this, image, color, scale, use_filter) }
    }

    #[inline]
    pub fn set_debug_generate_wireframes(&mut self, generate: bool) -> () {
        unsafe { VisualServer_set_debug_generate_wireframes(self.this, generate) }
    }

    #[inline]
    pub fn set_default_clear_color(&mut self, color: Color) -> () {
        unsafe { VisualServer_set_default_clear_color(self.this, color) }
    }

    #[inline]
    pub fn shader_create(&mut self) -> Rid {
        unsafe { VisualServer_shader_create(self.this) }
    }

    #[inline]
    pub fn shader_get_code(&self, shader: Rid) -> GodotString {
        unsafe { VisualServer_shader_get_code(self.this, shader) }
    }

    #[inline]
    pub fn shader_get_default_texture_param(&self, shader: Rid, name: GodotString) -> Rid {
        unsafe { VisualServer_shader_get_default_texture_param(self.this, shader, name) }
    }

    #[inline]
    pub fn shader_get_param_list(&self, shader: Rid) -> VariantArray {
        unsafe { VisualServer_shader_get_param_list(self.this, shader) }
    }

    #[inline]
    pub fn shader_set_code(&mut self, shader: Rid, code: GodotString) -> () {
        unsafe { VisualServer_shader_set_code(self.this, shader, code) }
    }

    #[inline]
    pub fn shader_set_default_texture_param(&mut self, shader: Rid, name: GodotString, texture: Rid) -> () {
        unsafe { VisualServer_shader_set_default_texture_param(self.this, shader, name, texture) }
    }

    #[inline]
    pub fn skeleton_allocate(&mut self, skeleton: Rid, bones: i64, is_2d_skeleton: bool) -> () {
        unsafe { VisualServer_skeleton_allocate(self.this, skeleton, bones, is_2d_skeleton) }
    }

    #[inline]
    pub fn skeleton_bone_get_transform(&self, skeleton: Rid, bone: i64) -> Transform {
        unsafe { VisualServer_skeleton_bone_get_transform(self.this, skeleton, bone) }
    }

    #[inline]
    pub fn skeleton_bone_get_transform_2d(&self, skeleton: Rid, bone: i64) -> Transform2D {
        unsafe { VisualServer_skeleton_bone_get_transform_2d(self.this, skeleton, bone) }
    }

    #[inline]
    pub fn skeleton_bone_set_transform(&mut self, skeleton: Rid, bone: i64, transform: Transform) -> () {
        unsafe { VisualServer_skeleton_bone_set_transform(self.this, skeleton, bone, transform) }
    }

    #[inline]
    pub fn skeleton_bone_set_transform_2d(&mut self, skeleton: Rid, bone: i64, transform: Transform2D) -> () {
        unsafe { VisualServer_skeleton_bone_set_transform_2d(self.this, skeleton, bone, transform) }
    }

    #[inline]
    pub fn skeleton_create(&mut self) -> Rid {
        unsafe { VisualServer_skeleton_create(self.this) }
    }

    #[inline]
    pub fn skeleton_get_bone_count(&self, skeleton: Rid) -> i64 {
        unsafe { VisualServer_skeleton_get_bone_count(self.this, skeleton) }
    }

    #[inline]
    pub fn sky_create(&mut self) -> Rid {
        unsafe { VisualServer_sky_create(self.this) }
    }

    #[inline]
    pub fn sky_set_texture(&mut self, sky: Rid, cube_map: Rid, radiance_size: i64) -> () {
        unsafe { VisualServer_sky_set_texture(self.this, sky, cube_map, radiance_size) }
    }

    #[inline]
    pub fn spot_light_create(&mut self) -> Rid {
        unsafe { VisualServer_spot_light_create(self.this) }
    }

    #[inline]
    pub fn sync(&mut self) -> () {
        unsafe { VisualServer_sync(self.this) }
    }

    #[inline]
    pub fn texture_allocate(&mut self, texture: Rid, width: i64, height: i64, depth_3d: i64, format: i64, _type: i64, flags: i64) -> () {
        unsafe { VisualServer_texture_allocate(self.this, texture, width, height, depth_3d, format, _type, flags) }
    }

    #[inline]
    pub fn texture_bind(&mut self, texture: Rid, number: i64) -> () {
        unsafe { VisualServer_texture_bind(self.this, texture, number) }
    }

    #[inline]
    pub fn texture_create(&mut self) -> Rid {
        unsafe { VisualServer_texture_create(self.this) }
    }

    #[inline]
    pub fn texture_create_from_image(&mut self, image: Option<Image>, flags: i64) -> Rid {
        unsafe { VisualServer_texture_create_from_image(self.this, image, flags) }
    }

    #[inline]
    pub fn texture_debug_usage(&mut self) -> VariantArray {
        unsafe { VisualServer_texture_debug_usage(self.this) }
    }

    #[inline]
    pub fn texture_get_data(&self, texture: Rid, cube_side: i64) -> Option<Image> {
        unsafe { VisualServer_texture_get_data(self.this, texture, cube_side) }
    }

    #[inline]
    pub fn texture_get_depth(&self, texture: Rid) -> i64 {
        unsafe { VisualServer_texture_get_depth(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_flags(&self, texture: Rid) -> i64 {
        unsafe { VisualServer_texture_get_flags(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_format(&self, texture: Rid) -> ImageFormat {
        unsafe { VisualServer_texture_get_format(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_height(&self, texture: Rid) -> i64 {
        unsafe { VisualServer_texture_get_height(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_path(&self, texture: Rid) -> GodotString {
        unsafe { VisualServer_texture_get_path(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_texid(&self, texture: Rid) -> i64 {
        unsafe { VisualServer_texture_get_texid(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_type(&self, texture: Rid) -> VisualServerTextureType {
        unsafe { VisualServer_texture_get_type(self.this, texture) }
    }

    #[inline]
    pub fn texture_get_width(&self, texture: Rid) -> i64 {
        unsafe { VisualServer_texture_get_width(self.this, texture) }
    }

    #[inline]
    pub fn texture_set_data(&mut self, texture: Rid, image: Option<Image>, layer: i64) -> () {
        unsafe { VisualServer_texture_set_data(self.this, texture, image, layer) }
    }

    #[inline]
    pub fn texture_set_data_partial(&mut self, texture: Rid, image: Option<Image>, src_x: i64, src_y: i64, src_w: i64, src_h: i64, dst_x: i64, dst_y: i64, dst_mip: i64, layer: i64) -> () {
        unsafe { VisualServer_texture_set_data_partial(self.this, texture, image, src_x, src_y, src_w, src_h, dst_x, dst_y, dst_mip, layer) }
    }

    #[inline]
    pub fn texture_set_flags(&mut self, texture: Rid, flags: i64) -> () {
        unsafe { VisualServer_texture_set_flags(self.this, texture, flags) }
    }

    #[inline]
    pub fn texture_set_path(&mut self, texture: Rid, path: GodotString) -> () {
        unsafe { VisualServer_texture_set_path(self.this, texture, path) }
    }

    #[inline]
    pub fn texture_set_shrink_all_x2_on_set_data(&mut self, shrink: bool) -> () {
        unsafe { VisualServer_texture_set_shrink_all_x2_on_set_data(self.this, shrink) }
    }

    #[inline]
    pub fn texture_set_size_override(&mut self, texture: Rid, width: i64, height: i64, depth: i64) -> () {
        unsafe { VisualServer_texture_set_size_override(self.this, texture, width, height, depth) }
    }

    #[inline]
    pub fn textures_keep_original(&mut self, enable: bool) -> () {
        unsafe { VisualServer_textures_keep_original(self.this, enable) }
    }

    #[inline]
    pub fn viewport_attach_camera(&mut self, viewport: Rid, camera: Rid) -> () {
        unsafe { VisualServer_viewport_attach_camera(self.this, viewport, camera) }
    }

    #[inline]
    pub fn viewport_attach_canvas(&mut self, viewport: Rid, canvas: Rid) -> () {
        unsafe { VisualServer_viewport_attach_canvas(self.this, viewport, canvas) }
    }

    #[inline]
    pub fn viewport_attach_to_screen(&mut self, viewport: Rid, rect: Rect2, screen: i64) -> () {
        unsafe { VisualServer_viewport_attach_to_screen(self.this, viewport, rect, screen) }
    }

    #[inline]
    pub fn viewport_create(&mut self) -> Rid {
        unsafe { VisualServer_viewport_create(self.this) }
    }

    #[inline]
    pub fn viewport_detach(&mut self, viewport: Rid) -> () {
        unsafe { VisualServer_viewport_detach(self.this, viewport) }
    }

    #[inline]
    pub fn viewport_get_render_info(&mut self, viewport: Rid, info: i64) -> i64 {
        unsafe { VisualServer_viewport_get_render_info(self.this, viewport, info) }
    }

    #[inline]
    pub fn viewport_get_texture(&self, viewport: Rid) -> Rid {
        unsafe { VisualServer_viewport_get_texture(self.this, viewport) }
    }

    #[inline]
    pub fn viewport_remove_canvas(&mut self, viewport: Rid, canvas: Rid) -> () {
        unsafe { VisualServer_viewport_remove_canvas(self.this, viewport, canvas) }
    }

    #[inline]
    pub fn viewport_set_active(&mut self, viewport: Rid, active: bool) -> () {
        unsafe { VisualServer_viewport_set_active(self.this, viewport, active) }
    }

    #[inline]
    pub fn viewport_set_canvas_stacking(&mut self, viewport: Rid, canvas: Rid, layer: i64, sublayer: i64) -> () {
        unsafe { VisualServer_viewport_set_canvas_stacking(self.this, viewport, canvas, layer, sublayer) }
    }

    #[inline]
    pub fn viewport_set_canvas_transform(&mut self, viewport: Rid, canvas: Rid, offset: Transform2D) -> () {
        unsafe { VisualServer_viewport_set_canvas_transform(self.this, viewport, canvas, offset) }
    }

    #[inline]
    pub fn viewport_set_clear_mode(&mut self, viewport: Rid, clear_mode: i64) -> () {
        unsafe { VisualServer_viewport_set_clear_mode(self.this, viewport, clear_mode) }
    }

    #[inline]
    pub fn viewport_set_debug_draw(&mut self, viewport: Rid, draw: i64) -> () {
        unsafe { VisualServer_viewport_set_debug_draw(self.this, viewport, draw) }
    }

    #[inline]
    pub fn viewport_set_disable_3d(&mut self, viewport: Rid, disabled: bool) -> () {
        unsafe { VisualServer_viewport_set_disable_3d(self.this, viewport, disabled) }
    }

    #[inline]
    pub fn viewport_set_disable_environment(&mut self, viewport: Rid, disabled: bool) -> () {
        unsafe { VisualServer_viewport_set_disable_environment(self.this, viewport, disabled) }
    }

    #[inline]
    pub fn viewport_set_global_canvas_transform(&mut self, viewport: Rid, transform: Transform2D) -> () {
        unsafe { VisualServer_viewport_set_global_canvas_transform(self.this, viewport, transform) }
    }

    #[inline]
    pub fn viewport_set_hdr(&mut self, viewport: Rid, enabled: bool) -> () {
        unsafe { VisualServer_viewport_set_hdr(self.this, viewport, enabled) }
    }

    #[inline]
    pub fn viewport_set_hide_canvas(&mut self, viewport: Rid, hidden: bool) -> () {
        unsafe { VisualServer_viewport_set_hide_canvas(self.this, viewport, hidden) }
    }

    #[inline]
    pub fn viewport_set_hide_scenario(&mut self, viewport: Rid, hidden: bool) -> () {
        unsafe { VisualServer_viewport_set_hide_scenario(self.this, viewport, hidden) }
    }

    #[inline]
    pub fn viewport_set_msaa(&mut self, viewport: Rid, msaa: i64) -> () {
        unsafe { VisualServer_viewport_set_msaa(self.this, viewport, msaa) }
    }

    #[inline]
    pub fn viewport_set_parent_viewport(&mut self, viewport: Rid, parent_viewport: Rid) -> () {
        unsafe { VisualServer_viewport_set_parent_viewport(self.this, viewport, parent_viewport) }
    }

    #[inline]
    pub fn viewport_set_render_direct_to_screen(&mut self, viewport: Rid, enabled: bool) -> () {
        unsafe { VisualServer_viewport_set_render_direct_to_screen(self.this, viewport, enabled) }
    }

    #[inline]
    pub fn viewport_set_scenario(&mut self, viewport: Rid, scenario: Rid) -> () {
        unsafe { VisualServer_viewport_set_scenario(self.this, viewport, scenario) }
    }

    #[inline]
    pub fn viewport_set_shadow_atlas_quadrant_subdivision(&mut self, viewport: Rid, quadrant: i64, subdivision: i64) -> () {
        unsafe { VisualServer_viewport_set_shadow_atlas_quadrant_subdivision(self.this, viewport, quadrant, subdivision) }
    }

    #[inline]
    pub fn viewport_set_shadow_atlas_size(&mut self, viewport: Rid, size: i64) -> () {
        unsafe { VisualServer_viewport_set_shadow_atlas_size(self.this, viewport, size) }
    }

    #[inline]
    pub fn viewport_set_size(&mut self, viewport: Rid, width: i64, height: i64) -> () {
        unsafe { VisualServer_viewport_set_size(self.this, viewport, width, height) }
    }

    #[inline]
    pub fn viewport_set_transparent_background(&mut self, viewport: Rid, enabled: bool) -> () {
        unsafe { VisualServer_viewport_set_transparent_background(self.this, viewport, enabled) }
    }

    #[inline]
    pub fn viewport_set_update_mode(&mut self, viewport: Rid, update_mode: i64) -> () {
        unsafe { VisualServer_viewport_set_update_mode(self.this, viewport, update_mode) }
    }

    #[inline]
    pub fn viewport_set_usage(&mut self, viewport: Rid, usage: i64) -> () {
        unsafe { VisualServer_viewport_set_usage(self.this, viewport, usage) }
    }

    #[inline]
    pub fn viewport_set_use_arvr(&mut self, viewport: Rid, use_arvr: bool) -> () {
        unsafe { VisualServer_viewport_set_use_arvr(self.this, viewport, use_arvr) }
    }

    #[inline]
    pub fn viewport_set_vflip(&mut self, viewport: Rid, enabled: bool) -> () {
        unsafe { VisualServer_viewport_set_vflip(self.this, viewport, enabled) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShader` inherits `Shader` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshader.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShader inherits methods from:
/// - [Shader](struct.Shader.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderType {
    Vertex = 0,
    Fragment = 1,
    Light = 2,
    Max = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShader {
    pub const TYPE_LIGHT: i64 = 2;
    pub const TYPE_FRAGMENT: i64 = 1;
    pub const NODE_ID_INVALID: i64 = -1;
    pub const NODE_ID_OUTPUT: i64 = 0;
    pub const TYPE_MAX: i64 = 3;
    pub const TYPE_VERTEX: i64 = 0;
}
impl VisualShader {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShader {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _input_type_changed(&mut self, arg0: i64, arg1: i64) -> () {
        unsafe { VisualShader__input_type_changed(self.this, arg0, arg1) }
    }

    #[inline]
    pub fn _queue_update(&mut self) -> () {
        unsafe { VisualShader__queue_update(self.this) }
    }

    #[inline]
    pub fn _update_shader(&self) -> () {
        unsafe { VisualShader__update_shader(self.this) }
    }

    #[inline]
    pub fn add_node(&mut self, _type: i64, node: Option<VisualShaderNode>, position: Vector2, id: i64) -> () {
        unsafe { VisualShader_add_node(self.this, _type, node, position, id) }
    }

    #[inline]
    pub fn can_connect_nodes(&self, _type: i64, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> bool {
        unsafe { VisualShader_can_connect_nodes(self.this, _type, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn connect_nodes(&mut self, _type: i64, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> GodotResult {
        unsafe { VisualShader_connect_nodes(self.this, _type, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn connect_nodes_forced(&mut self, _type: i64, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> () {
        unsafe { VisualShader_connect_nodes_forced(self.this, _type, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn disconnect_nodes(&mut self, _type: i64, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> () {
        unsafe { VisualShader_disconnect_nodes(self.this, _type, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn get_graph_offset(&self) -> Vector2 {
        unsafe { VisualShader_get_graph_offset(self.this) }
    }

    #[inline]
    pub fn get_node(&self, _type: i64, id: i64) -> Option<VisualShaderNode> {
        unsafe { VisualShader_get_node(self.this, _type, id) }
    }

    #[inline]
    pub fn get_node_connections(&self, _type: i64) -> VariantArray {
        unsafe { VisualShader_get_node_connections(self.this, _type) }
    }

    #[inline]
    pub fn get_node_list(&self, _type: i64) -> Int32Array {
        unsafe { VisualShader_get_node_list(self.this, _type) }
    }

    #[inline]
    pub fn get_node_position(&self, _type: i64, id: i64) -> Vector2 {
        unsafe { VisualShader_get_node_position(self.this, _type, id) }
    }

    #[inline]
    pub fn get_valid_node_id(&self, _type: i64) -> i64 {
        unsafe { VisualShader_get_valid_node_id(self.this, _type) }
    }

    #[inline]
    pub fn is_node_connection(&self, _type: i64, from_node: i64, from_port: i64, to_node: i64, to_port: i64) -> bool {
        unsafe { VisualShader_is_node_connection(self.this, _type, from_node, from_port, to_node, to_port) }
    }

    #[inline]
    pub fn remove_node(&mut self, _type: i64, id: i64) -> () {
        unsafe { VisualShader_remove_node(self.this, _type, id) }
    }

    #[inline]
    pub fn set_graph_offset(&mut self, offset: Vector2) -> () {
        unsafe { VisualShader_set_graph_offset(self.this, offset) }
    }

    #[inline]
    pub fn set_mode(&mut self, mode: i64) -> () {
        unsafe { VisualShader_set_mode(self.this, mode) }
    }

    #[inline]
    pub fn set_node_position(&mut self, _type: i64, id: i64, position: Vector2) -> () {
        unsafe { VisualShader_set_node_position(self.this, _type, id, position) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_shader(&self) -> Shader {
        unsafe {{ object::add_ref(self.this); }}
        Shader { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNode` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernode.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNode inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNode {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodePortType {
    Scalar = 0,
    Vector = 1,
    Boolean = 2,
    Transform = 3,
    Sampler = 4,
    Max = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNode {
    pub const PORT_TYPE_TRANSFORM: i64 = 3;
    pub const PORT_TYPE_BOOLEAN: i64 = 2;
    pub const PORT_TYPE_VECTOR: i64 = 1;
    pub const PORT_TYPE_MAX: i64 = 5;
    pub const PORT_TYPE_SCALAR: i64 = 0;
    pub const PORT_TYPE_SAMPLER: i64 = 4;
}
impl VisualShaderNode {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_default_input_values(&self) -> VariantArray {
        unsafe { VisualShaderNode_get_default_input_values(self.this) }
    }

    #[inline]
    pub fn get_input_port_default_value(&self, port: i64) -> Variant {
        unsafe { VisualShaderNode_get_input_port_default_value(self.this, port) }
    }

    #[inline]
    pub fn get_output_port_for_preview(&self) -> i64 {
        unsafe { VisualShaderNode_get_output_port_for_preview(self.this) }
    }

    #[inline]
    pub fn set_default_input_values(&mut self, values: VariantArray) -> () {
        unsafe { VisualShaderNode_set_default_input_values(self.this, values) }
    }

    #[inline]
    pub fn set_input_port_default_value(&mut self, port: i64, value: Variant) -> () {
        unsafe { VisualShaderNode_set_input_port_default_value(self.this, port, value) }
    }

    #[inline]
    pub fn set_output_port_for_preview(&mut self, port: i64) -> () {
        unsafe { VisualShaderNode_set_output_port_for_preview(self.this, port) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeBooleanConstant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodebooleanconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeBooleanConstant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeBooleanConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeBooleanConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeBooleanConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeBooleanConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant(&self) -> bool {
        unsafe { VisualShaderNodeBooleanConstant_get_constant(self.this) }
    }

    #[inline]
    pub fn set_constant(&mut self, value: bool) -> () {
        unsafe { VisualShaderNodeBooleanConstant_set_constant(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeBooleanUniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodebooleanuniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeBooleanUniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeBooleanUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeBooleanUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeBooleanUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeBooleanUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeColorConstant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecolorconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeColorConstant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeColorConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeColorConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeColorConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeColorConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant(&self) -> Color {
        unsafe { VisualShaderNodeColorConstant_get_constant(self.this) }
    }

    #[inline]
    pub fn set_constant(&mut self, value: Color) -> () {
        unsafe { VisualShaderNodeColorConstant_set_constant(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeColorFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecolorfunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeColorFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeColorFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeColorFuncFunction {
    FuncGrayscale = 0,
    FuncSepia = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeColorFunc {
    pub const FUNC_SEPIA: i64 = 1;
    pub const FUNC_GRAYSCALE: i64 = 0;
}
impl VisualShaderNodeColorFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeColorFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeColorFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeColorFuncFunction {
        unsafe { VisualShaderNodeColorFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeColorFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeColorOp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecolorop.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeColorOp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeColorOp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeColorOpOperator {
    OpScreen = 0,
    OpDifference = 1,
    OpDarken = 2,
    OpLighten = 3,
    OpOverlay = 4,
    OpDodge = 5,
    OpBurn = 6,
    OpSoftLight = 7,
    OpHardLight = 8,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeColorOp {
    pub const OP_BURN: i64 = 6;
    pub const OP_LIGHTEN: i64 = 3;
    pub const OP_DIFFERENCE: i64 = 1;
    pub const OP_DODGE: i64 = 5;
    pub const OP_SOFT_LIGHT: i64 = 7;
    pub const OP_OVERLAY: i64 = 4;
    pub const OP_DARKEN: i64 = 2;
    pub const OP_HARD_LIGHT: i64 = 8;
    pub const OP_SCREEN: i64 = 0;
}
impl VisualShaderNodeColorOp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeColorOpMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeColorOp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VisualShaderNodeColorOpOperator {
        unsafe { VisualShaderNodeColorOp_get_operator(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualShaderNodeColorOp_set_operator(self.this, op) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeColorUniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecoloruniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeColorUniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeColorUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeColorUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeColorUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeColorUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeCompare` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecompare.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeCompare inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeCompare {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeCompareComparisonType {
    CtypeScalar = 0,
    CtypeVector = 1,
    CtypeBoolean = 2,
    CtypeTransform = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeCompareFunction {
    FuncEqual = 0,
    FuncNotEqual = 1,
    FuncGreaterThan = 2,
    FuncGreaterThanEqual = 3,
    FuncLessThan = 4,
    FuncLessThanEqual = 5,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeCompareCondition {
    CondAll = 0,
    CondAny = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeCompare {
    pub const CTYPE_BOOLEAN: i64 = 2;
    pub const COND_ANY: i64 = 1;
    pub const FUNC_EQUAL: i64 = 0;
    pub const CTYPE_VECTOR: i64 = 1;
    pub const COND_ALL: i64 = 0;
    pub const FUNC_GREATER_THAN: i64 = 2;
    pub const FUNC_LESS_THAN: i64 = 4;
    pub const FUNC_LESS_THAN_EQUAL: i64 = 5;
    pub const CTYPE_TRANSFORM: i64 = 3;
    pub const FUNC_GREATER_THAN_EQUAL: i64 = 3;
    pub const CTYPE_SCALAR: i64 = 0;
    pub const FUNC_NOT_EQUAL: i64 = 1;
}
impl VisualShaderNodeCompare {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeCompareMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeCompare {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_comparison_type(&self) -> VisualShaderNodeCompareComparisonType {
        unsafe { VisualShaderNodeCompare_get_comparison_type(self.this) }
    }

    #[inline]
    pub fn get_condition(&self) -> VisualShaderNodeCompareCondition {
        unsafe { VisualShaderNodeCompare_get_condition(self.this) }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeCompareFunction {
        unsafe { VisualShaderNodeCompare_get_function(self.this) }
    }

    #[inline]
    pub fn set_comparison_type(&mut self, _type: i64) -> () {
        unsafe { VisualShaderNodeCompare_set_comparison_type(self.this, _type) }
    }

    #[inline]
    pub fn set_condition(&mut self, condition: i64) -> () {
        unsafe { VisualShaderNodeCompare_set_condition(self.this, condition) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeCompare_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeCubeMap` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecubemap.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeCubeMap inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeCubeMap {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeCubeMapTextureType {
    TypeData = 0,
    TypeColor = 1,
    TypeNormalmap = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeCubeMapSource {
    Texture = 0,
    Port = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeCubeMap {
    pub const SOURCE_PORT: i64 = 1;
    pub const TYPE_COLOR: i64 = 1;
    pub const TYPE_DATA: i64 = 0;
    pub const SOURCE_TEXTURE: i64 = 0;
    pub const TYPE_NORMALMAP: i64 = 2;
}
impl VisualShaderNodeCubeMap {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeCubeMapMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeCubeMap {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_cube_map(&self) -> Option<CubeMap> {
        unsafe { VisualShaderNodeCubeMap_get_cube_map(self.this) }
    }

    #[inline]
    pub fn get_source(&self) -> VisualShaderNodeCubeMapSource {
        unsafe { VisualShaderNodeCubeMap_get_source(self.this) }
    }

    #[inline]
    pub fn get_texture_type(&self) -> VisualShaderNodeCubeMapTextureType {
        unsafe { VisualShaderNodeCubeMap_get_texture_type(self.this) }
    }

    #[inline]
    pub fn set_cube_map(&mut self, value: Option<CubeMap>) -> () {
        unsafe { VisualShaderNodeCubeMap_set_cube_map(self.this, value) }
    }

    #[inline]
    pub fn set_source(&mut self, value: i64) -> () {
        unsafe { VisualShaderNodeCubeMap_set_source(self.this, value) }
    }

    #[inline]
    pub fn set_texture_type(&mut self, value: i64) -> () {
        unsafe { VisualShaderNodeCubeMap_set_texture_type(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeCubeMapUniform` inherits `VisualShaderNodeTextureUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecubemapuniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeCubeMapUniform inherits methods from:
/// - [VisualShaderNodeTextureUniform](struct.VisualShaderNodeTextureUniform.html)
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeCubeMapUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeCubeMapUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeCubeMapUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeCubeMapUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_texture_uniform(&self) -> VisualShaderNodeTextureUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeTextureUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeCustom` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodecustom.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeCustom inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeCustom {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeCustom {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeCustomMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeCustom {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn _get_category(&mut self) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_category(self.this) }
    }

    #[inline]
    pub fn _get_code(&mut self, input_vars: VariantArray, output_vars: VariantArray, mode: i64, _type: i64) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_code(self.this, input_vars, output_vars, mode, _type) }
    }

    #[inline]
    pub fn _get_description(&mut self) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_description(self.this) }
    }

    #[inline]
    pub fn _get_global_code(&mut self, mode: i64) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_global_code(self.this, mode) }
    }

    #[inline]
    pub fn _get_input_port_count(&mut self) -> i64 {
        unsafe { VisualShaderNodeCustom__get_input_port_count(self.this) }
    }

    #[inline]
    pub fn _get_input_port_name(&mut self, port: i64) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_input_port_name(self.this, port) }
    }

    #[inline]
    pub fn _get_input_port_type(&mut self, port: i64) -> i64 {
        unsafe { VisualShaderNodeCustom__get_input_port_type(self.this, port) }
    }

    #[inline]
    pub fn _get_name(&mut self) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_name(self.this) }
    }

    #[inline]
    pub fn _get_output_port_count(&mut self) -> i64 {
        unsafe { VisualShaderNodeCustom__get_output_port_count(self.this) }
    }

    #[inline]
    pub fn _get_output_port_name(&mut self, port: i64) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_output_port_name(self.this, port) }
    }

    #[inline]
    pub fn _get_output_port_type(&mut self, port: i64) -> i64 {
        unsafe { VisualShaderNodeCustom__get_output_port_type(self.this, port) }
    }

    #[inline]
    pub fn _get_return_icon_type(&mut self) -> i64 {
        unsafe { VisualShaderNodeCustom__get_return_icon_type(self.this) }
    }

    #[inline]
    pub fn _get_subcategory(&mut self) -> GodotString {
        unsafe { VisualShaderNodeCustom__get_subcategory(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeDeterminant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodedeterminant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeDeterminant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeDeterminant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeDeterminant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeDeterminantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeDeterminant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeDotProduct` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodedotproduct.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeDotProduct inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeDotProduct {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeDotProduct {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeDotProductMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeDotProduct {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeExpression` inherits `VisualShaderNodeGroupBase` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeexpression.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeExpression inherits methods from:
/// - [VisualShaderNodeGroupBase](struct.VisualShaderNodeGroupBase.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeExpression {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeExpression {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeExpressionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeExpression {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_expression(&self) -> GodotString {
        unsafe { VisualShaderNodeExpression_get_expression(self.this) }
    }

    #[inline]
    pub fn set_expression(&mut self, expression: GodotString) -> () {
        unsafe { VisualShaderNodeExpression_set_expression(self.this, expression) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_group_base(&self) -> VisualShaderNodeGroupBase {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeGroupBase { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeFaceForward` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodefaceforward.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeFaceForward inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeFaceForward {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeFaceForward {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeFaceForwardMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeFaceForward {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeFresnel` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodefresnel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeFresnel inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeFresnel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeFresnel {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeFresnelMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeFresnel {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeGlobalExpression` inherits `VisualShaderNodeExpression` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeglobalexpression.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeGlobalExpression inherits methods from:
/// - [VisualShaderNodeExpression](struct.VisualShaderNodeExpression.html)
/// - [VisualShaderNodeGroupBase](struct.VisualShaderNodeGroupBase.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeGlobalExpression {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeGlobalExpression {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeGlobalExpressionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeGlobalExpression {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_expression(&self) -> VisualShaderNodeExpression {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeExpression { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_group_base(&self) -> VisualShaderNodeGroupBase {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeGroupBase { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeGroupBase` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodegroupbase.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeGroupBase inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeGroupBase {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeGroupBase {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeGroupBaseMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeGroupBase {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_input_port(&mut self, id: i64, _type: i64, name: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_add_input_port(self.this, id, _type, name) }
    }

    #[inline]
    pub fn add_output_port(&mut self, id: i64, _type: i64, name: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_add_output_port(self.this, id, _type, name) }
    }

    #[inline]
    pub fn clear_input_ports(&mut self) -> () {
        unsafe { VisualShaderNodeGroupBase_clear_input_ports(self.this) }
    }

    #[inline]
    pub fn clear_output_ports(&mut self) -> () {
        unsafe { VisualShaderNodeGroupBase_clear_output_ports(self.this) }
    }

    #[inline]
    pub fn get_free_input_port_id(&self) -> i64 {
        unsafe { VisualShaderNodeGroupBase_get_free_input_port_id(self.this) }
    }

    #[inline]
    pub fn get_free_output_port_id(&self) -> i64 {
        unsafe { VisualShaderNodeGroupBase_get_free_output_port_id(self.this) }
    }

    #[inline]
    pub fn get_input_port_count(&self) -> i64 {
        unsafe { VisualShaderNodeGroupBase_get_input_port_count(self.this) }
    }

    #[inline]
    pub fn get_inputs(&self) -> GodotString {
        unsafe { VisualShaderNodeGroupBase_get_inputs(self.this) }
    }

    #[inline]
    pub fn get_output_port_count(&self) -> i64 {
        unsafe { VisualShaderNodeGroupBase_get_output_port_count(self.this) }
    }

    #[inline]
    pub fn get_outputs(&self) -> GodotString {
        unsafe { VisualShaderNodeGroupBase_get_outputs(self.this) }
    }

    #[inline]
    pub fn get_size(&self) -> Vector2 {
        unsafe { VisualShaderNodeGroupBase_get_size(self.this) }
    }

    #[inline]
    pub fn has_input_port(&self, id: i64) -> bool {
        unsafe { VisualShaderNodeGroupBase_has_input_port(self.this, id) }
    }

    #[inline]
    pub fn has_output_port(&self, id: i64) -> bool {
        unsafe { VisualShaderNodeGroupBase_has_output_port(self.this, id) }
    }

    #[inline]
    pub fn is_valid_port_name(&self, name: GodotString) -> bool {
        unsafe { VisualShaderNodeGroupBase_is_valid_port_name(self.this, name) }
    }

    #[inline]
    pub fn remove_input_port(&mut self, id: i64) -> () {
        unsafe { VisualShaderNodeGroupBase_remove_input_port(self.this, id) }
    }

    #[inline]
    pub fn remove_output_port(&mut self, id: i64) -> () {
        unsafe { VisualShaderNodeGroupBase_remove_output_port(self.this, id) }
    }

    #[inline]
    pub fn set_input_port_name(&mut self, id: i64, name: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_set_input_port_name(self.this, id, name) }
    }

    #[inline]
    pub fn set_input_port_type(&mut self, id: i64, _type: i64) -> () {
        unsafe { VisualShaderNodeGroupBase_set_input_port_type(self.this, id, _type) }
    }

    #[inline]
    pub fn set_inputs(&mut self, inputs: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_set_inputs(self.this, inputs) }
    }

    #[inline]
    pub fn set_output_port_name(&mut self, id: i64, name: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_set_output_port_name(self.this, id, name) }
    }

    #[inline]
    pub fn set_output_port_type(&mut self, id: i64, _type: i64) -> () {
        unsafe { VisualShaderNodeGroupBase_set_output_port_type(self.this, id, _type) }
    }

    #[inline]
    pub fn set_outputs(&mut self, outputs: GodotString) -> () {
        unsafe { VisualShaderNodeGroupBase_set_outputs(self.this, outputs) }
    }

    #[inline]
    pub fn set_size(&mut self, size: Vector2) -> () {
        unsafe { VisualShaderNodeGroupBase_set_size(self.this, size) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeIf` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeif.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeIf inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeIf {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeIf {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeIfMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeIf {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeInput` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeinput.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeInput inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeInput {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeInput {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeInputMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeInput {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_input_name(&self) -> GodotString {
        unsafe { VisualShaderNodeInput_get_input_name(self.this) }
    }

    #[inline]
    pub fn get_input_real_name(&self) -> GodotString {
        unsafe { VisualShaderNodeInput_get_input_real_name(self.this) }
    }

    #[inline]
    pub fn set_input_name(&mut self, name: GodotString) -> () {
        unsafe { VisualShaderNodeInput_set_input_name(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeIs` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeis.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeIs inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeIs {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeIsFunction {
    FuncIsInf = 0,
    FuncIsNan = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeIs {
    pub const FUNC_IS_INF: i64 = 0;
    pub const FUNC_IS_NAN: i64 = 1;
}
impl VisualShaderNodeIs {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeIsMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeIs {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeIsFunction {
        unsafe { VisualShaderNodeIs_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeIs_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeOuterProduct` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeouterproduct.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeOuterProduct inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeOuterProduct {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeOuterProduct {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeOuterProductMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeOuterProduct {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeOutput` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeoutput.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeOutput inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeOutput {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeOutput {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarClamp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarclamp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarClamp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarClamp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarClamp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarClampMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarClamp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarConstant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarConstant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant(&self) -> f64 {
        unsafe { VisualShaderNodeScalarConstant_get_constant(self.this) }
    }

    #[inline]
    pub fn set_constant(&mut self, value: f64) -> () {
        unsafe { VisualShaderNodeScalarConstant_set_constant(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarDerivativeFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarderivativefunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarDerivativeFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarDerivativeFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeScalarDerivativeFuncFunction {
    FuncSum = 0,
    FuncX = 1,
    FuncY = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeScalarDerivativeFunc {
    pub const FUNC_Y: i64 = 2;
    pub const FUNC_SUM: i64 = 0;
    pub const FUNC_X: i64 = 1;
}
impl VisualShaderNodeScalarDerivativeFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarDerivativeFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarDerivativeFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeScalarDerivativeFuncFunction {
        unsafe { VisualShaderNodeScalarDerivativeFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeScalarDerivativeFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarfunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeScalarFuncFunction {
    FuncSin = 0,
    FuncCos = 1,
    FuncTan = 2,
    FuncAsin = 3,
    FuncAcos = 4,
    FuncAtan = 5,
    FuncSinh = 6,
    FuncCosh = 7,
    FuncTanh = 8,
    FuncLog = 9,
    FuncExp = 10,
    FuncSqrt = 11,
    FuncAbs = 12,
    FuncSign = 13,
    FuncFloor = 14,
    FuncRound = 15,
    FuncCeil = 16,
    FuncFrac = 17,
    FuncSaturate = 18,
    FuncNegate = 19,
    FuncAcosh = 20,
    FuncAsinh = 21,
    FuncAtanh = 22,
    FuncDegrees = 23,
    FuncExp2 = 24,
    FuncInverseSqrt = 25,
    FuncLog2 = 26,
    FuncRadians = 27,
    FuncReciprocal = 28,
    FuncRoundeven = 29,
    FuncTrunc = 30,
    FuncOneminus = 31,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeScalarFunc {
    pub const FUNC_NEGATE: i64 = 19;
    pub const FUNC_RADIANS: i64 = 27;
    pub const FUNC_TRUNC: i64 = 30;
    pub const FUNC_ACOSH: i64 = 20;
    pub const FUNC_ASIN: i64 = 3;
    pub const FUNC_CEIL: i64 = 16;
    pub const FUNC_COSH: i64 = 7;
    pub const FUNC_RECIPROCAL: i64 = 28;
    pub const FUNC_COS: i64 = 1;
    pub const FUNC_ONEMINUS: i64 = 31;
    pub const FUNC_EXP: i64 = 10;
    pub const FUNC_ACOS: i64 = 4;
    pub const FUNC_DEGREES: i64 = 23;
    pub const FUNC_TAN: i64 = 2;
    pub const FUNC_FRAC: i64 = 17;
    pub const FUNC_EXP2: i64 = 24;
    pub const FUNC_SQRT: i64 = 11;
    pub const FUNC_TANH: i64 = 8;
    pub const FUNC_SINH: i64 = 6;
    pub const FUNC_SATURATE: i64 = 18;
    pub const FUNC_ROUNDEVEN: i64 = 29;
    pub const FUNC_FLOOR: i64 = 14;
    pub const FUNC_LOG2: i64 = 26;
    pub const FUNC_LOG: i64 = 9;
    pub const FUNC_ATAN: i64 = 5;
    pub const FUNC_INVERSE_SQRT: i64 = 25;
    pub const FUNC_SIGN: i64 = 13;
    pub const FUNC_ASINH: i64 = 21;
    pub const FUNC_SIN: i64 = 0;
    pub const FUNC_ATANH: i64 = 22;
    pub const FUNC_ABS: i64 = 12;
    pub const FUNC_ROUND: i64 = 15;
}
impl VisualShaderNodeScalarFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeScalarFuncFunction {
        unsafe { VisualShaderNodeScalarFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeScalarFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarInterp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarinterp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarInterp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarInterp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarInterp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarInterpMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarInterp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarOp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarop.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarOp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarOp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeScalarOpOperator {
    OpAdd = 0,
    OpSub = 1,
    OpMul = 2,
    OpDiv = 3,
    OpMod = 4,
    OpPow = 5,
    OpMax = 6,
    OpMin = 7,
    OpAtan2 = 8,
    OpStep = 9,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeScalarOp {
    pub const OP_STEP: i64 = 9;
    pub const OP_MIN: i64 = 7;
    pub const OP_MOD: i64 = 4;
    pub const OP_ATAN2: i64 = 8;
    pub const OP_SUB: i64 = 1;
    pub const OP_MAX: i64 = 6;
    pub const OP_DIV: i64 = 3;
    pub const OP_POW: i64 = 5;
    pub const OP_MUL: i64 = 2;
    pub const OP_ADD: i64 = 0;
}
impl VisualShaderNodeScalarOp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarOpMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarOp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VisualShaderNodeScalarOpOperator {
        unsafe { VisualShaderNodeScalarOp_get_operator(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualShaderNodeScalarOp_set_operator(self.this, op) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarSmoothStep` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarsmoothstep.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarSmoothStep inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarSmoothStep {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarSmoothStep {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarSmoothStepMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarSmoothStep {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarSwitch` inherits `VisualShaderNodeSwitch` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalarswitch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarSwitch inherits methods from:
/// - [VisualShaderNodeSwitch](struct.VisualShaderNodeSwitch.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarSwitch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarSwitch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarSwitchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarSwitch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_switch(&self) -> VisualShaderNodeSwitch {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeSwitch { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeScalarUniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodescalaruniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeScalarUniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeScalarUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeScalarUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeScalarUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeScalarUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeSwitch` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeswitch.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeSwitch inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeSwitch {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeSwitch {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeSwitchMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeSwitch {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTexture` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetexture.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTexture inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTexture {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTextureTextureType {
    TypeData = 0,
    TypeColor = 1,
    TypeNormalmap = 2,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTextureSource {
    Texture = 0,
    Screen = 1,
    Source2dTexture = 2,
    Source2dNormal = 3,
    Depth = 4,
    Port = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeTexture {
    pub const SOURCE_TEXTURE: i64 = 0;
    pub const TYPE_COLOR: i64 = 1;
    pub const SOURCE_2D_NORMAL: i64 = 3;
    pub const SOURCE_PORT: i64 = 5;
    pub const SOURCE_DEPTH: i64 = 4;
    pub const SOURCE_SCREEN: i64 = 1;
    pub const TYPE_NORMALMAP: i64 = 2;
    pub const SOURCE_2D_TEXTURE: i64 = 2;
    pub const TYPE_DATA: i64 = 0;
}
impl VisualShaderNodeTexture {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTextureMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTexture {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_source(&self) -> VisualShaderNodeTextureSource {
        unsafe { VisualShaderNodeTexture_get_source(self.this) }
    }

    #[inline]
    pub fn get_texture(&self) -> Option<Texture> {
        unsafe { VisualShaderNodeTexture_get_texture(self.this) }
    }

    #[inline]
    pub fn get_texture_type(&self) -> VisualShaderNodeTextureTextureType {
        unsafe { VisualShaderNodeTexture_get_texture_type(self.this) }
    }

    #[inline]
    pub fn set_source(&mut self, value: i64) -> () {
        unsafe { VisualShaderNodeTexture_set_source(self.this, value) }
    }

    #[inline]
    pub fn set_texture(&mut self, value: Option<Texture>) -> () {
        unsafe { VisualShaderNodeTexture_set_texture(self.this, value) }
    }

    #[inline]
    pub fn set_texture_type(&mut self, value: i64) -> () {
        unsafe { VisualShaderNodeTexture_set_texture_type(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTextureUniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetextureuniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTextureUniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTextureUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTextureUniformTextureType {
    TypeData = 0,
    TypeColor = 1,
    TypeNormalmap = 2,
    TypeAniso = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTextureUniformColorDefault {
    White = 0,
    Black = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeTextureUniform {
    pub const COLOR_DEFAULT_WHITE: i64 = 0;
    pub const TYPE_ANISO: i64 = 3;
    pub const COLOR_DEFAULT_BLACK: i64 = 1;
    pub const TYPE_NORMALMAP: i64 = 2;
    pub const TYPE_DATA: i64 = 0;
    pub const TYPE_COLOR: i64 = 1;
}
impl VisualShaderNodeTextureUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTextureUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTextureUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_color_default(&self) -> VisualShaderNodeTextureUniformColorDefault {
        unsafe { VisualShaderNodeTextureUniform_get_color_default(self.this) }
    }

    #[inline]
    pub fn get_texture_type(&self) -> VisualShaderNodeTextureUniformTextureType {
        unsafe { VisualShaderNodeTextureUniform_get_texture_type(self.this) }
    }

    #[inline]
    pub fn set_color_default(&mut self, _type: i64) -> () {
        unsafe { VisualShaderNodeTextureUniform_set_color_default(self.this, _type) }
    }

    #[inline]
    pub fn set_texture_type(&mut self, _type: i64) -> () {
        unsafe { VisualShaderNodeTextureUniform_set_texture_type(self.this, _type) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTextureUniformTriplanar` inherits `VisualShaderNodeTextureUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetextureuniformtriplanar.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTextureUniformTriplanar inherits methods from:
/// - [VisualShaderNodeTextureUniform](struct.VisualShaderNodeTextureUniform.html)
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTextureUniformTriplanar {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeTextureUniformTriplanar {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTextureUniformTriplanarMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTextureUniformTriplanar {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_texture_uniform(&self) -> VisualShaderNodeTextureUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeTextureUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformCompose` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformcompose.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformCompose inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformCompose {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeTransformCompose {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformComposeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformCompose {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformConstant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformconstant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformConstant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformConstant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeTransformConstant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformConstant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant(&self) -> Transform {
        unsafe { VisualShaderNodeTransformConstant_get_constant(self.this) }
    }

    #[inline]
    pub fn set_constant(&mut self, value: Transform) -> () {
        unsafe { VisualShaderNodeTransformConstant_set_constant(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformDecompose` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformdecompose.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformDecompose inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformDecompose {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeTransformDecompose {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformDecomposeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformDecompose {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformfunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTransformFuncFunction {
    FuncInverse = 0,
    FuncTranspose = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeTransformFunc {
    pub const FUNC_INVERSE: i64 = 0;
    pub const FUNC_TRANSPOSE: i64 = 1;
}
impl VisualShaderNodeTransformFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeTransformFuncFunction {
        unsafe { VisualShaderNodeTransformFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeTransformFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformMult` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformmult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformMult inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformMult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTransformMultOperator {
    OpAxB = 0,
    OpBxA = 1,
    OpAxBComp = 2,
    OpBxAComp = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeTransformMult {
    pub const OP_AxB_COMP: i64 = 2;
    pub const OP_BxA: i64 = 1;
    pub const OP_BxA_COMP: i64 = 3;
    pub const OP_AxB: i64 = 0;
}
impl VisualShaderNodeTransformMult {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformMultMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformMult {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VisualShaderNodeTransformMultOperator {
        unsafe { VisualShaderNodeTransformMult_get_operator(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualShaderNodeTransformMult_set_operator(self.this, op) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformUniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformuniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformUniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeTransformUniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformUniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformUniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeTransformVecMult` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodetransformvecmult.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeTransformVecMult inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeTransformVecMult {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeTransformVecMultOperator {
    OpAxB = 0,
    OpBxA = 1,
    Op3x3AxB = 2,
    Op3x3BxA = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeTransformVecMult {
    pub const OP_3x3_AxB: i64 = 2;
    pub const OP_3x3_BxA: i64 = 3;
    pub const OP_AxB: i64 = 0;
    pub const OP_BxA: i64 = 1;
}
impl VisualShaderNodeTransformVecMult {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeTransformVecMultMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeTransformVecMult {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VisualShaderNodeTransformVecMultOperator {
        unsafe { VisualShaderNodeTransformVecMult_get_operator(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualShaderNodeTransformVecMult_set_operator(self.this, op) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeUniform` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodeuniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeUniform inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeUniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeUniform {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_uniform_name(&self) -> GodotString {
        unsafe { VisualShaderNodeUniform_get_uniform_name(self.this) }
    }

    #[inline]
    pub fn set_uniform_name(&mut self, name: GodotString) -> () {
        unsafe { VisualShaderNodeUniform_set_uniform_name(self.this, name) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVec3Constant` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevec3constant.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVec3Constant inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVec3Constant {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVec3Constant {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVec3ConstantMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVec3Constant {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_constant(&self) -> Vector3 {
        unsafe { VisualShaderNodeVec3Constant_get_constant(self.this) }
    }

    #[inline]
    pub fn set_constant(&mut self, value: Vector3) -> () {
        unsafe { VisualShaderNodeVec3Constant_set_constant(self.this, value) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVec3Uniform` inherits `VisualShaderNodeUniform` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevec3uniform.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVec3Uniform inherits methods from:
/// - [VisualShaderNodeUniform](struct.VisualShaderNodeUniform.html)
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVec3Uniform {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVec3Uniform {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVec3UniformMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVec3Uniform {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node_uniform(&self) -> VisualShaderNodeUniform {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNodeUniform { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorClamp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorclamp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorClamp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorClamp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorClamp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorClampMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorClamp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorCompose` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorcompose.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorCompose inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorCompose {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorCompose {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorComposeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorCompose {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorDecompose` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectordecompose.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorDecompose inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorDecompose {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorDecompose {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorDecomposeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorDecompose {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorDerivativeFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorderivativefunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorDerivativeFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorDerivativeFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeVectorDerivativeFuncFunction {
    FuncSum = 0,
    FuncX = 1,
    FuncY = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeVectorDerivativeFunc {
    pub const FUNC_SUM: i64 = 0;
    pub const FUNC_X: i64 = 1;
    pub const FUNC_Y: i64 = 2;
}
impl VisualShaderNodeVectorDerivativeFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorDerivativeFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorDerivativeFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeVectorDerivativeFuncFunction {
        unsafe { VisualShaderNodeVectorDerivativeFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeVectorDerivativeFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorDistance` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectordistance.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorDistance inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorDistance {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorDistance {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorDistanceMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorDistance {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorFunc` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorfunc.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorFunc inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorFunc {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeVectorFuncFunction {
    FuncNormalize = 0,
    FuncSaturate = 1,
    FuncNegate = 2,
    FuncReciprocal = 3,
    FuncRgb2hsv = 4,
    FuncHsv2rgb = 5,
    FuncAbs = 6,
    FuncAcos = 7,
    FuncAcosh = 8,
    FuncAsin = 9,
    FuncAsinh = 10,
    FuncAtan = 11,
    FuncAtanh = 12,
    FuncCeil = 13,
    FuncCos = 14,
    FuncCosh = 15,
    FuncDegrees = 16,
    FuncExp = 17,
    FuncExp2 = 18,
    FuncFloor = 19,
    FuncFrac = 20,
    FuncInverseSqrt = 21,
    FuncLog = 22,
    FuncLog2 = 23,
    FuncRadians = 24,
    FuncRound = 25,
    FuncRoundeven = 26,
    FuncSign = 27,
    FuncSin = 28,
    FuncSinh = 29,
    FuncSqrt = 30,
    FuncTan = 31,
    FuncTanh = 32,
    FuncTrunc = 33,
    FuncOneminus = 34,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeVectorFunc {
    pub const FUNC_NEGATE: i64 = 2;
    pub const FUNC_ONEMINUS: i64 = 34;
    pub const FUNC_SINH: i64 = 29;
    pub const FUNC_TRUNC: i64 = 33;
    pub const FUNC_FLOOR: i64 = 19;
    pub const FUNC_COS: i64 = 14;
    pub const FUNC_NORMALIZE: i64 = 0;
    pub const FUNC_LOG: i64 = 22;
    pub const FUNC_RGB2HSV: i64 = 4;
    pub const FUNC_ROUND: i64 = 25;
    pub const FUNC_EXP: i64 = 17;
    pub const FUNC_DEGREES: i64 = 16;
    pub const FUNC_COSH: i64 = 15;
    pub const FUNC_FRAC: i64 = 20;
    pub const FUNC_SIN: i64 = 28;
    pub const FUNC_ASINH: i64 = 10;
    pub const FUNC_SATURATE: i64 = 1;
    pub const FUNC_SQRT: i64 = 30;
    pub const FUNC_TANH: i64 = 32;
    pub const FUNC_ACOS: i64 = 7;
    pub const FUNC_INVERSE_SQRT: i64 = 21;
    pub const FUNC_ATANH: i64 = 12;
    pub const FUNC_HSV2RGB: i64 = 5;
    pub const FUNC_TAN: i64 = 31;
    pub const FUNC_ATAN: i64 = 11;
    pub const FUNC_EXP2: i64 = 18;
    pub const FUNC_ASIN: i64 = 9;
    pub const FUNC_ROUNDEVEN: i64 = 26;
    pub const FUNC_ABS: i64 = 6;
    pub const FUNC_SIGN: i64 = 27;
    pub const FUNC_CEIL: i64 = 13;
    pub const FUNC_RECIPROCAL: i64 = 3;
    pub const FUNC_LOG2: i64 = 23;
    pub const FUNC_ACOSH: i64 = 8;
    pub const FUNC_RADIANS: i64 = 24;
}
impl VisualShaderNodeVectorFunc {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorFuncMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorFunc {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_function(&self) -> VisualShaderNodeVectorFuncFunction {
        unsafe { VisualShaderNodeVectorFunc_get_function(self.this) }
    }

    #[inline]
    pub fn set_function(&mut self, func: i64) -> () {
        unsafe { VisualShaderNodeVectorFunc_set_function(self.this, func) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorInterp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorinterp.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorInterp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorInterp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorInterp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorInterpMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorInterp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorLen` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorlen.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorLen inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorLen {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorLen {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorLenMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorLen {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorOp` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorop.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorOp inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorOp {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VisualShaderNodeVectorOpOperator {
    OpAdd = 0,
    OpSub = 1,
    OpMul = 2,
    OpDiv = 3,
    OpMod = 4,
    OpPow = 5,
    OpMax = 6,
    OpMin = 7,
    OpCross = 8,
    OpAtan2 = 9,
    OpReflect = 10,
    OpStep = 11,
}
/// Constants
#[allow(non_upper_case_globals)]
impl VisualShaderNodeVectorOp {
    pub const OP_STEP: i64 = 11;
    pub const OP_MUL: i64 = 2;
    pub const OP_POW: i64 = 5;
    pub const OP_SUB: i64 = 1;
    pub const OP_MIN: i64 = 7;
    pub const OP_MOD: i64 = 4;
    pub const OP_ADD: i64 = 0;
    pub const OP_ATAN2: i64 = 9;
    pub const OP_DIV: i64 = 3;
    pub const OP_MAX: i64 = 6;
    pub const OP_CROSS: i64 = 8;
    pub const OP_REFLECT: i64 = 10;
}
impl VisualShaderNodeVectorOp {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorOpMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorOp {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_operator(&self) -> VisualShaderNodeVectorOpOperator {
        unsafe { VisualShaderNodeVectorOp_get_operator(self.this) }
    }

    #[inline]
    pub fn set_operator(&mut self, op: i64) -> () {
        unsafe { VisualShaderNodeVectorOp_set_operator(self.this, op) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorRefract` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorrefract.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorRefract inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorRefract {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorRefract {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorRefractMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorRefract {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorScalarMix` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorscalarmix.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorScalarMix inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorScalarMix {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorScalarMix {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorScalarMixMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorScalarMix {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorScalarSmoothStep` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorscalarsmoothstep.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorScalarSmoothStep inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorScalarSmoothStep {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorScalarSmoothStep {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorScalarSmoothStepMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorScalarSmoothStep {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorScalarStep` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorscalarstep.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorScalarStep inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorScalarStep {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorScalarStep {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorScalarStepMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorScalarStep {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class VisualShaderNodeVectorSmoothStep` inherits `VisualShaderNode` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualshadernodevectorsmoothstep.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// VisualShaderNodeVectorSmoothStep inherits methods from:
/// - [VisualShaderNode](struct.VisualShaderNode.html)
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualShaderNodeVectorSmoothStep {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualShaderNodeVectorSmoothStep {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = VisualShaderNodeVectorSmoothStepMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            VisualShaderNodeVectorSmoothStep {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_visual_shader_node(&self) -> VisualShaderNode {
        unsafe {{ object::add_ref(self.this); }}
        VisualShaderNode { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WeakRef` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_weakref.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WeakRef inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WeakRef {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WeakRef {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WeakRefMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WeakRef {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_ref(&self) -> Variant {
        unsafe { WeakRef_get_ref(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebRTCDataChannel` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_webrtcdatachannel.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebRTCDataChannel inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebRTCDataChannel {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum WebRTCDataChannelWriteMode {
    ModeText = 0,
    ModeBinary = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum WebRTCDataChannelChannelState {
    StateConnecting = 0,
    StateOpen = 1,
    StateClosing = 2,
    StateClosed = 3,
}
/// Constants
#[allow(non_upper_case_globals)]
impl WebRTCDataChannel {
    pub const STATE_CLOSING: i64 = 2;
    pub const STATE_CLOSED: i64 = 3;
    pub const STATE_OPEN: i64 = 1;
    pub const WRITE_MODE_BINARY: i64 = 1;
    pub const STATE_CONNECTING: i64 = 0;
    pub const WRITE_MODE_TEXT: i64 = 0;
}
impl WebRTCDataChannel {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { WebRTCDataChannel_close(self.this) }
    }

    #[inline]
    pub fn get_id(&self) -> i64 {
        unsafe { WebRTCDataChannel_get_id(self.this) }
    }

    #[inline]
    pub fn get_label(&self) -> GodotString {
        unsafe { WebRTCDataChannel_get_label(self.this) }
    }

    #[inline]
    pub fn get_max_packet_life_time(&self) -> i64 {
        unsafe { WebRTCDataChannel_get_max_packet_life_time(self.this) }
    }

    #[inline]
    pub fn get_max_retransmits(&self) -> i64 {
        unsafe { WebRTCDataChannel_get_max_retransmits(self.this) }
    }

    #[inline]
    pub fn get_protocol(&self) -> GodotString {
        unsafe { WebRTCDataChannel_get_protocol(self.this) }
    }

    #[inline]
    pub fn get_ready_state(&self) -> WebRTCDataChannelChannelState {
        unsafe { WebRTCDataChannel_get_ready_state(self.this) }
    }

    #[inline]
    pub fn get_write_mode(&self) -> WebRTCDataChannelWriteMode {
        unsafe { WebRTCDataChannel_get_write_mode(self.this) }
    }

    #[inline]
    pub fn is_negotiated(&self) -> bool {
        unsafe { WebRTCDataChannel_is_negotiated(self.this) }
    }

    #[inline]
    pub fn is_ordered(&self) -> bool {
        unsafe { WebRTCDataChannel_is_ordered(self.this) }
    }

    #[inline]
    pub fn poll(&mut self) -> GodotResult {
        unsafe { WebRTCDataChannel_poll(self.this) }
    }

    #[inline]
    pub fn set_write_mode(&mut self, write_mode: i64) -> () {
        unsafe { WebRTCDataChannel_set_write_mode(self.this, write_mode) }
    }

    #[inline]
    pub fn was_string_packet(&self) -> bool {
        unsafe { WebRTCDataChannel_was_string_packet(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebRTCDataChannelGDNative` inherits `WebRTCDataChannel` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_webrtcdatachannelgdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebRTCDataChannelGDNative inherits methods from:
/// - [WebRTCDataChannel](struct.WebRTCDataChannel.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebRTCDataChannelGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebRTCDataChannelGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebRTCDataChannelGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebRTCDataChannelGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_web_rtc_data_channel(&self) -> WebRTCDataChannel {
        unsafe {{ object::add_ref(self.this); }}
        WebRTCDataChannel { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebRTCMultiplayer` inherits `NetworkedMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_webrtcmultiplayer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebRTCMultiplayer inherits methods from:
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebRTCMultiplayer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebRTCMultiplayer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebRTCMultiplayerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebRTCMultiplayer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_peer(&mut self, peer: Option<WebRTCPeerConnection>, peer_id: i64, unreliable_lifetime: i64) -> GodotResult {
        unsafe { WebRTCMultiplayer_add_peer(self.this, peer, peer_id, unreliable_lifetime) }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { WebRTCMultiplayer_close(self.this) }
    }

    #[inline]
    pub fn get_peer(&mut self, peer_id: i64) -> Dictionary {
        unsafe { WebRTCMultiplayer_get_peer(self.this, peer_id) }
    }

    #[inline]
    pub fn get_peers(&mut self) -> Dictionary {
        unsafe { WebRTCMultiplayer_get_peers(self.this) }
    }

    #[inline]
    pub fn has_peer(&mut self, peer_id: i64) -> bool {
        unsafe { WebRTCMultiplayer_has_peer(self.this, peer_id) }
    }

    #[inline]
    pub fn initialize(&mut self, peer_id: i64, server_compatibility: bool) -> GodotResult {
        unsafe { WebRTCMultiplayer_initialize(self.this, peer_id, server_compatibility) }
    }

    #[inline]
    pub fn remove_peer(&mut self, peer_id: i64) -> () {
        unsafe { WebRTCMultiplayer_remove_peer(self.this, peer_id) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebRTCPeerConnection` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_webrtcpeerconnection.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebRTCPeerConnection inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebRTCPeerConnection {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum WebRTCPeerConnectionConnectionState {
    StateNew = 0,
    StateConnecting = 1,
    StateConnected = 2,
    StateDisconnected = 3,
    StateFailed = 4,
    StateClosed = 5,
}
/// Constants
#[allow(non_upper_case_globals)]
impl WebRTCPeerConnection {
    pub const STATE_CONNECTING: i64 = 1;
    pub const STATE_DISCONNECTED: i64 = 3;
    pub const STATE_NEW: i64 = 0;
    pub const STATE_FAILED: i64 = 4;
    pub const STATE_CLOSED: i64 = 5;
    pub const STATE_CONNECTED: i64 = 2;
}
impl WebRTCPeerConnection {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebRTCPeerConnectionMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebRTCPeerConnection {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn add_ice_candidate(&mut self, media: GodotString, index: i64, name: GodotString) -> GodotResult {
        unsafe { WebRTCPeerConnection_add_ice_candidate(self.this, media, index, name) }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { WebRTCPeerConnection_close(self.this) }
    }

    #[inline]
    pub fn create_data_channel(&mut self, label: GodotString, options: Dictionary) -> Option<WebRTCDataChannel> {
        unsafe { WebRTCPeerConnection_create_data_channel(self.this, label, options) }
    }

    #[inline]
    pub fn create_offer(&mut self) -> GodotResult {
        unsafe { WebRTCPeerConnection_create_offer(self.this) }
    }

    #[inline]
    pub fn get_connection_state(&self) -> WebRTCPeerConnectionConnectionState {
        unsafe { WebRTCPeerConnection_get_connection_state(self.this) }
    }

    #[inline]
    pub fn initialize(&mut self, configuration: Dictionary) -> GodotResult {
        unsafe { WebRTCPeerConnection_initialize(self.this, configuration) }
    }

    #[inline]
    pub fn poll(&mut self) -> GodotResult {
        unsafe { WebRTCPeerConnection_poll(self.this) }
    }

    #[inline]
    pub fn set_local_description(&mut self, _type: GodotString, sdp: GodotString) -> GodotResult {
        unsafe { WebRTCPeerConnection_set_local_description(self.this, _type, sdp) }
    }

    #[inline]
    pub fn set_remote_description(&mut self, _type: GodotString, sdp: GodotString) -> GodotResult {
        unsafe { WebRTCPeerConnection_set_remote_description(self.this, _type, sdp) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebRTCPeerConnectionGDNative` inherits `WebRTCPeerConnection` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_webrtcpeerconnectiongdnative.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebRTCPeerConnectionGDNative inherits methods from:
/// - [WebRTCPeerConnection](struct.WebRTCPeerConnection.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebRTCPeerConnectionGDNative {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebRTCPeerConnectionGDNative {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebRTCPeerConnectionGDNativeMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebRTCPeerConnectionGDNative {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    /// Up-cast.
    #[inline]
    pub fn to_web_rtc_peer_connection(&self) -> WebRTCPeerConnection {
        unsafe {{ object::add_ref(self.this); }}
        WebRTCPeerConnection { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebSocketClient` inherits `WebSocketMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_websocketclient.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebSocketClient inherits methods from:
/// - [WebSocketMultiplayerPeer](struct.WebSocketMultiplayerPeer.html)
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebSocketClient {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebSocketClient {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebSocketClientMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebSocketClient {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn connect_to_url(&mut self, url: GodotString, protocols: StringArray, gd_mp_api: bool, custom_headers: StringArray) -> GodotResult {
        unsafe { WebSocketClient_connect_to_url(self.this, url, protocols, gd_mp_api, custom_headers) }
    }

    #[inline]
    pub fn disconnect_from_host(&mut self, code: i64, reason: GodotString) -> () {
        unsafe { WebSocketClient_disconnect_from_host(self.this, code, reason) }
    }

    #[inline]
    pub fn get_connected_host(&self) -> GodotString {
        unsafe { WebSocketClient_get_connected_host(self.this) }
    }

    #[inline]
    pub fn get_connected_port(&self) -> i64 {
        unsafe { WebSocketClient_get_connected_port(self.this) }
    }

    #[inline]
    pub fn get_trusted_ssl_certificate(&self) -> Option<X509Certificate> {
        unsafe { WebSocketClient_get_trusted_ssl_certificate(self.this) }
    }

    #[inline]
    pub fn is_verify_ssl_enabled(&self) -> bool {
        unsafe { WebSocketClient_is_verify_ssl_enabled(self.this) }
    }

    #[inline]
    pub fn set_trusted_ssl_certificate(&mut self, arg0: Option<X509Certificate>) -> () {
        unsafe { WebSocketClient_set_trusted_ssl_certificate(self.this, arg0) }
    }

    #[inline]
    pub fn set_verify_ssl_enabled(&mut self, enabled: bool) -> () {
        unsafe { WebSocketClient_set_verify_ssl_enabled(self.this, enabled) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_web_socket_multiplayer_peer(&self) -> WebSocketMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        WebSocketMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebSocketMultiplayerPeer` inherits `NetworkedMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_websocketmultiplayerpeer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebSocketMultiplayerPeer inherits methods from:
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebSocketMultiplayerPeer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebSocketMultiplayerPeer {

    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_peer(&self, peer_id: i64) -> Option<WebSocketPeer> {
        unsafe { WebSocketMultiplayerPeer_get_peer(self.this, peer_id) }
    }

    #[inline]
    pub fn set_buffers(&mut self, input_buffer_size_kb: i64, input_max_packets: i64, output_buffer_size_kb: i64, output_max_packets: i64) -> GodotResult {
        unsafe { WebSocketMultiplayerPeer_set_buffers(self.this, input_buffer_size_kb, input_max_packets, output_buffer_size_kb, output_max_packets) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebSocketPeer` inherits `PacketPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_websocketpeer.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebSocketPeer inherits methods from:
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebSocketPeer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum WebSocketPeerWriteMode {
    ModeText = 0,
    ModeBinary = 1,
}
/// Constants
#[allow(non_upper_case_globals)]
impl WebSocketPeer {
    pub const WRITE_MODE_BINARY: i64 = 1;
    pub const WRITE_MODE_TEXT: i64 = 0;
}
impl WebSocketPeer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebSocketPeerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebSocketPeer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close(&mut self, code: i64, reason: GodotString) -> () {
        unsafe { WebSocketPeer_close(self.this, code, reason) }
    }

    #[inline]
    pub fn get_connected_host(&self) -> GodotString {
        unsafe { WebSocketPeer_get_connected_host(self.this) }
    }

    #[inline]
    pub fn get_connected_port(&self) -> i64 {
        unsafe { WebSocketPeer_get_connected_port(self.this) }
    }

    #[inline]
    pub fn get_write_mode(&self) -> WebSocketPeerWriteMode {
        unsafe { WebSocketPeer_get_write_mode(self.this) }
    }

    #[inline]
    pub fn is_connected_to_host(&self) -> bool {
        unsafe { WebSocketPeer_is_connected_to_host(self.this) }
    }

    #[inline]
    pub fn set_no_delay(&mut self, enabled: bool) -> () {
        unsafe { WebSocketPeer_set_no_delay(self.this, enabled) }
    }

    #[inline]
    pub fn set_write_mode(&mut self, mode: i64) -> () {
        unsafe { WebSocketPeer_set_write_mode(self.this, mode) }
    }

    #[inline]
    pub fn was_string_packet(&self) -> bool {
        unsafe { WebSocketPeer_was_string_packet(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WebSocketServer` inherits `WebSocketMultiplayerPeer` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_websocketserver.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// WebSocketServer inherits methods from:
/// - [WebSocketMultiplayerPeer](struct.WebSocketMultiplayerPeer.html)
/// - [NetworkedMultiplayerPeer](struct.NetworkedMultiplayerPeer.html)
/// - [PacketPeer](struct.PacketPeer.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WebSocketServer {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WebSocketServer {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WebSocketServerMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            WebSocketServer {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn disconnect_peer(&mut self, id: i64, code: i64, reason: GodotString) -> () {
        unsafe { WebSocketServer_disconnect_peer(self.this, id, code, reason) }
    }

    #[inline]
    pub fn get_bind_ip(&self) -> GodotString {
        unsafe { WebSocketServer_get_bind_ip(self.this) }
    }

    #[inline]
    pub fn get_ca_chain(&self) -> Option<X509Certificate> {
        unsafe { WebSocketServer_get_ca_chain(self.this) }
    }

    #[inline]
    pub fn get_peer_address(&self, id: i64) -> GodotString {
        unsafe { WebSocketServer_get_peer_address(self.this, id) }
    }

    #[inline]
    pub fn get_peer_port(&self, id: i64) -> i64 {
        unsafe { WebSocketServer_get_peer_port(self.this, id) }
    }

    #[inline]
    pub fn get_private_key(&self) -> Option<CryptoKey> {
        unsafe { WebSocketServer_get_private_key(self.this) }
    }

    #[inline]
    pub fn get_ssl_certificate(&self) -> Option<X509Certificate> {
        unsafe { WebSocketServer_get_ssl_certificate(self.this) }
    }

    #[inline]
    pub fn has_peer(&self, id: i64) -> bool {
        unsafe { WebSocketServer_has_peer(self.this, id) }
    }

    #[inline]
    pub fn is_listening(&self) -> bool {
        unsafe { WebSocketServer_is_listening(self.this) }
    }

    #[inline]
    pub fn listen(&mut self, port: i64, protocols: StringArray, gd_mp_api: bool) -> GodotResult {
        unsafe { WebSocketServer_listen(self.this, port, protocols, gd_mp_api) }
    }

    #[inline]
    pub fn set_bind_ip(&mut self, arg0: GodotString) -> () {
        unsafe { WebSocketServer_set_bind_ip(self.this, arg0) }
    }

    #[inline]
    pub fn set_ca_chain(&mut self, arg0: Option<X509Certificate>) -> () {
        unsafe { WebSocketServer_set_ca_chain(self.this, arg0) }
    }

    #[inline]
    pub fn set_private_key(&mut self, arg0: Option<CryptoKey>) -> () {
        unsafe { WebSocketServer_set_private_key(self.this, arg0) }
    }

    #[inline]
    pub fn set_ssl_certificate(&mut self, arg0: Option<X509Certificate>) -> () {
        unsafe { WebSocketServer_set_ssl_certificate(self.this, arg0) }
    }

    #[inline]
    pub fn stop(&mut self) -> () {
        unsafe { WebSocketServer_stop(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_web_socket_multiplayer_peer(&self) -> WebSocketMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        WebSocketMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_networked_multiplayer_peer(&self) -> NetworkedMultiplayerPeer {
        unsafe {{ object::add_ref(self.this); }}
        NetworkedMultiplayerPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_packet_peer(&self) -> PacketPeer {
        unsafe {{ object::add_ref(self.this); }}
        PacketPeer { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WindowDialog` inherits `Popup` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_windowdialog.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `WindowDialog` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `WindowDialog::free`.
///
/// ## Class hierarchy
///
/// WindowDialog inherits methods from:
/// - [Popup](struct.Popup.html)
/// - [Control](struct.Control.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WindowDialog {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WindowDialog {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `WindowDialog::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WindowDialogMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            WindowDialog {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn _closed(&mut self) -> () {
        WindowDialog__closed(self.this)
    }

    #[inline]
    pub unsafe fn _gui_input(&mut self, arg0: Option<InputEvent>) -> () {
        WindowDialog__gui_input(self.this, arg0)
    }

    #[inline]
    pub unsafe fn get_close_button(&mut self) -> Option<TextureButton> {
        WindowDialog_get_close_button(self.this)
    }

    #[inline]
    pub unsafe fn get_resizable(&self) -> bool {
        WindowDialog_get_resizable(self.this)
    }

    #[inline]
    pub unsafe fn get_title(&self) -> GodotString {
        WindowDialog_get_title(self.this)
    }

    #[inline]
    pub unsafe fn set_resizable(&mut self, resizable: bool) -> () {
        WindowDialog_set_resizable(self.this, resizable)
    }

    #[inline]
    pub unsafe fn set_title(&mut self, title: GodotString) -> () {
        WindowDialog_set_title(self.this, title)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_popup(&self) -> Popup {
        // Not reference-counted.
        Popup { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_control(&self) -> Control {
        // Not reference-counted.
        Control { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class World` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_world.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// World inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct World {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl World {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WorldMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            World {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_direct_space_state(&mut self) -> Option<PhysicsDirectSpaceState> {
        unsafe { World_get_direct_space_state(self.this) }
    }

    #[inline]
    pub fn get_environment(&self) -> Option<Environment> {
        unsafe { World_get_environment(self.this) }
    }

    #[inline]
    pub fn get_fallback_environment(&self) -> Option<Environment> {
        unsafe { World_get_fallback_environment(self.this) }
    }

    #[inline]
    pub fn get_scenario(&self) -> Rid {
        unsafe { World_get_scenario(self.this) }
    }

    #[inline]
    pub fn get_space(&self) -> Rid {
        unsafe { World_get_space(self.this) }
    }

    #[inline]
    pub fn set_environment(&mut self, env: Option<Environment>) -> () {
        unsafe { World_set_environment(self.this, env) }
    }

    #[inline]
    pub fn set_fallback_environment(&mut self, env: Option<Environment>) -> () {
        unsafe { World_set_fallback_environment(self.this, env) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class World2D` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_world2d.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// World2D inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct World2D {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl World2D {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = World2DMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            World2D {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_canvas(&mut self) -> Rid {
        unsafe { World2D_get_canvas(self.this) }
    }

    #[inline]
    pub fn get_direct_space_state(&mut self) -> Option<Physics2DDirectSpaceState> {
        unsafe { World2D_get_direct_space_state(self.this) }
    }

    #[inline]
    pub fn get_space(&mut self) -> Rid {
        unsafe { World2D_get_space(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class WorldEnvironment` inherits `Node` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_worldenvironment.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `WorldEnvironment` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `WorldEnvironment::free`.
///
/// ## Class hierarchy
///
/// WorldEnvironment inherits methods from:
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct WorldEnvironment {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl WorldEnvironment {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `WorldEnvironment::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = WorldEnvironmentMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            WorldEnvironment {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn get_environment(&self) -> Option<Environment> {
        WorldEnvironment_get_environment(self.this)
    }

    #[inline]
    pub unsafe fn set_environment(&mut self, env: Option<Environment>) -> () {
        WorldEnvironment_set_environment(self.this, env)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class X509Certificate` inherits `Resource` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_x509certificate.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// X509Certificate inherits methods from:
/// - [Resource](struct.Resource.html)
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct X509Certificate {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl X509Certificate {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = X509CertificateMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            X509Certificate {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString) -> GodotResult {
        unsafe { X509Certificate_load(self.this, path) }
    }

    #[inline]
    pub fn save(&mut self, path: GodotString) -> GodotResult {
        unsafe { X509Certificate_save(self.this, path) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_resource(&self) -> Resource {
        unsafe {{ object::add_ref(self.this); }}
        Resource { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class XMLParser` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_xmlparser.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// XMLParser inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct XMLParser {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum XMLParserNodeType {
    NodeNone = 0,
    NodeElement = 1,
    NodeElementEnd = 2,
    NodeText = 3,
    NodeComment = 4,
    NodeCdata = 5,
    NodeUnknown = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl XMLParser {
    pub const NODE_CDATA: i64 = 5;
    pub const NODE_TEXT: i64 = 3;
    pub const NODE_UNKNOWN: i64 = 6;
    pub const NODE_ELEMENT_END: i64 = 2;
    pub const NODE_NONE: i64 = 0;
    pub const NODE_ELEMENT: i64 = 1;
    pub const NODE_COMMENT: i64 = 4;
}
impl XMLParser {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = XMLParserMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            XMLParser {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_attribute_count(&self) -> i64 {
        unsafe { XMLParser_get_attribute_count(self.this) }
    }

    #[inline]
    pub fn get_attribute_name(&self, idx: i64) -> GodotString {
        unsafe { XMLParser_get_attribute_name(self.this, idx) }
    }

    #[inline]
    pub fn get_attribute_value(&self, idx: i64) -> GodotString {
        unsafe { XMLParser_get_attribute_value(self.this, idx) }
    }

    #[inline]
    pub fn get_current_line(&self) -> i64 {
        unsafe { XMLParser_get_current_line(self.this) }
    }

    #[inline]
    pub fn get_named_attribute_value(&self, name: GodotString) -> GodotString {
        unsafe { XMLParser_get_named_attribute_value(self.this, name) }
    }

    #[inline]
    pub fn get_named_attribute_value_safe(&self, name: GodotString) -> GodotString {
        unsafe { XMLParser_get_named_attribute_value_safe(self.this, name) }
    }

    #[inline]
    pub fn get_node_data(&self) -> GodotString {
        unsafe { XMLParser_get_node_data(self.this) }
    }

    #[inline]
    pub fn get_node_name(&self) -> GodotString {
        unsafe { XMLParser_get_node_name(self.this) }
    }

    #[inline]
    pub fn get_node_offset(&self) -> i64 {
        unsafe { XMLParser_get_node_offset(self.this) }
    }

    #[inline]
    pub fn get_node_type(&mut self) -> XMLParserNodeType {
        unsafe { XMLParser_get_node_type(self.this) }
    }

    #[inline]
    pub fn has_attribute(&self, name: GodotString) -> bool {
        unsafe { XMLParser_has_attribute(self.this, name) }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        unsafe { XMLParser_is_empty(self.this) }
    }

    #[inline]
    pub fn open(&mut self, file: GodotString) -> GodotResult {
        unsafe { XMLParser_open(self.this, file) }
    }

    #[inline]
    pub fn open_buffer(&mut self, buffer: ByteArray) -> GodotResult {
        unsafe { XMLParser_open_buffer(self.this, buffer) }
    }

    #[inline]
    pub fn read(&mut self) -> GodotResult {
        unsafe { XMLParser_read(self.this) }
    }

    #[inline]
    pub fn seek(&mut self, position: i64) -> GodotResult {
        unsafe { XMLParser_seek(self.this, position) }
    }

    #[inline]
    pub fn skip_section(&mut self) -> () {
        unsafe { XMLParser_skip_section(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class YSort` inherits `Node2D` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_ysort.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// Non reference counted objects such as the ones of this type are usually owned by the engine.
///
/// `YSort` is an unsafe pointer, and all of its methods are unsafe.
///
/// In the cases where Rust code owns an object of this type, for example if the object was just
/// created on the Rust side and not passed to the engine yet, ownership should be either given
/// to the engine or the object must be manually destroyed using `YSort::free`.
///
/// ## Class hierarchy
///
/// YSort inherits methods from:
/// - [Node2D](struct.Node2D.html)
/// - [CanvasItem](struct.CanvasItem.html)
/// - [Node](struct.Node.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct YSort {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl YSort {

    /// Constructor.
    ///
    /// Because this type is not reference counted, the lifetime of the returned object
    /// is *not* automatically managed.
    /// Immediately after creation, the object is owned by the caller, and can be
    /// passed to the engine (in which case the engine will be responsible for
    /// destroying the object) or destroyed manually using `YSort::free`.
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = YSortMethodTable::get(gd_api).class_constructor.unwrap();
            let this = ctor();

            YSort {
                this
            }
        }
    }

    /// Manually deallocate the object.
    #[inline]
    pub unsafe fn free(self) {
        (get_api().godot_object_destroy)(self.this);
    }
    #[inline]
    pub unsafe fn is_sort_enabled(&self) -> bool {
        YSort_is_sort_enabled(self.this)
    }

    #[inline]
    pub unsafe fn set_sort_enabled(&mut self, enabled: bool) -> () {
        YSort_set_sort_enabled(self.this, enabled)
    }


    /// Up-cast.
    #[inline]
    pub unsafe fn to_node_2d(&self) -> Node2D {
        // Not reference-counted.
        Node2D { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_canvas_item(&self) -> CanvasItem {
        // Not reference-counted.
        CanvasItem { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_node(&self) -> Node {
        // Not reference-counted.
        Node { this: self.this }
    }

    /// Up-cast.
    #[inline]
    pub unsafe fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub unsafe fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class ClassDB` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_classdb.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ClassDB inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ClassDB {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ClassDB {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"ClassDB\0".as_ptr() as *mut _);

            ClassDB {
                this
            }
        }
    }
    #[inline]
    pub fn can_instance(&self, class: GodotString) -> bool {
        unsafe { ClassDB_can_instance(self.this, class) }
    }

    #[inline]
    pub fn class_exists(&self, class: GodotString) -> bool {
        unsafe { ClassDB_class_exists(self.this, class) }
    }

    #[inline]
    pub fn class_get_category(&self, class: GodotString) -> GodotString {
        unsafe { ClassDB_class_get_category(self.this, class) }
    }

    #[inline]
    pub fn class_get_integer_constant(&self, class: GodotString, name: GodotString) -> i64 {
        unsafe { ClassDB_class_get_integer_constant(self.this, class, name) }
    }

    #[inline]
    pub fn class_get_integer_constant_list(&self, class: GodotString, no_inheritance: bool) -> StringArray {
        unsafe { ClassDB_class_get_integer_constant_list(self.this, class, no_inheritance) }
    }

    #[inline]
    pub fn class_get_method_list(&self, class: GodotString, no_inheritance: bool) -> VariantArray {
        unsafe { ClassDB_class_get_method_list(self.this, class, no_inheritance) }
    }

    #[inline]
    pub fn class_get_property(&self, object: Option<Object>, property: GodotString) -> Variant {
        unsafe { ClassDB_class_get_property(self.this, object, property) }
    }

    #[inline]
    pub fn class_get_property_list(&self, class: GodotString, no_inheritance: bool) -> VariantArray {
        unsafe { ClassDB_class_get_property_list(self.this, class, no_inheritance) }
    }

    #[inline]
    pub fn class_get_signal(&self, class: GodotString, signal: GodotString) -> Dictionary {
        unsafe { ClassDB_class_get_signal(self.this, class, signal) }
    }

    #[inline]
    pub fn class_get_signal_list(&self, class: GodotString, no_inheritance: bool) -> VariantArray {
        unsafe { ClassDB_class_get_signal_list(self.this, class, no_inheritance) }
    }

    #[inline]
    pub fn class_has_integer_constant(&self, class: GodotString, name: GodotString) -> bool {
        unsafe { ClassDB_class_has_integer_constant(self.this, class, name) }
    }

    #[inline]
    pub fn class_has_method(&self, class: GodotString, method: GodotString, no_inheritance: bool) -> bool {
        unsafe { ClassDB_class_has_method(self.this, class, method, no_inheritance) }
    }

    #[inline]
    pub fn class_has_signal(&self, class: GodotString, signal: GodotString) -> bool {
        unsafe { ClassDB_class_has_signal(self.this, class, signal) }
    }

    #[inline]
    pub fn class_set_property(&self, object: Option<Object>, property: GodotString, value: Variant) -> GodotResult {
        unsafe { ClassDB_class_set_property(self.this, object, property, value) }
    }

    #[inline]
    pub fn get_class_list(&self) -> StringArray {
        unsafe { ClassDB_get_class_list(self.this) }
    }

    #[inline]
    pub fn get_inheriters_from_class(&self, class: GodotString) -> StringArray {
        unsafe { ClassDB_get_inheriters_from_class(self.this, class) }
    }

    #[inline]
    pub fn get_parent_class(&self, class: GodotString) -> GodotString {
        unsafe { ClassDB_get_parent_class(self.this, class) }
    }

    #[inline]
    pub fn instance(&self, class: GodotString) -> Variant {
        unsafe { ClassDB_instance(self.this, class) }
    }

    #[inline]
    pub fn is_class_enabled(&self, class: GodotString) -> bool {
        unsafe { ClassDB_is_class_enabled(self.this, class) }
    }

    #[inline]
    pub fn is_parent_class(&self, class: GodotString, inherits: GodotString) -> bool {
        unsafe { ClassDB_is_parent_class(self.this, class, inherits) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Directory` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_directory.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Directory inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Directory {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Directory {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = DirectoryMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Directory {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn change_dir(&mut self, todir: GodotString) -> GodotResult {
        unsafe { Directory_change_dir(self.this, todir) }
    }

    #[inline]
    pub fn copy(&mut self, from: GodotString, to: GodotString) -> GodotResult {
        unsafe { Directory_copy(self.this, from, to) }
    }

    #[inline]
    pub fn current_is_dir(&self) -> bool {
        unsafe { Directory_current_is_dir(self.this) }
    }

    #[inline]
    pub fn dir_exists(&mut self, path: GodotString) -> bool {
        unsafe { Directory_dir_exists(self.this, path) }
    }

    #[inline]
    pub fn file_exists(&mut self, path: GodotString) -> bool {
        unsafe { Directory_file_exists(self.this, path) }
    }

    #[inline]
    pub fn get_current_dir(&mut self) -> GodotString {
        unsafe { Directory_get_current_dir(self.this) }
    }

    #[inline]
    pub fn get_current_drive(&mut self) -> i64 {
        unsafe { Directory_get_current_drive(self.this) }
    }

    #[inline]
    pub fn get_drive(&mut self, idx: i64) -> GodotString {
        unsafe { Directory_get_drive(self.this, idx) }
    }

    #[inline]
    pub fn get_drive_count(&mut self) -> i64 {
        unsafe { Directory_get_drive_count(self.this) }
    }

    #[inline]
    pub fn get_next(&mut self) -> GodotString {
        unsafe { Directory_get_next(self.this) }
    }

    #[inline]
    pub fn get_space_left(&mut self) -> i64 {
        unsafe { Directory_get_space_left(self.this) }
    }

    #[inline]
    pub fn list_dir_begin(&mut self, skip_navigational: bool, skip_hidden: bool) -> GodotResult {
        unsafe { Directory_list_dir_begin(self.this, skip_navigational, skip_hidden) }
    }

    #[inline]
    pub fn list_dir_end(&mut self) -> () {
        unsafe { Directory_list_dir_end(self.this) }
    }

    #[inline]
    pub fn make_dir(&mut self, path: GodotString) -> GodotResult {
        unsafe { Directory_make_dir(self.this, path) }
    }

    #[inline]
    pub fn make_dir_recursive(&mut self, path: GodotString) -> GodotResult {
        unsafe { Directory_make_dir_recursive(self.this, path) }
    }

    #[inline]
    pub fn open(&mut self, path: GodotString) -> GodotResult {
        unsafe { Directory_open(self.this, path) }
    }

    #[inline]
    pub fn remove(&mut self, path: GodotString) -> GodotResult {
        unsafe { Directory_remove(self.this, path) }
    }

    #[inline]
    pub fn rename(&mut self, from: GodotString, to: GodotString) -> GodotResult {
        unsafe { Directory_rename(self.this, from, to) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Engine` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_engine.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Engine inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Engine {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Engine {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Engine\0".as_ptr() as *mut _);

            Engine {
                this
            }
        }
    }
    #[inline]
    pub fn get_author_info(&self) -> Dictionary {
        unsafe { Engine_get_author_info(self.this) }
    }

    #[inline]
    pub fn get_copyright_info(&self) -> VariantArray {
        unsafe { Engine_get_copyright_info(self.this) }
    }

    #[inline]
    pub fn get_donor_info(&self) -> Dictionary {
        unsafe { Engine_get_donor_info(self.this) }
    }

    #[inline]
    pub fn get_frames_drawn(&mut self) -> i64 {
        unsafe { Engine_get_frames_drawn(self.this) }
    }

    #[inline]
    pub fn get_frames_per_second(&self) -> f64 {
        unsafe { Engine_get_frames_per_second(self.this) }
    }

    #[inline]
    pub fn get_idle_frames(&self) -> i64 {
        unsafe { Engine_get_idle_frames(self.this) }
    }

    #[inline]
    pub fn get_iterations_per_second(&self) -> i64 {
        unsafe { Engine_get_iterations_per_second(self.this) }
    }

    #[inline]
    pub fn get_license_info(&self) -> Dictionary {
        unsafe { Engine_get_license_info(self.this) }
    }

    #[inline]
    pub fn get_license_text(&self) -> GodotString {
        unsafe { Engine_get_license_text(self.this) }
    }

    #[inline]
    pub fn get_main_loop(&self) -> Option<MainLoop> {
        unsafe { Engine_get_main_loop(self.this) }
    }

    #[inline]
    pub fn get_physics_frames(&self) -> i64 {
        unsafe { Engine_get_physics_frames(self.this) }
    }

    #[inline]
    pub fn get_physics_interpolation_fraction(&self) -> f64 {
        unsafe { Engine_get_physics_interpolation_fraction(self.this) }
    }

    #[inline]
    pub fn get_physics_jitter_fix(&self) -> f64 {
        unsafe { Engine_get_physics_jitter_fix(self.this) }
    }

    #[inline]
    pub fn get_singleton(&self, name: GodotString) -> Option<Object> {
        unsafe { Engine_get_singleton(self.this, name) }
    }

    #[inline]
    pub fn get_target_fps(&self) -> i64 {
        unsafe { Engine_get_target_fps(self.this) }
    }

    #[inline]
    pub fn get_time_scale(&mut self) -> f64 {
        unsafe { Engine_get_time_scale(self.this) }
    }

    #[inline]
    pub fn get_version_info(&self) -> Dictionary {
        unsafe { Engine_get_version_info(self.this) }
    }

    #[inline]
    pub fn has_singleton(&self, name: GodotString) -> bool {
        unsafe { Engine_has_singleton(self.this, name) }
    }

    #[inline]
    pub fn is_editor_hint(&self) -> bool {
        unsafe { Engine_is_editor_hint(self.this) }
    }

    #[inline]
    pub fn is_in_physics_frame(&self) -> bool {
        unsafe { Engine_is_in_physics_frame(self.this) }
    }

    #[inline]
    pub fn set_editor_hint(&mut self, enabled: bool) -> () {
        unsafe { Engine_set_editor_hint(self.this, enabled) }
    }

    #[inline]
    pub fn set_iterations_per_second(&mut self, iterations_per_second: i64) -> () {
        unsafe { Engine_set_iterations_per_second(self.this, iterations_per_second) }
    }

    #[inline]
    pub fn set_physics_jitter_fix(&mut self, physics_jitter_fix: f64) -> () {
        unsafe { Engine_set_physics_jitter_fix(self.this, physics_jitter_fix) }
    }

    #[inline]
    pub fn set_target_fps(&mut self, target_fps: i64) -> () {
        unsafe { Engine_set_target_fps(self.this, target_fps) }
    }

    #[inline]
    pub fn set_time_scale(&mut self, time_scale: f64) -> () {
        unsafe { Engine_set_time_scale(self.this, time_scale) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class File` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_file.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// File inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct File {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileCompressionMode {
    Fastlz = 0,
    Deflate = 1,
    Zstd = 2,
    Gzip = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileModeFlags {
    Read = 1,
    Write = 2,
    ReadWrite = 3,
    WriteRead = 7,
}
/// Constants
#[allow(non_upper_case_globals)]
impl File {
    pub const COMPRESSION_ZSTD: i64 = 2;
    pub const WRITE_READ: i64 = 7;
    pub const READ_WRITE: i64 = 3;
    pub const READ: i64 = 1;
    pub const COMPRESSION_GZIP: i64 = 3;
    pub const COMPRESSION_DEFLATE: i64 = 1;
    pub const WRITE: i64 = 2;
    pub const COMPRESSION_FASTLZ: i64 = 0;
}
impl File {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = FileMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            File {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn close(&mut self) -> () {
        unsafe { File_close(self.this) }
    }

    #[inline]
    pub fn eof_reached(&self) -> bool {
        unsafe { File_eof_reached(self.this) }
    }

    #[inline]
    pub fn file_exists(&self, path: GodotString) -> bool {
        unsafe { File_file_exists(self.this, path) }
    }

    #[inline]
    pub fn get_16(&self) -> i64 {
        unsafe { File_get_16(self.this) }
    }

    #[inline]
    pub fn get_32(&self) -> i64 {
        unsafe { File_get_32(self.this) }
    }

    #[inline]
    pub fn get_64(&self) -> i64 {
        unsafe { File_get_64(self.this) }
    }

    #[inline]
    pub fn get_8(&self) -> i64 {
        unsafe { File_get_8(self.this) }
    }

    #[inline]
    pub fn get_as_text(&self) -> GodotString {
        unsafe { File_get_as_text(self.this) }
    }

    #[inline]
    pub fn get_buffer(&self, len: i64) -> ByteArray {
        unsafe { File_get_buffer(self.this, len) }
    }

    #[inline]
    pub fn get_csv_line(&self, delim: GodotString) -> StringArray {
        unsafe { File_get_csv_line(self.this, delim) }
    }

    #[inline]
    pub fn get_double(&self) -> f64 {
        unsafe { File_get_double(self.this) }
    }

    #[inline]
    pub fn get_endian_swap(&mut self) -> bool {
        unsafe { File_get_endian_swap(self.this) }
    }

    #[inline]
    pub fn get_error(&self) -> GodotResult {
        unsafe { File_get_error(self.this) }
    }

    #[inline]
    pub fn get_float(&self) -> f64 {
        unsafe { File_get_float(self.this) }
    }

    #[inline]
    pub fn get_len(&self) -> i64 {
        unsafe { File_get_len(self.this) }
    }

    #[inline]
    pub fn get_line(&self) -> GodotString {
        unsafe { File_get_line(self.this) }
    }

    #[inline]
    pub fn get_md5(&self, path: GodotString) -> GodotString {
        unsafe { File_get_md5(self.this, path) }
    }

    #[inline]
    pub fn get_modified_time(&self, file: GodotString) -> i64 {
        unsafe { File_get_modified_time(self.this, file) }
    }

    #[inline]
    pub fn get_pascal_string(&mut self) -> GodotString {
        unsafe { File_get_pascal_string(self.this) }
    }

    #[inline]
    pub fn get_path(&self) -> GodotString {
        unsafe { File_get_path(self.this) }
    }

    #[inline]
    pub fn get_path_absolute(&self) -> GodotString {
        unsafe { File_get_path_absolute(self.this) }
    }

    #[inline]
    pub fn get_position(&self) -> i64 {
        unsafe { File_get_position(self.this) }
    }

    #[inline]
    pub fn get_real(&self) -> f64 {
        unsafe { File_get_real(self.this) }
    }

    #[inline]
    pub fn get_sha256(&self, path: GodotString) -> GodotString {
        unsafe { File_get_sha256(self.this, path) }
    }

    #[inline]
    pub fn get_var(&self, allow_objects: bool) -> Variant {
        unsafe { File_get_var(self.this, allow_objects) }
    }

    #[inline]
    pub fn is_open(&self) -> bool {
        unsafe { File_is_open(self.this) }
    }

    #[inline]
    pub fn open(&mut self, path: GodotString, flags: i64) -> GodotResult {
        unsafe { File_open(self.this, path, flags) }
    }

    #[inline]
    pub fn open_compressed(&mut self, path: GodotString, mode_flags: i64, compression_mode: i64) -> GodotResult {
        unsafe { File_open_compressed(self.this, path, mode_flags, compression_mode) }
    }

    #[inline]
    pub fn open_encrypted(&mut self, path: GodotString, mode_flags: i64, key: ByteArray) -> GodotResult {
        unsafe { File_open_encrypted(self.this, path, mode_flags, key) }
    }

    #[inline]
    pub fn open_encrypted_with_pass(&mut self, path: GodotString, mode_flags: i64, pass: GodotString) -> GodotResult {
        unsafe { File_open_encrypted_with_pass(self.this, path, mode_flags, pass) }
    }

    #[inline]
    pub fn seek(&mut self, position: i64) -> () {
        unsafe { File_seek(self.this, position) }
    }

    #[inline]
    pub fn seek_end(&mut self, position: i64) -> () {
        unsafe { File_seek_end(self.this, position) }
    }

    #[inline]
    pub fn set_endian_swap(&mut self, enable: bool) -> () {
        unsafe { File_set_endian_swap(self.this, enable) }
    }

    #[inline]
    pub fn store_16(&mut self, value: i64) -> () {
        unsafe { File_store_16(self.this, value) }
    }

    #[inline]
    pub fn store_32(&mut self, value: i64) -> () {
        unsafe { File_store_32(self.this, value) }
    }

    #[inline]
    pub fn store_64(&mut self, value: i64) -> () {
        unsafe { File_store_64(self.this, value) }
    }

    #[inline]
    pub fn store_8(&mut self, value: i64) -> () {
        unsafe { File_store_8(self.this, value) }
    }

    #[inline]
    pub fn store_buffer(&mut self, buffer: ByteArray) -> () {
        unsafe { File_store_buffer(self.this, buffer) }
    }

    #[inline]
    pub fn store_csv_line(&mut self, values: StringArray, delim: GodotString) -> () {
        unsafe { File_store_csv_line(self.this, values, delim) }
    }

    #[inline]
    pub fn store_double(&mut self, value: f64) -> () {
        unsafe { File_store_double(self.this, value) }
    }

    #[inline]
    pub fn store_float(&mut self, value: f64) -> () {
        unsafe { File_store_float(self.this, value) }
    }

    #[inline]
    pub fn store_line(&mut self, line: GodotString) -> () {
        unsafe { File_store_line(self.this, line) }
    }

    #[inline]
    pub fn store_pascal_string(&mut self, string: GodotString) -> () {
        unsafe { File_store_pascal_string(self.this, string) }
    }

    #[inline]
    pub fn store_real(&mut self, value: f64) -> () {
        unsafe { File_store_real(self.this, value) }
    }

    #[inline]
    pub fn store_string(&mut self, string: GodotString) -> () {
        unsafe { File_store_string(self.this, string) }
    }

    #[inline]
    pub fn store_var(&mut self, value: Variant, full_objects: bool) -> () {
        unsafe { File_store_var(self.this, value, full_objects) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Geometry` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_geometry.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Geometry inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Geometry {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GeometryPolyEndType {
    EndPolygon = 0,
    EndJoined = 1,
    EndButt = 2,
    EndSquare = 3,
    EndRound = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GeometryPolyBooleanOperation {
    OperationUnion = 0,
    OperationDifference = 1,
    OperationIntersection = 2,
    OperationXor = 3,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum GeometryPolyJoinType {
    JoinSquare = 0,
    JoinRound = 1,
    JoinMiter = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Geometry {
    pub const JOIN_SQUARE: i64 = 0;
    pub const OPERATION_DIFFERENCE: i64 = 1;
    pub const OPERATION_INTERSECTION: i64 = 2;
    pub const OPERATION_UNION: i64 = 0;
    pub const OPERATION_XOR: i64 = 3;
    pub const END_JOINED: i64 = 1;
    pub const END_ROUND: i64 = 4;
    pub const END_BUTT: i64 = 2;
    pub const END_SQUARE: i64 = 3;
    pub const JOIN_ROUND: i64 = 1;
    pub const JOIN_MITER: i64 = 2;
    pub const END_POLYGON: i64 = 0;
}
impl Geometry {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Geometry\0".as_ptr() as *mut _);

            Geometry {
                this
            }
        }
    }
    #[inline]
    pub fn build_box_planes(&mut self, extents: Vector3) -> VariantArray {
        unsafe { Geometry_build_box_planes(self.this, extents) }
    }

    #[inline]
    pub fn build_capsule_planes(&mut self, radius: f64, height: f64, sides: i64, lats: i64, axis: i64) -> VariantArray {
        unsafe { Geometry_build_capsule_planes(self.this, radius, height, sides, lats, axis) }
    }

    #[inline]
    pub fn build_cylinder_planes(&mut self, radius: f64, height: f64, sides: i64, axis: i64) -> VariantArray {
        unsafe { Geometry_build_cylinder_planes(self.this, radius, height, sides, axis) }
    }

    #[inline]
    pub fn clip_polygon(&mut self, points: Vector3Array, plane: Plane) -> Vector3Array {
        unsafe { Geometry_clip_polygon(self.this, points, plane) }
    }

    #[inline]
    pub fn clip_polygons_2d(&mut self, polygon_a: Vector2Array, polygon_b: Vector2Array) -> VariantArray {
        unsafe { Geometry_clip_polygons_2d(self.this, polygon_a, polygon_b) }
    }

    #[inline]
    pub fn clip_polyline_with_polygon_2d(&mut self, polyline: Vector2Array, polygon: Vector2Array) -> VariantArray {
        unsafe { Geometry_clip_polyline_with_polygon_2d(self.this, polyline, polygon) }
    }

    #[inline]
    pub fn convex_hull_2d(&mut self, points: Vector2Array) -> Vector2Array {
        unsafe { Geometry_convex_hull_2d(self.this, points) }
    }

    #[inline]
    pub fn exclude_polygons_2d(&mut self, polygon_a: Vector2Array, polygon_b: Vector2Array) -> VariantArray {
        unsafe { Geometry_exclude_polygons_2d(self.this, polygon_a, polygon_b) }
    }

    #[inline]
    pub fn get_closest_point_to_segment(&mut self, point: Vector3, s1: Vector3, s2: Vector3) -> Vector3 {
        unsafe { Geometry_get_closest_point_to_segment(self.this, point, s1, s2) }
    }

    #[inline]
    pub fn get_closest_point_to_segment_2d(&mut self, point: Vector2, s1: Vector2, s2: Vector2) -> Vector2 {
        unsafe { Geometry_get_closest_point_to_segment_2d(self.this, point, s1, s2) }
    }

    #[inline]
    pub fn get_closest_point_to_segment_uncapped(&mut self, point: Vector3, s1: Vector3, s2: Vector3) -> Vector3 {
        unsafe { Geometry_get_closest_point_to_segment_uncapped(self.this, point, s1, s2) }
    }

    #[inline]
    pub fn get_closest_point_to_segment_uncapped_2d(&mut self, point: Vector2, s1: Vector2, s2: Vector2) -> Vector2 {
        unsafe { Geometry_get_closest_point_to_segment_uncapped_2d(self.this, point, s1, s2) }
    }

    #[inline]
    pub fn get_closest_points_between_segments(&mut self, p1: Vector3, p2: Vector3, q1: Vector3, q2: Vector3) -> Vector3Array {
        unsafe { Geometry_get_closest_points_between_segments(self.this, p1, p2, q1, q2) }
    }

    #[inline]
    pub fn get_closest_points_between_segments_2d(&mut self, p1: Vector2, q1: Vector2, p2: Vector2, q2: Vector2) -> Vector2Array {
        unsafe { Geometry_get_closest_points_between_segments_2d(self.this, p1, q1, p2, q2) }
    }

    #[inline]
    pub fn get_uv84_normal_bit(&mut self, normal: Vector3) -> i64 {
        unsafe { Geometry_get_uv84_normal_bit(self.this, normal) }
    }

    #[inline]
    pub fn intersect_polygons_2d(&mut self, polygon_a: Vector2Array, polygon_b: Vector2Array) -> VariantArray {
        unsafe { Geometry_intersect_polygons_2d(self.this, polygon_a, polygon_b) }
    }

    #[inline]
    pub fn intersect_polyline_with_polygon_2d(&mut self, polyline: Vector2Array, polygon: Vector2Array) -> VariantArray {
        unsafe { Geometry_intersect_polyline_with_polygon_2d(self.this, polyline, polygon) }
    }

    #[inline]
    pub fn is_point_in_circle(&mut self, point: Vector2, circle_position: Vector2, circle_radius: f64) -> bool {
        unsafe { Geometry_is_point_in_circle(self.this, point, circle_position, circle_radius) }
    }

    #[inline]
    pub fn is_point_in_polygon(&mut self, point: Vector2, polygon: Vector2Array) -> bool {
        unsafe { Geometry_is_point_in_polygon(self.this, point, polygon) }
    }

    #[inline]
    pub fn is_polygon_clockwise(&mut self, polygon: Vector2Array) -> bool {
        unsafe { Geometry_is_polygon_clockwise(self.this, polygon) }
    }

    #[inline]
    pub fn line_intersects_line_2d(&mut self, from_a: Vector2, dir_a: Vector2, from_b: Vector2, dir_b: Vector2) -> Variant {
        unsafe { Geometry_line_intersects_line_2d(self.this, from_a, dir_a, from_b, dir_b) }
    }

    #[inline]
    pub fn make_atlas(&mut self, sizes: Vector2Array) -> Dictionary {
        unsafe { Geometry_make_atlas(self.this, sizes) }
    }

    #[inline]
    pub fn merge_polygons_2d(&mut self, polygon_a: Vector2Array, polygon_b: Vector2Array) -> VariantArray {
        unsafe { Geometry_merge_polygons_2d(self.this, polygon_a, polygon_b) }
    }

    #[inline]
    pub fn offset_polygon_2d(&mut self, polygon: Vector2Array, delta: f64, join_type: i64) -> VariantArray {
        unsafe { Geometry_offset_polygon_2d(self.this, polygon, delta, join_type) }
    }

    #[inline]
    pub fn offset_polyline_2d(&mut self, polyline: Vector2Array, delta: f64, join_type: i64, end_type: i64) -> VariantArray {
        unsafe { Geometry_offset_polyline_2d(self.this, polyline, delta, join_type, end_type) }
    }

    #[inline]
    pub fn point_is_inside_triangle(&self, point: Vector2, a: Vector2, b: Vector2, c: Vector2) -> bool {
        unsafe { Geometry_point_is_inside_triangle(self.this, point, a, b, c) }
    }

    #[inline]
    pub fn ray_intersects_triangle(&mut self, from: Vector3, dir: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Variant {
        unsafe { Geometry_ray_intersects_triangle(self.this, from, dir, a, b, c) }
    }

    #[inline]
    pub fn segment_intersects_circle(&mut self, segment_from: Vector2, segment_to: Vector2, circle_position: Vector2, circle_radius: f64) -> f64 {
        unsafe { Geometry_segment_intersects_circle(self.this, segment_from, segment_to, circle_position, circle_radius) }
    }

    #[inline]
    pub fn segment_intersects_convex(&mut self, from: Vector3, to: Vector3, planes: VariantArray) -> Vector3Array {
        unsafe { Geometry_segment_intersects_convex(self.this, from, to, planes) }
    }

    #[inline]
    pub fn segment_intersects_cylinder(&mut self, from: Vector3, to: Vector3, height: f64, radius: f64) -> Vector3Array {
        unsafe { Geometry_segment_intersects_cylinder(self.this, from, to, height, radius) }
    }

    #[inline]
    pub fn segment_intersects_segment_2d(&mut self, from_a: Vector2, to_a: Vector2, from_b: Vector2, to_b: Vector2) -> Variant {
        unsafe { Geometry_segment_intersects_segment_2d(self.this, from_a, to_a, from_b, to_b) }
    }

    #[inline]
    pub fn segment_intersects_sphere(&mut self, from: Vector3, to: Vector3, sphere_position: Vector3, sphere_radius: f64) -> Vector3Array {
        unsafe { Geometry_segment_intersects_sphere(self.this, from, to, sphere_position, sphere_radius) }
    }

    #[inline]
    pub fn segment_intersects_triangle(&mut self, from: Vector3, to: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Variant {
        unsafe { Geometry_segment_intersects_triangle(self.this, from, to, a, b, c) }
    }

    #[inline]
    pub fn triangulate_delaunay_2d(&mut self, points: Vector2Array) -> Int32Array {
        unsafe { Geometry_triangulate_delaunay_2d(self.this, points) }
    }

    #[inline]
    pub fn triangulate_polygon(&mut self, polygon: Vector2Array) -> Int32Array {
        unsafe { Geometry_triangulate_polygon(self.this, polygon) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class JSON` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_json.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// JSON inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct JSON {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl JSON {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"JSON\0".as_ptr() as *mut _);

            JSON {
                this
            }
        }
    }
    #[inline]
    pub fn parse(&mut self, json: GodotString) -> Option<JSONParseResult> {
        unsafe { JSON_parse(self.this, json) }
    }

    #[inline]
    pub fn print(&mut self, value: Variant, indent: GodotString, sort_keys: bool) -> GodotString {
        unsafe { JSON_print(self.this, value, indent, sort_keys) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class Marshalls` inherits `Reference` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_marshalls.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// Marshalls inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Marshalls {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Marshalls {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"Marshalls\0".as_ptr() as *mut _);

            Marshalls {
                this
            }
        }
    }
    #[inline]
    pub fn base64_to_raw(&mut self, base64_str: GodotString) -> ByteArray {
        unsafe { Marshalls_base64_to_raw(self.this, base64_str) }
    }

    #[inline]
    pub fn base64_to_utf8(&mut self, base64_str: GodotString) -> GodotString {
        unsafe { Marshalls_base64_to_utf8(self.this, base64_str) }
    }

    #[inline]
    pub fn base64_to_variant(&mut self, base64_str: GodotString, allow_objects: bool) -> Variant {
        unsafe { Marshalls_base64_to_variant(self.this, base64_str, allow_objects) }
    }

    #[inline]
    pub fn raw_to_base64(&mut self, array: ByteArray) -> GodotString {
        unsafe { Marshalls_raw_to_base64(self.this, array) }
    }

    #[inline]
    pub fn utf8_to_base64(&mut self, utf8_str: GodotString) -> GodotString {
        unsafe { Marshalls_utf8_to_base64(self.this, utf8_str) }
    }

    #[inline]
    pub fn variant_to_base64(&mut self, variant: Variant, full_objects: bool) -> GodotString {
        unsafe { Marshalls_variant_to_base64(self.this, variant, full_objects) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Mutex` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_mutex.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Mutex inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Mutex {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Mutex {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = MutexMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Mutex {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn lock(&mut self) -> () {
        unsafe { Mutex_lock(self.this) }
    }

    #[inline]
    pub fn try_lock(&mut self) -> GodotResult {
        unsafe { Mutex_try_lock(self.this) }
    }

    #[inline]
    pub fn unlock(&mut self) -> () {
        unsafe { Mutex_unlock(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class OS` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_os.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// OS inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct OS {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSVideoDriver {
    Gles3 = 0,
    Gles2 = 1,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSSystemDir {
    Desktop = 0,
    Dcim = 1,
    Documents = 2,
    Downloads = 3,
    Movies = 4,
    Music = 5,
    Pictures = 6,
    Ringtones = 7,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSScreenOrientation {
    Landscape = 0,
    Portrait = 1,
    ReverseLandscape = 2,
    ReversePortrait = 3,
    SensorLandscape = 4,
    SensorPortrait = 5,
    Sensor = 6,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSPowerState {
    Unknown = 0,
    OnBattery = 1,
    NoBattery = 2,
    Charging = 3,
    Charged = 4,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSMonth {
    January = 1,
    February = 2,
    March = 3,
    April = 4,
    May = 5,
    June = 6,
    July = 7,
    August = 8,
    September = 9,
    October = 10,
    November = 11,
    December = 12,
}
#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum OSWeekday {
    DaySunday = 0,
    DayMonday = 1,
    DayTuesday = 2,
    DayWednesday = 3,
    DayThursday = 4,
    DayFriday = 5,
    DaySaturday = 6,
}
/// Constants
#[allow(non_upper_case_globals)]
impl OS {
    pub const SYSTEM_DIR_RINGTONES: i64 = 7;
    pub const SYSTEM_DIR_MUSIC: i64 = 5;
    pub const VIDEO_DRIVER_GLES3: i64 = 0;
    pub const MONTH_JULY: i64 = 7;
    pub const SCREEN_ORIENTATION_PORTRAIT: i64 = 1;
    pub const DAY_SUNDAY: i64 = 0;
    pub const SCREEN_ORIENTATION_REVERSE_LANDSCAPE: i64 = 2;
    pub const MONTH_DECEMBER: i64 = 12;
    pub const SCREEN_ORIENTATION_REVERSE_PORTRAIT: i64 = 3;
    pub const MONTH_OCTOBER: i64 = 10;
    pub const MONTH_MARCH: i64 = 3;
    pub const POWERSTATE_NO_BATTERY: i64 = 2;
    pub const MONTH_SEPTEMBER: i64 = 9;
    pub const SCREEN_ORIENTATION_SENSOR_LANDSCAPE: i64 = 4;
    pub const SYSTEM_DIR_PICTURES: i64 = 6;
    pub const DAY_THURSDAY: i64 = 4;
    pub const VIDEO_DRIVER_GLES2: i64 = 1;
    pub const MONTH_NOVEMBER: i64 = 11;
    pub const POWERSTATE_CHARGED: i64 = 4;
    pub const DAY_WEDNESDAY: i64 = 3;
    pub const SYSTEM_DIR_DOCUMENTS: i64 = 2;
    pub const SYSTEM_DIR_DESKTOP: i64 = 0;
    pub const SYSTEM_DIR_MOVIES: i64 = 4;
    pub const POWERSTATE_CHARGING: i64 = 3;
    pub const SYSTEM_DIR_DOWNLOADS: i64 = 3;
    pub const MONTH_JANUARY: i64 = 1;
    pub const SCREEN_ORIENTATION_SENSOR: i64 = 6;
    pub const MONTH_MAY: i64 = 5;
    pub const SCREEN_ORIENTATION_SENSOR_PORTRAIT: i64 = 5;
    pub const MONTH_FEBRUARY: i64 = 2;
    pub const MONTH_AUGUST: i64 = 8;
    pub const SYSTEM_DIR_DCIM: i64 = 1;
    pub const POWERSTATE_UNKNOWN: i64 = 0;
    pub const SCREEN_ORIENTATION_LANDSCAPE: i64 = 0;
    pub const DAY_TUESDAY: i64 = 2;
    pub const MONTH_APRIL: i64 = 4;
    pub const DAY_SATURDAY: i64 = 6;
    pub const DAY_MONDAY: i64 = 1;
    pub const POWERSTATE_ON_BATTERY: i64 = 1;
    pub const MONTH_JUNE: i64 = 6;
    pub const DAY_FRIDAY: i64 = 5;
}
impl OS {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"OS\0".as_ptr() as *mut _);

            OS {
                this
            }
        }
    }
    #[inline]
    pub fn alert(&mut self, text: GodotString, title: GodotString) -> () {
        unsafe { OS_alert(self.this, text, title) }
    }

    #[inline]
    pub fn can_draw(&self) -> bool {
        unsafe { OS_can_draw(self.this) }
    }

    #[inline]
    pub fn can_use_threads(&self) -> bool {
        unsafe { OS_can_use_threads(self.this) }
    }

    #[inline]
    pub fn center_window(&mut self) -> () {
        unsafe { OS_center_window(self.this) }
    }

    #[inline]
    pub fn close_midi_inputs(&mut self) -> () {
        unsafe { OS_close_midi_inputs(self.this) }
    }

    #[inline]
    pub fn delay_msec(&self, msec: i64) -> () {
        unsafe { OS_delay_msec(self.this, msec) }
    }

    #[inline]
    pub fn delay_usec(&self, usec: i64) -> () {
        unsafe { OS_delay_usec(self.this, usec) }
    }

    #[inline]
    pub fn dump_memory_to_file(&mut self, file: GodotString) -> () {
        unsafe { OS_dump_memory_to_file(self.this, file) }
    }

    #[inline]
    pub fn dump_resources_to_file(&mut self, file: GodotString) -> () {
        unsafe { OS_dump_resources_to_file(self.this, file) }
    }

    #[inline]
    pub fn execute(&mut self, path: GodotString, arguments: StringArray, blocking: bool, output: VariantArray, read_stderr: bool) -> i64 {
        unsafe { OS_execute(self.this, path, arguments, blocking, output, read_stderr) }
    }

    #[inline]
    pub fn find_scancode_from_string(&self, string: GodotString) -> i64 {
        unsafe { OS_find_scancode_from_string(self.this, string) }
    }

    #[inline]
    pub fn get_audio_driver_count(&self) -> i64 {
        unsafe { OS_get_audio_driver_count(self.this) }
    }

    #[inline]
    pub fn get_audio_driver_name(&self, driver: i64) -> GodotString {
        unsafe { OS_get_audio_driver_name(self.this, driver) }
    }

    #[inline]
    pub fn get_borderless_window(&self) -> bool {
        unsafe { OS_get_borderless_window(self.this) }
    }

    #[inline]
    pub fn get_clipboard(&self) -> GodotString {
        unsafe { OS_get_clipboard(self.this) }
    }

    #[inline]
    pub fn get_cmdline_args(&mut self) -> StringArray {
        unsafe { OS_get_cmdline_args(self.this) }
    }

    #[inline]
    pub fn get_connected_midi_inputs(&mut self) -> StringArray {
        unsafe { OS_get_connected_midi_inputs(self.this) }
    }

    #[inline]
    pub fn get_current_screen(&self) -> i64 {
        unsafe { OS_get_current_screen(self.this) }
    }

    #[inline]
    pub fn get_current_video_driver(&self) -> OSVideoDriver {
        unsafe { OS_get_current_video_driver(self.this) }
    }

    #[inline]
    pub fn get_date(&self, utc: bool) -> Dictionary {
        unsafe { OS_get_date(self.this, utc) }
    }

    #[inline]
    pub fn get_datetime(&self, utc: bool) -> Dictionary {
        unsafe { OS_get_datetime(self.this, utc) }
    }

    #[inline]
    pub fn get_datetime_from_unix_time(&self, unix_time_val: i64) -> Dictionary {
        unsafe { OS_get_datetime_from_unix_time(self.this, unix_time_val) }
    }

    #[inline]
    pub fn get_dynamic_memory_usage(&self) -> i64 {
        unsafe { OS_get_dynamic_memory_usage(self.this) }
    }

    #[inline]
    pub fn get_environment(&self, environment: GodotString) -> GodotString {
        unsafe { OS_get_environment(self.this, environment) }
    }

    #[inline]
    pub fn get_executable_path(&self) -> GodotString {
        unsafe { OS_get_executable_path(self.this) }
    }

    #[inline]
    pub fn get_exit_code(&self) -> i64 {
        unsafe { OS_get_exit_code(self.this) }
    }

    #[inline]
    pub fn get_granted_permissions(&self) -> StringArray {
        unsafe { OS_get_granted_permissions(self.this) }
    }

    #[inline]
    pub fn get_ime_selection(&self) -> Vector2 {
        unsafe { OS_get_ime_selection(self.this) }
    }

    #[inline]
    pub fn get_ime_text(&self) -> GodotString {
        unsafe { OS_get_ime_text(self.this) }
    }

    #[inline]
    pub fn get_latin_keyboard_variant(&self) -> GodotString {
        unsafe { OS_get_latin_keyboard_variant(self.this) }
    }

    #[inline]
    pub fn get_locale(&self) -> GodotString {
        unsafe { OS_get_locale(self.this) }
    }

    #[inline]
    pub fn get_low_processor_usage_mode_sleep_usec(&self) -> i64 {
        unsafe { OS_get_low_processor_usage_mode_sleep_usec(self.this) }
    }

    #[inline]
    pub fn get_max_window_size(&self) -> Vector2 {
        unsafe { OS_get_max_window_size(self.this) }
    }

    #[inline]
    pub fn get_min_window_size(&self) -> Vector2 {
        unsafe { OS_get_min_window_size(self.this) }
    }

    #[inline]
    pub fn get_model_name(&self) -> GodotString {
        unsafe { OS_get_model_name(self.this) }
    }

    #[inline]
    pub fn get_name(&self) -> GodotString {
        unsafe { OS_get_name(self.this) }
    }

    #[inline]
    pub fn get_power_percent_left(&mut self) -> i64 {
        unsafe { OS_get_power_percent_left(self.this) }
    }

    #[inline]
    pub fn get_power_seconds_left(&mut self) -> i64 {
        unsafe { OS_get_power_seconds_left(self.this) }
    }

    #[inline]
    pub fn get_power_state(&mut self) -> OSPowerState {
        unsafe { OS_get_power_state(self.this) }
    }

    #[inline]
    pub fn get_process_id(&self) -> i64 {
        unsafe { OS_get_process_id(self.this) }
    }

    #[inline]
    pub fn get_processor_count(&self) -> i64 {
        unsafe { OS_get_processor_count(self.this) }
    }

    #[inline]
    pub fn get_real_window_size(&self) -> Vector2 {
        unsafe { OS_get_real_window_size(self.this) }
    }

    #[inline]
    pub fn get_scancode_string(&self, code: i64) -> GodotString {
        unsafe { OS_get_scancode_string(self.this, code) }
    }

    #[inline]
    pub fn get_screen_count(&self) -> i64 {
        unsafe { OS_get_screen_count(self.this) }
    }

    #[inline]
    pub fn get_screen_dpi(&self, screen: i64) -> i64 {
        unsafe { OS_get_screen_dpi(self.this, screen) }
    }

    #[inline]
    pub fn get_screen_orientation(&self) -> OSScreenOrientation {
        unsafe { OS_get_screen_orientation(self.this) }
    }

    #[inline]
    pub fn get_screen_position(&self, screen: i64) -> Vector2 {
        unsafe { OS_get_screen_position(self.this, screen) }
    }

    #[inline]
    pub fn get_screen_size(&self, screen: i64) -> Vector2 {
        unsafe { OS_get_screen_size(self.this, screen) }
    }

    #[inline]
    pub fn get_splash_tick_msec(&self) -> i64 {
        unsafe { OS_get_splash_tick_msec(self.this) }
    }

    #[inline]
    pub fn get_static_memory_peak_usage(&self) -> i64 {
        unsafe { OS_get_static_memory_peak_usage(self.this) }
    }

    #[inline]
    pub fn get_static_memory_usage(&self) -> i64 {
        unsafe { OS_get_static_memory_usage(self.this) }
    }

    #[inline]
    pub fn get_system_dir(&self, dir: i64) -> GodotString {
        unsafe { OS_get_system_dir(self.this, dir) }
    }

    #[inline]
    pub fn get_system_time_msecs(&self) -> i64 {
        unsafe { OS_get_system_time_msecs(self.this) }
    }

    #[inline]
    pub fn get_system_time_secs(&self) -> i64 {
        unsafe { OS_get_system_time_secs(self.this) }
    }

    #[inline]
    pub fn get_ticks_msec(&self) -> i64 {
        unsafe { OS_get_ticks_msec(self.this) }
    }

    #[inline]
    pub fn get_ticks_usec(&self) -> i64 {
        unsafe { OS_get_ticks_usec(self.this) }
    }

    #[inline]
    pub fn get_time(&self, utc: bool) -> Dictionary {
        unsafe { OS_get_time(self.this, utc) }
    }

    #[inline]
    pub fn get_time_zone_info(&self) -> Dictionary {
        unsafe { OS_get_time_zone_info(self.this) }
    }

    #[inline]
    pub fn get_unique_id(&self) -> GodotString {
        unsafe { OS_get_unique_id(self.this) }
    }

    #[inline]
    pub fn get_unix_time(&self) -> i64 {
        unsafe { OS_get_unix_time(self.this) }
    }

    #[inline]
    pub fn get_unix_time_from_datetime(&self, datetime: Dictionary) -> i64 {
        unsafe { OS_get_unix_time_from_datetime(self.this, datetime) }
    }

    #[inline]
    pub fn get_user_data_dir(&self) -> GodotString {
        unsafe { OS_get_user_data_dir(self.this) }
    }

    #[inline]
    pub fn get_video_driver_count(&self) -> i64 {
        unsafe { OS_get_video_driver_count(self.this) }
    }

    #[inline]
    pub fn get_video_driver_name(&self, driver: i64) -> GodotString {
        unsafe { OS_get_video_driver_name(self.this, driver) }
    }

    #[inline]
    pub fn get_virtual_keyboard_height(&mut self) -> i64 {
        unsafe { OS_get_virtual_keyboard_height(self.this) }
    }

    #[inline]
    pub fn get_window_per_pixel_transparency_enabled(&self) -> bool {
        unsafe { OS_get_window_per_pixel_transparency_enabled(self.this) }
    }

    #[inline]
    pub fn get_window_position(&self) -> Vector2 {
        unsafe { OS_get_window_position(self.this) }
    }

    #[inline]
    pub fn get_window_safe_area(&self) -> Rect2 {
        unsafe { OS_get_window_safe_area(self.this) }
    }

    #[inline]
    pub fn get_window_size(&self) -> Vector2 {
        unsafe { OS_get_window_size(self.this) }
    }

    #[inline]
    pub fn global_menu_add_item(&mut self, menu: GodotString, label: GodotString, id: Variant, meta: Variant) -> () {
        unsafe { OS_global_menu_add_item(self.this, menu, label, id, meta) }
    }

    #[inline]
    pub fn global_menu_add_separator(&mut self, menu: GodotString) -> () {
        unsafe { OS_global_menu_add_separator(self.this, menu) }
    }

    #[inline]
    pub fn global_menu_clear(&mut self, menu: GodotString) -> () {
        unsafe { OS_global_menu_clear(self.this, menu) }
    }

    #[inline]
    pub fn global_menu_remove_item(&mut self, menu: GodotString, idx: i64) -> () {
        unsafe { OS_global_menu_remove_item(self.this, menu, idx) }
    }

    #[inline]
    pub fn has_environment(&self, environment: GodotString) -> bool {
        unsafe { OS_has_environment(self.this, environment) }
    }

    #[inline]
    pub fn has_feature(&self, tag_name: GodotString) -> bool {
        unsafe { OS_has_feature(self.this, tag_name) }
    }

    #[inline]
    pub fn has_touchscreen_ui_hint(&self) -> bool {
        unsafe { OS_has_touchscreen_ui_hint(self.this) }
    }

    #[inline]
    pub fn has_virtual_keyboard(&self) -> bool {
        unsafe { OS_has_virtual_keyboard(self.this) }
    }

    #[inline]
    pub fn hide_virtual_keyboard(&mut self) -> () {
        unsafe { OS_hide_virtual_keyboard(self.this) }
    }

    #[inline]
    pub fn is_debug_build(&self) -> bool {
        unsafe { OS_is_debug_build(self.this) }
    }

    #[inline]
    pub fn is_in_low_processor_usage_mode(&self) -> bool {
        unsafe { OS_is_in_low_processor_usage_mode(self.this) }
    }

    #[inline]
    pub fn is_keep_screen_on(&self) -> bool {
        unsafe { OS_is_keep_screen_on(self.this) }
    }

    #[inline]
    pub fn is_ok_left_and_cancel_right(&self) -> bool {
        unsafe { OS_is_ok_left_and_cancel_right(self.this) }
    }

    #[inline]
    pub fn is_scancode_unicode(&self, code: i64) -> bool {
        unsafe { OS_is_scancode_unicode(self.this, code) }
    }

    #[inline]
    pub fn is_stdout_verbose(&self) -> bool {
        unsafe { OS_is_stdout_verbose(self.this) }
    }

    #[inline]
    pub fn is_userfs_persistent(&self) -> bool {
        unsafe { OS_is_userfs_persistent(self.this) }
    }

    #[inline]
    pub fn is_vsync_enabled(&self) -> bool {
        unsafe { OS_is_vsync_enabled(self.this) }
    }

    #[inline]
    pub fn is_vsync_via_compositor_enabled(&self) -> bool {
        unsafe { OS_is_vsync_via_compositor_enabled(self.this) }
    }

    #[inline]
    pub fn is_window_always_on_top(&self) -> bool {
        unsafe { OS_is_window_always_on_top(self.this) }
    }

    #[inline]
    pub fn is_window_focused(&self) -> bool {
        unsafe { OS_is_window_focused(self.this) }
    }

    #[inline]
    pub fn is_window_fullscreen(&self) -> bool {
        unsafe { OS_is_window_fullscreen(self.this) }
    }

    #[inline]
    pub fn is_window_maximized(&self) -> bool {
        unsafe { OS_is_window_maximized(self.this) }
    }

    #[inline]
    pub fn is_window_minimized(&self) -> bool {
        unsafe { OS_is_window_minimized(self.this) }
    }

    #[inline]
    pub fn is_window_resizable(&self) -> bool {
        unsafe { OS_is_window_resizable(self.this) }
    }

    #[inline]
    pub fn kill(&mut self, pid: i64) -> GodotResult {
        unsafe { OS_kill(self.this, pid) }
    }

    #[inline]
    pub fn move_window_to_foreground(&mut self) -> () {
        unsafe { OS_move_window_to_foreground(self.this) }
    }

    #[inline]
    pub fn native_video_is_playing(&mut self) -> bool {
        unsafe { OS_native_video_is_playing(self.this) }
    }

    #[inline]
    pub fn native_video_pause(&mut self) -> () {
        unsafe { OS_native_video_pause(self.this) }
    }

    #[inline]
    pub fn native_video_play(&mut self, path: GodotString, volume: f64, audio_track: GodotString, subtitle_track: GodotString) -> GodotResult {
        unsafe { OS_native_video_play(self.this, path, volume, audio_track, subtitle_track) }
    }

    #[inline]
    pub fn native_video_stop(&mut self) -> () {
        unsafe { OS_native_video_stop(self.this) }
    }

    #[inline]
    pub fn native_video_unpause(&mut self) -> () {
        unsafe { OS_native_video_unpause(self.this) }
    }

    #[inline]
    pub fn open_midi_inputs(&mut self) -> () {
        unsafe { OS_open_midi_inputs(self.this) }
    }

    #[inline]
    pub fn print_all_resources(&mut self, tofile: GodotString) -> () {
        unsafe { OS_print_all_resources(self.this, tofile) }
    }

    #[inline]
    pub fn print_all_textures_by_size(&mut self) -> () {
        unsafe { OS_print_all_textures_by_size(self.this) }
    }

    #[inline]
    pub fn print_resources_by_type(&mut self, types: StringArray) -> () {
        unsafe { OS_print_resources_by_type(self.this, types) }
    }

    #[inline]
    pub fn print_resources_in_use(&mut self, short: bool) -> () {
        unsafe { OS_print_resources_in_use(self.this, short) }
    }

    #[inline]
    pub fn request_attention(&mut self) -> () {
        unsafe { OS_request_attention(self.this) }
    }

    #[inline]
    pub fn request_permission(&mut self, name: GodotString) -> bool {
        unsafe { OS_request_permission(self.this, name) }
    }

    #[inline]
    pub fn request_permissions(&mut self) -> bool {
        unsafe { OS_request_permissions(self.this) }
    }

    #[inline]
    pub fn set_borderless_window(&mut self, borderless: bool) -> () {
        unsafe { OS_set_borderless_window(self.this, borderless) }
    }

    #[inline]
    pub fn set_clipboard(&mut self, clipboard: GodotString) -> () {
        unsafe { OS_set_clipboard(self.this, clipboard) }
    }

    #[inline]
    pub fn set_current_screen(&mut self, screen: i64) -> () {
        unsafe { OS_set_current_screen(self.this, screen) }
    }

    #[inline]
    pub fn set_exit_code(&mut self, code: i64) -> () {
        unsafe { OS_set_exit_code(self.this, code) }
    }

    #[inline]
    pub fn set_icon(&mut self, icon: Option<Image>) -> () {
        unsafe { OS_set_icon(self.this, icon) }
    }

    #[inline]
    pub fn set_ime_active(&mut self, active: bool) -> () {
        unsafe { OS_set_ime_active(self.this, active) }
    }

    #[inline]
    pub fn set_ime_position(&mut self, position: Vector2) -> () {
        unsafe { OS_set_ime_position(self.this, position) }
    }

    #[inline]
    pub fn set_keep_screen_on(&mut self, enabled: bool) -> () {
        unsafe { OS_set_keep_screen_on(self.this, enabled) }
    }

    #[inline]
    pub fn set_low_processor_usage_mode(&mut self, enable: bool) -> () {
        unsafe { OS_set_low_processor_usage_mode(self.this, enable) }
    }

    #[inline]
    pub fn set_low_processor_usage_mode_sleep_usec(&mut self, usec: i64) -> () {
        unsafe { OS_set_low_processor_usage_mode_sleep_usec(self.this, usec) }
    }

    #[inline]
    pub fn set_max_window_size(&mut self, size: Vector2) -> () {
        unsafe { OS_set_max_window_size(self.this, size) }
    }

    #[inline]
    pub fn set_min_window_size(&mut self, size: Vector2) -> () {
        unsafe { OS_set_min_window_size(self.this, size) }
    }

    #[inline]
    pub fn set_native_icon(&mut self, filename: GodotString) -> () {
        unsafe { OS_set_native_icon(self.this, filename) }
    }

    #[inline]
    pub fn set_screen_orientation(&mut self, orientation: i64) -> () {
        unsafe { OS_set_screen_orientation(self.this, orientation) }
    }

    #[inline]
    pub fn set_thread_name(&mut self, name: GodotString) -> GodotResult {
        unsafe { OS_set_thread_name(self.this, name) }
    }

    #[inline]
    pub fn set_use_file_access_save_and_swap(&mut self, enabled: bool) -> () {
        unsafe { OS_set_use_file_access_save_and_swap(self.this, enabled) }
    }

    #[inline]
    pub fn set_use_vsync(&mut self, enable: bool) -> () {
        unsafe { OS_set_use_vsync(self.this, enable) }
    }

    #[inline]
    pub fn set_vsync_via_compositor(&mut self, enable: bool) -> () {
        unsafe { OS_set_vsync_via_compositor(self.this, enable) }
    }

    #[inline]
    pub fn set_window_always_on_top(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_always_on_top(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_fullscreen(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_fullscreen(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_maximized(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_maximized(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_minimized(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_minimized(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_per_pixel_transparency_enabled(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_per_pixel_transparency_enabled(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_position(&mut self, position: Vector2) -> () {
        unsafe { OS_set_window_position(self.this, position) }
    }

    #[inline]
    pub fn set_window_resizable(&mut self, enabled: bool) -> () {
        unsafe { OS_set_window_resizable(self.this, enabled) }
    }

    #[inline]
    pub fn set_window_size(&mut self, size: Vector2) -> () {
        unsafe { OS_set_window_size(self.this, size) }
    }

    #[inline]
    pub fn set_window_title(&mut self, title: GodotString) -> () {
        unsafe { OS_set_window_title(self.this, title) }
    }

    #[inline]
    pub fn shell_open(&mut self, uri: GodotString) -> GodotResult {
        unsafe { OS_shell_open(self.this, uri) }
    }

    #[inline]
    pub fn show_virtual_keyboard(&mut self, existing_text: GodotString) -> () {
        unsafe { OS_show_virtual_keyboard(self.this, existing_text) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class ResourceLoader` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourceloader.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ResourceLoader inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceLoader {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl ResourceLoader {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"ResourceLoader\0".as_ptr() as *mut _);

            ResourceLoader {
                this
            }
        }
    }
    #[inline]
    pub fn exists(&mut self, path: GodotString, type_hint: GodotString) -> bool {
        unsafe { ResourceLoader_exists(self.this, path, type_hint) }
    }

    #[inline]
    pub fn get_dependencies(&mut self, path: GodotString) -> StringArray {
        unsafe { ResourceLoader_get_dependencies(self.this, path) }
    }

    #[inline]
    pub fn get_recognized_extensions_for_type(&mut self, _type: GodotString) -> StringArray {
        unsafe { ResourceLoader_get_recognized_extensions_for_type(self.this, _type) }
    }

    #[inline]
    pub fn has(&mut self, path: GodotString) -> bool {
        unsafe { ResourceLoader_has(self.this, path) }
    }

    #[inline]
    pub fn has_cached(&mut self, path: GodotString) -> bool {
        unsafe { ResourceLoader_has_cached(self.this, path) }
    }

    #[inline]
    pub fn load(&mut self, path: GodotString, type_hint: GodotString, no_cache: bool) -> Option<Resource> {
        unsafe { ResourceLoader_load(self.this, path, type_hint, no_cache) }
    }

    #[inline]
    pub fn load_interactive(&mut self, path: GodotString, type_hint: GodotString) -> Option<ResourceInteractiveLoader> {
        unsafe { ResourceLoader_load_interactive(self.this, path, type_hint) }
    }

    #[inline]
    pub fn set_abort_on_missing_resources(&mut self, abort: bool) -> () {
        unsafe { ResourceLoader_set_abort_on_missing_resources(self.this, abort) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core singleton class ResourceSaver` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_resourcesaver.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// ResourceSaver inherits methods from:
/// - [Object](struct.Object.html)
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct ResourceSaver {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ResourceSaverSaverFlags {
    FlagRelativePaths = 1,
    FlagBundleResources = 2,
    FlagChangePath = 4,
    FlagOmitEditorProperties = 8,
    FlagSaveBigEndian = 16,
    FlagCompress = 32,
    FlagReplaceSubresourcePaths = 64,
}
/// Constants
#[allow(non_upper_case_globals)]
impl ResourceSaver {
    pub const FLAG_SAVE_BIG_ENDIAN: i64 = 16;
    pub const FLAG_CHANGE_PATH: i64 = 4;
    pub const FLAG_OMIT_EDITOR_PROPERTIES: i64 = 8;
    pub const FLAG_COMPRESS: i64 = 32;
    pub const FLAG_RELATIVE_PATHS: i64 = 1;
    pub const FLAG_REPLACE_SUBRESOURCE_PATHS: i64 = 64;
    pub const FLAG_BUNDLE_RESOURCES: i64 = 2;
}
impl ResourceSaver {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"ResourceSaver\0".as_ptr() as *mut _);

            ResourceSaver {
                this
            }
        }
    }
    #[inline]
    pub fn get_recognized_extensions(&mut self, _type: Option<Resource>) -> StringArray {
        unsafe { ResourceSaver_get_recognized_extensions(self.this, _type) }
    }

    #[inline]
    pub fn save(&mut self, path: GodotString, resource: Option<Resource>, flags: i64) -> GodotResult {
        unsafe { ResourceSaver_save(self.this, path, resource, flags) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Semaphore` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_semaphore.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Semaphore inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Semaphore {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl Semaphore {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = SemaphoreMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Semaphore {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn post(&mut self) -> GodotResult {
        unsafe { Semaphore_post(self.this) }
    }

    #[inline]
    pub fn wait(&mut self) -> GodotResult {
        unsafe { Semaphore_wait(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `core class Thread` inherits `Reference` (reference counted).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_thread.html) in the Godot engine's official documentation.
///
/// ## Memory management
///
/// The lifetime of this object is automatically managed through reference counting.
///
/// ## Class hierarchy
///
/// Thread inherits methods from:
/// - [Reference](struct.Reference.html)
/// - [Object](struct.Object.html)
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct Thread {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

#[repr(u32)]
#[allow(non_camel_case_types)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ThreadPriority {
    Low = 0,
    Normal = 1,
    High = 2,
}
/// Constants
#[allow(non_upper_case_globals)]
impl Thread {
    pub const PRIORITY_HIGH: i64 = 2;
    pub const PRIORITY_LOW: i64 = 0;
    pub const PRIORITY_NORMAL: i64 = 1;
}
impl Thread {

    // Constructor
    pub fn new() -> Self {
        unsafe {
            let gd_api = get_api();
            let ctor = ThreadMethodTable::get(gd_api).class_constructor.unwrap();
            let obj = ctor();
            object::init_ref_count(obj);

            Thread {
                this: obj
            }
        }
    }


    /// Creates a new reference to the same reference-counted object.
    pub fn new_ref(&self) -> Self {
        unsafe {
            object::add_ref(self.this);

            Self {
                this: self.this,
            }
        }
    }

    #[inline]
    pub fn get_id(&self) -> GodotString {
        unsafe { Thread_get_id(self.this) }
    }

    #[inline]
    pub fn is_active(&self) -> bool {
        unsafe { Thread_is_active(self.this) }
    }

    #[inline]
    pub fn start(&mut self, instance: Option<Object>, method: GodotString, userdata: Variant, priority: i64) -> GodotResult {
        unsafe { Thread_start(self.this, instance, method, userdata, priority) }
    }

    #[inline]
    pub fn wait_to_finish(&mut self) -> Variant {
        unsafe { Thread_wait_to_finish(self.this) }
    }

    /// Inherited from [Reference](struct.Reference.html).
    #[inline]
    pub fn init_ref(&mut self) -> bool {
        unsafe { Reference_init_ref(self.this) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_reference(&self) -> Reference {
        unsafe {{ object::add_ref(self.this); }}
        Reference { this: self.this }
    }
    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}

/// `tools singleton class VisualScriptEditor` inherits `Object` (unsafe).
///
/// ## Official documentation
///
/// See the [documentation of this class](https://godot.readthedocs.io/en/latest/classes/class_visualscripteditor.html) in the Godot engine's official documentation.
///
/// ## Class hierarchy
///
/// VisualScriptEditor inherits methods from:
/// - [Object](struct.Object.html)
///
/// ## Tool
///
/// This class is used to interact with Godot's editor.
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct VisualScriptEditor {
    #[doc(hidden)]
    pub this: *mut sys::godot_object,
}

impl VisualScriptEditor {

    #[inline]
    pub fn godot_singleton() -> Self {
        unsafe {
            let this = (get_api().godot_global_get_singleton)(b"VisualScriptEditor\0".as_ptr() as *mut _);

            VisualScriptEditor {
                this
            }
        }
    }
    #[inline]
    pub fn add_custom_node(&mut self, name: GodotString, category: GodotString, script: Option<Script>) -> () {
        unsafe { VisualScriptEditor_add_custom_node(self.this, name, category, script) }
    }

    #[inline]
    pub fn remove_custom_node(&mut self, name: GodotString, category: GodotString) -> () {
        unsafe { VisualScriptEditor_remove_custom_node(self.this, name, category) }
    }

    /// Up-cast.
    #[inline]
    pub fn to_object(&self) -> Object {
        // Not reference-counted.
        Object { this: self.this }
    }

    /// Generic dynamic cast.
    pub fn cast<T: GodotObject>(&self) -> Option<T> {
        object::godot_cast::<T>(self.this)
    }
}
